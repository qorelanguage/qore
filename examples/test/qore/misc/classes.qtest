#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../qlib/QUnit.qm

%exec-class ClassesTest

class Test1 inherits Socket {
    private {
        int a;
        int b;
    }
    public {
        list data;
        hash t;
        int x;
    }

    constructor(any n_a, any n_b, any n_c) {
        a = 1;
        b = 2;
        data = (n_a, n_b, n_c);
    }
    any getData(int elem) {
        if (exists elem)
            return data[elem];
        return data;
    }
    string methodGate(string m) {
        return m;
    }
    string memberGate(string m) {
        return "memberGate-" + m;
    }
    memberNotification(string m) {
        t{m} = self{m};
    }
    code closure(any x) {
        int a = 1;
        # return a closure encapsulating the state of the object
        return string sub (any y) {
            return sprintf("%s-%n-%n-%n", data[1], x, y, ++a);
        };
    }
    any argTest() {
        return argv;
    }
}

class Test2 {
    private {
        any a;
    }

    private int priv() {
        return 1;
    }

    int pub() {
        return call_object_method(self, "priv");
    }
}

int sub throw_exception() {
    throw "TEST", "test";
}

class Base {
    constructor(int i) {
    }
}

class BaseClassExceptionTest inherits Base {
    constructor() : Base(throw_exception()) {
    }
}

class Base1 {
    public {
        int i;
    }

    constructor(int i) {
        self.i = i;
    }
}

class Child1 inherits Base1 {
    constructor(Base2 b) : Base1(b.doInt(1)) {
    }
}

class Base2 {
    int doInt(int i) {
        return i;
    }

    int doInt(float f) {
        return f.toInt();
    }
}

class Child2 inherits Base2 {
    int doInt(int i) {
        return i + 1;
    }
}

public class ClassesTest inherits QUnit::Test {
    constructor() : Test("Classes test", "1.0") {
        addTestCase("Class library test", \classLibraryTest());
        addTestCase("Deprecated method test", \deprecatedMethodTest());
        addTestCase("Built-in class w/o methods", \builtinNoMethods());
        addTestCase("Base class tests", \baseClassTests());

        # Return for compatibility with test harness that checks return value.
        set_return_value(main());
    }

    classLibraryTest() {
        Test1 t(1, "gee", 2);
        assertEq("gee", t.getData(1), "first object");
        assertTrue(exists t.testing, "memberGate() existence");
        assertEq("memberGate-testing", t.testing, "memberGate() value");
        assertEq("test", t.test(), "methodGate() value");
        assertTrue(t instanceof Test1, "first instanceof");
        assertTrue(t instanceof Qore::Socket, "second instanceof");

        # verify private member access protection

        # object -= private member
        assertThrows("PRIVATE-MEMBER", sub () { t -= "a"; });
        # object -= list of private members
        assertThrows("PRIVATE-MEMBER", sub () { t -= ("a", "b"); });

        any t1 = new Test1(1, "gee", 2);
        # delete object's private member
        assertThrows("PRIVATE-MEMBER", sub () { delete t1.a; });
        # reassign object's private member
        assertThrows("PRIVATE-MEMBER", sub () { t1.a = 3; });

        any t2 = new Test2();
        # read object's private member
        assertThrows("PRIVATE-MEMBER", sub () { any x = t2.a + x; });

        # test memberGate
        assertEq("memberGate-a", t.a, "object memberGate() methods");

        # test memberNotification()
        t.x = 1;
        # test object closure
        code c = t.closure(1);
        assertEq("gee-1-2-2", c(2), "first object closure");
        assertEq("gee-1-2-3", c(2), "second object closure");
        assertEq(1, t.t.x, "memberNotification() method");

        # test call_object_method*()
        assertEq((1, 2),  call_object_method(t1, "argTest", 1, 2), "call_object_method()");
        assertEq(NOTHING, call_object_method_args(t1, "argTest"), "first call_object_method_args()");
        assertEq(list(1), call_object_method_args(t1, "argTest", 1), "second call_object_method_args()");
        assertEq((1, 2),  call_object_method_args(t1, "argTest", (1, 2)), "third call_object_method_args()");

        assertThrows("METHOD-IS-PRIVATE", \call_object_method(), (t2, "priv"));
        assertThrows("METHOD-IS-PRIVATE", \t2.pub());
    }

    deprecatedMethodTest() {
        Program p(PO_NEW_STYLE|PO_REQUIRE_TYPES);

        *hash wh = p.parse("class X {deprecated meth() {} other() { meth(); }}", "", WARN_ALL);
        assertEq("DEPRECATED", wh.err);
        assertEq("System", wh.type);
        assertEq(1, wh.line);
        assertEq(1, wh.endline);
    }

    builtinNoMethods() {
        AbstractQuantifiedBidirectionalIterator a = new HashIterator({'a': 1});
        assertTrue(a.next());
        assertEq(1, a.getValue());
    }

    baseClassTests() {
        hash ex;
        try {
            BaseClassExceptionTest b();
        }
        catch (hash nex) {
            ex = nex;
        }
        assertEq(79, ex.callstack[0].line);

        Child2 c2();
        Child1 c1(c2);
        assertEq(2, c1.i);
    }
}
