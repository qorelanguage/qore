#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../qlib/QUnit.qm

%exec-class ReflectionTest

class Test {
    public {
        int i = 1;

        static int si = 2;

        const C_I = 3;
    }

    private {
        string str = "string";

        static string sstr = "string2";

        const C_STR = "string3";
    }

    private:internal {
        number pi = M_PI;

        static number spi = M_PI * M_PI;

        const C_PI = M_PI * M_PI * M_PI;
    }
}

class ReflectionTest inherits QUnit::Test {
    constructor() : QUnit::Test("ReflectionTest", "1.0") {
        addTestCase("reflection tests", \reflectionTests());
        set_return_value(main());
    }

    reflectionTests() {
        Class c("Mutex");

        assertTrue(c.isBuiltin());
        assertFalse(c.isUser());
        assertFalse(c.isAbstract());
        assertEq("Mutex", c.getName());
        assertEq("Qore::Thread::Mutex", c.getPathName());
        assertGt(0, c.getId());
        assertEq(20, c.getHash().size());
        assertFalse(c.hasMemberGate());
        assertFalse(c.hasMethodGate());
        assertFalse(c.hasMemberNotification());
        assertEq(MC_BUILTIN, c.getModifiers());
        assertEq(("builtin",), c.getModifierList());
        assertEq(DOM_THREAD_CLASS, c.getDomain());
        assertEq(("THREAD_CLASS",), c.getDomainStringList());

        {
            auto v = c.newObject();
            assertTrue(v instanceof Mutex);
            Class c1 = v.getReflectionClass();
            assertEq(c1.getId(), c.getId());
            assertEq(c1.getHash(), c.getHash());
        }

        {
            auto v = c.newObjectArgs();
            assertTrue(v instanceof Mutex);
            Class c1 = v.getReflectionClass();
            assertEq(c1.getId(), c.getId());
            assertEq(c1.getHash(), c.getHash());
        }

        NormalMethod m = c.getMethod("lock");
        assertTrue(m.isBuiltin());
        assertFalse(m.isUser());
        assertEq("lock", m.getName());
        assertFalse(m.isInjected());

        m = c.getNormalMethod("lock");
        assertEq("normal", m.getMethodTypeName());
        assertTrue(m.isBuiltin());
        assertFalse(m.isUser());
        assertEq("lock", m.getName());

        assertThrows("METHOD-ERROR", \c.getStaticMethod(), "lock");

        Mutex mtx = c.newObject();
        m.call(mtx);
        assertTrue(mtx.lockOwner());
        mtx.unlock();

        m.callArgs(mtx);
        assertTrue(mtx.lockOwner());
        mtx.unlock();

        assertThrows("METHOD-ERROR", \m.call(), new Condition());

        {
            ConstructorMethod con = c.getMethod("constructor");
            assertEq("constructor", con.getMethodTypeName());
            assertTrue(con.isBuiltin());
            assertFalse(con.isUser());
            assertEq("constructor", con.getName());
            {
                object o = con.call();
                assertTrue(o instanceof Mutex);
            }

            DestructorMethod des = c.getMethod("destructor");
            assertEq("destructor", des.getMethodTypeName());
            assertTrue(des.isBuiltin());
            assertFalse(des.isUser());
            assertEq("destructor", des.getName());
            {
                object o = con.call();
                assertTrue(o instanceof Mutex);
                assertEq("Mutex", o.className());
                des.call(o);
                assertThrows("OBJECT-ALREADY-DELETED", \o.lock());
            }

            {
                Class c1 = Class::forName("Mutex");
                assertEq("Mutex", c1.getName());
                assertEq(c1.getId(), c.getId());
                assertEq(c1.getHash(), c.getHash());
            }

            CopyMethod copy = c.getMethod("copy");
            assertEq("copy", copy.getMethodTypeName());
            assertTrue(copy.isBuiltin());
            assertFalse(copy.isUser());
            assertEq("copy", copy.getName());
            {
                object o = con.call();
                assertTrue(o instanceof Mutex);
                assertEq("Mutex", o.className());
                Mutex o2 = copy.call(o);
                assertTrue(o2 instanceof Mutex);
                assertEq("Mutex", o2.className());
                assertThrows("METHOD-ERROR", \copy.call(), new Condition());
            }
        }

        {
            list<AbstractMethod> l = c.getMethods();
            assertEq(6, l.size());
        }

        {
            list<hash<ClassAccessInfo>> l = c.getParentClasses();
            assertEq(1, l.size());
            hash<ClassAccessInfo> h = l[0];
            assertEq("AbstractSmartLock", h.cls.getName());
            assertEq(AC_PUBLIC, h.access);
            assertEq("public", h.access_string);
        }

        {
            Class c1 = Class::forName("HashIterator");
            list<hash<ClassAccessInfo>> l = c1.getParentClasses();
            assertEq(1, l.size());
            hash<ClassAccessInfo> h = l[0];
            assertEq("AbstractQuantifiedBidirectionalIterator", h.cls.getName());
            assertEq(AC_PUBLIC, h.access);
            assertEq("public", h.access_string);
        }

        {
            Class c1 = Class::forName("AbstractQuantifiedBidirectionalIterator");
            list<hash<ClassAccessInfo>> l = c1.getParentClasses();
            assertEq(2, l.size());
            hash<ClassAccessInfo> h = l[0];
            assertEq("AbstractBidirectionalIterator", h.cls.getName());
            assertEq(AC_PUBLIC, h.access);
            assertEq("public", h.access_string);
            h = l[1];
            assertEq("AbstractQuantifiedIterator", h.cls.getName());
            assertEq(AC_PUBLIC, h.access);
            assertEq("public", h.access_string);

            assertThrows("ABSTRACT-CLASS-ERROR", \c1.newObject());
        }

        NormalMethodVariant v = m.getVariants()[0];
        assertEq(MC_PUBLIC | MC_BUILTIN, v.getModifiers());
        assertEq(("public", "builtin",), v.getModifierList());
        assertEq("", v.getParamString());
        assertEq("nothing", v.getReturnTypeString());
        assertEq(DOM_THREAD_CLASS, v.getDomain());
        assertEq(("THREAD_CLASS",), v.getDomainStringList());

        {
            mtx = new Mutex();
            assertNothing(v.call(mtx));
            assertTrue(mtx.lockOwner());
            mtx.unlock();
            assertThrows("CALL-WITH-TYPE-ERRORS", \v.call(), (mtx, 1));

            Condition cond();
            NormalMethodVariant v1 = cond.getReflectionClass().getMethod("wait").getVariants()[0];
            assertThrows("RUNTIME-TYPE-ERROR", \v1.call(), (cond, 1));
        }

        {
            Class c1 = Class::forName("Qore::TimeZone");
            StaticMethodVariant v1 = c1.getStaticMethod("set").getVariants()[0];
            assertThrows("RUNTIME-TYPE-ERROR", \v1.call(), (1));
        }

        {
            AbstractReflectionFunction f = v.getFunction();
            assertEq(m.getName(), f.getName());
        }

        {
            Class c1 = Class::forName("AbstractIterator");
            assertEq(MC_ABSTRACT, c1.getModifiers() & MC_ABSTRACT);
            NormalMethodVariant v1 = c1.getMethod("getValue").getVariants()[0];
            assertTrue(v1.isAbstract());
            assertTrue(v1.empty());
            assertFalse(v1.hasBody());
            assertThrows("ABSTRACT-VARIANT-ERROR", \v1.call(), (new ListIterator()));
        }

        c = Class::forName("Condition");

        v = c.getVariant("wait", Class::forName("AbstractSmartLock").typeObject(), TimeoutType);
        assertEq("int", v.getReturnType().getName());
        assertEq((NOTHING, 0), v.getDefaultArgs());
        assertEq(("lock", "timeout_ms"), v.getParamNames());
        assertEq("object<AbstractSmartLock> lock, timeout timeout_ms = 0", v.getParamString());
        assertEq("public int Condition::wait(object<AbstractSmartLock> lock, timeout timeout_ms = 0)", v.toString());
        assertEq(0, v.getCodeFlags());
        assertEq((), v.getCodeFlagList());

        v = Class::forName("File").getMethod("printf").getVariants()[0];
        assertEq(CF_USES_EXTRA_ARGS, v.getCodeFlags());
        assertEq(("USES_EXTRA_ARGS",), v.getCodeFlagList());

        {
            ConstructorMethodVariant conv = c.getConstructorVariant();
            Condition cond = conv.call();
            assertEq("Condition", cond.className());
            assertEq("public", conv.getAccessModifierString());

            assertThrows("CALL-WITH-TYPE-ERRORS", \conv.call(), 1);

            assertThrows("METHOD-ERROR", \c.getDestructorVariant());
            assertNothing(c.getIfDestructorVariant());

            Class c1 = Class::forName("Queue");
            conv = c1.getConstructorVariant();
            Queue q = conv.call();
            assertEq("Queue", q.className());

            CopyMethodVariant copyv = c1.getCopyVariant();
            assertThrows("METHOD-ERROR", \copyv.call(), cond);
            Queue q2 = copyv.call(q);
            assertEq("Queue", q2.className());

            DestructorMethodVariant destrv = c1.getDestructorVariant();
            assertThrows("METHOD-ERROR", \destrv.call(), cond);
            destrv.call(q);
            assertFalse(q.val());
            assertTrue(c1.isEqual(destrv.getClass()));
            assertTrue(c1.getDestructorMethod().isEqual(destrv.getMethod()));
        }

        {
            Test t();
            Class c1 = t.getReflectionClass();
            list<AbstractMember> l = c1.getMembers();
            NormalMember nm = l[0];
            assertEq("i", nm.getName());
            assertTrue(IntType.isEqual(nm.typeObject()));
            assertEq(MC_PUBLIC | MC_USER, nm.getModifiers());
            assertEq("public", nm.getAccessModifierString());
            assertTrue(c1.isEqual(nm.getClass()));
            assertThrows("UNKNOWN-MEMBER", \c1.getMember(), "x");
            assertEq(t.i, nm.getValue(t));
            assertThrows("RUNTIME-TYPE-ERROR", \nm.setValue(), (t, "str"));
            assertEq(t.i, nm.getValue(t));
            nm.setValue(t, 4);
            assertEq(4, nm.getValue(t));
            assertEq(4, t.i);
            assertTrue(nm.isEqual(c1.getMember("i")));

            assertThrows("UNKNOWN-NORMAL-MEMBER", \c1.getNormalMember(), "si");
            assertThrows("UNKNOWN-STATIC-MEMBER", \c1.getStaticMember(), "i");

            StaticMember sm = c1.getStaticMember("si");
            assertEq(MC_PUBLIC | MC_STATIC | MC_USER, sm.getModifiers());
            assertEq(2, sm.getValue());
            assertThrows("RUNTIME-TYPE-ERROR", \sm.setValue(), "str");
            assertEq(2, sm.getValue());
            sm.setValue(3);
            assertEq(3, sm.getValue());

            list<ClassConstant> cl = c1.getConstants();
            ClassConstant con = cl[0];
            assertEq("C_I", con.getName());
            assertEq(MC_PUBLIC | MC_USER, con.getModifiers());
            assertFalse(con.getSourceLocation().builtin);

            assertThrows("UNKNOWN-CONSTANT", \c1.getConstant(), "x");
            ClassConstant con2 = c1.getConstant("C_I");
            assertTrue(con2.isEqual(con));
            #map printf("%y %s: %y\n", $1.getModifierList(), $1.getName(), $1.getSourceLocation()), cl;
        }

        {
            Namespace n = Namespace::forName("Thread");
            assertFalse(n.isRoot());
            assertFalse(n.isImported());
            assertTrue(n.isBuiltin());
            assertFalse(n.isUser());
            assertEq("Thread", n.getName());
            assertEq("Qore::Thread", n.getPathName());

            assertThrows("UNKNOWN-CONSTANT", \n.getConstant(), "x");

            n = Namespace::forName("Option");
            Constant c1 = n.getConstant("HAVE_ROUND");
            assertTrue(c1.getValue());
            #map printf("%y %s: %y\n", $1.getModifierList(), $1.getName(), $1.getSourceLocation()), n.getConstants();

            assertEq((), n.getClasses());
            assertThrows("UNKNOWN-CLASS", \n.getClass(), "x");

            assertEq((), n.getNamespaces());
            assertThrows("UNKNOWN-NAMESPACE", \n.getNamespace(), "x");

            n = Namespace::forName("Qore");
            assertTrue(Class::forName("File").isEqual(n.getClass("File")));
            assertFalse(Class::forName("File").isEqual(n.getClass("ReadOnlyFile")));
            assertTrue(Namespace::forName("Thread").isEqual(n.getNamespace("Thread")));
            assertFalse(Namespace::forName("Thread").isEqual(n.getNamespace("Option")));

            #map printf("%y %s: %y\n", $1.getModifierList(), $1.getName(), $1.getPathName()), n.getClasses();
            #map printf("%y %s: %y\n", $1.getModifierList(), $1.getName(), $1.getPathName()), n.getNamespaces();
        }
    }
}
