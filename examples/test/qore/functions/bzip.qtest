#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../qlib/QUnit.qm

%exec-class Bzip2Test

class Bzip2Test inherits QUnit::Test {
    private {
        string uncompressed_string = "This is a long string xxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        binary compressed = parse_base64_string("QlpoMzFBWSZTWVOcyk4AAAMzgABAQAAEACDlnEAgACGo0yA/ShAAAYqyprq0Y5c8OFI7R8XckU4UJBTnMpOA");

        # Binary formatted as string. Has the ability to crash the underlying bzip2 library.
        binary compressed_bad = binary("BZh91AY&SYwcUC^@^@^Có<80>^@^P^@@@^@^D^@ å<9c>@ ^@!©<90>Ð7©\n`^@^Z<85>^ZY<8f>-<97>ë^RS¬Igø»<92>)Â<84><83>»^Zª^X");
    }

    constructor() : Test("Bzip2Test", "1.0", \ARGV) {
        addTestCase("bzip compression test", \testCompress(), NOTHING);
        addTestCase("bzip decompression test", \testDecompress(), NOTHING);
        addTestCase("bzip bad data decompression test", \testBad(), NOTHING);

        # Return for compatibility with test harness that checks return value.
        set_return_value(main());
    }

    testCompress() {
        assertEq(compressed, bzip2(uncompressed_string));
        assertEq(compressed, bzip2(binary(uncompressed_string)));
    }

    testDecompress() {
        assertEq(uncompressed_string, bunzip2_to_string(compressed));
        assertEq(binary(uncompressed_string), bunzip2_to_binary(compressed));
    }

    testBad() {
        assertThrows("BZIP2-DECOMPRESS-ERROR", sub() { bunzip2_to_binary(compressed_bad); });
        assertThrows("BZIP2-DECOMPRESS-ERROR", sub() { bunzip2_to_binary(compressed.substr(0, 20)); });
        assertThrows("BZIP2-DECOMPRESS-ERROR", sub() { bunzip2_to_binary(compressed + <01>); });
    }
}
