#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../../qlib/Util.qm
%requires ../../../../../qlib/QUnit.qm

%exec-class SerializableTest

const RCount = 3;

class Err inherits Serializable {
    public {
        Mutex m();
    }
}

class Test inherits Serializable {
    public {
        Test t;
        int i0 = 1;
        int i2 = 1024;
        int i4 = 100000;
        int i8 = 23918328238923;
        bool b = True;
        list l = (1, "2", True);
        float f = 1.1;
        number n = 100n;
        date ab = now_us();
        date rel = now_us() - 2017-01-02;
    }

    constructor() {
        t = self;
    }
}

class RTest inherits Serializable {
    public {
        list<RTest> l;
    }
}

class Other inherits Serializable;

class Foundation inherits Serializable {
    public {
        int i = 3;
    }

    int getfi() {
        return i;
    }
}

class Base inherits Serializable, private:internal Foundation {
    public {
        int x = 2;
    }

    private:internal {
        int i = 2;
    }

    int get() {
        return x;
    }

    int geti() {
        return i;
    }

    int getfi() {
        return Foundation::getfi();
    }
}

class T inherits Serializable, private:internal Base {
    public {
        int i = 1;
        float f = 1.0;
        number n = M_PIn;
        date now = now_us();
        date rel = 1s;
        hash<auto> h = {
            "a": 1,
        };
        hash<StatInfo> si();

        transient int skip = 1;

        Other o0();
        Other o1;
    }

    private {
        string str = "test";
    }

    private:internal {
        bool flag = False;
    }

    constructor() {
        o1 = o0;
        skip = 2;
    }

    int get() {
        return Base::get();
    }

    int geti() {
        return Base::geti();
    }

    int getfi() {
        return Base::getfi();
    }
}

class SerializableTest inherits QUnit::Test {
    public {
        const Data = (
            1,
            "two",
            NOTHING,
            0,
            0.0,
            22,
            9223372036854775807,
            -9223372036854775807,
            500n,
            M_PIn,
            2.141578291e50n,
            2010-05-05T15:35:02.100,
            False,
            M_PI,
            250.192393,
            1970-01-01Z,
            (hash(), (), "three \"things\""),
            P2M3DT10H14u,
            now_us(),
            <beadface>,
            {
                "a": 2.0,
                "b": "hello",
                "key": True,
            },
            @inf@n,
            -@inf@n,
            @inf@,
            -@inf@,
            "'single quoted string'",
            "'1234'",
        );
    }

    constructor() : QUnit::Test("Serializable", "1.0") {
        addTestCase("SerializableTest", \serializableTest());
        set_return_value(main());
    }

    serializableTest() {
        {
            Err err();
            assertThrows("SERIALIZATION-ERROR", \err.serializeToData());
        }

        {
            T t();
            assertEq(2, t.skip);
            hash<SerializationInfo> h = t.serializeToData();
            assertEq(2, h._index.size());
            assertEq(1, h._data.size());
            assertEq(Type::String, h._data._index.type());
            assertEq(1, h._index."0"._class_data.T.i);

            assertEq(2, t.get());
            assertEq(2, t.geti());
            assertEq(3, t.getfi());

            # ensure that transient members are not serialized
            assertNothing(h._index."0"._class_data.T.skip);
            #printf("%N\n", h);

            T t1 = Serializable::deserialize(h);
            assertEq(1, t1.skip);
            assertEq(2, t1.get());
            assertEq(2, t1.geti());
            assertEq(3, t1.getfi());

            {
                hash<SerializationInfo> h0 = h;
                h0._index."0"._class = "T0";
                assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), h0);
            }

            {
                # invalid type
                StringInputStream sis("QS_" + chr(0) + "1.0" + chr(0));
                assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), sis);

                # invalid version
                sis = new StringInputStream("QS" + chr(0) + "0.9" + chr(0));
                assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), sis);

                # premature end of stream
                sis = new StringInputStream("QS" + chr(0) + "1.0");
                assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), sis);

                # invalid header
                sis = new StringInputStream("QS" + chr(0) + "1.0" + strmul("x", 100));
                assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), sis);

                /*
                BinaryOutputStream bin();
                t.serialize(bin);

                BinaryInputStream bis(bin.getData());

                auto x = Serializable::deserialize(bis);
                printf("x: %N\n", x);
                */
            }

            #printf("t: %N\n", t1);
        }

        {
            Test t();
            hash<SerializationInfo> h = t.serializeToData();
            Test t1 = Serializable::deserialize(h);
            assertEq(t1.t, t1);
            #printf("%N\n", h);
            #h = x;

            BinaryOutputStream bin();
            t.serialize(bin);

            binary bin_data = bin.getData();
            BinaryInputStream bis(bin_data);

            Test t2 = Serializable::deserialize(bis);
            assertEq(t2.t, t2);
        }

        {
            list<RTest> l = map new RTest(), xrange(RCount - 1);
            for (int i = 0; i < RCount; ++i) {
                for (int j = 0; j < RCount; ++j) {
                    int k = i + j + 1;
                    if (k >= RCount) {
                        k -= RCount;
                    }
                    #printf("%y %y %y\n", i, j, k);
                    l[i].l[j] = l[k];
                }
            }
            hash<SerializationInfo> h = Serializable::serializeToData(l);
            #printf("%N\n", h);
            list<RTest> l1 = Serializable::deserialize(h);
            assertTrue(l1[0].l[0] == l1[1]);
            assertTrue(l1[0].l[1] == l1[2]);
            assertTrue(l1[0].l[2] == l1[0]);
            #printf("%N\n", l1);
        }

        {
            hash<SerializationInfo> h = Serializable::serializeToData(Data);
            auto d = Serializable::deserialize(h);
            assertEq(Data, d);
        }

        {
            TimeZone tz("Europe/Prague");
            hash<SerializationInfo> h = tz.serializeToData();
            #printf("%N\n", h);

            TimeZone tz1 = Serializable::deserialize(h);
            assertEq("Europe/Prague", tz1.region());
            #printf("%N\n", tz1);

            hash<auto> h1 = h;
            assertEq("Europe/Prague", remove h1._index."0"._class_data."Qore::TimeZone".region);
            assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), h1);

            h1 = h;
            assertEq({"region": "Europe/Prague"}, remove h1._index."0"._class_data."Qore::TimeZone");
            assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), h1);

            h1 = h;
            h1._index."0"._class_data."Qore::extra" = {};
            assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), h1);

            h1 = h;
            h1._index."0"._class_data."Qore::Serializable" = {};
            assertThrows("DESERIALIZATION-ERROR", \Serializable::deserialize(), h1);
        }
    }
}
