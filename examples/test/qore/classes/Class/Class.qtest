#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../../qlib/QUnit.qm

%exec-class Test

class Test inherits QUnit::Test {
    constructor() : QUnit::Test("Class", "1.0") {
        addTestCase("simple tests", \simpleTests());
        set_return_value(main());
    }

    simpleTests() {
        Class c("Mutex");

        assertTrue(c.isBuiltin());
        assertFalse(c.isUser());
        assertFalse(c.isAbstract());
        assertEq("Mutex", c.getName());
        assertEq("Qore::Thread::Mutex", c.getPathName());
        assertGt(0, c.getId());
        assertEq(20, c.getHash().size());
        assertFalse(c.hasMemberGate());
        assertFalse(c.hasMethodGate());
        assertFalse(c.hasMemberNotification());

        {
            auto v = c.newObject();
            assertTrue(v instanceof Mutex);
            Class c1 = v.getClass();
            assertEq(c1.getId(), c.getId());
            assertEq(c1.getHash(), c.getHash());
        }

        {
            auto v = c.newObjectArgs();
            assertTrue(v instanceof Mutex);
            Class c1 = v.getClass();
            assertEq(c1.getId(), c.getId());
            assertEq(c1.getHash(), c.getHash());
        }

        NormalMethod m = c.getMethod("lock");
        assertTrue(m.isBuiltin());
        assertFalse(m.isUser());
        assertEq("lock", m.getName());

        m = c.getNormalMethod("lock");
        assertEq("normal", m.getMethodTypeName());
        assertTrue(m.isBuiltin());
        assertFalse(m.isUser());
        assertEq("lock", m.getName());

        assertThrows("METHOD-ERROR", \c.getStaticMethod(), "lock");

        Mutex mtx = c.newObject();
        m.call(mtx);
        assertTrue(mtx.lockOwner());
        mtx.unlock();

        m.callArgs(mtx);
        assertTrue(mtx.lockOwner());
        mtx.unlock();

        assertThrows("METHOD-ERROR", \m.call(), new Condition());

        ConstructorMethod con = c.getMethod("constructor");
        assertEq("constructor", con.getMethodTypeName());
        assertTrue(con.isBuiltin());
        assertFalse(con.isUser());
        assertEq("constructor", con.getName());
        {
            object o = con.call();
            assertTrue(o instanceof Mutex);
        }

        DestructorMethod des = c.getMethod("destructor");
        assertEq("destructor", des.getMethodTypeName());
        assertTrue(des.isBuiltin());
        assertFalse(des.isUser());
        assertEq("destructor", des.getName());
        {
            object o = con.call();
            assertTrue(o instanceof Mutex);
            assertEq("Mutex", o.className());
            des.call(o);
            assertThrows("OBJECT-ALREADY-DELETED", \o.lock());
        }

        {
            Class c1 = Class::forName("Mutex");
            assertEq("Mutex", c1.getName());
            assertEq(c1.getId(), c.getId());
            assertEq(c1.getHash(), c.getHash());
        }

        CopyMethod copy = c.getMethod("copy");
        assertEq("copy", copy.getMethodTypeName());
        assertTrue(copy.isBuiltin());
        assertFalse(copy.isUser());
        assertEq("copy", copy.getName());
        {
            object o = con.call();
            assertTrue(o instanceof Mutex);
            assertEq("Mutex", o.className());
            Mutex o2 = copy.call(o);
            assertTrue(o2 instanceof Mutex);
            assertEq("Mutex", o2.className());
            assertThrows("METHOD-ERROR", \copy.call(), new Condition());
        }

        {
            list<AbstractMethod> l = c.getMethods();
            assertEq(6, l.size());
        }

        {
            list<hash<ClassAccessInfo>> l = c.getParentClasses();
            assertEq(1, l.size());
            hash<ClassAccessInfo> h = l[0];
            assertEq("AbstractSmartLock", h.cls.getName());
            assertEq(AC_Public, h.access);
            assertEq("public", h.access_string);
        }

        {
            Class c1 = Class::forName("HashIterator");
            list<hash<ClassAccessInfo>> l = c1.getParentClasses();
            assertEq(1, l.size());
            hash<ClassAccessInfo> h = l[0];
            assertEq("AbstractQuantifiedBidirectionalIterator", h.cls.getName());
            assertEq(AC_Public, h.access);
            assertEq("public", h.access_string);
        }

        {
            Class c1 = Class::forName("AbstractQuantifiedBidirectionalIterator");
            list<hash<ClassAccessInfo>> l = c1.getParentClasses();
            #map printf("%y (%s)\n", $1.cls.getName(), $1.access_name), l;
            assertEq(2, l.size());
            hash<ClassAccessInfo> h = l[0];
            assertEq("AbstractBidirectionalIterator", h.cls.getName());
            assertEq(AC_Public, h.access);
            assertEq("public", h.access_string);
            h = l[1];
            assertEq("AbstractQuantifiedIterator", h.cls.getName());
            assertEq(AC_Public, h.access);
            assertEq("public", h.access_string);

            assertThrows("ABSTRACT-CLASS-ERROR", \c1.newObject());
        }
    }
}
