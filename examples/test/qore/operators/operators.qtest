#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../qlib/QUnit.qm

%exec-class Test

class Test inherits QUnit::Test {
    constructor() : QUnit::Test("operators", "1.0", \ARGV) {
        addTestCase("basic operator tests", \basicTests());
        addTestCase("lvalue tests", \lvalueTests());
        addTestCase("const modulo", \constModulo());
        set_return_value(main());
    }

    basicTests() {
        int a = 1;
        testAssertionValue("variable assignment", a, 1);
        a += 3;
        testAssertionValue("integer += operator", a, 4);
        a -= 2;
        testAssertionValue("integer -= operator", a, 2);
        a |= 1;
        testAssertionValue("|= operator", a, 3);
        a &= 1;
        testAssertionValue("&= operator", a, 1);
        a *= 10;
        testAssertionValue("integer *= operator", a, 10);
        float f = a;
        f *= 2.2;
        testAssertionValue("first float *= operator", f, 22.0);
        f *= 2;
        testAssertionValue("second float *= operator", f, 44.0);
        f /= 4.4;
        testAssertionValue("float /= operator", f, 10.0);
        a = 10;
        a /= 2;
        testAssertionValue("integer /= operator", a, 5);
        testAssertionValue("first / operator", 4 / 2, 2);
        a = 0xfdb4902a;
        a ^= 0xbf40e848;
        testAssertionValue("^= xor equals operator", a, 0x42f47862);
        a <<= 2;
        testAssertionValue("<<= shift-left-equals operator", a, 0x10bd1e188);
        a >>= 3;
        testAssertionValue(">>= shift-right-equals operator", a, 0x217a3c31);
        a = 1;
        testAssertionValue("pre post-increment (++) operator", a++, 1);
        testAssertionValue("post post-increment (++) operator", a, 2);
        testAssertionValue("pre post-decrement (--) operator", a--, 2);
        testAssertionValue("post post-decrement (--) operator", a, 1);
        testAssertionValue("pre-increment (++) operator", ++a, 2);
        testAssertionValue("pre-decrement (--) operator", --a, 1);

        string astr = "hello" + " there";
        testAssertionValue("string concatenation", astr, "hello there");
        astr += " gee";
        testAssertionValue("string plus equals", astr, "hello there gee");

        f = 1.0;
        f += 1.2;
        testAssertionValue("float += operator", f, 2.2);
        f -= 1.1;
        testAssertionValue("float -= operator", f, 1.1);
        f = 5.5 * 2.0;
        testAssertionValue("float * operator", f, 11.0);

        testAssertionValue("date > operator", now() > (now() - 1D), True);
        testAssertionValue("date >= operator", now() >= (now() - 1h), True);
        testAssertionValue("date < operator", (now() - 1m) < now(), True);
        testAssertionValue("date <= operator", (now() - 1M) <= now(), True);

        date bt = date at = now();
        testAssertionValue("date == operator", at, bt);
        at = 2004-02-28-12:00:00;
        at += 1D;
        testAssertionValue("first date += operator", at, 2004-02-29-12:00:00);
        at -= (3h + 5m);
        testAssertionValue("second date += operator", at, 2004-02-29-08:55:00);

        # relative date arithmetic tests
        assertEq(3s, 5s - 2s);
        assertEq(-1s, 2s - 3s);
        # check for normalization between hours & minutes
        assertEq(30m, 1h - 30m);
        # rel date - abs date is performed by using the seconds + us offset from the epoch in the absolute date
        assertEq(15s, 30s - 1970-01-01T00:00:15Z);

        # relative date comparison tests
        assertEq(True, 72h > 2D);
        assertEq(True, 72h == 3D);
        assertEq(True, 72h < 4D);
        assertEq(True, 7201s > 2h);
        assertEq(True, 7200s == 2h);
        assertEq(True, 7199s < 2h);
        assertEq(True, 86401s > 1D);
        assertEq(True, 86400s == 1D);
        assertEq(True, 86399s < 1D);
        assertEq(True, 32D > 1M);
        assertEq(True, 31D == 1M);
        assertEq(True, 30D < 1M);
        assertEq(True, 2678399s < 1M);
        assertEq(True, 2678400s == 1M);
        assertEq(True, 2678401s > 1M);
        assertEq(True, P1M32D > 2M);
        assertEq(True, P1M31D == 2M);
        assertEq(True, P1M30D < 2M);
        assertEq(True, 13M > 1Y);
        assertEq(True, 12M == 1Y);
        assertEq(True, 11M < 1Y);
        assertEq(True, 366D > 1Y);
        assertEq(True, 365D == 1Y);
        assertEq(True, 364D < 1Y);
        assertEq(True, 86400s + 1us > 1D);
        assertEq(True, 86400s + 1000ms == 1D + 1s);
        assertEq(True, 86400s + 20ms < 1D + 1s);

        any ni += 3.2;
        testAssertionValue("float +=, lhs NOTHING", ni, 3.2);
        delete ni;
        ni += "hello";
        testAssertionValue("string +=, lhs NOTHING", ni, "hello");
        delete ni;
        ni -= 4.5;
        testAssertionValue("float -=, lhs NOTHING", ni, -4.5);
        delete ni;
        ni -= 4;
        testAssertionValue("integer -=, lhs NOTHING", ni, -4);
        # some array and hash tests in separate functions

        # get function closure with bound local variable (multiply by 2)
        code c = mapClosure(2);

        # map function to list
        testAssertionValue("map operator using closure", (map c($1), (1, 2, 3)), (2, 4, 6));

        # map immediate expression to list
        testAssertionValue("map operator using expression", (map $1 * 2, (1, 2, 3)), (2, 4, 6));

        # map function to list with optional select code as expression
        testAssertionValue("map operator using closure with optional select expression", (map c($1), (1, 2, 3), $1 > 1), (4, 6));

        # select all elements from list greater than 1 with expression
        testAssertionValue("select operator with expression", (select (1, 2, 3), $1 > 1), (2, 3));

        # create a sinple closure to subtract the second argument from the first
        c = any sub(any x, any y) { return x - y; };

        # left fold function on list using closure
        testAssertionValue("foldl operator with closure", (foldl c($1, $2), (2, 3, 4)), -5);

        # left fold function on list using expression
        testAssertionValue("foldl operator with expression", (foldl $1 - $2, (2, 3, 4)), -5);

        # right fold function on list using immediate closure
        testAssertionValue("foldr operator with closure", (foldr c($1, $2), (2, 3, 4)), -1);

        # right fold function on list using expression and implicit arguments
        testAssertionValue("foldr operator with expression", (foldr $1 - $2, (2, 3, 4)), -1);

        hash h = ("test" : 1, "two" : 2.0, "three" : "three", "four" : False );
        testAssertionValue("first remove operator", remove h.two, 2.0);

        testAssertion("int div by zero", any sub () {int i = 0; return 1 / i;}, NOTHING, new TestResultExceptionType("DIVISION-BY-ZERO"));
        testAssertion("float div by zero", any sub () {float n = 0; return 1 / n;}, NOTHING, new TestResultExceptionType("DIVISION-BY-ZERO"));
        testAssertion("numeric div by zero", any sub () {number n = 0n; return 1 / n;}, NOTHING, new TestResultExceptionType("DIVISION-BY-ZERO"));
        testAssertion("div by zero", any sub () {any n; return 1 / n;}, NOTHING, new TestResultExceptionType("DIVISION-BY-ZERO"));

        Program p(PO_NEW_STYLE);
        testAssertion("trim operator parse-time return value", \p.parse(), ("string sub test() {string str = \"a string \\n\"; string astr = trim str; return astr;}", "trim operator test"), new TestResultValue(NOTHING));
        testAssertionValue("trim operator", p.callFunction("test"), "a string");
    }

    lvalueTests() {
        # bug 88: lvalue reference-handling bug
        hash h.a = 1;
        h.b = h;
        testAssertionValue("hash assignment", sprintf("%y", h), "{a: 1, b: {a: 1}}");
        string str = "a";
        h = (str: 1); h.b += h;
        testAssertionValue("hash +=", sprintf("%y", h), "{a: 1, b: {a: 1}}");
    }

    constModulo() {
        assertEq(2, 12 % 10);
    }

    static code mapClosure(any v) {
        return any sub(any v1) { return v * v1; };
    }
}
