#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../qlib/QUnit.qm
%requires ../../../../qlib/CsvUtil.qm

%exec-class CsvUtilTest

softstring sub detectLineType(any values) {
    softint type = -1;
    switch (values.typeCode()) {
    case NT_HASH:
        type = values.type;
        break;
    case NT_LIST:
        type = values[0];
        break;
    }
    switch (type) {
    case 1:
        return "header";
    case 2:
        return "item";
    case 3:
        return "footer";
    }
    return NULL;
}

public class CsvMultiDataIterator inherits CsvDataIterator {
    constructor(string data, *hash opts)
            : CsvDataIterator(data, opts) {
    }

    public softstring detectLineTypeImpl(any values) {
        return detectLineType(values);
    }
}

public class CsvMultiStringWriter inherits CsvStringWriter {
    constructor(*hash opts) : CsvStringWriter(opts) {
    }

    public softstring detectLineTypeImpl(any values) {
        return detectLineType(values);
    }
}


public class CsvUtilTest inherits QUnit::Test {
    private {
        const CsvInput = "UK,1234567890,\"Sony, Xperia S\",31052012
UK,1234567891,\"Sony, Xperia S\",31052012
UK,1234567892,\"Sony, Xperia S\",31052012
UK,1234567893,\"Sony, Xperia S\",31052012";

        const CsvRecords = (
            ("cc": "UK", "serno": 1234567890, "desc": "Sony, Xperia S", "received": 2012-05-31),
            ("cc": "UK", "serno": 1234567891, "desc": "Sony, Xperia S", "received": 2012-05-31),
            ("cc": "UK", "serno": 1234567892, "desc": "Sony, Xperia S", "received": 2012-05-31),
            ("cc": "UK", "serno": 1234567893, "desc": "Sony, Xperia S", "received": 2012-05-31),
        );
        const CsvMultiInput = "1,2016-01,20160401
2,123,\"Sony, Xperia S\",1,100
2,124,\"Nokia, Lumia\",2,150
3,250
";

        const CsvMultiRecords = (
            ("type": 1, "invoice_no": "2016-01", "date": 2016-04-01),
            ("type": 2, "item_no": 123, "item": "Sony, Xperia S", "pcs": 1, "price": 100),
            ("type": 2, "item_no": 124, "item": "Nokia, Lumia", "pcs": 2, "price": 150),
            ("type": 3, "total": 250),
        );
}

    constructor() : Test("CsvUtilTest", "1.0") {
        addTestCase("Basic CSV tests", \csvTest(), NOTHING);
        addTestCase("Multi-type CSV tests", \csvMultiTest(), NOTHING);
        addTestCase("Escaping", \escapeTest());

        # Return for compatibility with test harness that checks return value.
        set_return_value(main());
    }

    csvTest() {
        hash opts = ("fields": ("cc": "string", "serno": "int", "desc": "string", "received": ("type": "date", "format": "DDMMYYYY")),);

        # Iterate through source
        CsvDataIterator i(CsvInput, opts);
        #list l = map $1, i;
        testAssertion("CsvDataIterator 1", \equalsIterated(), (i, new ListIterator(CsvRecords)));

        # test with empty data and header lines
        i = new CsvDataIterator("", ("header-lines": 1));
        testAssertion("CsvDataIterator 2", \i.next(), (), RESULT_FAILURE);
    }

    csvMultiTest() {
        *hash opts = (
            "fields": (
                "type": "int",

                "invoice_no": "string",
                "date": ("type": "date", "format": "YYYYMMDD"),

                "item_no": "string",
                "item": "string",
                "pcs": "int",
                "price": "number",

                "total": "number",
            ),
            "headers": (
                "header": ("type", "invoice_no", "date"),
                "item":   ("type", "item_no", "item", "pcs", "price"),
                "footer": ("type", "total"),
            ),
        );

        # Iterate through source
        CsvMultiDataIterator i(CsvMultiInput, opts);
        #list l = map $1, i;
        testAssertion("CsvMultiDataIterator ", \equalsIterated(), (i, new ListIterator(CsvMultiRecords)));

        CsvMultiStringWriter w( ("write-headers": False, "optimal-quotes" : True, "quote_escape" : '"')+opts );
        string outstr = w.write(CsvMultiRecords);
        testAssertion("multi writer", \equals(), (CsvMultiInput, outstr));

    }

    escapeTest() {
        list row = ( ( '12"', 'a"bc"', ), );
        string esc_default = '"12\"","a\"bc\""'+"\n";
        string esc_double = '"12""","a""bc"""'+"\n";

        CsvStringWriter w( ("optimal-quotes" : False) );
        string outstr = w.write(row);
        testAssertion("default escaping", \equals(), (esc_default, outstr));

        w = new CsvStringWriter(("optimal_quotes": False) );
        outstr = w.write(row);
        assertEq(esc_default, outstr);

        w = new CsvStringWriter( ("optimal-quotes" : False, "quote_escape" : '"') );
        outstr = w.write(row);
        testAssertion("double escaping", \equals(), (esc_double, outstr));

        hash dmh = ("cc": "XX");
        w = new CsvStringWriter(("headers": ("XX", "serno", "desc", "received"), "fields": ("received": ("type": "date", "format": "DDMMYYYY")), "datamap": dmh));
        outstr = w.write(CsvRecords.iterator());
        assertEq("XX,serno,desc,received\n" + CsvInput + "\n", outstr);
    }
/*
    csvData() {
        my hash opts = ("fields": ("id": "int", "name": "string", "descr": "string"));
        const CsvInput2 = "1,UK,United Kingdom
2,AT,Austria
3,CZ,Czech rep.
4,IE,Ireland
";
        const Output = (
            {"id": 1, "name": "UK", "descr": "United Kingdom"},
            {"id": 2, "name": "AT", "descr": "Austria"},
            {"id": 3, "name": "UK", "descr": "Czech rep."},
            {"id": 4, "name": "IE", "descr": "Ireland"},
        };

        # Iterate through source
        CsvDataIterator i(CsvInput, opts);

        testAssertion("CsvDataIterator 2", \equalsIterated(), (i, new ListIterator(Output)));

    } */

}
