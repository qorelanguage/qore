#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%require-types
%enable-all-warnings
%new-style
%strict-args
%allow-injection

%requires ../../../../qlib/Util.qm
%requires ../../../../qlib/QUnit.qm
%requires ../../../../qlib/ConnectionProvider.qm

%exec-class ConnectionProviderTest

const CertPath = normalize_dir(get_script_dir() + DirSep + "mycert.pem");
const KeyPath = normalize_dir(get_script_dir() + DirSep + "mykey.pem");
const KeyPassword = "password";

public class ConnectionProviderTest inherits QUnit::Test {
    constructor() : Test("ConnectionProvider Test", "1.0") {
        addTestCase("ftp", \ftpConnectionTest());
        addTestCase("ftp deprecated", \ftpConnectionTestDeprecated());
        addTestCase("http", \httpConnectionTest());
        addTestCase("http deprecated", \httpConnectionTestDeprecated());
        addTestCase("fs", \fsConnectionTest());
        addTestCase("fs deprecated", \fsConnectionTestDeprecated());
        addTestCase("invalid", \invalidConnectionTest());
        addTestCase("custom parseUrl", \customParseUrlTest());

        # Return for compatibility with a test harness that checks the return value
        set_return_value(main());
    }

    ftpConnectionTest() {
        string url = "ftp://user:pass@localhost:1234/some_path";
        FtpConnection fc("name", "desc", url);
        assertEq(True, fc.enabled, "connection is enabled by default");
        assertEq(True, fc.monitor, "connection is monitored by default");
        assertEq(False, fc.locked, "connection is unlocked by default");

        hash<ConnectionConstructorInfo> info = fc.getConstructorInfo();
        assertEq("FtpClient", info.class_name);
        assertEq(url, info.args[0]);
        checkPreAndPostProcessing(info);
    }

    ftpConnectionTestDeprecated() {
        string url = "ftp://user:pass@localhost:1234/some_path";
        hash urlh = parse_url(url);
        FtpConnection fc("name", "desc", url, True, NOTHING, urlh);
        assertEq(True, fc.enabled, "connection is enabled by default");
        assertEq(False, fc.locked, "connection is unlocked by defaul");

        hash<ConnectionConstructorInfo> info = fc.getConstructorInfo();
        assertEq("FtpClient", info.class_name);
        assertEq(url, info.args[0]);
        checkPreAndPostProcessing(info);
    }

    private checkPreAndPostProcessing(hash<ConnectionConstructorInfo> info) {
        Program p(PO_NEW_STYLE | PO_STRICT_ARGS | PO_REQUIRE_TYPES);
        if (info.module)
            p.loadModule(info.module);
        if (info.pre_processing) {
            string pre_processing = sprintf("sub pre_processing(reference<*softlist<auto>> args, bool connect, *hash rtopts) { %s }", info.pre_processing);
            # ensure that the pre processing code can be parsed
            p.parse(pre_processing, "pre processing");
            assertTrue(True, "pre processing: " + info.class_name);
        }
        if (info.post_processing) {
            string post_processing = sprintf("sub post_processing(%s obj, bool connect, *hash rtopts) { %s }", info.class_name, info.post_processing);
            # ensure that the post processing code can be parsed
            p.parse(post_processing, "post processing");
            assertTrue(True, "post processing: " + info.class_name);
        }
    }

    httpConnectionTest() {
        TestSslServer server();
        on_exit
            server.stop();
        # use IPv4 localhost to work around potential issues with localhost -> ::1 and IPv6 -> IPv4 mappings
        # (ex: Windows)
        string url = "https://127.0.0.1:" + server.getPort();
        hash opts = (
            "ssl_cert_path": CertPath,
            "ssl_key_path": KeyPath,
            "ssl_key_password": KeyPassword,
        );
        hash attributes = {
            "monitor": True,
        };
        HttpConnection hc("name", "desc", url, attributes, opts);
        assertEq(True, hc.enabled, "connection is enabled by default");
        assertEq(False, hc.locked, "connection is unlocked by default");

        HTTPClient client = hc.get();
        assertEq("X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT", server.wait());

        hash<ConnectionConstructorInfo> info = hc.getConstructorInfo();
        assertEq("HTTPClient", info.class_name);
        assertEq(45s, info.args[0].timeout);
        assertEq(45s, info.args[0].connect_timeout);
        assertEq("password", info.args[0].ssl_key_password);
        checkPreAndPostProcessing(info);

        # turn on certificate verification in the server
        server.acceptAllCertificates(False);
        assertEq(False, server.getAcceptAllCertificates());
        client.disconnect();
        # verify that exceptions are raised in the server & client when connecting
        assertThrows("SOCKET-SSL-ERROR", \client.connect());
        assertEq("SOCKET-SSL-ERROR", server.waitException().err);

        # turn off certificate verification in the server
        server.acceptAllCertificates(True);
        # verify server certificate in the client
        opts.ssl_verify_cert = True;
        hc = new HttpConnection("name", "desc", url, attributes, opts);
        # verify that exceptions are raised in the server & client when connecting
        assertThrows("SOCKET-SSL-ERROR", \hc.get());
        assertEq("SOCKET-SSL-ERROR", server.waitException().err);
    }

    httpConnectionTestDeprecated() {
        string url = "http://127.0.0.1";
        HttpConnection hc("name", "desc", url, True, NOTHING, Qore::parse_url(url));
        assertEq(True, hc.enabled, "connection is enabled by default");
        assertEq(False, hc.locked, "connection is unlocked by defaul");
    }

    fsConnectionTest() {
        string url = Util::tmp_location();
        hash opts = (
            "readonly": False,
        );
        hash attributes = {
            "monitor": True,
        };

        FilesystemConnection fs("name", "desc", url, attributes, opts);
        assertEq(True, fs.enabled, "connection is enabled by default");
        assertEq(False, fs.locked, "connection is unlocked by defaul");
        assertEq(False, fs.opts.readonly, "readonly enabled by opts");

        Dir d = fs.get();
        assertEq(Util::tmp_location(), d.path(), "Path equality");
    }

    fsConnectionTestDeprecated() {
        string url = Util::tmp_location();
        FilesystemConnection fs("name", "desc", url, True, NOTHING, Qore::parse_url(url));
        assertEq(True, fs.enabled, "connection is enabled by default");
        assertEq(False, fs.locked, "connection is unlocked by defaul");

        Dir d = fs.get();
        assertEq(Util::tmp_location(), d.path(), "Path equality");
    }

    invalidConnectionTest() {
        InvalidConnection ic1("name", "desc", "url");
        assertEq("unknown error", ic1.error);

        hash attributes = {
            "error": "lorem ipsum",
        };
        InvalidConnection ic2("name", "desc", "url", attributes);
        assertEq(attributes.error, ic2.error);
    }

    customParseUrlTest() {
        # Qore::parse_url() must fail on this URL
        assertThrows("PARSE-URL-ERROR", \Qore::parse_url(), MyConnection::URL);

        # and now the custom parsing
        MyConnection db();
        assertEq("pgsql", db.urlh.type);
        assertEq("user", db.urlh.user);
        assertEq("pass", db.urlh.pass);
        assertEq("db", db.urlh.db);
        assertEq("host", db.urlh.host);
        assertEq(1234, db.urlh.port);

        assertEq(True, db.locked, "test locked connection");

        # safe url
        assertEq("pgsql:user@db%host:1234", db.safe_url);
    }
}

class MyConnection inherits AbstractConnection {
    public {
        # let's simulate a DB connection (without DatasourcePool options for a simplicity)
        const URL = "sql://pgsql:user/pass@db%host:1234";
    }

    constructor() : AbstractConnection("name", "desc", URL, {"locked": True}) {
    }

    private hash parseUrl(string url) {
        url = replace(url, "sql://", "");
        return parse_datasource(url);
    }

    private string getSafeUrl(hash urlh) {
        string url = sprintf("%s:%s@%s", urlh.type, urlh.user, urlh.db);
        if (urlh.host.val()) {
            url += "%" + urlh.host;
        }
        if (urlh.port.val()) {
            url += ":" + urlh.port;
        }
        return url;
    }

    # just to implement abstract methods
    string getType() {
        return "sql";
    }
    hash<ConnectionConstructorInfo> getConstructorInfoImpl() {
        return hash<ConnectionConstructorInfo>{};
    }
    object getImpl(bool _ = True, *hash __) {
        return new Dir(); # just a silence the missing abtsract method. No use for Dir at all
    }
}

class TestSslServer {
    private:internal {
        Socket sock();
        Queue q();
        bool exit;
    }

    constructor() {
        sock.setCertificate(ReadOnlyFile::readTextFile(CertPath));
        sock.setPrivateKey(ReadOnlyFile::readTextFile(KeyPath), KeyPassword);
        sock.setSslVerifyMode(SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT);
        sock.acceptAllCertificates(True);

        if (sock.bind("localhost:0"))
            throw "BIND-ERROR", strerror();

        if (sock.listen())
            throw "LISTEN-ERROR", strerror();

        background listen();
    }

    stop() {
        exit = True;
    }

    acceptAllCertificates(bool accept_all = True) {
        sock.acceptAllCertificates(accept_all);
    }

    bool getAcceptAllCertificates() {
        return sock.getAcceptAllCertificates();
    }

    private:internal listen() {
        while (!exit) {
            try {
                *Socket a = sock.acceptSSL(100ms);
                if (a) {
                    #printf("got %y\n", a.verifyPeerCertificate());
                    q.push(a.verifyPeerCertificate());
                }
            }
            catch (hash ex) {
                #printf("got ex: %s: %s\n", ex.err, ex.desc);
                q.push(ex);
            }
        }
    }

    *string wait() {
        return q.get();
    }

    *hash waitException() {
        return q.get();
    }

    int queueSize() {
        return q.size();
    }

    int getPort() {
        return sock.getSocketInfo().port;
    }
}
