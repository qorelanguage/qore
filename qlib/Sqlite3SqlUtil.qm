# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Sqlite3SqlUtil.qm Qore user module for working with Sqlite3 SQL data

/*  Sqlite3SqlUtil.qm Copyright 2013 - 2023 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:bool n_auto_increment = False, bool n_pk = False

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 1.8

# requires the SqlUtil module
%requires SqlUtil >= 1.7.5

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module Sqlite3SqlUtil {
    version = "1.1";
    desc = "user module for working with Sqlite3 SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Sqlite3SqlUtil Module

    @tableofcontents

    @section sqlite3sqlutilintro Sqlite3SqlUtil Module Introduction

    The %Sqlite3SqlUtil module provides a high level API for working with Sqlite3 database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires Sqlite3SqlUtil" in your code.

    All the public symbols in the module are defined in the Sqlite3SqlUtil namespace

    @note
    - This module requires the <a href="https://github.com/qorelanguage/module-sqlite3">sqlite3</a> binary module
      for communication with Sqlite3 databases
    - This module does not yet support schema management for sqlite3 DBs

    @section sqlite_schema_management Schema Management on Sqlite3

    @subsection sqlite3_type_mapping Type Mapping

    Column types are mapped from %Qore types as follows:

    <b>Sqlite3 Column Type Mappings</b>
    |!Generic Type Name|!Sqlite3 Type Used
    |\c int|\c integer
    |\c float|\c real
    |\c number|\c real
    |\c string|\c text
    |\c date|\c text (iso-8601 format with millisecond precision)
    |\c binary|\c blob
    |\c bool|\c integer
    |@ref SqlUtil::BLOB|\c blob
    |@ref SqlUtil::CHAR|\c text
    |@ref SqlUtil::CLOB|\c text
    |@ref SqlUtil::NUMERIC|\c real
    |@ref SqlUtil::VARCHAR|\c text

    @section sqlite3_relnotes Release Notes

    @subsection sqlite3sqlutilv10 Sqlite3SqlUtil_1_1 Sqlite3SqlUtil Module v1.1
    - implemented support for generating queries based on generic expressions using the DataProvider module's generic
      expression support
      (<a href="https://github.com/qorelanguage/qore/issues/4538">issue 4538</a>)

    @subsection sqlite3sqlutilv10 Sqlite3SqlUtil_1_0 Sqlite3SqlUtil Module v1.0
    - initial release
*/

#! the Sqlite3SqlUtil namespace contains all the objects in the Sqlite3SqlUtil module
public namespace Sqlite3SqlUtil {
    #! returns a Sqlite3Table object corresponding to the arguments
    public Sqlite3Table sub get_table(AbstractDatasource nds, string nname, *hash<auto> opts) {
        return new Sqlite3Table(nds, nname, opts);
    }

    #! returns a Sqlite3Database object corresponding to the arguments
    public Sqlite3Database sub get_database(AbstractDatasource nds, *hash<auto> opts) {
        return new Sqlite3Database(nds, opts);
    }

    #! Sqlite3 savepoint helper
    public class Sqlite3SavepointHelper inherits AbstractSavepointHelper {
        #! Creates the object
        constructor(AbstractDatasource ds, *string savepoint) : AbstractSavepointHelper(ds, savepoint) {
        }

        #! Creates the savepoint
        private createSavepointImpl() {
            ds.exec("savepoint " + savepoint);
        }

        #! Rolls back to the savepoint
        private rollbackImpl() {
            ds.exec("rollback to " + savepoint);
        }

        #! Deletes the savepoint
        private deleteSavepointImpl() {
            ds.exec("release " + savepoint);
        }
    }

    #! represents a Sqlite3-specific index
    public class Sqlite3Index inherits SqlUtil::AbstractIndex {
        public {
            hash<string, string> collations;
        }

        #! creates the object from the arguments
        constructor(string name, bool unique, hash<auto> cols, *hash<string, string> collations)
                : AbstractIndex(name, unique, cols) {
            if (collations) {
                self.collations = collations;
            }
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash<auto> opt) {
            return sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name,
                (foldl $1 + ", " + $2, getColumnCollationList()));
        }

        #! Returns a list of column name with COLLATE argument per column, if appropriate
        list<string> getColumnCollationList() {
            return map sprintf("%s%s", $1, (*string col = collations{$1} ? " COLLATE " + col : NOTHING)),
                columns.getSqlColumnNameIterator();
        }

        #! returns @ref True "True" if the argument is equal to the current index, @ref False "False" if not
        private bool equalImpl(AbstractIndex ix) {
            return True;
        }

        #! returns a string that can be used to rename the index in the database
        /** however sqlite3 does not support renaming indexes, so the index is dropped and recreated
        */
        string getRenameSql(string table_name, string new_name) {
            return sprintf("drop index %s; create %sindex %s on %s (%s)", name, unique ? "unique " : "", new_name,
                table_name, (foldl $1 + ", " + $2, columns.getSqlColumnNameIterator()));
        }

        #! returns a string that can be used to drop the index from the table
        string getDropSql(string table_name) {
            return sprintf("drop index %s", name);
        }
    }

    #! represents a Sqlite3-specific foreign constraint
    public class Sqlite3ForeignConstraint inherits SqlUtil::AbstractForeignConstraint {
        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractForeignConstraint(n, c, t) {
        }

        string getCreateSql(string table_name, *hash<auto> opt) {
            return getCreateSql(name, table_name, opt);
        }

        #! returns a string that drops the constraint and re-adds it, since Sqlite3 does not support renaming constraints
        softlist getRenameSql(string table_name, string new_name) {
            return getDropSql(table_name) + ", " + getAddSql(new_name, table_name);
        }

        string getCreateSql(string name, string table_name, *hash<auto> opt) {
            return sprintf("alter table %s ", table_name) + getAddSql(name, table_name, opt);
        }

        string getAddSql(string name, string table_name, *hash<auto> opt) {
            return sprintf("add constraint %s foreign key (%s) references %s (%s)", name,
                (foldl $1 + ", " + $2, h.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }

        #! returns a string that can be used to drop the foreign constraint from the database
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop foreign key %s", table_name, name);
        }
    }

    #! represents a Sqlite3-specific column
    public class Sqlite3Column inherits SqlUtil::AbstractColumn {
        public {
            bool auto_increment;
            bool primary_key;
        }

        #! empty constructor for subclasses
        private constructor() {
        }

        #! Creates the column
        constructor(string name, string native_type, *string qore_type, bool nullable, *string default_value,
                bool auto_increment = False, bool primary_key = False)
                : AbstractColumn(name, native_type, qore_type, 0, nullable, default_value) {
            self.auto_increment = auto_increment;
            self.primary_key = primary_key;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code{.py}
list<string> l = col.getAddColumnSql(t);
            @endcode

            @param t the AbstractTable object to modify
         */
        softlist<string> getAddColumnSql(AbstractTable t) {
            return sprintf("alter table %s add column %s", t.getSqlName(), AbstractColumn::getCreateSql(t));
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition
        /** if the column definitions are identical then an empty list is returned

            @par Example:
            @code{.py}
list l = col.getModifySql(t, newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param col the new column definition
            @param opt column modification options (none are supported in this class)

            @return a list of sql strings that can be used to modify the column to the new definition; if the column
            definitions are identical then an empty list is returned
         */
        softlist<string> getModifySqlImpl(AbstractTable t, AbstractColumn col, *hash<auto> opt) {
            throw "UNSUPPORTED";
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code{.py}
string str = col.getRenameSql(t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("alter table %s rename column %s to %s", t.getSqlName(), ddl_name, getDdlName(new_name));
        }

        #! returns the column name with quoting in case the column name is a reserved word
        /** the name returned here will be used when executing DDL
        */
        string getDdlName(string name) {
            return Sqlite3Database::Sqlite3ReservedWords{name.lwr()} ? ("'" + name + "'") : name;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractColumn c) {
            return True;
        }
    }

    public class Sqlite3UniqueConstraint inherits SqlUtil::AbstractUniqueConstraint {
        constructor(string name, hash<auto> cols) : AbstractUniqueConstraint(name, cols) {
        }

        #! returns the Sqlite3Column value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from
            outside the class

            @see @ref memberGate_methods
        */
        Sqlite3Column memberGate(string k) {
            if (!h.hasKey(k)) {
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k,
                    h.keys());
            }
            return h{k};
        }

        string getCreateSql(string table_name, *hash<auto> opts) {
            return getCreateSql(name, table_name, opts);
        }

        list<string> getRenameSql(string table_name, string new_name) {
        }

        string getCreateSql(string name, string table_name, *hash<auto> opts) {
            throw "UNSUPPORTED";
        }

        #! returns a string that can be used to drop the constraint from the database
        string getDropSql(string table_name) {
            throw "UNSUPPORTED";
        }
    }

    #! represents a Sqlite3-specific primary key constraint
    public class Sqlite3PrimaryKey inherits SqlUtil::AbstractPrimaryKey {
        constructor() {
        }

        constructor(hash<auto> c) : AbstractPrimaryKey("PRIMARY", c) {
        }

        string getCreateSql(string table_name, *hash<auto> opts) {
            throw "UNSUPPORTED";
        }

        list<string> getRenameSql(string table_name, string new_name) {
            throw "UNSUPPORTED";
        }

        #! returns @ref False "False" since primary key constraints in Sqlite3 have no name
        bool supportsName() {
            return False;
        }
    }

    #! represents a Sqlite3-specific trigger
    public class Sqlite3Trigger inherits SqlUtil::AbstractTrigger {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractTrigger(n, n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        softlist getCreateSql(string table_name, *hash<auto> opt) {
            return sprintf("create trigger %s %s", name, src);
        }

        #! returns a string that can be used to drop the trigger from the database
        softlist getDropSql(string table_name) {
            return sprintf("drop trigger %s", name);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the trigger in the database
        softlist getRenameSql(string table_name, string new_name) {
            throw "UNSUPPORTED";
            #return sprintf("alter trigger %s on %s rename to %s", name, table_name, new_name);
        }
    }

    #! represents a Sqlite3 view
    public class Sqlite3View inherits SqlUtil::AbstractView {
        #! creates the object from the arguments
        constructor(string name, string src) : AbstractView(name, src) {
        }

        #! returns a string that can be used to create the view in the database
        string getCreateSql(*hash<auto> opt) {
            # TODO/FIXME: check options
            return sprintf("create view %s as %s", name, src);
        }

        #! returns a string that can be used to rename the view in the database
        /** @param new_name the new name of the object
            @param opt this argument is ignored
         */
        softlist getRenameSql(string new_name, *hash<auto> opt) {
            throw "UNSUPPORTED";
        }
    }

    #! provides the Sqlite3-specific implementation of the AbstractDatabase interface
    public class Sqlite3Database inherits SqlUtil::AbstractDatabase {
        public {
            #! hash of reserved words
            const Sqlite3ReservedWords = {
                "abort": True,
                "action": True,
                "add": True,
                "after": True,
                "all": True,
                "alter": True,
                "always": True,
                "analyze": True,
                "and": True,
                "as": True,
                "asc": True,
                "attach": True,
                "autoincrement": True,
                "before": True,
                "begin": True,
                "between": True,
                "by": True,
                "cascade": True,
                "case": True,
                "cast": True,
                "check": True,
                "collate": True,
                "column": True,
                "commit": True,
                "conflict": True,
                "constraint": True,
                "create": True,
                "cross": True,
                "current": True,
                "current_date": True,
                "current_time": True,
                "current_timestamp": True,
                "database": True,
                "default": True,
                "deferrable": True,
                "deferred": True,
                "delete": True,
                "desc": True,
                "detach": True,
                "distinct": True,
                "do": True,
                "drop": True,
                "each": True,
                "else": True,
                "end": True,
                "escape": True,
                "except": True,
                "exclude": True,
                "exclusive": True,
                "exists": True,
                "explain": True,
                "fail": True,
                "filter": True,
                "first": True,
                "following": True,
                "for": True,
                "foreign": True,
                "from": True,
                "full": True,
                "generated": True,
                "glob": True,
                "group": True,
                "groups": True,
                "having": True,
                "if": True,
                "ignore": True,
                "immediate": True,
                "in": True,
                "index": True,
                "indexed": True,
                "initially": True,
                "inner": True,
                "insert": True,
                "instead": True,
                "intersect": True,
                "into": True,
                "is": True,
                "isnull": True,
                "join": True,
                "key": True,
                "last": True,
                "left": True,
                "like": True,
                "limit": True,
                "match": True,
                "materialized": True,
                "natural": True,
                "no": True,
                "not": True,
                "nothing": True,
                "notnull": True,
                "null": True,
                "nulls": True,
                "of": True,
                "offset": True,
                "on": True,
                "or": True,
                "order": True,
                "others": True,
                "outer": True,
                "over": True,
                "partition": True,
                "plan": True,
                "pragma": True,
                "preceding": True,
                "primary": True,
                "query": True,
                "raise": True,
                "range": True,
                "recursive": True,
                "references": True,
                "regexp": True,
                "reindex": True,
                "release": True,
                "rename": True,
                "replace": True,
                "restrict": True,
                "returning": True,
                "right": True,
                "rollback": True,
                "row": True,
                "rows": True,
                "savepoint": True,
                "select": True,
                "set": True,
                "table": True,
                "temp": True,
                "temporary": True,
                "then": True,
                "ties": True,
                "to": True,
                "transaction": True,
                "trigger": True,
                "unbounded": True,
                "union": True,
                "unique": True,
                "update": True,
                "using": True,
                "vacuum": True,
                "values": True,
                "view": True,
                "virtual": True,
                "when": True,
                "where": True,
                "window": True,
                "with": True,
                "without": True,
            };
        }

        constructor(AbstractDatasource ds, *hash<auto> opts) : AbstractDatabase(ds, opts) {
        }

        #! Returns @ref True if the driver requires a scale to support decimal values in numeric or decimal columns
        /** @return @ref True if the driver requires a scale to support decimal values in numeric or decimal columns

            @since %Sqlite3SqlUtil 1.4.3
        */
        bool requiresScale() {
            return False;
        }

        #! Returns the maximum precision for numeric or decimal columns
        /** @return -1 means, no maximum

            @since %Sqlite3SqlUtil 1.4.3
        */
        int getMaximumPrecision() {
            return 0;
        }

        private list<string> featuresImpl() {
            return (DB_TABLES, DB_VIEWS);
        }

        string getSchemaName() {
            return ds.getDBName();
        }

        private AbstractSequence makeSequenceImpl(string name, number start = 1, number increment = 1,
                *softnumber end, *hash<auto> opts) {
            throw "UNSUPPORTED";
        }

        private *AbstractSequence getSequenceImpl(string name) {
        }

        private *AbstractView getViewImpl(string name) {
            *hash<auto> row = ds.selectRow("select * from sqlite_schema where type = 'view' and name = %v", name);
            if (!row) {
                return;
            }

            return new Sqlite3View(name, row.sql);
        }

        private AbstractFunction makeFunctionImpl(string name, string src, *hash<auto> opts) {
            throw "UNSUPPORTED";
        }

        private AbstractFunction makeProcedureImpl(string name, string src, *hash<auto> opts) {
            throw "UNSUPPORTED";
        }

        private *AbstractFunction getFunctionImpl(string name) {
        }

        private *AbstractFunction getProcedureImpl(string name) {
        }

        private list<string> getDropSchemaSqlImpl(hash<auto> schema_hash, *hash<auto> opt) {
            return ();
        }

        private list<string> getAlignSqlImpl(hash schema_hash, *hash<auto> opt) {
            return ();
        }

        #! returns a list of string table names in the database
        private list<string> listTablesImpl() {
            return ds.select("select name from sqlite_schema where type = 'table'").name;
        }

        #! returns a list of string function names in the database
        /** The function names will include arguments in parentheses after the names

            @return a list of string function names in the database
        */
        private list<string> listFunctionsImpl() {
            return ();
        }

        #! returns a list of string procedure names in the database
        /** The procedure names will include arguments in parentheses after the names

            @return a list of string procedure names in the database
        */
        private list<string> listProceduresImpl() {
            return ();
        }

        private list<string> listSequencesImpl() {
            return ();
        }

        private list<string> listViewsImpl() {
            return ds.select("select name from sqlite_schema where type = 'view'").name;
        }

        private string getCreateSqlImpl(list<auto> l) {
            return Sqlite3Database::getCreateSql(l);
        }

        static string getCreateSql(list<auto> l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l);
        }

        #! returns the next value in the given sequence
        private softint getNextSequenceValueImpl(string name) {
            throw "SQLITE3-SEQUENCE-ERROR", "Sqlite3 does not support sequences";
        }

        #! returns the last value issued for the given sequence in the current session
        private softint getCurrentSequenceValueImpl(string name) {
            throw "SQLITE3-SEQUENCE-ERROR", "Sqlite3 does not support sequences";
        }

        #! returns @ref True "True" since we have a workaround implementation for sequences in Sqlite3
        private bool supportsSequencesImpl() {
            return False;
        }

        #! returns @ref True "True" if the database supports named types
        private bool supportsTypesImpl() {
            return False;
        }

        #! returns @ref True "True" if the database supports packages
        private bool supportsPackagesImpl() {
            return False;
        }

        #! rebuild index implementation. See @ref SqlUtil::AbstractDatabase::rebuildIndex()
        private bool rebuildIndexImpl(string name, *hash<auto> options) {
            throw "REBUILD-INDEX-ERROR", "Sqlite3 does not support index rebuilding";
        }

        #! compute statistics implementation. See @ref SqlUtil::AbstractDatabase::computeStatistics()
        private computeStatisticsImpl(*hash<auto> options) {
        }

        #! reclaim space implementation. See @ref SqlUtil::AbstractDatabase::reclaimSpace()
        private reclaimSpaceImpl(*hash<auto> options) {
        }

        #! @ref SqlUtil::AbstractDatabase.getPhysicalSize()
        private int getPhysicalSizeImpl() {
            throw "UNSUPPORTED";
        }
    }

    #! provides the Sqlite3-specific implementation of the AbstractTable interface
    public class Sqlite3Table inherits SqlUtil::AbstractTable {
        public {
            #! maps sqlite3 type names to type configurations
            const Sqlite3TypeMap = {
                "real": {
                    "qore": Type::Float,
                    "size": SZ_NUM,
                },
                "integer": {
                    "qore": Type::Int,
                    "ai": True,
                },
                "text": {
                    "qore": Type::String,
                },
                "varchar": {
                    "qore": Type::String,
                },
                "blob": {
                    "qore": Type::Binary,
                },
            };

            #! maps qore type names to Sqlite3 type names
            const QoreTypeMap = (
                "integer": "int",
                "float": "real",
                "number": "text",
                "string": "text",
                "date": "text",
                "binary": "blob",
                "bool": "int",
                SqlUtil::CHAR: "text",
                SqlUtil::CLOB: "text",
                SqlUtil::BLOB: "blob",
            );

            #! column operator specializations for Sqlite3
            const Sqlite3CopMap = (
                COP_CAST: (
                    "code": string sub (string cve, list<auto> args) {
                        return sprintf("cast(%s as %s)", cve, QoreTypeMap{args[0]} ?? args[0]);
                    },
                ),
                COP_PREPEND: (
                    "arg": Type::String,
                    "sqlvalue": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("%s || %s", arg, cve);
                    },
                ),
                COP_APPEND: (
                    "arg": Type::String,
                    "sqlvalue": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("%s || %s", cve, arg);
                    },
                ),
            );
        }

        constructor(AbstractDatasource ds, string name, *hash<auto> opts) : AbstractTable(ds, name, opts) {
        }

        #! returns the name of the table to be used in SQL (with a possible qualifiers for schema, etc)
        string getSqlName() {
            return name;
        }

        #! returns the column operator map for this object
        private hash getColumnOperatorMapImpl() {
            return Sqlite3CopMap;
        }

        private bool checkExistenceImpl() {
            *hash<auto> qh = ds.selectRow("select * from sqlite_schema where name = %v and type = 'table'", name);
            if (qh) {
                return inDb = True;
            }
            return False;
        }

        private Columns describeImpl() {
            /*
            string sql = ds.selectRow("select sql from sqlite_master where type = 'table' and tbl_name = %v",
                name).sql;
            *string cols = (sql =~ x/\((.*)\)/)[0];
            if (cols) {
                list<string> l = cols.split(",");
                for (int i = 0; i < l.size(); ++i) {
                    string str = l[i];
                    if (str =~ /foreign key/) {
                        int pc = 0;
                        string fk = str;
                        while (True) {
                            # count to second close paren
                            int spc = (str =~ x/(\))/g).size();
                            if (spc) {
                                pc += spc;
                                if (pc == 2) {
                                    break;
                                }
                            }
                            ++i;
                            if (i == l.size()) {
                                throw "SQLITE3-ERROR", sprintf("unbalanced parens in sql: %y", sql);
                            }
                            str = l[i];
                            fk += str;
                        }
                        (string fk_cols, string other_table, string other_cols) =
                            (fk =~ x/foreign key\(([^\)]+)\) references ([^\)]+)\((.*)\)/);
                        Columns targ_columns = getReferencedTableColumnsUnlocked(other_table, opts.table_cache);
                        ForeignConstraintTarget fct(other_table, targ_columns.subset(other_cols.split(" ")));
                        list<string> fk_col_list = fk_cols.split(" ");
                        string fk_name = name + fk_col_list.join("_");
                        rv{fk_name} = new Sqlite3ForeignConstraint(fk_name, new Columns(columns{fk_col_list}), fct);
                    }
                }
            }
            */
            # get column descriptions
            *hash<auto> qh = ds.select("pragma table_info(%s)", name);
            if (!qh.name) {
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);
            }

            hash<string, AbstractColumn> rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                row.type = row.type.lwr();
                auto defval = exists row.dflt_value && row.dflt_value !== NULL && row.dflt_value != "NULL"
                    ? row.dflt_value
                    : NOTHING;
                *hash<auto> th = Sqlite3TypeMap{row.type};
                if (exists defval) {
                    # process default value according to column type
                    switch (th.qore) {
                        case Type::Int: defval = defval.toInt(); break;
                        case Type::Float: defval = defval.toFloat(); break;
                        case Type::Number: defval = defval.toNumber(); break;
                        case Type::Date: {
                            try {
                                defval = date(defval);
                            } catch (hash<ExceptionInfo> ex) {
                                # ignore INVALID-DATE; keep text (ex: "CURRENT_TIMESTAMP")
                                if (ex.err != "INVALID-DATE") {
                                    rethrow;
                                }
                            }
                        }
                        case Type::String: {
                            if (defval =~ /^'.*'$/) {
                                defval = defval[1..(defval.size() - 2)];
                                defval =~ s/''/'/g;
                            }
                            break;
                        }
                        # don't know what to do with Type::Binary ???
                        default: break;
                    }
                    defval = getSqlValue(defval);
                }
                bool auto_increment = (row.type =~ / auto_increment/);
                if (auto_increment) {
                    row.type =~ s/ auto_increment//;
                }
                bool primary_key = (row.type =~ / primary_key/);
                if (primary_key) {
                    row.type =~ s/ primary_key//;
                }

                Sqlite3Column c(row.name, row.type, th.qore, !row.notnull, defval, auto_increment, primary_key);
                rv{row.name} = c;
            }

            return new Columns(rv);
        }

        private *string getCreatePrimaryKeySqlUnlocked(*hash<auto> opt, bool cache = True) {
        }

        private Sqlite3PrimaryKey getPrimaryKeyImpl() {
            return new Sqlite3PrimaryKey();
        }

        private Indexes getIndexesImpl() {
            hash<auto> rv;

            # get index descriptions
            *hash<auto> qh = ds.select("select * from sqlite_master where type = 'index' and tbl_name = %v", name);
            if (qh.name) {
                hash<auto> ih;
                foreach hash<auto> row in (qh.contextIterator()) {
                    list<string> cols = map trim($1),
                        (row.sql =~ x/CREATE (?:UNIQUE )?INDEX.*[^\(]+\((.*)\)$/)[0].split(",");
                    bool unique = (row.sql =~ /^CREATE UNIQUE INDEX /);
                    ih{row.name}.unique = unique;
                    foreach string col in (cols) {
                        *string collation = (col =~ x/ COLLATE (.*)$/)[0];
                        if (collation) {
                            col =~ s/ COLLATE .*//g;
                            ih{row.name}.collations{col} = collation;
                        }
                        ih{row.name}.columns{col} = columns{col};
                    }
                }

                foreach hash<auto> i in (ih.pairIterator()) {
                    rv{i.key} = new Sqlite3Index(i.key, i.value.unique, i.value.columns, i.value.collations);
                }
            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl(*hash<auto> opts) {
            return new ForeignConstraints();
        }

        private Constraints getConstraintsImpl() {
            hash<auto> rv;

            Constraints c = new Constraints(rv);
            /*
            # get unique constraints
            *hash qh = ds.select("");
            delete rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                reference<Sqlite3UniqueConstraint> ch = \rv.(row.constraint_name);
                if (!ch)
                    ch = new Sqlite3UniqueConstraint(row.constraint_name, {});
                ch.add(row.column_name, columns{row.column_name});
            }

            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();
            */
            return c;
        }

        private Triggers getTriggersImpl() {
            hash rv;
            /*
            # get trigger description
            *hash qh = ds.select("");

            foreach hash<auto> row in (qh.contextIterator()) {
                string src = sprintf("%s %s on %s for each %s %s", row.action_timing.lwr(), row.event_manipulation.lwr(), name, row.action_orientation.lwr(), row.action_statement);
                rv{row.trigger_name} = new Sqlite3Trigger(row.trigger_name, src);
            }
            */
            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash<auto> opt) {
            string sql = sprintf("create table %s (\n", name);
            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(self), columns.iterator());
            sql += "\n)";
            return sql;
        }

        #! returns @ref False "False" because the sqlite3 driver does not support array binds / bulk DML operations
        bool hasArrayBind() {
            return False;
        }

        private *list getCreateMiscSqlImpl(*hash<auto> opt, bool cache) {
        }

        private *list getAlignSqlImpl(AbstractTable table, *hash<auto> opt) {
        }

        private string getCreateSqlImpl(list l) {
            return Sqlite3Database::getCreateSql(l);
        }

        private string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash<auto> opt, bool nullable = True) {
            return new Sqlite3Column(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value,
                opt.comment, 0);
        }

        private setPrimaryKeyUnlocked(AbstractPrimaryKey pk) {
            AbstractTable::setPrimaryKeyUnlocked(pk);
            if (pk.size() == 1 && columns.hasKey(pk.getName())) {
                Sqlite3Column c = columns{pk.getName()};
                if (c.auto_increment && !c.primary_key) {
                    c.primary_key = True;
                }
            }
        }

        private addColumnToTableUnlocked(AbstractColumn c) {
            AbstractTable::addColumnToTableUnlocked(c);
            Sqlite3Column col = c;
            if (col.auto_increment) {
                Sqlite3Index ix;
                # see if a unique index already exists with this name
                if (indexes.hasKey(c.name)) {
                    ix = indexes{c.name};
                    if (!ix.unique)
                        throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is "
                            "also flagged as a unique index for the table does not match with the existing index's "
                            "definition which is not unique; columns: %y", name, c.name, ix.columns.keys());
                    if (ix.columns.size() > 1 || ix.columns.firstKey() != c.name)
                        throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a unique index for the table does not match with the existing index's column definition: %y", name, c.name, ix.columns.keys());
                }

                AbstractUniqueConstraint uk;
                if (col.primary_key) {
                    # add primary key if not present
                    if (!primaryKey.empty()) {
                        if (primaryKey.size() > 1 || primaryKey.firstKey() != c.name)
                            throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a primary key for the table does not match with the existing primary key column definition: %y", name, c.name, primaryKey.keys());
                    } else
                        primaryKey = new Sqlite3PrimaryKey(columns{c.name,});
                    uk = primaryKey;
                } else {
                    # see if a unique constraint already exists with this name
                    if (constraints.hasKey(c.name)) {
                        if (!(constraints{c.name} instanceof AbstractUniqueConstraint))
                            throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a unique constraint for the table does not match with the existing constraint type: %y", name, c.name, constraints{c.name}.className());

                        uk = constraints{c.name};
                        if (uk.size() > 1 || uk.firstKey() != c.name)
                            throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a unique constraint for the table does not match with the existing unique constraint's column definition: %y", name, c.name, uk.keys());
                    } else {
                        if (!constraints)
                            constraints = new Constraints();
                        uk = new Sqlite3UniqueConstraint(c.name, columns.(list(c.name)));
                        constraints.add(c.name, uk);
                    }
                }
                if (ix)
                    uk.setIndexBase(c.name);
            }
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash<auto> ch, *hash<auto> opt) {
            return new Sqlite3PrimaryKey(ch);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash<auto> ch, *hash<auto> opt) {
            return new Sqlite3Index(iname, enabled, ch);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash<auto> ch, string table,
                hash<auto> tch, *hash<auto> opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new Sqlite3ForeignConstraint(cname, new Columns(ch), fct);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash<auto> opt) {
            throw "SQLITE3-CHECK-CONSTRAINT-ERROR", sprintf("Sqlite3 does not support check constraints");
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash<auto> ch, *hash<auto> opt) {
            return new Sqlite3UniqueConstraint(cname, ch);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash<auto> opt) {
            return new Sqlite3Trigger(tname, src);
        }

        private bool tryInsertImpl(string sql, hash<auto> row) {
            try {
                ds.vexec(sql, row.values());
            } catch (hash<ExceptionInfo> ex) {
                if (isDuplicateRowError(ex)) {
                    return False;
                }
                rethrow;
            }
            return True;
        }

        #! Returns True if the exception was raised because of a duplicate row / key error
        /** @since Sqlite3SqlUtil 1.4.2
        */
        private bool isDuplicateRowErrorImpl(hash<ExceptionInfo> ex) {
            return (ex.desc =~ /^Duplicate entry /);
        }

        private hash<auto> getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash<auto> getTypeMapImpl() {
            return Sqlite3TypeMap;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(auto v) {
            return Sqlite3Table::getSqlValueIntern(v);
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private static *string getSqlValueIntern(auto v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toString();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "true" : "false";

                case NT_DATE: {
                    # Sqlite3 does not allow us to specify the UTC offset in the timestamp literal :(
                    TimeZone tz = TimeZone::get();
                    v = tz.date(v);
                    return "timestamp " + v.format("'YYYY-MM-DDTHH:mm:SS.us'");
                }
            }
        }

        #! returns the column name for use in SQL strings; subclasses can return a special string in case the column name is a reserved word
        /** Sqlite3/MariaDB etc require column names to be enclosed in backticks instead of double quotes
        */
        string getColumnSqlName(string col) {
            return Sqlite3Database::Sqlite3ReservedWords{col.lwr()} ? ("`" + col + "`") : col;
        }

        #! returns a list of column names for use in SQL strings; subclasses can process the argument list in case a column name is a reserved word
        list<string> getColumnSqlNames(softlist<auto> cols) {
            return map getColumnSqlName($1), cols;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code{.py}
string str = table.getSqlValue(date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver

            @throw VALUE-ERROR the given value cannot be converted to an SQL string (missing rules for value)
         */
        static *string getSqlValue(auto v) {
           *string str = Sqlite3Table::getSqlValueIntern(v);
            if (!exists str)
                throw "VALUE-ERROR", sprintf("class Sqlite3Table cannot convert type %y to an SQL string (value: %y)", v.type(), v);
            return str;
        }

        private bool emptyImpl() {
            return True;
        }

        private preSetupTableImpl(reference<hash> desc, *hash<auto> opt) {
            # see if there is an auto-increment column and set the primary key flag if it matches the primary key declaraion
            foreach string k in (desc.columns.keyIterator()) {
                if (desc.columns{k}.auto_increment) {
                    if (!desc.columns{k}.pk) {
                        if (desc.primary_key.columns.lsize() == 1) {
                            softlist cl = desc.primary_key.columns;
                            if (cl[0] == k) {
                                desc.columns{k}.pk = True;
                                # delete the primary key description; it will be added again when the column is added
                                delete desc.primary_key;
                            }
                        }
                    }
                    break;
                }
            }
        }

        private setupTableImpl(hash<auto> desc, *hash<auto> opt) {
        }

        #! returns @ref True "True" if the database links constraints to indexes (ie dropping the constraint drops the index, etc)
        private bool constraintsLinkedToIndexesImpl() {
            return True;
        }

        #! returns @ref True "True" if the database automatically creates a unique constraint when a unique index is created (ex: sqlite3)
        private bool uniqueIndexCreatesConstraintImpl() {
            return True;
        }

        #! returns @ref True "True" if the database support tablespaces
        private bool supportsTablespacesImpl() {
            return False;
        }

        #! processes a string for use in SQL select statements when there is a "limit" argument, but no "orderby" or "offset" arguments
        private doSelectLimitOnlyUnlockedImpl(reference<hash<QueryInfo>> info, reference<string> sql) {
           sql += " limit %v";
           info.args += info.query_hash.limit.toInt();
        }

        #! processes a string for use in SQL select statements when there is an "order by" and "offset" argument
        private doSelectOrderByWithOffsetSqlUnlockedImpl(reference<hash<QueryInfo>> info, reference<string> sql,
                list<auto> coll) {
            doSelectOrderBySqlUnlocked(info, \sql, coll);
            if (info.query_hash.limit) {
                sql += " limit %v";
                info.args += info.query_hash.limit.toInt();
            }

            if (info.query_hash.offset) {
                sql += " offset %v";
                info.args += info.query_hash.offset.toInt();
            }
        }

        #! returns @ref True if the database requires a wildcard \c "*" to be prefixed with the table name when it appears with other column arguments in a select statement
        private bool asteriskRequiresPrefix() {
            return True;
        }

        private *hash<auto> doReturningImpl(hash<auto> opt, reference<string> sql, list<auto> args) {
            throw "RETURNING-ERROR", sprintf("table %s: the sqlite3 driver does not support the returning clause "
                "in an insert statement", getSqlName());
        }

        private list<auto> getGroupOrderByListUnlocked(hash<QueryInfo> info, string key, list<auto> coll) {
            list<auto> ce = ();
            foreach auto cv in (info.query_hash{key}) {
                switch (cv.typeCode()) {
                    case NT_STRING: {
                        if (cv.toInt() == cv) {
                            ce += cv;
                        } else {
                            ce += getColumnNameIntern(info, cv);
                        }
                        break;
                    }

                    case NT_HASH: {
                        ce += doColumnOperatorIntern(\info, cv);
                        break;
                    }

                    case NT_INT: {
                        ce += cv.toString();
                        break;
                    }

                    default:
                        throw "SELECT-ERROR", sprintf("%s: don't know how to parse argument type %y (value: %y) in "
                            "%s list, expecting \"string\" or \"hash\"", getDesc(), cv.type(), cv, key);
                }
            }
            return ce;
        }

        #! returns @ref True "True" if the current database driver supports the \c "returning" clause in insert statements, @ref False "False" if not
        bool hasReturningImpl() {
            return False;
        }

        #! db-specific copy actions
        private copyImpl(AbstractTable old) {
        }

        #! returns the type for number / numeric columns for the database so that data conversions can be handled
        private AbstractDataProviderType getNumericTypeImpl(string native_type, bool nullable, *hash<auto> options) {
            return AbstractDataProviderType::get(FloatType);
        }

        #! get DB-specific savepoint helper
        /** @param savepoint the savepoint string, if not given a unique savepoint string will be generated

            @since SqlUtil 1.6
        */
        private AbstractSavepointHelper getSavepointHelperImpl(*string savepoint) {
            return new Sqlite3SavepointHelper(ds, savepoint);
        }
    }
}
