# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Util.qm Qore user module for generally useful routines

/*  Util.qm Copyright 2014 - 2020 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum Qore version
%requires qore >= 0.9.5

# do not use $ for vars, assume local var scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module Util {
    version = "1.6";
    desc    = "user module for generally useful routines";
    author  = "David Nichols <david@qore.org>";
    url     = "http://qore.org";
    license = "MIT";
    init    = sub () { init(); };
}

/** @mainpage Util Module

    @tableofcontents

    @section utilintro Util Module Introduction

    The %Util module provides some generally-useful routines that are more suitable for
    writing in Qore than in C++.

    To use this module, use \c "%requires Util" in your code.

    All the public symbols in the module are defined in the Util namespace

    Functions:
    - @ref Util::compare_version()
    - @ref Util::flatten()
    - @ref Util::get_byte_size()
    - @ref Util::get_exception_string()
    - @ref Util::get_marketing_byte_size()
    - @ref Util::get_random_string()
    - @ref Util::glob_to_regex()
    - @ref Util::is_int()
    - @ref Util::is_float()
    - @ref Util::is_number()
    - @ref Util::lpad()
    - @ref Util::make_uri_query()
    - @ref Util::normalize_dir()
      - @ref Util::normalize_dir_unix()
      - @ref Util::normalize_dir_windows()
    - @ref Util::ordinal()
    - @ref Util::parse_memory_size()
    - @ref Util::parse_ranges()
    - @ref Util::parse_to_qore_value()
    - @ref Util::parse_uri_query()
    - @ref Util::plural()
    - @ref Util::regex_escape()
    - @ref Util::rpad()
    - @ref Util::same()
    - @ref Util::slice()
    - @ref Util::tmp_location()
    - @ref Util::uniq()
    - @ref Util::zip()

    @section utilrelnotes Release Notes

    @subsection util_1_6 Util 1.6
    - added the @ref Util::parse_memory_size() "parse_memory_size()" function
      (<a href="https://github.com/qorelanguage/qore/issues/4004">issue 4004</a>)

    @subsection util_1_5_1 Util 1.5.1
    - fixed bugs in \c %EVAL= expressions in @ref Util::parse_to_qore_value() "parse_to_qore_value()" where
      expressions that evaluated to integer 0 or floating-point values were returned as @ref NOTHING
      (<a href="https://github.com/qorelanguage/qore/issues/3851">issue 3851</a>)
    - added the get_file_from_url() function

    @subsection util_1_5 Util 1.5
    - added the get_file_from_url() function

    @subsection util_1_4_1 Util 1.4.1
    - fixed a bug in @ref Util::get_exception_string() "get_exception_string()" with Java exceptions
      (<a href="https://github.com/qorelanguage/qore/issues/3304">issue 3304</a>)

    @subsection util_1_4 Util 1.4
    - added the @ref Util::parse_ranges() "parse_ranges()" function (<a href="https://github.com/qorelanguage/qore/issues/2438">issue 2438</a>)
    - added the @ref Util::check_ip_address() "check_ip_address()" function (<a href="https://github.com/qorelanguage/qore/issues/2483">issue 2483</a>)
    - updated @ref Util::parse_to_qore_value() "parse_to_qore_value()" to support single-element lists and hashes with
      curly brackets including empty hashes
      (<a href="https://github.com/qorelanguage/qore/issues/3138">issue 3138</a>)
    - updated @ref Util::get_exception_string() "get_exception_string()" to show the \c lang value
      (<a href="https://github.com/qorelanguage/qore/issues/3182">issue 3182</a>)

    @subsection util_1_3 Util 1.3
    - updated for complex types
    - added the @ref Util::make_uri_query() "make_uri_query()" function
    - added the @ref Util::parse_uri_query() "parse_uri_query()" function
    - added the @ref Util::UriQueryInfo "UriQueryInfo" hashdecl
    - added the @ref Util::flatten() "flatten()" function
    - added the @ref Util::uniq() "uniq()" function

    @subsection util_1_2 Util 1.2
    - the following functions are now actually implemented in the %Qore library and only reexported here for backwards-compatibility:
      - @ref Qore::absolute_path()
      - @ref Qore::absolute_path_windows()
      - @ref Qore::absolute_path_unix()
    - added Util::glob_to_regex()
    - added Util::is_int()
    - added Util::is_float()
    - added Util::is_number()
    - added Util::lpad()
    - added Util::ordinal()
    - added Util::plural()
    - added Util::regex_escape()
    - added Util::rpad()
    - added Util::same()
    - added Util::slice()
    - added Util::tmp_location()
    - added Util::zip()
    - fixed Util::get_random_string() on Windows
    - fixed Util::absolute_path_windows()
    - fixed Util::parse_to_qore_value() with hashes with a comma in the first key name; now respects parentheses when parsing lists and hashes (<a href="https://github.com/qorelanguage/qore/issues/846">issue 846</a>)
    - fixed Util::normalize_dir_windows() handling of UNC paths (<a href="https://github.com/qorelanguage/qore/issues/813">issue 813</a>)

    @subsection util_1_1 Util 1.1
    - added the Util::get_byte_size() and Util::get_marketing_byte_size() functions

    @subsection util_1_0 Util 1.0
    - the initial version of the Util module
*/

namespace Init {
    sub init() {
        our hash<auto> storage_sizes;
        map storage_sizes.$1 = pow(1024, $# + 1), StorageNames;

        our hash<auto> marketing_storage_sizes;
        map marketing_storage_sizes.$1 = pow(1000, $# + 1), StorageNames;
    }
}

#! the Util namespace contains all the objects in the Util module
public namespace Util {
    #! the return value of the @ref Util::parse_uri_query() "parse_uri_query()" function
    /** @since Util 1.3
    */
    public hashdecl UriQueryInfo {
        #! the part of the URI path before the first \c "?" character or the entire path if no \c "?" character is present in the path
        string method;

        #! (only present if a "?" character is present in the input); the part of the path after the first \c "?" character; arguments should be separated by ";" characters (according to a w3c recommendation: http://www.w3.org/TR/1999/REC-html401-19991224/appendix/notes.html#h-B.2.2), however this function supports both \c ";" and \c "&" as argument separators; if the arguments are not key=value, then each element without a value is assigned @ref True "True"
        *hash<auto> params;
    }

    #! Returns a size in bytes from a string where "1M" = 1048576 and so forth
    /** @param str the input string to parse
        @param use_binary if @ref True then base-2-based values are always assumed (i.e. "1 KB" = 1024 bytes and so
        forth)

        @return the size in bytes

        Known suffixes:
        - \c K, KiB = one Kibibyte (1024 bytes)
        - \c M, MiB = one Mebibyte (1024 * 1024 bytes)
        - \c G, GiB = one Gibibyte (1024 * 1024 * 1024 bytes)
        - \c KB = 1,000 bytes (i.e. a "marketing kilobyte")
        - \c MB = 1,000,000 bytes (i.e. a "marketing megabyte")
        - \c GB = 1,000,000,000 bytes (i.e. a "marketing gigabyte")
        . and so on

        @throw MEMORY-SIZE-ERROR: cannot parse string
    */
    public int sub parse_memory_size(string str, *bool use_binary) {
        (*string num, *string suffix) = (str =~ x/^\s*([0-9](?:\.[0-9]+)?+)\s*([a-z]+)?$/i);
        if (!num) {
            throw "MEMORY-SIZE-ERROR", sprintf("cannot parse input string %y as a memory size", str);
        }

        if (suffix) {
            *int match = StorageAbbr{suffix[0].lwr()};
            if (exists match) {
                if (suffix.size() == 3 && (suffix[1..2].lwr() == "ib")) {
                    return _get_size(num, storage_sizes{StorageNames[match]});
                }
                if (suffix.size() == 1 || (suffix.size() == 2 && suffix[1].lwr() == "b")) {
                    return _get_size(num, use_binary
                        ? storage_sizes{StorageNames[match]}
                        : marketing_storage_sizes{StorageNames[match]}
                    );
                }
                string pattern = StorageNames[match] + "(bytes?)?";
                if (regex(suffix, pattern, RE_Caseless)) {
                    return _get_size(num, use_binary
                        ? storage_sizes{StorageNames[match]}
                        : marketing_storage_sizes{StorageNames[match]}
                    );
                }
                pattern = StorageNames[match][0..1] + "bi(bytes?)?";
                if (regex(suffix, pattern, RE_Caseless)) {
                    return _get_size(num, storage_sizes{StorageNames[match]});
                }
            }
            throw "MEMORY-SIZE-ERROR", sprintf("cannot parse input string suffix %y in %y as a memory size", suffix, str);
        }

        return num.toInt();
    }

    #! compares complex versions by breaking down strings into component parts
    /** @par Example:
        @code{.py}
int result = compare_version("2.11.1", "2.2");
        @endcode

        Each element is compared separately, so that compare_version("2.11.1", "2.2") returns 1
        (a regular string comparison would give the opposite result)

        @param lv left-hand version
        @param rv right-hand version

        @return -1 if lv < rv, 0 if equal, and 1 if lv > rv
    */
    public int sub compare_version(string lv, string rv) {
        list ll = lv.split(".");
        list rl = rv.split(".");

        int le = ll.size();
        int re = rl.size();

        int i = 0;
        while (True) {
            if (le == i) {
                if (re == i)
                    return 0;
                # see if all remaining elements in rl are 0
                splice rl, 0, i;
                return (select rl, $1) ? -1 : 0;
            }
            if (re == i) {
                # see if all remaining elements in ll are 0
                splice ll, 0, i;
                return (select ll, $1) ? 1 : 0;
            }
            auto l = ll[i];
            auto r = rl[i];
            if (l =~ /^[0-9]/)
                l = int(l);
            if (r =~ /^[0-9]/)
                r = int(r);

            int rc = l <=> r;
            if (rc)
                return rc;

            ++i;
        }
    }

    #! returns a platform-specific normalized path name (starting from /, eliminates \c ".", \c "..", and \c "//")
    /** @par Example:
        @code{.py}
string dir = normalize_dir(dir);
        @endcode

        Currently only Windows and UNIX-style directories are supported; this function calls either:
        - @ref Util::normalize_dir_unix() or
        - @ref Util::normalize_dir_windows()

        @param dir the directory name to normalize
        @param cwd the current working directory for normalizing relative paths

        @return a normalized path name for the current platform

        @see
        - @ref Util::normalize_dir_unix() or
        - @ref Util::normalize_dir_windows()
     */
    public string sub normalize_dir(string dir, string cwd = getcwd()) {
        return PlatformOS != "Windows" ? normalize_dir_unix(dir, cwd) : normalize_dir_windows(dir, cwd);
    }

    #! returns a normalized UNIX path name (starting from /, eliminates \c ".", \c "..", and \c "//")
    /** @par Example:
        @code{.py}
string dir = normalize_dir_unix(dir, "/var/tmp");
        @endcode

        For example, calling:
        @code{.py} normalize_dir("../../test/.//dir"); @endcode
        from current directory \c "/opt/qorus/sub/dir" returns:
        @code{.py} "/opt/qorus/test/dir" @endcode

        @param dir the directory name to normalize
        @param cwd the current working directory

        @return a normalized path name (starting from /, eliminates \c ".", \c "..", and \c "//")
     */
    public string sub normalize_dir_unix(string dir, string cwd = getcwd()) {
        # if the directory begins with a ".", prefix the cwd to the string
        if (!absolute_path_unix(dir))
            dir = cwd + "/" + dir;

        # substitute "/./" with "/" until all occurrences are gone
        while (True) {
            string old = dir;
            dir =~ s/\/\.\//\//g;
            if (old == dir)
                break;
        }

        dir =~ s/^\.\///;
        dir =~ s/\/\.$//;

        # change // -> /
        dir =~ s/\/\/+/\//g;

        # separate into a list for eliminating occurences of ".."
        list l = dir.split("/");

        for (int i = 1; i < l.size(); ++i) {
            if (l[i] == "..") {
                splice l, i - 1, 2;
                i -= 2;
            }
        }

        dir = l.join("/");
        return dir ? dir : "/";
    }

    #! returns a normalized Windows path name (eliminates \c ".", \c "..", and \c "//")
    /** @par Example:
        @code{.py}
string dir = normalize_dir_windows(dir, "c:\\qore"));
        @endcode

        For example, calling:
        @code{.py} normalize_dir("..\..\test\.\\dir"); @endcode
        from current directory \c "c:\\lang\\qore\\prog1" returns:
        @code{.py} "c:\\lang\\test\\dir" @endcode

        @param dir the directory name to normalize
        @param cwd the current working directory

        @return a normalized path name; eliminates \c ".", \c "..", and \c "\\" (except at the beginning of a UNC path)
     */
    public string sub normalize_dir_windows(string dir, string cwd = getcwd()) {
        # change all occurrences of "/" to "\"
        dir =~ s/\//\\/g;

        # if the directory begins with a ".", prefix the cwd to the string
        if (!absolute_path_windows(dir))
            dir = cwd + "\\" + dir;

        # substitute "\.\" with "\" until all occurrences are gone
        while (True) {
            string old = dir;
            dir =~ s/\\\.\\/\\/g;
            if (old == dir)
                break;
        }

        dir =~ s/^\.\\//;
        dir =~ s/\\\.$//;

        # change \\ -> \ except at the beginning of the string
        dir =~ s/([^^])\\\\+/$1\\/g;

        # separate into a list for eliminating occurences of ".."
        list l = dir.split("\\");

        for (int i = 1; i < l.size(); ++i) {
            if (l[i] == "..") {
                splice l, i - 1, 2;
                i -= 2;
            }
        }

        dir = l.join("\\");
        return dir ? dir : "\\";
    }

    #! returns @ref True "True" if the argument is an absolute path, @ref False "False" if not
    /** @par Example:
        @code{.py}
bool abs = absolute_path(path);
        @endcode

        @param path the path to check

        @return @ref True "True" if the argument is an absolute path, @ref False "False" if not

        @see @ref Qore::absolute_path()

        @note this function has been moved to the %Qore library and is reexported here for backwards-compatibility
     */
    public bool sub absolute_path(string path) {
        return Qore::absolute_path(path);
    }

    #! returns @ref True "True" if the argument is a UNIX absolute path, @ref False "False" if not
    /** @par Example:
        @code{.py}
bool abs = absolute_path_unix(path);
        @endcode

        @param path the path to check

        @return @ref True "True" if the argument is a UNIX absolute path, @ref False "False" if not

        @see @ref Qore::absolute_path_unix()

        @note this function has been moved to the %Qore library and is reexported here for backwards-compatibility
     */
    public bool sub absolute_path_unix(string path) {
        return Qore::absolute_path_unix(path);
    }

    #! returns @ref True "True" if the argument is a Windows absolute path, @ref False "False" if not
    /** @par Example:
        @code{.py}
bool abs = absolute_path_windows(path);
        @endcode

        @param path the path to check

        @return @ref True "True" if the argument is a Windows absolute path, @ref False "False" if not

        @see @ref Qore::absolute_path_windows()

        @note this function has been moved to the %Qore library and is reexported here for backwards-compatibility
     */
    public bool sub absolute_path_windows(string path) {
        return Qore::absolute_path_windows(path);
    }

    # private, non-exported helper function for parse_memory_size()
    int sub _get_size(string num, number mult) {
        float f = num.toFloat();
        return (f * mult).toInt();
    }

    # private, non-exported constant hashes for scan_exp() below
    const ParenMap = (")": "(", "}": "{", "]": "[",);
    const FwdParenMap = map {$1.value: $1.key}, ParenMap.pairIterator();

    # private, non-exported constants for parsing
    const ET_RawString = 0;
    const ET_QuotedString = 1;
    const ET_BracketString = 2;
    const ET_CurlyBracketString = 3;
    const ET_Eq = 4;
    const ET_Comma = 5;
    const EtMap = {
        ET_RawString: "raw string",
        ET_QuotedString: "quoted string",
        ET_BracketString: "bracket expression",
        ET_CurlyBracketString: "curly bracket expression",
        ET_Eq: "=",
        ET_Comma: ",",
    };
    const Suffixes = ("th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th");

    # private scanner for parse_to_qore_value()
    list<hash> sub scan_exp(string arg) {
        #printf("DBG se: %y\n", arg);

        list<hash> l = ();

        # bracket stack
        string bracket_stack;

        # active quote character
        *string quote;

        int len = arg.length();
        string str;

        for (int i = 0; i < len; ++i) {
            string c = arg[i];
            if (c == ",") {
                if (!quote && !bracket_stack) {
                    #printf("DBG: got comma i:%d\n", i);
                    trim str;
                    if (str.val()) {
                        l += ("type": ET_RawString, "val": str);
                        str = "";
                    }
                    l += ("type": ET_Comma);
                    continue;
                }
            } else if (c == "=") {
                if (!quote && !bracket_stack) {
                    trim str;
                    if (str.val()) {
                        l += ("type": ET_RawString, "val": str);
                        str = "";
                    }
                    l += ("type": ET_Eq);
                    continue;
                }
            } else if (c == '"' || c == "'") {
                if (quote) {
                    if (c == quote) {
                        delete quote;
                        if (!bracket_stack) {
                            l += ("type": ET_QuotedString, "val": str);
                            str = "";
                            continue;
                        }
                    }
                } else {
                    quote = c;
                    if (!bracket_stack) {
                        trim str;
                        if (str.val()) {
                            l += ("type": ET_RawString, "val": str);
                            str = "";
                        }
                        continue;
                    }
                }
            } else if (!quote) {
                *string p = FwdParenMap{c};
                if (p) {
                    bool first;
                    if (!bracket_stack) {
                        first = True;
                        trim str;
                        if (str.val()) {
                            l += {"type": ET_RawString, "val": str};
                            str = "";
                        }
                    }
                    bracket_stack += p;
                    if (first) {
                        continue;
                    }
                } else if (ParenMap{c} && (c == bracket_stack[-1])) {
                    splice bracket_stack, -1;
                    if (!bracket_stack) {
                        #printf("DBG: got bracket string: %y\n", str);
                        l += {
                            "type": c == "}" ? ET_CurlyBracketString : ET_BracketString,
                            "val": str,
                        };
                        str = "";
                        continue;
                    }
                }
            }
            str += c;
        }

        trim str;
        if (str.val())
            l += ("type": ET_RawString, "val": str);

        return l;
    }

    # private, non-exported function: tries to evaluate the argument as a Qore expression/value
    hash<auto> sub eval_text(string arg, bool err = False) {
        # try to evaluate as a Qore expression
        string str = sprintf("auto sub get() { return %s; }", arg);
        # use a sandboxed Program object
        Program prog(PO_LOCKDOWN);
        try {
            prog.setScriptPath("Qore::Util::eval_text");
            prog.parse(str, "main");
            auto rv = prog.callFunction("get");
            return ("valid": True, "value": rv);
        } catch (hash<ExceptionInfo> ex) {
            if (err)
                throw "EVAL-ERROR", sprintf("error in EVAL cmd: %s: %s (arg: %s)\n", ex.err, ex.desc, arg);
        }

        return ("valid": False);
    }

    # private, non-exported function: tries to evaluate the argument as a Qore expression/value
    /* returns the value parsed
    */
    auto sub parse_to_basic_value(*string arg) {
        if (arg.empty())
            return;

        # see if there is aprocessing cmd
        if (*list pc = (arg =~ x/^\%(STR|EVAL)=(.*)$/s)) {
            if (pc[0] == "STR")
                return pc[1];
            else # must be EVAL
                return eval_text(pc[1], True).value;
        }

        # see if it's an int
        {
            int i = int(arg);
            if (i == arg)
                return i;
        }

        {
            float f = float(arg);
            if (f == arg)
                return f;
        }

        {
            number n = number(arg);
            if (n == arg)
                return n;
        }

        if (arg == "True" || arg == "true")
            return True;
        if (arg == "False" || arg == "false")
            return False;

        # see if it's a date/time value
        if (arg =~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}([-T ][0-5][0-9]:[0-5][0-9](:[0-5][0-9](\.[0-9]+)))?/)
            return date(arg);

        return arg;
    }

    #! tries to convert a string (such as an argument given from the command-line) to a Qore value
    /** This function recognizes two special prefixes in the string:
        - \c %STR= this prefix indicates that the rest of the string should be passed literally and not parsed
        - \c %EVAL= this prefix indicates that the rest of the string should be taken as a Qore expression and executed and the value returned

        Strings are interpreted as in the following table.

        <b>String Parsing</b>
        |!Format|!Description
        |<tt><i>key_string</i> = <i>value</i>[, ...]</tt>|a @ref hash "hash"
        |<tt><i>value</i>, [...]</tt>|a @ref list "list"
        |integers|an @ref integer "integer"
        |floats|a @ref float "float"
        |arbitrary-numeric value|a @ref number "number"
        |\c True, \c true, \c False, \c false|a @ref boolean "bool"
        |<tt>YYYY-MM-DD[[-T ]HH:mm[:SS[.uu]]]</tt>|a @ref date "date"
        |a %Qore expression|the value evaluated
        |a quoted string|a @ref string "string"

        @par Examples:
        @verbatim
prompt% qore -l Util -X 'parse_to_qore_value("(a=(b=(c=x, 2, 3)))")'
hash: (1 member)
  a : hash: (1 member)
    b : list: (3 elements)
      [0]=hash: (1 member)
        c : "x"
      [1]=2
      [2]=3
        @endverbatim

        @param arg a string to convert to a Qore value according to the rules documented above

        @return the Qore value corresponding to the input string

        @throw PARSE-ERROR cannot parse the string given
    */
    public auto sub parse_to_qore_value(string arg) {
        # see if there is aprocessing cmd
        if (*list pc = (arg =~ x/^\%(STR|EVAL)=(.*)$/s)) {
            if (pc[0] == "STR")
                return pc[1];
            else # must be EVAL
                return eval_text(pc[1], True).value;
        }

        # we should not use "auto" here because this lvalue must be able to convert to an untyped list
        auto v;

        list<hash> l = scan_exp(arg);

        #map printf("%d: %y: %y, ", $#, EtMap{$1.type}, $1.val), l; printf("\n");

        bool do_break;
        bool in_hash;

        # process values after an "=" sign
        code do_eq = sub (reference<int> i, string key) {
            # get the value
            auto val;
            switch (l[i+2].type) {
                case ET_BracketString: val = !l[i+2].val.empty() ? parse_to_qore_value(l[i+2].val) : (); break;
                case ET_CurlyBracketString: val = !l[i+2].val.empty() ? parse_to_qore_value(l[i+2].val) : {}; break;
                case ET_RawString: val = parse_to_basic_value(l[i+2].val); break;
                case ET_QuotedString: val = l[i+2].val; break;
                case ET_Comma: --i; break;
                case ET_Eq: throw "PARSE-ERROR", sprintf("cannot parse %y after %y", EtMap{ET_Eq}, EtMap{ET_Eq});
            }
            #printf("do_eq() i: %d key: %y v: %y val: %y\n", i, key, v, val);
            if (!exists v) {
                v{key} = val;
                in_hash = True;
            } else switch (v.typeCode()) {
                case NT_HASH: {
                    if (do_break)
                        v = (v, {key: val});
                    else
                        v{key} = val;
                    break;
                }
                case NT_LIST: {
                    if (v.last().typeCode() == NT_HASH && !do_break) {
                        # must use += here so that any hash created stays "hash<auto>"
                        v[v.size() - 1]{key} += val;
                    } else {
                        v += {key: val};
                    }
                    break;
                }
                default: throw "PARSE-ERROR", sprintf("impossible hash v: %y key: %y val: %y", v, key, val);
            }
            do_break = False;

            i += 2;
        };

        # process other values
        code do_val = sub (auto val, *bool in_parens) {
            switch (v.typeCode()) {
                case NT_NOTHING: {
                    v = val;
                    break;
                }
                case NT_LIST: {
                    if (!in_parens) {
                        v += val;
                    } else {
                        push v, val;
                    }
                    break;
                }
                default: {
                    v = (v, val);
                    break;
                }
            }
        };

        code check_val = sub (int i) {
            if (i) {
                int lt = l[i-1].type;
                if (lt != ET_Comma && lt != ET_Eq) {
                    throw "PARSE-ERROR", sprintf("cannot parse %y (%y) after %y (%y)", EtMap{l[i].type}, l[i].val, EtMap{lt}, l[i-1].val);
                }
            }
        };

        for (int i = 0; i < l.size(); ++i) {
            hash<auto> h = l[i];
            # get preceding type
            *int pt;
            if (i)
                pt = l[i-1].type;
            switch (h.type) {
                case ET_RawString: {
                    check_val(i);
                    # check next symbol, if it's an "=" sign, then use as a hash key
                    if (l[i+1].type == ET_Eq) {
                        do_eq(\i, trim(h.val));
                        continue;
                    }
                    do_val(parse_to_basic_value(h.val));
                    do_break = False;
                    break;
                }
                case ET_CurlyBracketString: {
                    check_val(i);
                    if (!exists h.val) {
                        do_val({});
                    } else {
                        do_val(parse_to_qore_value(h.val));
                    }
                    do_break = True;
                    break;
                }
                case ET_BracketString: {
                    check_val(i);
                    if (!exists h.val) {
                        do_val(());
                    } else {
                        do_val(parse_to_qore_value(h.val), True);
                    }
                    do_break = True;
                    break;
                }
                case ET_QuotedString: {
                    check_val(i);
                    # check next symbol, if it's an "=" sign, then use as a hash key
                    if (l[i+1].type == ET_Eq) {
                        do_eq(\i, h.val);
                        continue;
                    }

                    do_val(h.val);
                    do_break = False;
                    break;
                }
                case ET_Comma: {
                    if (v.typeCode() != NT_LIST && !in_hash) {
                        # convert to list<auto>
                        list<auto> tmp;
                        tmp += v;
                        v = tmp;
                    }
                    break;
                }
                case ET_Eq: {
                    if (i)
                        throw "PARSE-ERROR", sprintf("cannot parse %y after %y (%y)", EtMap{h.type}, EtMap{l[i-1].type}, h.val);
                    else
                        throw "PARSE-ERROR", sprintf("cannot parse %y at the beginning of the expression", EtMap{h.type});
                }
            }
        }

        # try to fold all types to the most specific type when returning
        return auto_cast(v);
    }

    #! parses a URI path for a arguments and a method; where the method is the part of the path before the first \c "?" character, and arguments are after
    /** @param path the URI path to parse

        @return a @ref UriQueryInfo hash

        @note the \a params output key value is always returned as a hash

        @since Util 1.3
    */
    public hash<UriQueryInfo> sub parse_uri_query(string path) {
        int i = path.find("?");
        if (i == -1)
            return new hash<UriQueryInfo>(("method": path));

        # we use "params" rather than "args" because some RPC protocols require it (like XML-RPC and JSON-RPC)
        hash<UriQueryInfo> h({
            "method": path.substr(0, i),
            "params": {},
        });

        # remove method and "?" char; leave only args in path
        splice path, 0, i + 1;

        # iterate through args
        # w3c recommends ";" instead of "&" to separate arguments
        # http://www.w3.org/TR/1999/REC-html401-19991224/appendix/notes.html#h-B.2.2
        # however we support both
        string sep = path.find(";") == -1 ? "&" : ";";
        foreach any arg in (split(sep, path)) {
            if (arg.val()) {
                (*string key, *string value) = (arg =~ x/([^=]+)=(.*)$/);
                if (exists key) {
                    reference kv = \h.params{key};
                    if (exists kv) {
                        if (kv.typeCode() != NT_LIST)
                            kv = (kv, value);
                        else
                            kv += value;
                    }
                    else
                        kv = value;
                }
                else
                    h.params{arg} = True;
            }
        }
        return h;
    }

    #! returns a serialized string for a UriQueryInfo hash
    /** @param h the UriQueryInfo hash to serialize
        @param arg_separator the character to use to separate URI query arguments

        @since Util 1.3
    */
    public string sub make_uri_query(hash<UriQueryInfo> h, string arg_separator = ";") {
        if (!h.params)
            return h.method ?? "";
        string str;
        foreach hash<auto> ph in (h.params.pairIterator()) {
            if (exists str)
                str += arg_separator;
            str += foldl $1 + arg_separator + $2, (map sprintf("%s=%s", ph.key, $1), ph.value);
        }
        return h.method + "?" + str;
    }

    #! function that returns a random string
    /** @par Example:
        @code{.py}
string pass = get_random_string();
        @endcode

        @param len the length fo the string returned
        @param level a value from 1 - 4 inclusive giving the range of printable ASCII characters included in the output (values out of the range result in the nearest value in the range being used):
        - 1: only upper case
        - 2: +lower case
        - 3: +numbers
        - 4: +symbols but not including any quote characters

        @return a random string of the given length containing only printable ASCII characters according to the \a level argument

        @see @ref Qore::get_random_bytes()
    */
    public string sub get_random_string(softint len = 15, int level = 3) {
        string str;
        if (level < 1)
            level = 1;
        else if (level > 4)
            level = 4;
        --level;
        level = (26, 52, 62, 88)[level];  # 15(77), 7(84), 4
        # do not seed the random number generator and use rand() as this requires PO_PROCESS_CONTROL permissions
        if (PlatformOS == "Windows") {
            # on windows, just use clock_getmicros() to generate a pseudo-random number
            int start = (clock_getmicros() * 7621 + 1);
            for (int i = 0; i < len; ++i) {
                int v = start;
                if (i)
                    v += rand();
                v = v.abs() % level;
                str += (v < 26 ? chr(v + ord("A")) :
                         (v < 52 ? chr(v - 26 + ord("a")) :
                          (v < 62 ? chr(v - 4) :
                           (v < 77 ? chr(v - 29) :
                            (v < 84 ? chr(v - 19) :
                             chr(v + 39))))));
            }
        }
        else {
            ReadOnlyFile f("/dev/urandom");
            for (int i = 0; i < len; ++i) {
                int v = f.readi2().abs() % level;
                str += (v < 26 ? chr(v + ord("A")) :
                         (v < 52 ? chr(v - 26 + ord("a")) :
                          (v < 62 ? chr(v - 4) :
                           (v < 77 ? chr(v - 29) :
                            (v < 84 ? chr(v - 19) :
                             chr(v + 39))))));
            }
        }
        return str;
    }

    #! returns a multi-line string from the exception hash argument suitable for logging or output on the console
    /** @param ex the exception hash to process

        @return a multi-line string from the exception hash argument suitable for logging or output on the console
     */
    public string sub get_exception_string(hash<auto> ex) {
        string str;

        while (True) {
            str += sprintf("%s exception: %s: %s: %s",
                            ex.type, get_ex_pos(ex), ex.err, ex.desc);
            if (exists ex.arg) {
                try {
                    # issue #3304: do not access any potential key of "ex.arg" directly, as it might be an object of a
                    # class with a specific member list or a hashdecl where accessing an invalid key would cause a
                    # runtime exception to be thrown
                    if (ex.arg.typeCode() == NT_HASH
                        && ex.arg.hasKey("ex")
                        && (ex.arg.ex instanceof hash<ExceptionInfo>
                            || (ex.arg.ex.err.typeCode() == NT_STRING
                                && ex.arg.ex.desc.typeCode() == NT_STRING
                                && ex.arg.ex.callstack.typeCode() == NT_LIST))) {
                        if (ex.arg.size() > 1) {
                            str += sprintf(" (arg: %y)", ex.arg - "ex");
                        }
                        str += sprintf("; source exception: %s", get_exception_string(ex.arg.ex));
                    } else {
                        str += sprintf(" (arg: %y)", ex.arg);
                    }
                } catch (hash<ExceptionInfo> ex) {
                    # in case "ex.arg" is an object from a deleted program, then ignore
                    if (ex.err != "PROGRAM-ERROR") {
                        rethrow;
                    }
                }
            }

            if (ex.callstack) {
                foreach hash<auto> l in (ex.callstack) {
                    if (l.type == "new-thread") {
                        str += sprintf("\n  *** thread started by background operator ***");
                    } else {
                        string pos = get_ex_pos(l);
                        if (l.type == "rethrow") {
                            str += sprintf("\n  *** RETHROW at %s", pos);
                        } else {
                            if (pos =~ /\)$/) {
                                splice pos, -1, 1, sprintf(" %s code)", l.type);
                            } else {
                                pos += sprintf(" (%s code)", l.type);
                            }
                            str += sprintf("\n  %s() called at %s", l.function, pos);
                        }
                    }
                }
            }

            if (!ex.next)
                break;
            ex = ex.next;
            str += "\nchained exception:\n";
        }
        return str;
    }

    #! storage names (Geop, which would normally follow Bronto, is excluded as the abbreviation would be GB/GiB)
    public const StorageNames = ("Kilo", "Mega", "Giga", "Tera", "Peta", "Exa", "Zetta", "Yotta", "Bronto");

    #! hash of single-letter storage name abbreviations
    public const StorageAbbr = map {$1[0].lwr(): $#}, StorageNames;

    #! returns a string giving a user-friendly real storage size (ie based on 1KiB = 1024 bytes) in KiB, MiB, GiB, TiB, etc for the given byte size
    /** @par Example:
        @code{.py}
string str = get_byte_size(n);
        @endcode

        @param n the number to display
        @param decimals the number of digits after the decimal point
    */
    public string sub get_byte_size(softnumber n, int decimals = 2) {
        string k;

        HashPairIterator i(storage_sizes);
        while (i.next()) {
            if (n >= i.getValue().value)
                k = i.getValue().key;
            else
                break;
        }

        string fmt = sprintf("%%.%df ", decimals);

        if (!k)
            return sprintf(fmt + "byte" + (n == 1 ? "" : "s"), n);

        n /= storage_sizes{k};
        string v = sprintf(fmt, n);
        v =~ s/(\.)?0*$//;

        return v + k[0] + "iB";
    }

    #! returns a string giving a user-friendly "marketing storage" size (ie based on 1KB = 1000 bytes) in KB, MB, GB, TB, etc for the given byte size
    /** @par Example:
        @code{.py}
string str = get_marketing_byte_size(n);
        @endcode

        @param n the number to display
        @param decimals the number of digits after the decimal point
    */
    public string sub get_marketing_byte_size(softnumber n, int decimals = 2) {
        string k;

        HashPairIterator i(marketing_storage_sizes);
        while (i.next()) {
            if (n >= i.getValue().value)
                k = i.getValue().key;
            else
                break;
        }

        string fmt = sprintf("%%.%df ", decimals);

        if (!k)
            return sprintf(fmt + "byte" + (n == 1 ? "" : "s"), n);

        n /= marketing_storage_sizes{k};
        string v = sprintf(fmt, n);
        # remove trailing zeros
        v =~ s/(\.)?0*$//;

        return v + k[0] + "B";
    }

    #! checks whether given list has only unique elements
    /** @par Example:
        @code{.py}
        if (same((1, 1, 1)) {
            printf("only unique elements");
        };
        @endcode

        @param l some list

        @since Util 1.2
    */
    public bool sub same(list<auto> l) {
        if (l.size() < 2) {
            return True;
        }
        for (int i0 = 0; i0 < l.size(); ++i0) {
            auto current_value = l[i0];
            for (int i1 = i0 + 1; i1 < l.size(); ++i1) {
                if (l[i1] != current_value) {
                    return False;
                }
            }
        }
        return True;
    }

    #! list slice implementation
    /** @par Example:
        @code{.py}
        list<string> l = slice(("a", "b", "c", "d"), (1, 3)); # returns ("b", "d")
        @endcode

        @param l some list
        @param indices indices that should be sliced from the original list

        @since Util 1.2
    */
    public list<auto> sub slice(list<auto> l, softlist<auto> indices) {
        return map l[$1], indices, ($1 >= 0 && $1 < l.size());
    }

    #! Returns a path for temporary files
    /** @par Example:
        @code{.py}
string testfile = tmp_location() + '/test.txt';
# some processing
unlink(testfile);
        @endcode

        Environment variables are searched in the following order (the first with a value is used):
        - \c TMPDIR
        - \c TMP
        - \c TEMP
        - \c TEMPDIR

        If none of these are present, then \c "/tmp" (UNIX) or \c "c:\temp" (Windows) is checked.

        @throw TMP-ERROR unable to find the location of the temporary directory; temporary directory is not writable

        @since Util 1.2
    */
    public string sub tmp_location() {
        # TODO: add support for other platforms
        *string dir = ENV.TMPDIR ?* ENV.TMP ?* ENV.TEMP ?* ENV.TEMPDIR;
        if (!dir)
            dir = PlatformOS == "Windows" ? "c:\\temp" : "/tmp";

        if (!is_writable(dir))
            throw "TMP-ERROR", sprintf("unable to find the location of the temporary directory; %y is not writable", dir);

        return realpath(dir);
    }

    #! Checks whether string represents a (true) integer value.
    /**
        @param  text a string to check
        @param  pure if True then only integers match, otherwise check floats too.
        @return True if input represents an integer value, False otherwise.

        @par Example:
        @code{.py}
bool match = is_int("123");
# returns True, while any of the following returns False:
match = is_int("1.0", True);
match = is_int("12x");
        @endcode

        @note The function only checks whether a string represents an integer value, but it does not validate size restrictions (that is whether it would fit %Qore's native int type) etc.

        @since Util 1.2
    */
    public bool sub is_int(string text, bool pure = False) {
        if (text =~ /^\s*[-+]?\d+\s*$/ || (!pure && is_float(text, True) && (float(text) == floor(float(text)))))
            return True;
        return False;
    }

    const RE_FLOAT = '^\s*[-+]?('
        '\d+\.\d*(e[-+]?\d+)?' # floating point number, with dot, optional exponent
        '|\.\d+(e[-+]?\d+)?' # floating point number, starting with a dot, optional exponent
        '|\d+e[-+]?\d+' # floating point number, without dot, with exponent
        ')\s*$'; #';

    #! Checks whether string represents a (true) float value.
    /**
        @param  text a string to check
        @param  pure if True then only floats match, otherwise include integers.
        @return True if input represents a float value, False otherwise.

        @par Example:
        @code{.py}
bool match = is_float("1.2");
# returns True, while any of the following returns False:
match = is_float("12", True);
match = is_float("1.2x");
        @endcode

        @note The function only checks whether a string represents a float value, but it does not validate size / precision restrictions (whether it would fit %Qore's native float type).

        @since Util 1.2
    */
    public bool sub is_float(string text, bool pure = False) {
        if (text.regex(RE_FLOAT) || (!pure && is_int(text)))
            return True;
        return False;
    }

    const RE_NUMBER = '^\s*[-+]?('
        '\d+\.\d*(e[-+]?\d+)?' # floating point number, with dot, optional exponent
        '|\.\d+(e[-+]?\d+)?' # floating point number, starting with a dot, optional exponent
        '|\d+e[-+]?\d+' # floating point number, without dot, with exponent
        '|\d+)n\s*$'; #'; #integer

    #! Checks whether string represents a (true) number value.
    /**
        @param  text a string to check
        @param  pure if True then only numbers match, otherwise include floats and integers.
        @return True if input represents a number value, False otherwise.

        @par Example:
        @code{.py}
bool match = is_number("1.2n");
# returns True, while any of the following returns False:
match = is_number("12", True);
match = is_number("1.2", True);
match = is_number("1.2x");
        @endcode

        @note The function only checks whether a string represents an arbitrary precision number value, but it does not validate any restrictions (whether it would fit %Qore's native number type).

        @since Util 1.2
    */
    public bool sub is_number(string text, bool pure = False) {
        if (text.regex(RE_NUMBER) || (!pure && is_float(text, pure)))
            return True;
        return False;
    }

    #! Returns a string left-padded to a specified length with the specified characters.
    /** Returns a string, left-padded to a specified length with the specified characters; or, when the string to be padded is longer than the length specified after padding, only that portion of the string that fits into the specified length.

        @param  text input string that you want to pad
        @param  length total length of output string (in characters)
        @param  padding padding character(s); default value is a single blank
        @return a string left-padded to the specified length

        @par Example:
        @code{.py}
string s = lpad ("123", 5); # returns "  123"
string s = lpad ("ABC", 9, "-"); # returns "------ABC"
        @endcode

        @since Util 1.2
    */
    public string sub lpad(softstring text, int length, string padding = ' ') {
        int d = length - text.length();
        if (d > 0) {
            string p = strmul (padding, d / padding.length() + 1);
            return p.substr(0, d) + text;
        }
        else if (d < 0)
            return text.substr(-d);
        else
            return text;
    }

    #! Returns a string right-padded to a specified length with the specified characters.
    /** Returns a string, right-padded to a specified length with the specified characters; or, when the string to be padded is longer than the length specified after padding, only that portion of the string that fits into the specified length.

        @param  text input string that you want to pad
        @param  length total length of output string (in characters)
        @param  padding padding character(s); default value is a single blank
        @return a string right-padded to the specified length

        @par Example:
        @code{.py}
string s = rpad ("123", 5); # returns "123  "
string s = rpad ("ABC", 9, "-"); # returns "ABC------"
        @endcode

        @since Util 1.2
    */
    public string sub rpad(softstring text, int length, string padding = ' ') {
        int d = length - text.length();
        if (d > 0) {
            string p = strmul (padding, d / padding.length() + 1);
            return text + p.substr(0, d);
        }
        else if (d < 0)
            return text.substr(0, d);
        else
            return text;
    }

    #! Returns string with partially textual representation of ordinal integer value
    /** @par Example:
        @code{.py}
printf("%s grade", ordinal(1));
# would print "1st grade"
        @endcode

        @param i integer value to convert to textual representation
        @return a string representation of ordinal value of the argument

        @since Util 1.2
    */
    public string sub ordinal(int i) {
        switch (i % 100) {
            case 11:
            case 12:
            case 13:
                return sprintf("%dth", i);
            default:
                return sprintf("%d%s", i, Suffixes[i % 10]);
        }
    }

    #! Returns string with number and proper singular/plural form of noun.
    /**
        @param  count integer value to convert
        @param  base base word or possibly nothing
        @param  singular singular form suffix or whole word
        @param  plural plural form suffix or whole word
        @return a string representation of number plus noun

        @par Example:
        @code{.py}
printf (plural(1, "beer"));
# would print "1 beer"
printf (plural(1, "lad", "y", "ies"));
# would print "1 lady"
printf (plural(32, "", "tooth", "teeth"));
# would print "32 teeth"
        @endcode

        @since Util 1.2
    */
    public string sub plural(int count, string base, string singular = "", string plural = "s") {
        return sprintf("%d %s", count, count == 1 ? base + singular : base + plural);
    }

    #! Escapes (backslashes) all non-alphanumeric characters in a string.
    /** Returns string with all non-alphanumerics backslashed; this is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it.

        @param  text string to escape / backslash
        @return a string escaped / backslashed

        @par Example:
        @code{.py}
string s = regex_escape ("Gain: $100"); # returns "Gain\\:\\ \\$100"
        @endcode

        @since Util 1.2
    */
    public string sub regex_escape(string text) {
        text =~ s/([^[:alnum:]])/\\$1/g;
        return text;
    }

    #! Translates a shell pattern to a regular expression.
    /** Returns the shell-style pattern converted to a regular expression.

        @param  pat the pattern to convert
        @return a converted pattern

        @par Example:
        @code{.py}
string s = glob_to_regex ("*.*"); # returns ".*\\..*"
        @endcode

        @since Util 1.2
    */
    public string sub glob_to_regex(string pat) {
        string r = '';
        int n = pat.length();
        int i = 0;
        while (i<n) {
            string c = pat[i];
            i++;
            if (c == '?')
                r += '.';
            else if (c == '*')
                r += '.*';
            else if (c == '[') {
                int j = i;
                if (j < n && pat[j] == '!')
                    j++;
                if (j < n && pat[j] == ']')
                    j++;
                while (j < n && pat[j] != ']')
                    j++;
                if (j >= n)
                    r += '\[';
                else {
                    string s = replace (pat.substr(i, j-i), '\', '\\');
                    i = j + 1;
                    if (s[0] == '!')
                        s = '^' + s.substr(1);
                    else if (s[0] == '^')
                        s = '\' + s;
                    r += '[' + s + ']';
                }
            }
            else
                r += regex_escape(c);
        }
        return '\A' + r + '\Z';
    }

    #! Flattens a nested list (the nesting can be to any depth).
    /**
        @param arg a list to flatten
        @return a flattened list

        @par Example:
        @code{.py}
list<int> f = flatten(((1, 2), (3, 4), 5)); # returns (1, 2, 3, 4, 5)
        @endcode

        @since Util 1.3
    */
    public list<auto> sub flatten(softlist<auto> arg) {
        list<auto> r;
        foreach auto i in (arg) {
            if (i.typeCode() == NT_LIST) {
                foreach auto j in (flatten(i)) {
                    r += j;
                }
            } else {
                r += i;
            }
        }
        return r ?? ();
    }

    #! Parses a string and returns a list of integers.
    /**
        @param text the string to parse
        @return a list of integer numbers

        @par Example:
        @code{.py}
list<int> ints = parse_ranges("3,5, 7-9"); # returns (3, 5, 7, 8, 9)
        @endcode

        @since Util 1.4
    */
    public list<int> sub parse_ranges(string text) {
        list<int> numbers = ();
        list<string> parts = select (map trim($1), text.split(',')), $1;
        foreach string str in (parts) {
            list<string> bounds = str.split("-");
            if (bounds.size() == 2) {
                numbers += range(int(bounds[0]), int(bounds[1]) + 1);
            } else {
                numbers += int(str);
            }
        }
        return numbers;
    }

    #! Returns a duplicate-free version of the list.
    /**
        @param arg a list of values to filter out
        @return a list of unique values

        @par Example:
        @code{.py}
list<auto> u = uniq((1,2,1,3,2,1)); # returns (1,2,3)
        @endcode

        @note Since the implementation of this function uses a %hash to keep track of the list values, it cannot process
        values that cannot be coverted to strings or for which implicit string representation collide (e.g. %float
        values that differ outside implicit %toString() precision).

        @throw UNIQ-ERROR if two different values from the list share the same implicit string representation

        @since Util 1.3
    */
    public list<auto> sub uniq(softlist<auto> arg) {
        hash<auto> h;
        foreach auto item in (arg) {
            string k = item.toString();
            if (exists h{k}) {
                if (h{k} !== item)
                    throw "UNIQ-ERROR", sprintf ("cannot safely handle %s %y -- set already contains %s %y",
                            item.type(), item, h{k}.type(), h{k});
            } else
                h{k} = item;
        }
        return h.values();
    }

    #! Returns a list of lists, where the i-th list contains the i-th element from each of the argument lists.
    /**
        @param  ... lists to 'zip'
        @return a list of lists

        @par Example:
        @code{.py}
list z = zip ((1, 2, 3), (4, 5)); # returns ((1,4), (2,5), (3,NOTHING))
        @endcode

        @since Util 1.2
    */
    public list<auto> sub zip() {
        if (argv.size() == 0)
            return ();
        int m = max (map $1.size(), argv);
        list<auto> r;
        for (int i=0; i < m; i++) {
            r[i] = map $1[i], argv;
        }
        return r ?? ();
    }

    #! verifies if a string is an IPv4 or IPv6 address
    /** @par Example:
        @code{.py}
check_ip_address(str, True);
        @endcode

        @param ip the string in dot-notation (for IPv4 addresses) or colon notation (for IPv6 addresses) to check; the string should not contain any network component which would cause the comparison to fail; note that IPv4 address components must be in the range of 0 - 255 and must not have leading zeros
        @param exception if @ref True an exception will be thrown if the string is not a valid IPv4 or IPv6 address, if @ref False the return value of the function indicates the string's validation status

        @return @ref True if the string is a valid IPv4 or IPv6 address, @ref False if not (note that if \c exception is @ref True then an \c INVALID-IP-ADDRESS exception is thrown if the string is invalid)

        @throw INVALID-IP-ADDRESS this exception is thrown if \c ip is not a valid IPv4 or IPv6 address and \c exception is @ref True

        @since Util 1.4
    */
    public bool sub check_ip_address(string ip, bool exception = False) {
        # check for IPv4 addresses (checks for 0 - 255 in each IPv4 component)
        if (ip =~ /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]))\.((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]))\.((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]))\.((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]))$/)
            return True;
        # check for IPv6 addresses
        if (ip =~ /^(([0-9a-f]{1,4}:){7,7}[0-9a-f]{1,4}|([0-9a-f]{1,4}:){1,7}:|([0-9a-f]{1,4}:){1,6}:[0-9a-f]{1,4}|([0-9a-f]{1,4}:){1,5}(:[0-9a-f]{1,4}){1,2}|([0-9a-f]{1,4}:){1,4}(:[0-9a-f]{1,4}){1,3}|([0-9a-f]{1,4}:){1,3}(:[0-9a-f]{1,4}){1,4}|([0-9a-f]{1,4}:){1,2}(:[0-9a-f]{1,4}){1,5}|[0-9a-f]{1,4}:((:[0-9a-f]{1,4}){1,6})|:((:[0-9a-f]{1,4}){1,7}|:)|fe80:(:[0-9a-f]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-f]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/i)
            return True;
        if (exception)
            throw "INVALID-IP-ADDRESS", sprintf("%y: is not a valid IPv4 or IPv6 address", ip);
        return False;
    }

    #! Verifies whether a string begins with specific substring
    /** @param str string to be checked
        @param substr substring to look for at str's start

        @return True if str starts with substr, False otherwise
    */
    public bool sub string_starts_with(string str, string substr) {
        if (substr == "") {
            return True;
        }

        return str.find(substr) == 0;
    }

    #! Verifies whether a string ends with specific substring
    /** @param str string to be checked
        @param substr substring to look for at str's end

        @return True if str ends with substr, False otherwise
    */
    public bool sub string_ends_with(string str, string substr) {
        int str_len = str.length();
        int substr_len = substr.length();

        if (substr_len == 0) {
            return True;
        }

        return str_len >= substr_len && str.rfind(substr) == str_len - substr_len;
    }

    #! URL retrieval options for get_file_from_url()
    public hashdecl UrlRetrievalOptions {
        #! Return the file data as binary data; if False (the default), a string will be returned
        bool as_binary = False;

        #! The default path for files with relative paths
        *string default_path;

        #! HTTP headers to add to any HTTP GET request
        *hash<auto> http_headers;

        #! SSH2 private key path
        *string ssh2_private_key;

        #! SSH2 public key path
        *string ssh2_public_key;
    }

    #! Retrieves file data from an SFTP URL and a path
    /** @param url the SFTP URL
        @param path the path to the file on the SFTP server
        @param options connection options

        @throw GET-FILE-FROM-URL-ERROR empty path string

        @since Util 1.5
    */
    public data sub get_file_from_sftp(string url, string path, *hash<UrlRetrievalOptions> options) {
        string file = basename(path);
        if (!file) {
            throw "GET-FILE-FROM-URL-ERROR", sprintf("missing file name in URL %y", url);
        }
        # dynamically load the ssh2 module
        try {
            load_module("ssh2");
        } catch (hash<ExceptionInfo> ex) {
            throw ex.err, sprintf("cannot retrieve %y with SFTP; the ssh2 module cannot be "
                "loaded: %s", ex.desc), ex.arg;
        }
        object sftp = create_object("SFTPClient", url);
        if (options.ssh2_private_key) {
            sftp.setKeys(options.ssh2_private_key, options.ssh2_public_key);
        }
        string dir = dirname(path);
        if (dir) {
            sftp.chdir(dir);
        }
        return options.as_binary ? sftp.getFile(file) : sftp.getTextFile(file);
    }

    #! Retrieves file data from an FTP URL and a path
    /** @param url the FTP URL
        @param path the path to the file on the FTP server
        @param options connection options

        @throw GET-FILE-FROM-URL-ERROR empty path string

        @since Util 1.5
    */
    public data sub get_file_from_ftp(string url, string path, *hash<UrlRetrievalOptions> options) {
        string file = basename(path);
        if (!file) {
            throw "GET-FILE-FROM-URL-ERROR", sprintf("missing file name in URL %y", url);
        }
        FtpClient f(url);
        f.connect();
        string dir = dirname(path);
        if (dir) {
            f.cwd(dir);
        }
        return options.as_binary ? f.getAsBinary(file) : f.getAsString(file);
    }

    #! Retrieves file data from an HTTP URL
    /** @param url the HTTP URL including the path to the resource to retrieve
        @param path an optional path to append to the URL
        @param options connection options

        @since Util 1.5
    */
    public data sub get_file_from_http(string url, *string path, *hash<UrlRetrievalOptions> options) {
        HTTPClient http({"url": url});
        string body = http.get(path ? path : "/", {"Accept": "*"} + options.http_headers);
        return options.as_binary ? binary(body) : body;
    }

    #! Retrieves file data from a local file path
    /** @param path the path to the file data on the local filesystem
        @param options connection options

        @since Util 1.5
    */
    public data sub get_local_file(string path, *hash<UrlRetrievalOptions> options) {
        return options.as_binary ? File::readBinaryFile(path) : File::readTextFile(path);
    }

    #! Retrieves file data from the given URL
    /** @param url the URL for the file
        @param options retrieval options

        @throw GET-FILE-FROM-URL-ERROR unknown or unsupported scheme in URL or other error retrieving the file

        @since Util 1.5
    */
    public data sub get_file_from_url(string url, *hash<UrlRetrievalOptions> options) {
        hash<UrlInfo> url_info = parse_url(url);

        switch (url_info.protocol ?? "file") {
            case "file": {
                string path;
                if (url_info.host)
                    path = url_info.host;
                if (url_info.path) {
                    if (path)
                        path += DirSep;
                    path += url_info.path;
                }
                # do environment variable substitution
                map path = replace(path, "\$" + $1, ENV.$1), (path =~ x/\$(\w+)/g);

                if (exists options.default_path && !absolute_path(path)) {
                    path = options.default_path + DirSep + path;
                }
                return get_local_file(path, options);
            }

            case /^http(s)?$/: {
                return get_file_from_http(url, url_info.path, options);
            }

            case /^ftp(s)?$/: {
                if (!url_info.path.val()) {
                    throw "GET-FILE-FROM-URL-ERROR", sprintf("missing path in URL %y", url);
                }
                return get_file_from_ftp(url, url_info.path, options);
            }

            case "sftp": {
                if (!url_info.path.val()) {
                    throw "GET-FILE-FROM-URL-ERROR", sprintf("missing path in URL %y", url);
                }
                return get_file_from_sftp(url, url_info.path, options);
            }

            default:
                throw "GET-FILE-FROM-URL-ERROR", sprintf("do not know how to retrieve data with scheme %y given in "
                    "URL %y", url_info.protocol, url);
        }
    }

    #! Substitutes environment variables in a string and returns the string
    /** @param str the string to process

        @return the string with environment variables substituted

        @since %Util 1.5.1
    */
    public string sub substitute_env_vars(string str) {
        while (True) {
            *list<string> x = (str =~ x/(\$[A-Za-z][A-Za-z0-9_]*)/);
            if (!x) {
                x = (str =~ x/(\${[^{}]*})/);
            }
            if (!x) {
                x = (str =~ x/(\$\([^\(\)]*\))/);
            }
            if (!x) {
                break;
            }

            foreach string var in (x) {
                # remove '$' character
                splice var, 0, 1;

                # substitute environment variable
                str = regex_subst(str, "\\\$" + var, ENV{var});
            }
        }
        return str;
    }
}
