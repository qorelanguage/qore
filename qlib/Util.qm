# -*- mode: qore; indent-tabs-mode: nil -*-
# @file Util.qm Qore user module for generally useful routines

/*  Util.qm Copyright 2014 - 2016 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.12 or better
%requires qore >= 0.8.12

# do not use $ for vars, assume local var scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module Util {
    version = "1.2";
    desc    = "user module for generally useful routines";
    author  = "David Nichols <david@qore.org>";
    url     = "http://qore.org";
    license = "MIT";
    init    = sub () { init(); };
}

/** @mainpage Util Module

    @tableofcontents

    @section utilintro Util Module Introduction

    The %Util module provides some generally-useful routines that are more suitable for
    writing in Qore than in C++.

    To use this module, use \c "%requires Util" in your code.

    All the public symbols in the module are defined in the Util namespace

    Functions:
    - @ref Util::compare_version()
    - @ref Util::get_byte_size()
    - @ref Util::get_exception_string()
    - @ref Util::get_marketing_byte_size()
    - @ref Util::get_random_string()
    - @ref Util::glob_to_regex()
    - @ref Util::lpad()
    - @ref Util::normalize_dir()
      - @ref Util::normalize_dir_unix()
      - @ref Util::normalize_dir_windows()
    - @ref Util::ordinal()
    - @ref Util::plural()
    - @ref Util::regex_escape()
    - @ref Util::rpad()
    - @ref Util::parse_to_qore_value()
    - @ref Util::slice()
    - @ref Util::same()
    - @ref Util::tmp_location()

    @section utilrelnotes Release Notes

    @subsection util_1_2 Util 1.2
    - the following functions are now actually implemented in the %Qore library and only reexported here for backwards-compatibility:
      - @ref Qore::absolute_path()
      - @ref Qore::absolute_path_windows()
      - @ref Qore::absolute_path_unix()
    - added Util::glob_to_regex()
    - added Util::lpad()
    - added Util::ordinal()
    - added Util::plural()
    - added Util::regex_escape()
    - added Util::rpad()
    - added Util::same()
    - added Util::slice()
    - added Util::tmp_location()
    - fixed Util::get_random_string() on Windows
    - fixed Util::absolute_path_windows()
    - fixed Util::parse_to_qore_value() with hashes with a comma in the first key name; now respects parentheses when parsing lists and hashes (<a href="https://github.com/qorelanguage/qore/issues/846">issue 846</a>)
    - fixed Util::normalize_dir_windows() handling of UNC paths (<a href="https://github.com/qorelanguage/qore/issues/813">issue 813</a>)

    @subsection util_1_1 Util 1.1
    - added the Util::get_byte_size() and Util::get_marketing_byte_size() functions

    @subsection util_1_0 Util 1.0
    - the initial version of the Util module
*/

namespace Init {
    sub init() {
        our hash storage_sizes;
        map storage_sizes.$1 = pow(1024, $# + 1), StorageNames;

        our hash marketing_storage_sizes;
        map marketing_storage_sizes.$1 = pow(1000, $# + 1), StorageNames;
    }
}

#! the Util namespace contains all the objects in the Util module
public namespace Util {
    #! compares complex versions by breaking down strings into component parts
    /** @par Example:
        @code{.py}
int result = compare_version("2.11.1", "2.2");
        @endcode

        Each element is compared separately, so that compare_version("2.11.1", "2.2") returns 1
        (a regular string comparison would give the opposite result)

        @param lv left-hand version
        @param rv right-hand version

        @return -1 if lv < rv, 0 if equal, and 1 if lv > rv
    */
    public int sub compare_version(string lv, string rv) {
        list ll = lv.split(".");
        list rl = rv.split(".");

        int le = ll.size();
        int re = rl.size();

        int i = 0;
        while (True) {
            if (le == i) {
                if (re == i)
                    return 0;
                # see if all remaining elements in rl are 0
                splice rl, 0, i;
                return (select rl, $1) ? -1 : 0;
            }
            if (re == i) {
                # see if all remaining elements in ll are 0
                splice ll, 0, i;
                return (select ll, $1) ? 1 : 0;
            }
            any l = ll[i];
            any r = rl[i];
            if (l =~ /^[0-9]/)
                l = int(l);
            if (r =~ /^[0-9]/)
                r = int(r);

            int rc = l <=> r;
            if (rc)
                return rc;

            ++i;
        }
    }

    #! returns a platform-specific normalized path name (starting from /, eliminates \c ".", \c "..", and \c "//")
    /** @par Example:
        @code{.py}
string dir = normalize_dir(dir);
        @endcode

        Currently only Windows and UNIX-style directories are supported; this function calls either:
        - @ref Util::normalize_dir_unix() or
        - @ref Util::normalize_dir_windows()

        @param dir the directory name to normalize
        @param cwd the current working directory for normalizing relative paths

        @return a normalized path name for the current platform

        @see
        - @ref Util::normalize_dir_unix() or
        - @ref Util::normalize_dir_windows()
     */
    public string sub normalize_dir(string dir, string cwd = getcwd()) {
        return PlatformOS != "Windows" ? normalize_dir_unix(dir, cwd) : normalize_dir_windows(dir, cwd);
    }

    #! returns a normalized UNIX path name (starting from /, eliminates \c ".", \c "..", and \c "//")
    /** @par Example:
        @code{.py}
string dir = normalize_dir_unix(dir, "/var/tmp");
        @endcode

        For example, calling:
        @code{.py} normalize_dir("../../test/.//dir"); @endcode
        from current directory \c "/opt/qorus/sub/dir" returns:
        @code{.py} "/opt/qorus/test/dir" @endcode

        @param dir the directory name to normalize
        @param cwd the current working directory

        @return a normalized path name (starting from /, eliminates \c ".", \c "..", and \c "//")
     */
    public string sub normalize_dir_unix(string dir, string cwd = getcwd()) {
        # if the directory begins with a ".", prefix the cwd to the string
        if (!absolute_path_unix(dir))
            dir = cwd + "/" + dir;

        # substitute "/./" with "/" until all occurrences are gone
        while (True) {
            string old = dir;
            dir =~ s/\/\.\//\//g;
            if (old == dir)
                break;
        }

        dir =~ s/^\.\///;
        dir =~ s/\/\.$//;

        # change // -> /
        dir =~ s/\/\/+/\//g;

        # separate into a list for eliminating occurences of ".."
        list l = dir.split("/");

        for (int i = 1; i < l.size(); ++i) {
            if (l[i] == "..") {
                splice l, i - 1, 2;
                i -= 2;
            }
        }

        dir = l.join("/");
        return dir ? dir : "/";
    }

    #! returns a normalized Windows path name (eliminates \c ".", \c "..", and \c "//")
    /** @par Example:
        @code{.py}
string dir = normalize_dir_windows(dir, "c:\\qore"));
        @endcode

        For example, calling:
        @code{.py} normalize_dir("..\..\test\.\\dir"); @endcode
        from current directory \c "c:\\lang\\qore\\prog1" returns:
        @code{.py} "c:\\lang\\test\\dir" @endcode

        @param dir the directory name to normalize
        @param cwd the current working directory

        @return a normalized path name; eliminates \c ".", \c "..", and \c "\\" (except at the beginning of a UNC path)
     */
    public string sub normalize_dir_windows(string dir, string cwd = getcwd()) {
        # change all occurrences of "/" to "\"
        dir =~ s/\//\\/g;

        # if the directory begins with a ".", prefix the cwd to the string
        if (!absolute_path_windows(dir))
            dir = cwd + "\\" + dir;

        # substitute "\.\" with "\" until all occurrences are gone
        while (True) {
            string old = dir;
            dir =~ s/\\\.\\/\\/g;
            if (old == dir)
                break;
        }

        dir =~ s/^\.\\//;
        dir =~ s/\\\.$//;

        # change \\ -> \ except at the beginning of the string
        dir =~ s/([^^])\\\\+/$1\\/g;

        # separate into a list for eliminating occurences of ".."
        list l = dir.split("\\");

        for (int i = 1; i < l.size(); ++i) {
            if (l[i] == "..") {
                splice l, i - 1, 2;
                i -= 2;
            }
        }

        dir = l.join("\\");
        return dir ? dir : "\\";
    }

    #! returns @ref Qore::True "True" if the argument is an absolute path, @ref Qore::False "False" if not
    /** @par Example:
        @code{.py}
bool abs = absolute_path(path);
        @endcode

        @param path the path to check

        @return @ref Qore::True "True" if the argument is an absolute path, @ref Qore::False "False" if not

        @see @ref Qore::absolute_path()

        @note this function has been moved to the %Qore library and is reexported here for backwards-compatibility
     */
    public bool sub absolute_path(string path) {
        return Qore::absolute_path(path);
    }

    #! returns @ref Qore::True "True" if the argument is a UNIX absolute path, @ref Qore::False "False" if not
    /** @par Example:
        @code{.py}
bool abs = absolute_path_unix(path);
        @endcode

        @param path the path to check

        @return @ref Qore::True "True" if the argument is a UNIX absolute path, @ref Qore::False "False" if not

        @see @ref Qore::absolute_path_unix()

        @note this function has been moved to the %Qore library and is reexported here for backwards-compatibility
     */
    public bool sub absolute_path_unix(string path) {
        return Qore::absolute_path_unix(path);
    }

    #! returns @ref Qore::True "True" if the argument is a Windows absolute path, @ref Qore::False "False" if not
    /** @par Example:
        @code{.py}
bool abs = absolute_path_windows(path);
        @endcode

        @param path the path to check

        @return @ref Qore::True "True" if the argument is a Windows absolute path, @ref Qore::False "False" if not

        @see @ref Qore::absolute_path_windows()

        @note this function has been moved to the %Qore library and is reexported here for backwards-compatibility
     */
    public bool sub absolute_path_windows(string path) {
        return Qore::absolute_path_windows(path);
    }

    # private, non-exported constant hashes for scan_exp() below
    const ParenMap = (")": "(", "}": "{", "]": "[",);
    const FwdParenMap = map {$1.value: $1.key}, ParenMap.pairIterator();

    # private, non-exported constants for parsing
    const ET_RawString = 0;
    const ET_QuotedString = 1;
    const ET_BracketString = 2;
    const ET_Eq = 3;
    const ET_Comma = 4;
    const EtMap = (
        ET_RawString: "raw string",
        ET_QuotedString: "quoted string",
        ET_BracketString: "bracket expression",
        ET_Eq: "=",
        ET_Comma: ",",
        );

    # private scanner for parse_to_qore_value()
    list sub scan_exp(string arg) {
        #printf("DBG se: %y\n", arg);

        list l = ();

        # bracket counter hash
        hash bc;

        # active quote character
        *string quote;

        int len = arg.length();
        string str;

        for (int i = 0; i < len; ++i) {
            string c = arg[i];
            if (c == ",") {
                if (!quote && !bc) {
                    #printf("DBG: got comma i:%d\n", i);
                    trim str;
                    if (str.val()) {
                        l += ("type": ET_RawString, "val": str);
                        str = "";
                    }
                    l += ("type": ET_Comma);
                    continue;
                }
            }
            else if (c == "=") {
                if (!quote && !bc) {
                    trim str;
                    if (str.val()) {
                        l += ("type": ET_RawString, "val": str);
                        str = "";
                    }
                    l += ("type": ET_Eq);
                    continue;
                }
            }
            else if (c == '"' || c == "'") {
                if (quote) {
                    if (c == quote) {
                        delete quote;
                        if (!bc) {
                            l += ("type": ET_QuotedString, "val": str);
                            str = "";
                            continue;
                        }
                    }
                }
                else {
                    quote = c;
                    if (!bc) {
                        trim str;
                        if (str.val()) {
                            l += ("type": ET_RawString, "val": str);
                            str = "";
                        }
                        continue;
                    }
                }
            }
            else if (!quote) {
                *string p = FwdParenMap{c};
                if (p) {
                    bool first;
                    if (!bc) {
                        first = True;
                        trim str;
                        if (str.val()) {
                            l += ("type": ET_RawString, "val": str);
                            str = "";
                        }
                    }
                    ++bc{p};
                    if (first)
                        continue;
                }
                else if (ParenMap{c}) {
                    if (bc{c} && !--bc{c}) {
                        delete bc{c};
                        #printf("DBG: got bracket string: %y\n", str);
                        l += ("type": ET_BracketString, "val": str);
                        delete bc{c};
                        str = "";
                        continue;
                    }
                }
            }
            str += c;
        }

        trim str;
        if (str.val())
            l += ("type": ET_RawString, "val": str);

        return l;
    }

    # private, non-exported function: tries to evaluate the argument as a Qore expression/value
    hash sub eval_text(string arg, bool err = False) {
        # try to evaluate as a Qore expression
        string str = sprintf("any sub get() { return %s; }", arg);
        # use a sandboxed Program object
        Program prog(PO_LOCKDOWN);
        try {
            prog.parse(str, "main");
            any rv = prog.callFunction("get");
            # if it's a float, then return a string to preseve formatting
            if (rv.typeCode() != NT_FLOAT && rv.val())
                return ("valid": True, "value": rv);
        }
        catch (hash ex) {
            if (err)
                throw "EVAL-ERROR", sprintf("error in EVAL cmd: %s: %s (arg: %s)\n", ex.err, ex.desc, arg);
        }

        return ("valid": False);
    }

    # private, non-exported function: tries to evaluate the argument as a Qore expression/value
    /* returns the value parsed
    */
    any sub parse_to_basic_value(*string arg) {
        if (arg.empty())
            return;

        # see if there is aprocessing cmd
        if (*list pc = (arg =~ x/^\%(STR|EVAL)=(.*)$/s)) {
            if (pc[0] == "STR")
                return pc[1];
            else # must be EVAL
                return eval_text(pc[1], True).value;
        }

        # see if it's an int
        {
            int i = int(arg);
            if (i == arg)
                return i;
        }

        {
            float f = float(arg);
            if (f == arg)
                return f;
        }

        {
            number n = number(arg);
            if (n == arg)
                return n;
        }

        if (arg == "True" || arg == "true")
            return True;
        if (arg == "False" || arg == "false")
            return False;

        # see if it's a date/time value
        if (arg =~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}([-T ][0-5][0-9]:[0-5][0-9](:[0-5][0-9](\.[0-9]+)))?/)
            return date(arg);

        return arg;
    }

    #! tries to convert a string (such as an argument given from the command-line) to a Qore value
    /** This function recognizes two special prefixes in the string:
        - \c %STR= this prefix indicates that the rest of the string should be passed literally and not parsed
        - \c %EVAL= this prefix indicates that the rest of the string should be taken as a Qore expression and executed and the value returned

        Strings are interpreted as in the following table.

        <b>String Parsing</b>
        |!Format|!Description
        |<tt><i>key_string</i> = <i>value</i>[, ...]</tt>|a @ref hash "hash"
        |<tt><i>value</i>, [...]|a @ref list "list"
        |integers|an @ref integer "integer"
        |floats|a @ref float "float"
        |arbitrary-numeric value|a @ref number "number"
        |\c True, \c true, \c False, \c false|a @ref boolean "bool"
        |<tt>YYYY-MM-DD[[-T ]HH:mm[:SS[.uu]]]</tt>|a @ref date "date"
        |a %Qore expression|the value evaluated
        |a quoted string|a @ref string "string"

        @par Examples:
        @verbatim
prompt% qore -l ./Util.qm -X 'parse_to_qore_value("(a=(b=(c=x, 2, 3)))")'
hash: (1 member)
  a : hash: (1 member)
    b : list: (3 elements)
      [0]=hash: (1 member)
        c : "x"
      [1]=2
      [2]=3
        @endverbatim

        @param arg a string to convert to a Qore value according to the rules documented above

        @return the Qore value corresponding to the input string

        @throw PARSE-ERROR cannot parse the string given
    */
    public any sub parse_to_qore_value(string arg) {
        # see if there is aprocessing cmd
        if (*list pc = (arg =~ x/^\%(STR|EVAL)=(.*)$/s)) {
            if (pc[0] == "STR")
                return pc[1];
            else # must be EVAL
                return eval_text(pc[1], True).value;
        }

        any v;

        list l = scan_exp(arg);

        #map printf("%d: %y: %y, ", $#, EtMap{$1.type}, $1.val), l; printf("\n");

        bool do_break;

        # process values after an "=" sign
        code do_eq = sub (reference i, string key) {
            # get the value
            any val;
            switch (l[i+2].type) {
                case ET_BracketString: val = parse_to_qore_value(l[i+2].val); break;
                case ET_RawString: val = parse_to_basic_value(l[i+2].val); break;
                case ET_QuotedString: val = l[i+2].val; break;
                case ET_Comma: --i; break;
                case ET_Eq: throw "PARSE-ERROR", sprintf("cannot parse %y after %y", EtMap{ET_Eq}, EtMap{ET_Eq});
            }
            if (!exists v)
                v{key} = val;
            else switch (v.typeCode()) {
                case NT_HASH: {
                    if (do_break)
                        v = (v, (key: val));
                    else
                        v{key} = val;
                    break;
                }
                case NT_LIST: {
                    if (v.last().typeCode() == NT_HASH && !do_break)
                        v[v.size() - 1]{key} = val;
                    else
                        v += (key: val);
                    break;
                }
                default: throw "PARSE-ERROR", sprintf("impossible hash v: %y key: %y val: %y", v, key, val);
            }
            do_break = False;

            i += 2;
            continue;
        };

        # process other values
        code do_val = sub (any val) {
            switch (v.typeCode()) {
                case NT_LIST: {
                    v += val;
                    break;
                }
                case NT_NOTHING: {
                    v = val;
                    break;
                }
                default: {
                    v = (v,val);
                    break;
                }
            }
        };

        code check_val = sub (int i) {
            if (i) {
                int lt = l[i-1].type;
                if (lt != ET_Comma && lt != ET_Eq)
                    throw "PARSE-ERROR", sprintf("cannot parse %y (%y) after %y (%y)", EtMap{l[i].type}, l[i].val, EtMap{lt}, l[i-1].val);
            }
        };

        for (int i = 0; i < l.size(); ++i) {
            hash h = l[i];
            # get preceding type
            *int pt;
            if (i)
                pt = l[i-1].type;
            switch (h.type) {
                case ET_RawString: {
                    check_val(i);
                    # check next symbol, if it's an "=" sign, then use as a hash key
                    if (l[i+1].type == ET_Eq) {
                        do_eq(\i, trim(h.val));
                        continue;
                    }
                    do_val(parse_to_basic_value(h.val));
                    do_break = False;
                    break;
                }
                case ET_BracketString: {
                    check_val(i);
                    do_val(parse_to_qore_value(h.val));
                    do_break = True;
                    break;
                }
                case ET_QuotedString: {
                    check_val(i);
                    # check next symbol, if it's an "=" sign, then use as a hash key
                    if (l[i+1].type == ET_Eq) {
                        do_eq(\i, h.val);
                        continue;
                    }

                    do_val(h.val);
                    do_break = False;
                    break;
                }
                case ET_Comma: {
                    break;
                }
                case ET_Eq: {
                    if (i)
                        throw "PARSE-ERROR", sprintf("cannot parse %y after %y (%y)", EtMap{h.type}, EtMap{l[i-1].type}, h.val);
                    else
                        throw "PARSE-ERROR", sprintf("cannot parse %y at the beginning of the expression", EtMap{h.type});
                }
            }
        }

        return v;
    }

    #! function that returns a random string
    /** @par Example:
        @code{.py}
string pass = get_random_string();
        @endcode

        @param len the length fo the string returned
        @param level a value from 1 - 4 inclusive giving the range of printable ASCII characters included in the output (values out of the range result in the nearest value in the range being used):
        - 1: only upper case
        - 2: +lower case
        - 3: +numbers
        - 4: +symbols but not including any quote characters

        @return a random string of the given length containing only printable ASCII characters according to the \a level argument
    */
    public string sub get_random_string(softint len = 15, int level = 3) {
        string str;
        if (level < 1)
            level = 1;
        else if (level > 4)
            level = 4;
        --level;
        level = (26, 52, 62, 88)[level];  # 15(77), 7(84), 4
        # do not seed the random number generator and use rand() as this requires PO_PROCESS_CONTROL permissions
        if (PlatformOS == "Windows") {
            # on windows, just use clock_getmicros() to generate a pseudo-random number
            int start = (clock_getmicros() * 7621 + 1);
            for (int i = 0; i < len; ++i) {
                int v = start;
                if (i)
                    v += rand();
                v = v.abs() % level;
                str += (v < 26 ? chr(v + ord("A")) :
                         (v < 52 ? chr(v - 26 + ord("a")) :
                          (v < 62 ? chr(v - 4) :
                           (v < 77 ? chr(v - 29) :
                            (v < 84 ? chr(v - 19) :
                             chr(v + 39))))));
            }
        }
        else {
            ReadOnlyFile f("/dev/urandom");
            for (int i = 0; i < len; ++i) {
                int v = f.readi2().abs() % level;
                str += (v < 26 ? chr(v + ord("A")) :
                         (v < 52 ? chr(v - 26 + ord("a")) :
                          (v < 62 ? chr(v - 4) :
                           (v < 77 ? chr(v - 29) :
                            (v < 84 ? chr(v - 19) :
                             chr(v + 39))))));
            }
        }
        return str;
    }

    #! returns a multi-line string from the exception hash argument suitable for logging or output on the console
    /** @param ex the exception hash to process

        @return a multi-line string from the exception hash argument suitable for logging or output on the console
     */
    public string sub get_exception_string(hash ex) {
        string str;

        while (True) {
            str += sprintf("%s exception: %s: %s: %s%s\ncall stack:",
                            ex.type, get_ex_pos(ex), ex.err, ex.desc,
                            ex.arg ? sprintf(" (arg: %y)", ex.arg) : "");

            if (ex.callstack) {
                foreach hash l in (ex.callstack) {
                    if (l.type == "new-thread")
                        str += sprintf("\n  *** thread started by background operator ***");
                    else if (l.type == "rethrow")
                        str += sprintf("\n  *** RETHROW at %s", get_ex_pos(l));
                    else
                        str += sprintf("\n  %s() called at %s (%s function)", l.function, get_ex_pos(l), l.type);
                }
            }

            if (!ex.next)
                break;
            ex = ex.next;
            str += "\nchained exception:\n";
        }
        return str;
    }

    #! storage names (Geop, which would normally follow Bronto, is excluded as the abbreviation would be GB/GiB)
    public const StorageNames = ("Kilo", "Mega", "Giga", "Tera", "Peta", "Exa", "Zetta", "Yotta", "Bronto");

    #! returns a string giving a user-friendly real storage size (ie based on 1KiB = 1024 bytes) in KiB, MiB, GiB, TiB, etc for the given byte size
    /** @par Example:
        @code{.py}
string str = get_byte_size(n);
        @endcode

        @param n the number to display
        @param decimals the number of digits after the decimal point
    */
    public string sub get_byte_size(softnumber n, int decimals = 2) {
        string k;

        HashPairIterator i(storage_sizes);
        while (i.next()) {
            if (n >= i.getValue().value)
                k = i.getValue().key;
            else
                break;
        }

        string fmt = sprintf("%%.%df ", decimals);

        if (!k)
            return sprintf(fmt + "byte" + (n == 1 ? "" : "s"), n);

        n /= storage_sizes{k};
        string v = sprintf(fmt, n);
        v =~ s/(\.)?0*$//;

        return v + k[0] + "iB";
    }

    #! returns a string giving a user-friendly "marketing storage" size (ie based on 1KB = 1000 bytes) in KB, MB, GB, TB, etc for the given byte size
    /** @par Example:
        @code{.py}
string str = get_marketing_byte_size(n);
        @endcode

        @param n the number to display
        @param decimals the number of digits after the decimal point
    */
    public string sub get_marketing_byte_size(softnumber n, int decimals = 2) {
        string k;

        HashPairIterator i(marketing_storage_sizes);
        while (i.next()) {
            if (n >= i.getValue().value)
                k = i.getValue().key;
            else
                break;
        }

        string fmt = sprintf("%%.%df ", decimals);

        if (!k)
            return sprintf(fmt + "byte" + (n == 1 ? "" : "s"), n);

        n /= marketing_storage_sizes{k};
        string v = sprintf(fmt, n);
        # remove trailing zeros
        v =~ s/(\.)?0*$//;

        return v + k[0] + "B";
    }

    #! checks whether given list has only uniq element
    /** @par Example:
        @code{.py}
        if (same((1, 1, 1)) {
            printf("only uniq element");
        };
        @endcode

        @param l some list

        @since Util 1.2
    */
    public bool sub same(list l) {
        if (l.size() < 2) {
            return True;
        }
        any random_value = l[0];
        for (int i = 1; i < l.size(); ++i) {
            if (l[i] != random_value) {
                return False;
            }
        }
        return True;
    }

    #! list slice implementation
    /** @par Example:
        @code{.py}
        list_slice(("a", "b", "c", "d"), (1, 3)); # returns ("b", "d")
        @endcode

        @param l some list
        @param indices indices that should be sliced from the original list

        @since Util 1.2
    */
    public list sub slice(list l, softlist indices) {
        return map l[$1], indices, ($1 >= 0 && $1 < l.size());
    }

    #! Returns a path for temporary files
    /** @par Example:
        @code{.py}
string testfile = tmp_location() + '/test.txt';
# some processing
unlink(testfile);
        @endcode

        Environment variables are searched in the following order (the first with a value is used):
        - \c TMPDIR
        - \c TMP
        - \c TEMP
        - \c TEMPDIR

        If none of these are present, then \c "/tmp" (UNIX) or \c "c:\temp" (Windows) is checked.

        @throw TMP-ERROR unable to find the location of the temporary directory; temporary directory is not writable

        @since Util 1.2
    */
    public string sub tmp_location() {
        # TODO: add support for other platforms
        *string dir = ENV.TMPDIR ?* ENV.TMP ?* ENV.TEMP ?* ENV.TEMPDIR;
        if (!dir)
            dir = PlatformOS == "Windows" ? "c:\\temp" : "/tmp";

        if (!is_writable(dir))
            throw "TMP-ERROR", sprintf("unable to find the location of the temporary directory; %y is not writable", dir);

        return realpath(dir);
    }

    #! Returns a string left-padded to a specified length with the specified characters.
    /** Returns a string, left-padded to a specified length with the specified characters; or, when the string to be padded is longer than the length specified after padding, only that portion of the string that fits into the specified length.

        @param  text input string that you want to pad
        @param  length total length of output string (in characters)
        @param  padding padding character(s); default value is a single blank
        @return a string left-padded to the specified length

        @par Example:
        @code{.py}
string s = lpad ("123", 5); # returns "  123"
string s = lpad ("ABC", 9, "-"); # returns "------ABC"
        @endcode

        @since Util 1.2
    */
    public string sub lpad (softstring text, int length, string padding = ' ') {
        int d = length - text.length();
        if (d > 0) {
            string p = strmul (padding, d / padding.length() + 1);
            return p.substr(0, d) + text;
        }
        else if (d < 0)
            return text.substr(-d);
        else
            return text;
    }

    #! Returns a string right-padded to a specified length with the specified characters.
    /** Returns a string, right-padded to a specified length with the specified characters; or, when the string to be padded is longer than the length specified after padding, only that portion of the string that fits into the specified length.

        @param  text input string that you want to pad
        @param  length total length of output string (in characters)
        @param  padding padding character(s); default value is a single blank
        @return a string right-padded to the specified length

        @par Example:
        @code{.py}
string s = rpad ("123", 5); # returns "123  "
string s = rpad ("ABC", 9, "-"); # returns "ABC------"
        @endcode

        @since Util 1.2
    */
    public string sub rpad (softstring text, int length, string padding = ' ') {
        int d = length - text.length();
        if (d > 0) {
            string p = strmul (padding, d / padding.length() + 1);
            return text + p.substr(0, d);
        }
        else if (d < 0)
            return text.substr(0, d);
        else
            return text;
    }

    #! Returns string with partially textual representation of ordinal integer value
    /** @par Example:
        @code{.py}
printf ("%s grade", ordinal(1));
# would print "1st grade"
        @endcode

        @param i integer value to convert to textual representation
        @return a string representation of ordinal value of the argument

        @since Util 1.2
    */
    public string sub ordinal (int i) {
        list suffixes = ("th", "st", "nd", "rd", "th", "th", "th", "th", "th", "th");

        switch (i % 100) {
            case 11:
            case 12:
            case 13:
                return sprintf("%dth", i);
            default:
                return sprintf("%d%s", i, suffixes[i % 10]);
        }
    }

    #! Returns string with number and proper singular/plural form of noun.
    /**
        @param  count integer value to convert
        @param  base base word or possibly nothing
        @param  singular singular form suffix or whole word
        @param  plural plural form suffix or whole word
        @return a string representation of number plus noun

        @par Example:
        @code{.py}
printf (plural(1, "beer"));
# would print "1 beer"
printf (plural(1, "lad", "y", "ies"));
# would print "1 lady"
printf (plural(32, "", "tooth", "teeth"));
# would print "32 teeth"
        @endcode

        @since Util 1.2
    */
    public string sub plural (int count, string base, string singular = "", string plural = "s") {
        return sprintf("%d %s", count, count == 1 ? base + singular : base + plural);
    }

    #! Escapes (backslashes) all non-alphanumeric characters in a string.
    /** Returns string with all non-alphanumerics backslashed; this is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it.

        @param  text string to escape / backslash
        @return a string escaped / backslashed

        @par Example:
        @code{.py}
string s = regex_escape ("Gain: $100"); # returns "Gain\\:\\ \\$100"
        @endcode

        @since Util 1.2
    */
    public string sub regex_escape (string text) {
        text =~ s/([^[:alnum:]])/\\$1/g;
        return text;
    }

    #! Translates a shell pattern to a regular expression.
    /** Returns the shell-style pattern converted to a regular expression.

        @param  pat the pattern to convert
        @return a converted pattern

        @par Example:
        @code{.py}
string s = glob_to_regex ("*.*"); # returns ".*\\..*"
        @endcode

        @since Util 1.2
    */
    public string sub glob_to_regex (string pat) {
        string r = '';
        int n = pat.length();
        int i = 0;
        while (i<n) {
            string c = pat[i];
            i++;
            if (c == '?')
                r += '.';
            else if (c == '*')
                r += '.*';
            else if (c == '[') {
                int j = i;
                if (j < n && pat[j] == '!')
                    j++;
                if (j < n && pat[j] == ']')
                    j++;
                while (j < n && pat[j] != ']')
                    j++;
                if (j >= n)
                    r += '\[';
                else {
                    string s = replace (pat.substr(i, j-i), '\', '\\');
                    i = j + 1;
                    if (s[0] == '!')
                        s = '^' + s.substr(1);
                    else if (s[0] == '^')
                        s = '\' + s;
                    r += '[' + s + ']';
                }
            }
            else
                r += regex_escape(c);
        }
        return '\A' + r + '\Z';
    }
}
