# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WebSocketClient.qm WebSocket client implementation

/*  WebSocketClient.qm Copyright 2013 - 2023 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 2.0

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

# do not require "$" signs for vars, assume local variable scope
%new-style

%requires WebSocketUtil >= 1.0
%requires Util >= 1.0
%requires(reexport) ConnectionProvider >= 1.4
%requires(reexport) DataProvider

%try-module yaml >= 0.5
%define NoYaml
%endtry

%try-module json >= 1.5
%define NoJson
%endtry

module WebSocketClient {
    version = "2.3";
    desc = "user module for providing client support for the WebSocket protocol";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
    init = sub () {
        # register connections
        ConnectionSchemeCache::registerScheme("ws", WebSocketConnectionObject::ConnectionScheme);
        ConnectionSchemeCache::registerScheme("wss", WebSocketConnectionObject::ConnectionScheme);

        # register the data provider factory
        DataProvider::registerFactory(new WebSocketClientDataProviderFactory());

        # register the data provider application
        DataProviderActionCatalog::registerApp(<DataProviderAppInfo>{
            "name": WebSocketClient::AppName,
            "desc": "Generic WebSocket server",
            "scheme": "ws",
            "logo": WebSocketsLogo,
            "logo_file_name": "generic-websockets-logo.svg",
            "logo_mime_type": MimeTypeSvg,
        });

        # register all supported actions
        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": WebSocketClient::AppName,
            "path": "/",
            "action": "websocket-get-msg",
            "short_desc": "Receive a WebSocket message",
            "desc": "Receive a WebSocket message from a WebSocket server",
            "action_code": DPAT_EVENT,
            "action_val": EVENT_WS_DATA,
        });

        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": WebSocketClient::AppName,
            "path": "/",
            "action": "websocket-send-msg-data",
            "short_desc": "Send a WebSocket data message",
            "desc": "Send a WebSocket data message to a WebSocket server; the message is serialized for sending",
            "action_code": DPAT_SEND_MESSAGE,
            "action_val": MESSAGE_WS_DATA,
        });

        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": WebSocketClient::AppName,
            "path": "/",
            "action": "websocket-send-msg-raw",
            "short_desc": "Send a raw WebSocket message",
            "desc": "Send a raw WebSocket message to a WebSocket server",
            "action_code": DPAT_SEND_MESSAGE,
            "action_val": MESSAGE_WS_RAW,
        });
    };
}

/** @mainpage WebSocketClient Module

    @tableofcontents

    @section websocketclientintro Introduction to the WebSocketClient Module

    The %WebSocketClient module provides client support for
    <a href="http://tools.ietf.org/html/rfc6455">RFC-6455 based WebSocket protocol</a> implementations in %Qore.

    To use this module, use \c "%requires WebSocketClient" in your code.

    This module automatically uses the <a href="../../WebSocketUtil/html/index.html">WebSocketUtil</a> module for
    encoding and decoding web socket messages.

    All the public symbols in the module are defined in the WebSocketClient namespace.

    Currently the module provides the following classes:
    - @ref WebSocketClient::WebSocketClient "WebSocketClient": the web socket client class
    - @ref WebSocketClient::WebSocketConnectionObject "WebSocketConnectionObject": the web socket connection class
      (based on the @ref connectionproviderintro "ConnectionProvider" module)

    <b>Example</b>
    @code{.py}
#!/usr/bin/env qore

%new-style
%enable-all-warnings

%requires WebSocketClient

*string url = shift ARGV;
if (!url) {
    stderr.printf("usage: %s <URL>\n", get_script_name());
    exit(1);
}

code callback = sub (*data d) {
    if (d.typeCode() == NT_BINARY) {
        printf("binary msg received: %y\n", d);
    } else if (d) {
        printf("%s\n", d);
    }
};
WebSocketClient ws(callback, {"url": url});
ws.connect();
# wait forever (or until ctrl-c)
Counter c(1);
c.waitForZero();
    @endcode

    @section websocketclient_relnotes WebSocketClient Module Release History

    @subsection wsc_v2_3 v2.3
    - added support for the data provider action catalog API
      (<a href="https://github.com/qorelanguage/qore/issues/4808">issue 4808</a>)

    @subsection wsc_v2_2 v2.2
    - fixed creating example WebSocket client data providers from factories with templated option values
      (<a href="https://github.com/qorelanguage/qore/issues/4716">issue 4716</a>)
    - added a "wait for message" API data provider to the WebSocket client data providers
      (<a href="https://github.com/qorelanguage/qore/issues/4716">issue 4716</a>)

    @subsection wsc_v2_1_1 v2.1.1
    - the data provider factory uses the delayed observable class instead
      (<a href="https://github.com/qorelanguage/qore/issues/4701">issue 4701</a>)

    @subsection wsc_v2_1 v2.1
    - fixed a deadlock deleting the client object when it goes out of scope in the event thread
      (<a href="https://github.com/qorelanguage/qore/issues/4697">issue 4697</a>)
    - added the \c headers option to allow auth headers to be set in WebSocket client connections and data providers
      (<a href="https://github.com/qorelanguage/qore/issues/4694">issue 4694</a>)

    @subsection wsc_v2_0 v2.0
    - added support for events and messages from the DataProvider API
      (<a href="https://github.com/qorelanguage/qore/issues/4557">issue 4557</a>)

    @subsection wsc_v1_9_1 v1.9.1
    - added support for continuation frames
      (<a href="https://github.com/qorelanguage/qore/issues/4073">issue 4073</a>)

    @subsection wsc_v1_9 v1.9
    - implemented support for a data provider scheme cache and rich option information for connections
      (<a href="https://github.com/qorelanguage/qore/issues/4025">issue 4025</a>)

    @subsection wsc_v1_8 v1.8
    - removed the \c WebSocketConnectionObject::getConstructorInfo() and
      \c WebSocketConnectionObject::getConstructorInfoImpl() methods
      (<a href="https://github.com/qorelanguage/qore/issues/3696">issue 3696</a>)
    - added support for socket events
      (<a href="https://github.com/qorelanguage/qore/issues/3425">issue 3425</a>)

    @subsection wsc_v1_7 v1.7
    - all connection clases have unified constructor
    - added the \c WebSocketConnectionObject::getConstructorInfo()
      method to allow connections to be created dynamically, potentially in another process from a network
      call (removed in WebSocketClient 1.8)
      (<a href="https://github.com/qorelanguage/qore/issues/2628">issue 2628</a>)
    - add WebSocketClient handling of WSCC_GoingAway event

    @subsection wsc_v1_6_3 v1.6.3
    - added missing exception handling in the connection close callback
      (<a href="https://github.com/qorelanguage/qore/issues/3225">issue 3225</a>)

    @subsection wsc_v1_6_2 v1.6.2
    - allowed the handling of \c PING messages to be customized
      (<a href="https://github.com/qorelanguage/qore/issues/2887">issue 2887</a>)

    @subsection wsc_v1_6_1 v1.6.1
    - added @ref WebSocketClient::WebSocketClient::pong() "WebSocketClient::pong()" to allow an unsolicited \c PONG
      message to be sent as a unidirectional keep-alive message from the client to the server
      (<a href="https://github.com/qorelanguage/qore/issues/2566">issue 2566</a>)

    @subsection wsc_v1_6 v1.6
    - added the @ref WebSocketClient::WebSocketConnectionObject "WebSocketConnectionObject" class to support the
      <a href="../../ConnectionProvider/html/index.html">ConnectionProvider</a> module
    - updated for complex types
    - fixed a bug where the event loop thread would immediately terminate after a reconnection
      (<a href="https://github.com/qorelanguage/qore/issues/2061">issue 2061</a>)
    - improved client logging
    - fixed a bug where the @ref WebSocketClient::WebSocketClient class did not validate the \c Sec-WebSocket-Accept
      response header according to RFC6455
      (<a href="https://github.com/qorelanguage/qore/issues/2062">issue 2062</a>)
    - added support for the \c yield option in the constructor

    @subsection wsc_v1_5 v1.5
    - added timeout values to @ref Qore::Socket "Socket" and @ref Qore::HTTPClient "HTTPClient" calls
      (<a href="https://github.com/qorelanguage/qore/issues/1725">issue 1725</a>)

    @subsection wsc_v1_4 v1.4
    - fixed a bug parsing and generating the websocket close status code
      (<a href="https://github.com/qorelanguage/qore/issues/1216">issue 1216</a>)

    @subsection wsc_v1_3 v1.3
    - ignore \c SOCKET-NOT-OPEN errors when closing (server already closed the connection)

    @subsection wsc_v1_2 v1.2
    - prepend \c "WebSocketClient: " to log messages

    @subsection wsc_v1_1 v1.1
    - added socket instrumention support from Qore 0.8.9

    @subsection wsc_v1_0 v1.0
    - the initial version of the WebSocketClient module
*/

#! the WebSocketClient namespace contains all the definitions in the WebSocketClient module
public namespace WebSocketClient {
#! known websocket schemes
public const WsSchemes = {
    "ws": {
        "ssl": False,
    },
    "wss": {
        "ssl": True,
    },
};

/** @defgroup WSClientRawCallbackReturnCodes WebSocketClient Raw Callback Return Codes
*/
#! Application name
public const AppName = "WebSockets";

#/@{
#! If the client should process the message normally
public const WSC_Process = 0;

#! If the client should continue listening (message already processed)
public const WSC_Continue = 1;

#! If the client should stop listening (message already processed)
public const WSC_Break = 2;
#/@}

#! default port for connections
public const WsDefaultPort = 80;

#! WebSocket data event constant
public const EVENT_WS_DATA = "ws-data-event";

#! WebSocket ping event constant
public const EVENT_WS_PING = "ws-ping-event";

#! WebSocket pong event constant
public const EVENT_WS_PONG = "ws-pong-event";

#! WebSocket connection closed event constant
public const EVENT_WS_CLOSED = "ws-closed-event";

#! WebSocket data message type
/** Sends a WebSocket message to the remote end; the message will be serialized according to the serialization option
    on the WebSocketClient object
*/
public const MESSAGE_WS_DATA = "data";

#! WebSocket raw data message type
/** Sends a raw message to the remote end; the message is sent as-is
*/
public const MESSAGE_WS_RAW = "raw";

#! WebSocket ping message type
/** Sends a \c PING message to the server, a PONG event should be generated
*/
public const MESSAGE_WS_PING = "ping";

#! WebSocket pong message type
/** Sends a \c PONG message to the server; should be sent when a \c PING event is received
*/
public const MESSAGE_WS_PONG = "pong";

#! the main websocket client class
/** To use this class, create a @ref WebSocketClient::WebSocketClient "WebSocketClient" object and the call
    @ref WebSocketClient::WebSocketClient::connect() "WebSocketClient::connect()".

    The @ref WebSocketClient::WebSocketClient::connect() "WebSocketClient::connect()" method starts a background
    thread to receive messages, which are then posted to the callback provided in the
    @ref WebSocketClient::WebSocketClient::constructor() "WebSocketClient::constructor()".

    To stop listening for web socket events, call
    @ref WebSocketClient::WebSocketClient::disconnect() "WebSocketClient::disconnect()".

    The @ref WebSocketClient::WebSocketClient "WebSocketClient" class includes support for running in sandboxed
    Program objects with the following parse options set:
    - \c PO_NO_PROCESS_CONTROL: in this case the \c "yield" option is required in
      @ref WebSocketClient::WebSocketClient::constructor() "WebSocketClient::constructor()"
*/
public class WebSocketClient {
    private {
        Mutex m();
        HTTPClient hc;
        int stop = 0;
        Counter c();
        code callback;
        code raw_callback;
        code pong_callback;
        *code log;
        *code errlog;
        *code debuglog;
        timeout timeout_ms = DefaultTimeout;
        #! TID of the event thread
        int tid;
        #! unique websocket connection ID; -1 when not connected
        int cid = -1;
        #! callable object to yield the current thread's execution
        *code yield;
        #! URL string
        string url;

        static Sequence seq();
    }

    public {
        #! default socket I/O operation timeout: 15 seconds
        const DefaultTimeout = 15s;

        #! module version
        const Version = "1.6";

        #! default user agent string for HTTP requests
        const DefaultUserAgent = sprintf("Qore-WebSocketClient/%s", WebSocketClient::Version);
    }

    #! creates the object and optionally sets logging targets
    /** @par Example:
        @code{.py}
sub event(*data msg) {
    if (!msg) {
        printf("connection closed\n");
    } else {
        printf("%s msg: %y\n", now_us().format("YYYY-MM-DD HH:mm:SS.xx"), msg);
    }
}
int sub raw_callback(hash<WsMsgInfo> event) {
    printf("raw event: %y\n", event);
    return WSC_Process;
}
WebSocketClient ws(\event(), {
    "url": "ws://example.com:8080/path",
    "raw_callback": \raw_callback(),
});
        @endcode

        @param cb the callback @ref closure "closure" or @ref call_reference "call reference" for received messages
        @param opts an option hash for the @ref Qore::HTTPClient::constructor(hash<auto>) "HTTPClient constructor"
        plus the following keys:
        - \c log: an optional @ref closure "closure" or @ref call_reference "call reference" for informational
            logging
        - \c errlog: an optional @ref closure "closure" or @ref call_reference "call reference" for error logging
        - \c debuglog: an optional @ref closure "closure" or @ref call_reference "call reference" for logging
            debugging/technical messages about the web socket connection
        - \c raw_callback: an optional @ref closure "closure" or @ref call_reference "call reference" for
          receiving raw WebSocket messages before processing; takes a single <tt>hash&lt;WsMsgInfo&gt;</tt>
          argument and must return one of the following values: @ref WSClientRawCallbackReturnCodes
        - \c yield: an options @ref closure "closure" or @ref call_reference "call reference" for yielding the
            current thread's execution to another thread (default value: @ref Qore::Threads::thread_yield());
            required if @ref Qore::PO_NO_PROCESS_CONTROL is set in the current execution context

        @throw WEBSOCKET-ERROR unknown scheme, missing 'url' key in option hash; invalid option value

        @since
        - WebSocketClient 1.6 added the \c yield option
        - WebSocketClient 1.9.1 added the \c raw_callback option
    */
    constructor(code cb, hash<auto> opts) {
        # += to keep "http_opts" "hash<auto>"
        hash<auto> http_opts += opts;
        if (http_opts.url.typeCode() != NT_STRING)
            throw "WEBSOCKET-ERROR", sprintf("option hash to WebSocketClient::constructor() missing 'url' key "
                "giving the connection target");
        url = http_opts.url;

        if (http_opts.hasKey("yield")) {
            if (!http_opts.yield.callp())
                throw "WEBSOCKET-ERROR", sprintf("option hash to WebSocketClient::constructor() has an invalid "
                    "'yield' key with type %y; must be a callable value", opts.yield.type());
            yield = http_opts.yield;
        }
%ifdef PO_NO_PROCESS_CONTROL
        else
            throw "WEBSOCKET-ERROR", sprintf("option hash to WebSocketClient::constructor() missing 'yield' key "
                "giving the thread yield closure/call reference which is required when PO_NO_PROCESS_CONTROL is "
                "in effect");
%endif

        if (http_opts.hasKey("raw_callback")) {
            if (!http_opts.raw_callback.callp()) {
                throw "WEBSOCKET-ERROR", sprintf("option hash to WebSocketClient::constructor() has an invalid "
                    "'raw_callback' key with type %y; must be a callable value", opts.raw_callback.type());
            }
            raw_callback = http_opts.raw_callback;
        }

        if (http_opts.hasKey("pong_callback")) {
            if (!http_opts.pong_callback.callp()) {
                throw "WEBSOCKET-ERROR", sprintf("option hash to WebSocketClient::constructor() has an invalid "
                    "'pong_callback' key with type %y; must be a callable value", opts.pong_callback.type());
            }
            pong_callback = http_opts.pong_callback;
        }

        hash<UrlInfo> uh = parse_url(http_opts.url);
        if (uh.protocol) {
            hash<auto> sh = getSchemes();
            *hash<auto> ph = sh{uh.protocol};
            if (!ph)
                throw "WEBSOCKET-ERROR", sprintf("schema %y is unknown in %y; known schemes: %y", uh.protocol,
                    http_opts.url, sh.keys());
            # replace websocket scheme with an http scheme
            splice http_opts.url, 0, uh.protocol.size(), "http" + (ph.ssl ? "s" : "");
        }

        # ensure that the timeout value is set correctly and consistently
        if (http_opts."timeout") {
            timeout_ms = http_opts."timeout";
        } else {
            http_opts."timeout" = timeout_ms;
        }

        hc = new HTTPClient(http_opts);
        log = http_opts.log;
        errlog = http_opts.errlog;
        debuglog = http_opts.debuglog;

        callback = cb;
    }

    #! disconnects the connection and stops the event thread if connected
    destructor() {
        disconnect();
    }

    #! returns the URL given in the constructor
    string getUrl() {
        return url;
    }

    #! Returns a "safe" URL, without any password info
    string getSafeUrl() {
        return hc.getSafeURL();
    }

    #! returns the unique connection ID
    int getConnectionId() {
        return cid;
    }

    #! returns a hash of URL scheme information for URL schemes supported by this object
    hash<auto> getSchemes() {
        return WsSchemes;
    }

    #! connects to the websocket server
    /** @par Example:
        @code{.py}
sub event(*data msg) {
    if (!msg) {
        printf("connection closed\n");
    } else {
        printf("%s msg: %y\n", now_us().format("YYYY-MM-DD HH:mm:SS.xx"), msg);
    }
}
int sub raw_callback(hash<WsMsgInfo> event) {
    printf("raw event: %y\n", event);
    return WSC_Process;
}
WebSocketClient ws(\event(), {
    "url": "ws://example.com:8080/path",
    "raw_callback": \raw_callback(),
});
ws.connect();
        @endcode

        This method starts a background thread to receive messages, which are then posted to the callback
        @ref closure "closure" or @ref call_reference "call reference" given as an argument.  If the server
        disconnects the web socket connection, the callback will be called with no argument (ie @ref nothing).
        In this case the event thread also terminates and the WebSocketClient object will be in a disconnected state.

        To stop listening for web socket events, call
        @ref WebSocketClient::WebSocketClient::disconnect() "WebSocketClient::disconnect()".

        If this method is called while a connection is already in progress, then the existing connection is first
        implicitly disconnected with close code @ref WebSocketUtil::WSCC_GoingAway "WSCC_GoingAway".

        @param opts a hash with the following keys:
        - \c hdr: (optional) a @ref hash_type "hash" giving header values for the connection request to the web socket
          server
        @param info a @ref reference_type "reference" to a hash which will be set to information about the call setup

        @return a hash with information about the HTTP response from the webn socket server corresponding to the
        return value of @ref Qore::Socket::readHTTPHeader()

        @throw WEBSOCKET-ERROR the option hash is missing either the 'url' or 'callback' keys or type error in the
        option hash
    */
    hash<auto> connect(*hash<auto> opts, *reference<hash<auto>> info) {
        if (opts.hdr) {
            if (opts.hdr.typeCode() != NT_HASH) {
                throw "WEBSOCKET-ERROR", sprintf("option hash to WebSocketClient::connect() 'hdr' key not assigned to a "
                    "hash; type received: %y", opts.hdr.type());
            }
        }

        m.lock();
        on_exit m.unlock();

        if (hc.isOpen()) {
            disconnectUnlocked();
        }

        hash<auto> h = connectUnlocked(opts.hdr, \info);
        c.inc();
        on_error {
            remove tid;
            c.dec();
        }
        tid = background eventLoop(callback);
        return h;
    }

    #! returns @ref True "True" if the connection is currently open and active, @ref False "False" if not
    bool isOpen() {
        m.lock();
        on_exit m.unlock();

        return hc.isOpen();
    }

    #! disconnect with the given @ref closecodes "close code"
    disconnect(int cmd = WSCC_GoingAway) {
        m.lock();
        on_exit m.unlock();

        if (hc.isOpen()) {
            disconnectUnlocked(cmd);
        }
    }

    #! Removes any warning @ref Qore::Thread::Queue "Queue" object from the Socket
    /** @par Example:
        @code{.py}
ws.clearWarningQueue();
        @endcode

        @see WebSocketClient::setWarningQueue()

        @since %WebSocketClient 1.1
    */
    nothing clearWarningQueue() {
        hc.clearWarningQueue();
    }

    #! Sets a @ref Qore::Thread::Queue "Queue" object to receive socket warnings
    /** @par Example:
        @code{.py}
ws.setWarningQueue(5000, 5000, queue, "socket-1");
        @endcode

        @param warning_ms the threshold in milliseconds for individual socket actions (send, receive, connect), if exceeded, a socket warning is placed on the warning queue with the following keys:
        - \c "type": a string with the constant value \c "SOCKET-OPERATION-WARNING"
        - \c "operation": a string giving the operation that caused the warning (ex: \c "connect")
        - \c "us": an integer giving the number of microseconds for the operation
        - \c "timeout": an integer giving the warning threshold in microseconds
        - \c "arg": if any \c "arg" argument is passed to the @ref setWarningQueue() "WebSocketClient::setWarningQueue()" method, it will be included in the warning hash here
        @param warning_bs value in bytes per second; if any call has performance below this threshold, a socket warning is placed on the warning queue with the following keys:
        - \c "type": a string with the constant value \c "SOCKET-THROUGHPUT-WARNING"
        - \c "dir": either \c "send" or \c "recv" depending on the direction of the data flow
        - \c "bytes": the amount of bytes sent
        - \c "us": an integer giving the number of microseconds for the operation
        - \c "bytes_sec": a float giving the transfer speed in bytes per second
        - \c "threshold": an integer giving the warning threshold in bytes per second
        - \c "arg": if any \c "arg" argument is passed to the @ref setWarningQueue() "WebSocketClient::setWarningQueue()" method, it will be included in the warning hash here
        @param queue the @ref Qore::Thread::Queue "Queue" object to receive warning events
        @param arg an optional argument to be placed in the \c "arg" key in each warning hash (could be used to identify the socket for example)
        @param min_ms the minimum transfer time with a resolution of milliseconds for a transfer to be eligible for triggering a warning; transfers that take less than this period of time are not eligible for raising a warning

        @throw QUEUE-ERROR the Queue passed has a maximum size set
        @throw SOCKET-SETWARNINGQUEUE-ERROR at least one of \a warning_ms and \a warning_bs must be > 0

        @see WebSocketClient::clearWarningQueue()

        @since %WebSocketClient 1.1
    */
    nothing setWarningQueue(int warning_ms, int warning_bs, Queue queue, auto arg, timeout min_ms = 1s) {
        hc.setWarningQueue(warning_ms, warning_bs, queue, arg, min_ms);
    }

    #! Returns performance statistics for the socket
    /** @par Example:
        @code{.py}
hash<auto> h = ws.getUsageInfo();
        @endcode

        @return a hash with the following keys:
        - \c "bytes_sent": an integer giving the total amount of bytes sent
        - \c "bytes_recv": an integer giving the total amount of bytes received
        - \c "us_sent": an integer giving the total number of microseconds spent sending data
        - \c "us_recv": an integer giving the total number of microseconds spent receiving data
        - \c "arg": (only if warning values have been set with @ref setWarningQueue() "WebSocketClient::setWarningQueue()") the optional argument for warning hashes
        - \c "timeout": (only if warning values have been set with @ref setWarningQueue() "WebSocketClient::setWarningQueue()") the warning timeout in microseconds
        - \c "min_throughput": (only if warning values have been set with @ref setWarningQueue() "WebSocketClient::setWarningQueue()") the minimum warning throughput in bytes/sec

        @since %WebSocketClient 1.1

        @see WebSocketClient::clearStats()
    */
    hash<auto> getUsageInfo() {
        return hc.getUsageInfo();
    }

    #! Clears performance statistics
    /** @par Example:
        @code{.py}
ws.clearStats();
        @endcode

        @since %WebSocketClient 1.1

        @see WebSocketClient::getUsageInfo()
    */
    clearStats() {
        hc.clearStats();
    }

    #! Sets a @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"
    /** @par Example:
        @code{.py}
ws.setEventQueue(queue);
        @endcode

        @param queue the @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"; note that
        the Queue passed cannot have any maximum size set or a QUEUE-ERROR will be thrown
        @param arg an argument that will be included in each event hash in the \a arg key
        @param with_data if @ref True, then the actual raw data transferred / received is also included in the events

        @throw QUEUE-ERROR the Queue passed has a maximum size set

        @see @ref event_handling for more information

        @since %WebSocketClient 1.8
    */
    setEventQueue(Qore::Thread::Queue queue, auto arg, *bool with_data) {
        hc.setEventQueue(queue, arg, with_data);
    }

    #! Removes any @ref Qore::Thread::Queue "Queue" object so that @ref socket_events "socket events" are no longer added to the @ref Qore::Thread::Queue "Queue"
    /** @par Example:
        @code{.py}
ws.setEventQueue();
        @endcode

        @see @ref event_handling for more information

        @since %WebSocketClient 1.8
    */
    setEventQueue() {
        hc.setEventQueue();
    }

    private disconnectUnlocked(int cmd = WSCC_GoingAway) {
        # disconnect only if possible; in case this method is called from the destructor from the event thread, we
        # cannot wait for the event thread to terminate, as there would be a deadlock
        if (tid != gettid()) {
            stop = cmd;
            c.waitForZero();
            cid = -1;
            remove tid;
        }
    }

    private eventLoop(code callback) {
        on_exit {
            # issue #4697: went out of scope in event loop
            if (self) {
                c.dec();
            }
        }

        # data buffer for fragmented frames
        data buf;
        while (True) {
            # issue #4697: went out of scope in event loop
            if (!self) {
                break;
            }
            if (stop) {
                sendClose(stop);
                logDebug("event loop stopping on user request");
                break;
            }

            try {
                if (!hc.isDataAvailable(50ms)) {
%ifdef PO_NO_PROCESS_CONTROL
                    call_function(yield);
%else
                    yield ? call_function(yield) : Qore::thread_yield();
%endif
                    continue;
                }
                hash<WsMsgInfo> h = ws_read_message(hc, timeout_ms);
                if (raw_callback) {
                    int state = raw_callback(h);
                    if (state == WSC_Continue) {
                        continue;
                    }
                    if (state == WSC_Break) {
                        break;
                    }
                }
                if (h.op == WSOP_Close) {
                    if (!h.close) {
                        logDebug("server sent OpClose without code; closing immediately");
                        break;
                    }
                    logDebug("client sent WSOP_Close code %d (%s): %s", h.close, WSCCMap.(h.close), h.msg);
                    sendClose(h.close, h.msg);
                    break;
                }

                if (h.op == WSCC_GoingAway) {
                    logDebug("server sent WSOP_GoingAway; closing immediately");
                    break;
                }

                logDebug("received msg (%s: %d bytes): %s", WSOPMap.(h.op) ?? sprintf("unknown opcode %y", h.op),
                    h.msg.size(), h.msg ? sprintf("type: %s: %y", h.msg.type(), h.msg) : "n/a");

                if (h.masked) {
                    logError("unmasked client frame received");
                    sendClose(WSCC_ProtocolError);
                    break;
                }

                if (h.op == WSOP_Ping) {
                    handlePing(h);
                    continue;
                }

                # issue #4073: handle fragmented frames
                if (!h.fin) {
                    if (!exists buf) {
                        if (h.op == WSOP_Text || h.op == WSOP_Binary) {
                            buf = h.msg;
                        } else {
                            logError("FIN bit not set but opcode is %d: %y", h.op, WSOPMap{h.op} ?? "unknown");
                            sendClose(WSCC_ProtocolError);
                            break;
                        }
                    } else {
                        if (h.op != WSOP_Continuation) {
                            logError("FIN bit not set with buffer of type %y but opcode is %d: %y", buf.type(), h.op,
                                WSOPMap{h.op} ?? "unknown");
                            sendClose(WSCC_ProtocolError);
                            break;
                        } else {
                            if (buf.typeCode() == NT_STRING) {
                                buf += h.msg.toString();
                            } else {
                                buf += h.msg;
                            }
                        }
                    }
                    continue;
                } else if (exists buf && h.op == WSOP_Continuation) {
                    if (buf.typeCode() == NT_STRING) {
                        buf += h.msg.toString();
                    } else {
                        buf += h.msg;
                    }
                    callback(remove buf);
                    continue;
                } else if (h.op == WSOP_Text || h.op == WSOP_Binary) {
                    callback(h.msg);
                    continue;
                } else if (h.op == WSOP_Pong) {
                    receivedPong(h.msg);
                    continue;
                } else if (h.op == WSOP_Continuation) {
                    logError("FIN bit set with %d: %y opcode, but no data has been buffered", h.op,
                        WSOPMap{h.op} ?? "unknown");
                    sendClose(WSCC_ProtocolError);
                    break;
                }

                # unrecognized opcode - close the connection
                sendClose(WSCC_UnsupportedData);
                break;
            } catch (hash<ExceptionInfo> ex) {
                string err = sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                logError(err);
                sendClose(WSCC_InternalServerError, err);
                break;
            }
        }

        # call the callback with NOTHING to signal that the connection has been closed
        try {
            # issue #3225 catch and log any exeptions in the closing callback
            callback();
        } catch (hash<ExceptionInfo> ex) {
            logError("exception in closing WebSocketClient callback: %s", get_exception_string(ex));
        }
        if (hc.isOpen()) {
            hc.shutdown();
            hc.close();
        }
        logDebug("disconnected websocket connection");
    }

    private receivedPong(*data msg) {
        if (pong_callback) {
            pong_callback(msg);
        }
    }

    private handlePing(hash<auto> h) {
        hc.send2(ws_encode_message(h.msg ?? "heartbeat", WSOP_Pong, True), timeout_ms);
    }

    private logInfo(string fmt, ...) {
        if (log)
            call_function(log, sprintf("WebSocketClient %s INFO: ", cid) + vsprintf(fmt, argv));
    }

    private logError(string fmt, ...) {
        if (errlog)
            call_function(errlog, sprintf("WebSocketClient %s ERROR: ", cid) + vsprintf(fmt, argv));
    }

    private logDebug(string fmt, ...) {
        if (debuglog)
            call_function(debuglog, sprintf("WebSocketClient %s DEBUG:", cid) + vsprintf(fmt, argv));
    }

    private sendClose(int code, *string txtmsg) {
        if (!WSCCMap{code}) {
            logError("WebSocketClient::sendClose(): invalid close code %d received; expecting one of: %y", code,
                (map $1.toInt(), WSCCMap.keyIterator()));
            code = WSCC_InternalServerError;
        }

        binary msg = code.encodeMsb(2);

        if (txtmsg) {
            if (txtmsg.encoding() != "UTF-8")
                txtmsg = convert_encoding(txtmsg, "UTF-8");
        } else
            txtmsg = WSCCMap{code};
        msg += txtmsg;
        try {
            hc.send2(ws_encode_message(msg, WSOP_Close, True), timeout_ms);
        } catch (hash<ExceptionInfo> ex) {
            # ignore SOCKET-NOT-OPEN errors when closing (server already closed the connection)
            if (ex.err == "SOCKET-NOT-OPEN")
                return;
            rethrow;
        }
    }

    private hash<auto> connectUnlocked(*hash<auto> hdr0, *reference<hash<auto>> info) {
        # in case hdr0 is hash<string, int> or similar
        hash<auto> hdr = {
            "User-Agent": DefaultUserAgent,
        } + hdr0;

        string key = get_random_string(16).toBase64();
        hdr += {
            "Upgrade": "websocket",
            "Connection": "Upgrade",
            # https://tools.ietf.org/html/rfc6455#section-4.1 specifies a 16-byte length for this random nonce
            "Sec-WebSocket-Key": key,
        };

        hash<auto> rh = hc.send(NOTHING, "GET", NOTHING, hdr, NOTHING, \info);

        if (rh.status_code != 101) {
            throw "WEBSOCKET-ERROR", sprintf("HTTP server at URL %y returned status code '%d %s' to our request; "
                "expecting '101 Switching Protocols'",
                hc.getURL(), rh.status_code, rh.status_message);
        }

        if (!rh."sec-websocket-accept") {
            throw "WEBSOCKET-ERROR", sprintf("HTTP server at URL %y did not return the Sec-WebSocket-Accept response "
                "header (headers returned: %y)", hc.getURL(), rh);
        }

        {
            string expected_key = ws_get_response_key(key);
            if (rh."sec-websocket-accept" != expected_key) {
                throw "WEBSOCKET-ERROR", sprintf("HTTP server at URL %y returned an invalid value in the "
                    "Sec-WebSocket-Accept response header: %y; expecting %y", hc.getURL(), rh."sec-websocket-accept",
                    expected_key);
            }
        }

        logDebug("connected websocket connection: %y", hc.isOpen());
        stop = 0;
        cid = seq.next();

        return rh;
    }

    #! Sends a \c PING message to the server as a unidirectional keep-alive message
    /** @since WebSocketClient 2.0
    */
    ping(*data msg) {
        logDebug("sending PING %y (open: %y connected: %y)", msg, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(msg ?? "", WSOP_Ping, True), timeout_ms);
    }

    #! Sends a \c PONG message to the server as a unidirectional keep-alive message
    /** @since WebSocketClient 1.6.1
    */
    pong(*data msg) {
        logDebug("sending PONG %y (open: %y connected: %y)", msg, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(msg ?? "", WSOP_Pong, True), timeout_ms);
    }

    #! Sends string data over the web socket with timeout specified in options; if any errors occur, an exception is thrown
    /**
        @param str Sends the string data over the socket

        @see Socket::send()
    */
    send(string str) {
        logDebug("sending string: %y (open: %y connected: %y)", str, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(str, WSOP_Text, True), timeout_ms);
    }

    #! Sends binary data over the web socket with timeout specified in options; if any errors occur, an exception is thrown
    /**
        @param bin Sends the binary data over the socket

        @see Socket::send()
    */
    send(binary bin) {
        logDebug("sending binary: %y (open: %y connected: %y)", bin, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(bin, WSOP_Binary, True), timeout_ms);
    }

    #! pushes an unencoded message on the connection's message queue; the message will be encoded with @ref WebSocketUtil::ws_encode_message() before sending
    send(data msg, int op, bool fin) {
        logDebug("sending message: %y op: %d/%y fin: %y (%y %y)", fin, op, WSOPMap{op} ?? "unknown", fin, hc.isOpen(),
            hc.isConnected());
        hc.send2(ws_encode_message(msg, op, True, fin), timeout_ms);
    }
}

#! class for websocket connections; returns an object of class @ref WebSocketClient for receiving websocket events from a websocket server
/** supports the following options:
    - \c "connect_timeout": connection timeout to use in milliseconds
    - \c "http_version": HTTP version to use (\c "1.0" or \c "1.1", defaults to \c "1.1")
    - \c "max_redirects": maximum redirects to support
    - \c "proxy": proxy URL to use
    - \c "timeout": transfer timeout to use in milliseconds

    also supports the following runtime options in getImpl():
    - \c "callback": (required) a callback to receive websocket events
    - \c "dbglog": a closure taking a single string for detailed technical connection logging
    - \c "errlog": a closure accepting a single string for error logging
    - \c "log": a closure accepting a single string for logging
    - \c "yield": a closure to yield current thread execution
*/
public class WebSocketConnectionObject inherits ConnectionProvider::AbstractConnectionWithInfo {
    public {
        #! Connection entry info
        const ConnectionScheme = <ConnectionSchemeInfo>{
            "cls": Class::forName("WebSocketConnectionObject"),
            "options": HttpConnection::ConnectionScheme.options,
        };
    }

    #! creates the WebSocketConnectionObject connection object
    /** @param name the name of the connection
        @param description connection description
        @param url connection URL (potentially with password info)
        @param attributes various attributes. See below
        @param options connection options

        See @ref AbstractConnection::constructor() for \c attributes and \c options reference.

        @throw CONNECTION-OPTION-ERROR missing or invalid connection option
    */
    constructor(string name, string description, string url, hash<auto> attributes = {}, hash<auto> options = {})
            : AbstractConnectionWithInfo(name, description, url, attributes, options) {
    }

    #! returns \c "ws"
    string getType() {
        return "ws";
    }

    #! returns runtime options
    /** @return a hash with the following keys reflecting support for the corresponding runtime options in getImpl():
        - \c "callback": (required) a callback to receive websocket events
        - \c "dbglog": a closure taking a single string for detailed technical connection logging
        - \c "errlog": a closure accepting a single string for error logging
        - \c "log": a closure accepting a single string for logging
        - \c "yield": a closure to yield current thread execution
    */
    *hash<auto> getRuntimeOptions() {
        return {
            "callback": True,
            "log": True,
            "errlog": True,
            "dbglog": True,
            "yield": True,
        };
    }

    private hash<PingInfo> pingIntern(hash<PingInfo> rv) {
        date start = now_us();
        object o = get();
        on_exit o.disconnect();
        return rv += {
            "ok": True,
            "time": now_us() - start,
            "info": "OK",
        };
    }

    #! returns a @ref WebSocketClient object
    /** @param connect if @ref True "True", then @ref WebSocketClient::connect() is called
        @param rtopts supports the following runtime options in getImpl():
        - \c "callback": (required) a callback to receive websocket events
        - \c "dbglog": a closure taking a single string for detailed technical connection logging
        - \c "errlog": a closure accepting a single string for error logging
        - \c "log": a closure accepting a single string for logging
        - \c "yield": a closure to yield current thread execution

        @return a @ref WebSocketClient object
    */
    private WebSocketClient getImpl(bool connect = True, *hash<auto> rtopts) {
        # to avoid type issues with rtopts
        if (exists rtopts) {
            rtopts = {} + rtopts;
        }
        if (!rtopts.callback) {
            rtopts.callback = sub (*data msg) {};
        }
        # rename "dbglog" to "debuglog" for WebSocketClient object
        if (rtopts.dbglog) {
            rtopts.debuglog = remove rtopts.dbglog;
        }
        WebSocketClient ws(rtopts.callback, {"url": url} + rtopts.("log", "errlog", "debuglog") + opts);
        if (connect)
            ws.connect();
        return ws;
    }

    #! returns an WebSocketClientDataProvider object for this connection
    /** @return an WebSocketClientDataProvider object for this connection

        @see hasDataProvider()
    */
    DataProvider::AbstractDataProvider getDataProvider() {
        return new WebSocketClientDataProvider({"url": url});
    }

    #! returns @ref True, as the connection returns a data provider with the @ref getDataProvider() method
    /** @return @ref True, as the connection returns a data provider with the @ref getDataProvider() method

        @see @ref getDataProvider()
    */
    bool hasDataProvider() {
        return True;
    }

    #! Sets child data provider capabilities
    private setChildCapabilities() {
        children_can_support_observers = True;
        children_can_support_messages = True;
    }

    #! Returns the ConnectionSchemeInfo hash for this object
    private hash<ConnectionSchemeInfo> getConnectionSchemeInfoImpl() {
        return ConnectionScheme;
    }
}

#! Event- and message-based data provider for WebSocket client-side events
/**
*/
public class WebSocketClientDataProviderBase inherits DataProvider::AbstractDataProvider {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "supports_children": True,
            "supports_observable": True,
            "supports_messages": MSG_Async,
            "children_can_support_apis": True,
            "constructor_options": ConstructorOptions,
            "desc": "Allows sending and receiving WebSocket messages to and from a WebSocket server",
        };

        #! Constructor options
        const ConstructorOptions = {
            "connect_timeout": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."int",
                "desc": "connection timeout to use in milliseconds",
            },
            "data": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."string",
                "desc": "data serialization to use:\n"
%ifndef NoJson
                    " - `json`: JSON serialization (default)\n"
%endif
%ifndef NoYaml
                    " - `yaml`: YAML serialization\n"
%endif
                    " - `none`: no serialization; raw messages\n",
                "default_value":
%ifndef NoJson
                    "json"
%else
                    "none"
%endif
                    ,
            },
            "headers": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."hash",
                "desc": "headers to add in each outgoing request",
            },
            "http_version": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."string",
                "desc": "HTTP version to use (`1.0` or `1.1`, defaults to `1.1`)",
                "default_value": "1.1",
            },
            "max_redirects": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."int",
                "desc": "maximum redirects to support",
            },
            "proxy": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."string",
                "desc": "proxy URL to use",
            },
            "report_pings": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."bool",
                "desc": "Raise events for ping message from clients",
                "default_value": False,
            },
            "timeout": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."int",
                "desc": "transfer timeout to use in milliseconds",
            },
            "url": <DataProviderOptionInfo>{
                "type": AbstractDataProviderTypeMap."string",
                "desc": "A URL for a WebSocket connection",
                "required": True,
            },
        };

        #! Registered API classes
        const ApiClasses = {
            "wait-for-message": Class::forName("WebSocketClientWaitForMessageDataProvider"),
        };

        #! Set of serialization options as a hash
        const SerializationMap = (
%ifndef NoJson
            "json": True,
%endif
%ifndef NoYaml
            "yaml": True,
%endif
            "none": True,
        );
    }

    private {
        #! The web socket client itself
        WebSocketClient client;

        #! Data serialization
        string serialization;

        #! report pings
        bool report_pings;

        #! Mutex for wait for message child data provider handling
        Mutex m();

        #! Wait for message API data provider
        WebSocketClientWaitForMessageDataProvider child;

        #! Child message queue
        Queue q;
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) {
        hash<auto> copts = checkOptions("CONSTRUCTOR-ERROR", ConstructorOptions, options);

        serialization = remove copts."data" ??
%ifndef NoJson
            "json"
%else
            "none"
%endif
            ;

        report_pings = remove copts.report_pings;

        if (!SerializationMap{serialization}) {
            throw "CONSTRUCTOR-ERROR", sprintf("invalid data serialization %y; known serialization values: %y",
                serialization, keys SerializationMap);
        }

        copts += {
            "log": sub (string msg) {
                if (logger) {
                    logger.info("%s", msg);
                }
            },
            "errlog": sub (string msg) {
                if (logger) {
                    logger.error("%s", msg);
                }
            },
            "dbglog": sub (string msg) {
                if (logger) {
                    logger.debug("%s", msg);
                }
            },
            "pong_callback": \pong(),
        };
        client = new WebSocketClient(\event(), copts);
    }

    destructor() {
        delete client;
    }

    string getName() {
        return "wsclient";
    }

    #! Regstiger a child data provider
    register(WebSocketClientWaitForMessageDataProvider child) {
        AutoLock al(m);
        if (self.child) {
            throw "WEBSOCKET-ERROR", "A child data provider to wait for a message on this connection already exists; "
                "only one child data provider to wait on messages can exist at a time for a single connection";
        }
        self.child = child;
        q = new Queue();
    }

    #! Dergister a child data provider
    deregister() {
        AutoLock al(m);
        remove child;
        delete q;
    }

    #! Returs the child message queue
    Queue getQueue() {
        return q;
    }

    #! Returns a list of child data provider names
    /** @return a list of child data provider names
    */
    private *list<string> getChildProviderNamesImpl() {
        return keys ApiClasses;
    }

    #! Returns the given child provider or @ref nothing if the given child is unknown
    /** @return the given child provider or @ref nothing if the given child is unknown

        @throw CHILD-PROVIDER-ERROR error acquiring child provider

        @see getChildProviderEx()
    */
    private *AbstractDataProvider getChildProviderImpl(string name) {
        *Class cls = ApiClasses{name};
        if (cls) {
            return cls.newObject(self);
        }
    }

    #! Connects and starts receiving messages
    private start() {
        hash<auto> info;
        client.connect(NOTHING, \info);
    }

    #! Returns a hash of all supported event types
    /** @return a hash of all supported event types

        @note only called if the provider supports the observer pattern / event API
    */
    private hash<string, hash<DataProviderMessageInfo>> getEventTypesImpl() {
        return {
            EVENT_WS_DATA: <DataProviderMessageInfo>{
                "desc": "A data event; data will be deserialized according to the serialization option",
                "type": new WebSocketClientEventDataType(),
            },
            EVENT_WS_PING: <DataProviderMessageInfo>{
                "desc": "A `PING` event; after this a `PONG` message should be sent",
                "type": new WebSocketClientEventDataType(),
            },
            EVENT_WS_PONG: <DataProviderMessageInfo>{
                "desc": "A `PONG` event; sent in reply to a `PING` message",
                "type": new WebSocketClientEventDataType(),
            },
            EVENT_WS_CLOSED: <DataProviderMessageInfo>{
                "desc": "The event signaling that the channel was closed",
                "type": new HashDataType(),
            },
        };
    }

    #! Returns the description of an outbound message, if any
    /** @return the message type for this provider

        @note only called if the provider supports sending messages
    */
    private hash<string, hash<DataProviderMessageInfo>> getMessageTypesImpl() {
        return {
            MESSAGE_WS_DATA: <DataProviderMessageInfo>{
                "desc": "An outgoing WebSocket message that will be serialized according to the serialization option",
                "type": serialization == "none"
                    ? AbstractDataProviderTypeMap."data"
                    : AbstractDataProviderTypeMap."any",
            },
            MESSAGE_WS_PING: <DataProviderMessageInfo>{
                "desc": "A WebSocket `PING` message; should result in a `PONG` event being raised by the remote end",
                "type": AbstractDataProviderTypeMap."*data",
            },
            MESSAGE_WS_PONG: <DataProviderMessageInfo>{
                "desc": "A WebSocket `PONG` message; sent in reply to a `PING` message",
                "type": AbstractDataProviderTypeMap."*data",
            },
            MESSAGE_WS_RAW: <DataProviderMessageInfo>{
                "desc": "A raw WebSocket message to be sent to the remote end (without serialization)",
                "type": AbstractDataProviderTypeMap."data",
            },
        };
    }

    #! Sends a message from message-capable data providers
    /**
        @param msg the message to send
        @param send_message_options the options for sending the message
    */
    private sendMessageImpl(string message_id, auto msg, *hash<auto> send_message_options) {
        try {
            switch (message_id) {
                case MESSAGE_WS_DATA:
                    client.send(serializeMessage(msg));
                    break;

                case MESSAGE_WS_RAW:
                    client.send(msg);
                    break;

                case MESSAGE_WS_PING:
                    client.ping(msg);
                    break;

                case MESSAGE_WS_PONG:
                    client.pong(msg);
                    break;

                default:
                    throw "UNSUPPORTED-MESSAGE", sprintf("message_id %y is unsupported; supported messages: %y",
                        keys getMessageTypesImpl());
            }
        } catch (hash<ExceptionInfo> ex) {
            if (logger) {
                logger.error("error sending WebSocket message: %s", get_exception_string(ex));
            }
        }
    }

    #! Called when a WebSocket event arrives
    private event(*data msg) {
        try {
            if (exists msg) {
                auto msgdata = deserializeMessage(msg);
                if (q) {
                    q.push(msgdata);
                    #logger.debug("pushed event: %y q: %y", msg, q);
                } else {
                    notifyObservers(EVENT_WS_DATA, {"data": msgdata});
                }
            } else {
                notifyObservers(EVENT_WS_CLOSED, {});
            }
        } catch (hash<ExceptionInfo> ex) {
            if (logger) {
                logger.error("error handling WebSocket %s message: %s", exists msg ? "event" : "close",
                    get_exception_string(ex));
            }
        }
    }

    #! Got a pong message
    private pong(*data msg) {
        notifyObservers(EVENT_WS_PONG, {"data": msg});
    }

    #! Deserializes the message
    auto deserializeMessage(data msg) {
        switch (serialization) {
            case "none":
                return msg;

            case "json":
                if (msg.typeCode() != NT_STRING) {
                    throw "WEBSOCKETCLIENT-JSON-ERROR", sprintf("cannot deserialize JSON in WebSocket event from %y "
                        "value", msg.fullType());
                }
%ifndef NoJson
                on_error rethrow $1.err, sprintf("%s (JSON: %y)", $1.desc, msg);
                return parse_json(msg);
%else
                unsupportedSerialization();
%endif

            case "yaml":
                if (msg.typeCode() != NT_STRING) {
                    throw "WEBSOCKETCLIENT-YAML-ERROR", sprintf("cannot deserialize YAML in WebSocket event from %y "
                        "value", msg.fullType());
                }
%ifndef NoYaml
                on_error rethrow $1.err, sprintf("%s (YAML: %y)", $1.desc, msg);
                return parse_yaml(msg);
%else
                unsupportedSerialization();
%endif

            default:
                unsupportedSerialization();
        }
    }

    #! Serializes the message for sending
    data serializeMessage(auto msg) {
        switch (serialization) {
            case "none":
                if (msg.typeCode() != NT_STRING && msg.typeCode() != NT_BINARY) {
                    throw "WEBSOCKETCLIENT-ERROR", sprintf("cannot send raw message of type %y", msg.fullType());
                }
                return msg;

            case "json":
%ifndef NoJson
                return make_json(msg);
%else
                unsupportedSerialization();
%endif

            case "yaml":
%ifndef NoYaml
                return make_yaml(msg);
%else
                unsupportedSerialization();
%endif

            default:
                unsupportedSerialization();
        }
    }

    #! Returns options from a template
    static hash<auto> getOptionsFromTemplate(hash<auto> template_options, *hash<auto> options) {
        if (exists options && template_options.url) {
            # overwrite the URL with a sample value to ensure that the data provider can be created for configuration
            # information only
            template_options.url = "ws://localhost";
        }
        return template_options + options;
    }

    #! Throws an UNSUPPORTED-SERIALIZATION error
    private unsupportedSerialization() {
        throw "UNSUPPORTED-SERIALIZATION", sprintf("unsupported data serialization value %y; known serialization "
            "values: %y", serialization, keys SerializationMap);
    }

    #! For WS event notifications
    abstract notifyObservers(string msg_id, hash<auto> event);
}

#! Event-based data provider for WebSocket messaging
/**
    The event ID raised for WebSocket data events is \c "ws-data-event" (see @ref EVENT_WS_DATA), and, when the
    connection is closed, a \c "ws-closed-event" (see @ref EVENT_WS_CLOSED) is raised.
*/
public class WebSocketClientDataProvider inherits WebSocketClientDataProviderBase, DataProvider::Observable {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "WebSocketClientDataProvider",
        } + WebSocketClientDataProviderBase::ProviderInfo;
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) : WebSocketClientDataProviderBase(options) {
        start();
    }

    #! Creates the object from constructor + template options
    constructor(hash<auto> template_options, *hash<auto> options)
            : WebSocketClientDataProviderBase(
                WebSocketClientDataProviderBase::getOptionsFromTemplate(template_options, options)
            ) {
        start();
    }

    private hash<DataProviderInfo> getStaticInfoImpl() {
        hash<DataProviderInfo> rv = ProviderInfo;
        string safe_url = client.getSafeUrl();
        safe_url =~ s/^http/ws/;
        rv.desc = sprintf("WebSocket client to URL %y", safe_url);
        return rv;
    }
}

#! Event-based data provider for WebSocket messaging
/**
    The event ID raised for WebSocket data events is \c "ws-data-event" (see @ref EVENT_WS_DATA), and, when the
    connection is closed, a \c "ws-closed-event" (see @ref EVENT_WS_CLOSED) is raised.
*/
public class WebSocketClientDelayedDataProvider inherits WebSocketClientDataProviderBase,
        DataProvider::DelayedObservable {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "WebSocketClientDelayedDataProvider",
        } + WebSocketClientDataProviderBase::ProviderInfo;
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) : WebSocketClientDataProviderBase(options) {
    }

    #! Creates the object from constructor + template options
    constructor(hash<auto> template_options, *hash<auto> options)
            : WebSocketClientDataProviderBase(
                WebSocketClientDataProviderBase::getOptionsFromTemplate(template_options, options)
            ) {
    }

    #! Called when all observers have been added to the object
    /** This method is meant to trigger event generation
    */
    observersReady() {
        start();
    }

    private hash<DataProviderInfo> getStaticInfoImpl() {
        hash<DataProviderInfo> rv = ProviderInfo;
        string safe_url = client.getSafeUrl();
        safe_url =~ s/^http/ws/;
        rv.desc = sprintf("WebSocket client to URL %y", safe_url);
        return rv;
    }
}

#! WebSocket event data description
public class WebSocketClientEventDataType inherits HashDataType {
    #! Creates the type
    constructor() {
        # add members for base hashdecl
        addField(new QoreDataField("data", "The message data", AbstractDataProviderType::anyType));
    }
}

#! WebSocket client wait for message from server API data provider
public class WebSocketClientWaitForMessageDataProvider inherits AbstractDataProvider {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "WebSocketClientWaitForMessageDataProvider",
            "supports_request": True,
            "desc": "Waits for a WebSocket message to be received from the server within a timeout period and "
                "returns the message if one is received in the timeout perdiod, or an exception is thrown",
        };

        #! Request type
        const RequestType = new WebSocketClientWaitForMessageRequestDataType();

        #! Response type
        const ResponseType = AbstractDataProviderTypeMap."any";
    }

    private {
        WebSocketClientDataProviderBase base;
    }

    #! Creates the object
    constructor(WebSocketClientDataProviderBase base) {
        base.register(self);
        self.base = base;
    }

    #! Deletes the object
    destructor() {
        if (base) {
            base.deregister();
        }
    }

    #! Returns the data provider name
    string getName() {
        return "wait-for-message";
    }

    #! Makes a request and returns the response
    /** @param req the request to serialize and make according to the request type
        @param request_options the request options; will be processed by validateRequestOptions()

        @return the response to the request
    */
    private auto doRequestImpl(auto req, *hash<auto> request_options) {
        Queue q = base.getQueue();
        on_error if ($1.err == "QUEUE-TIMEOUT") {
            rethrow "WEBSOCKET-RECV-TIMEOUT", sprintf("timed out waiting for WebSocket message: %s: %s", $1.err,
                $1.desc);
        }
        return q.get(req."timeout");
    }

    #! Returns the description of a successful request message, if any
    /** @return the request type for this provider
    */
    private *AbstractDataProviderType getRequestTypeImpl() {
        return RequestType;
    }

    #! Returns the description of a response message, if this object represents a response message
    /** @return the response type for this response message
    */
    private *AbstractDataProviderType getResponseTypeImpl() {
        return ResponseType;
    }

    #! Returns data provider static info
    hash<DataProviderInfo> getStaticInfoImpl() {
        return ProviderInfo;
    }
}

#! Data type for delete order calls
public class WebSocketClientWaitForMessageRequestDataType inherits HashDataType {
    public {
        #! Field descriptions
        const Fields = {
            "timeout": {
                "type": IntType,
                "desc": "The number of milliseconds to wait for an incoming message; after this point, if no "
                    "WebSocket message has been received, an exception will be thrown",
                "required": True,
                "default_value": 10000,
            },
        };
    }

    #! Creates the object
    constructor() {
        map addField(new QoreDataField($1.key, $1.value.desc, $1.value.type, $1.value.default_value)),
            Fields.pairIterator();
    }
}

#! The WebSocket data provider factory
public class WebSocketClientDataProviderFactory inherits AbstractDataProviderFactory {
    private {
        #! Data provider type info
        static Class cls = new Class("WebSocketClientDelayedDataProvider");

        #! Factory info
        const FactoryInfo = <DataProviderFactoryInfo>{
            "name": "wsclient",
            "desc": "WebSocket client data provider factory",
            "children_can_support_observers": True,
            "children_can_support_messages": True,
        };
    }

    #! Returns static factory information without \a provider_info
    /** @return static factory information without \a provider_info which is provided by @ref getProviderInfo()
    */
    private hash<DataProviderFactoryInfo> getInfoImpl() {
        return FactoryInfo;
    }

    #! Returns static provider information
    /** @note the \c name and \c children attributes are not returned as they are dynamic attributes
    */
    private hash<DataProviderInfo> getProviderInfoImpl() {
        return WebSocketClientDataProvider::ProviderInfo;
    }

    #! Returns the class for the data provider object
    private Class getClassImpl() {
        return cls;
    }
}
}

namespace Priv {
#! Logo for the WebSockets app
const WebSocketsLogo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>
<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">
<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 567 567\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" xmlns:serif=\"http://www.serif.com/\" style=\"fill-rule:evenodd;clip-rule:evenodd;\">
    <g id=\"Layer-1\" serif:id=\"Layer 1\">
        <g id=\"g5\" transform=\"matrix(1,0,0,1,0,-21)\">
            <path id=\"rect1\" d=\"M445.886,268.502C445.886,234.066 417.929,206.109 383.493,206.109L182.735,206.109C148.299,206.109 120.342,234.066 120.342,268.502L120.342,457.2C120.342,491.635 148.299,519.593 182.735,519.593L383.493,519.593C417.929,519.593 445.886,491.635 445.886,457.2L445.886,268.502Z\" style=\"fill:rgb(0,12,60);stroke:white;stroke-width:2.31px;\"/>
            <rect id=\"rect2\" x=\"186.959\" y=\"280.083\" width=\"33.727\" height=\"80.473\" style=\"fill:white;stroke:white;stroke-width:2.31px;\"/>
            <g id=\"g3\" transform=\"matrix(1.44,0,0,1.44,60.276,91.5143)\">
                <ellipse id=\"path2\" cx=\"156.458\" cy=\"231.332\" rx=\"13.39\" ry=\"15.519\" style=\"fill:white;stroke:white;stroke-width:1.57px;\"/>
                <rect id=\"rect3\" x=\"143.371\" y=\"230.964\" width=\"26.707\" height=\"25.537\" style=\"fill:white;stroke:white;stroke-width:1.64px;\"/>
            </g>
            <g id=\"image1\" transform=\"matrix(1.08,0,0,1.08,340.423,278.93)\">
                <use xlink:href=\"#_Image1\" x=\"0\" y=\"0\" width=\"33px\" height=\"77px\"/>
            </g>
        </g>
        <g transform=\"matrix(1,0,0,1,46.2005,136.933)\">
            <g id=\"text5\">
                <g>
                    <path d=\"M61.2,-4.23C60.66,-1.17 58.8,0.36 55.62,0.36L51.75,0.36C49.11,0.36 47.4,-1.14 46.62,-4.14L37.8,-37.44C37.68,-37.98 37.5,-38.25 37.26,-38.25L37.08,-38.25C36.84,-38.25 36.66,-37.98 36.54,-37.44L27.63,-4.14C26.85,-1.14 25.14,0.36 22.5,0.36L18.72,0.36C15.54,0.36 13.68,-1.17 13.14,-4.23L3.15,-65.34C3.15,-66.36 3.66,-66.87 4.68,-66.87L9.9,-66.87C10.74,-66.87 11.25,-66.36 11.43,-65.34L20.16,-8.01C20.34,-7.11 20.49,-6.66 20.61,-6.66C20.85,-6.66 21.06,-7.11 21.24,-8.01L30.06,-41.31C30.66,-43.71 32.07,-44.91 34.29,-44.91L40.05,-44.91C42.27,-44.91 43.68,-43.71 44.28,-41.31L53.1,-8.01C53.28,-7.11 53.49,-6.66 53.73,-6.66C53.85,-6.66 54,-7.11 54.18,-8.01L62.91,-65.34C63.09,-66.36 63.6,-66.87 64.44,-66.87L69.66,-66.87C70.68,-66.87 71.19,-66.36 71.19,-65.34L61.2,-4.23Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M115.74,-24.21C115.74,-22.89 115.17,-22.23 114.03,-22.23L83.88,-22.23L83.88,-20.97C83.88,-15.75 84.93,-11.97 87.03,-9.63C89.01,-7.41 92.13,-6.3 96.39,-6.3C102.75,-6.3 108.09,-6.63 112.41,-7.29L112.86,-7.29C113.82,-7.29 114.3,-6.87 114.3,-6.03L114.3,-2.97C114.3,-1.83 113.7,-1.14 112.5,-0.9C107.22,0.12 101.85,0.63 96.39,0.63C90.45,0.63 85.74,-0.87 82.26,-3.87C78.06,-7.53 75.96,-13.23 75.96,-20.97L75.96,-29.07C75.96,-35.61 77.67,-40.74 81.09,-44.46C84.63,-48.24 89.58,-50.13 95.94,-50.13C102.36,-50.13 107.31,-48.21 110.79,-44.37C114.09,-40.71 115.74,-35.61 115.74,-29.07L115.74,-24.21ZM107.73,-29.07C107.73,-38.49 103.8,-43.2 95.94,-43.2C87.9,-43.2 83.88,-38.49 83.88,-29.07L83.88,-28.26L107.73,-28.26L107.73,-29.07Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M164.61,-21.6C164.61,-6.78 158.07,0.63 144.99,0.63C139.23,0.63 133.71,0.12 128.43,-0.9C127.17,-1.14 126.54,-1.83 126.54,-2.97L126.54,-65.97C126.54,-67.11 127.08,-67.68 128.16,-67.68L132.75,-67.68C133.89,-67.68 134.46,-67.11 134.46,-65.97L134.46,-49.23C137.7,-49.83 141.21,-50.13 144.99,-50.13C158.07,-50.13 164.61,-42.78 164.61,-28.08L164.61,-21.6ZM156.69,-28.08C156.69,-33.12 155.85,-36.84 154.17,-39.24C152.31,-41.88 149.25,-43.2 144.99,-43.2C140.31,-43.2 136.8,-42.99 134.46,-42.57L134.46,-6.84C138.54,-6.48 142.05,-6.3 144.99,-6.3C149.25,-6.3 152.31,-7.62 154.17,-10.26C155.85,-12.66 156.69,-16.44 156.69,-21.6L156.69,-28.08Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M214.11,-17.37C214.11,-5.37 206.7,0.63 191.88,0.63C187.2,0.63 182.22,0.21 176.94,-0.63C175.8,-0.81 175.23,-1.35 175.23,-2.25L175.23,-5.85C175.23,-6.81 175.74,-7.29 176.76,-7.29L177.03,-7.29C181.17,-6.93 186.12,-6.75 191.88,-6.75C201,-6.75 205.56,-10.29 205.56,-17.37C205.56,-19.59 204.78,-21.54 203.22,-23.22C201.78,-24.78 198.96,-26.85 194.76,-29.43L186.03,-34.74C177.75,-39.78 173.61,-45.39 173.61,-51.57C173.61,-62.19 180.78,-67.5 195.12,-67.5C201,-67.5 206.22,-67.14 210.78,-66.42C211.8,-66.24 212.31,-65.73 212.31,-64.89L212.31,-61.02C212.31,-60.06 211.8,-59.58 210.78,-59.58L210.6,-59.58C205.32,-59.94 200.16,-60.12 195.12,-60.12C190.38,-60.12 187.02,-59.52 185.04,-58.32C182.94,-57.06 181.89,-54.81 181.89,-51.57C181.89,-48.27 185.16,-44.64 191.7,-40.68L199.98,-35.73C209.4,-30.15 214.11,-24.03 214.11,-17.37Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M263.16,-21.33C263.16,-14.55 261.48,-9.24 258.12,-5.4C254.58,-1.38 249.57,0.63 243.09,0.63C236.61,0.63 231.63,-1.38 228.15,-5.4C224.79,-9.24 223.11,-14.55 223.11,-21.33L223.11,-28.17C223.11,-34.95 224.79,-40.26 228.15,-44.1C231.63,-48.12 236.61,-50.13 243.09,-50.13C249.57,-50.13 254.58,-48.12 258.12,-44.1C261.48,-40.26 263.16,-34.95 263.16,-28.17L263.16,-21.33ZM255.24,-28.17C255.24,-38.19 251.19,-43.2 243.09,-43.2C235.05,-43.2 231.03,-38.19 231.03,-28.17L231.03,-21.33C231.03,-11.31 235.05,-6.3 243.09,-6.3C251.19,-6.3 255.24,-11.31 255.24,-21.33L255.24,-28.17Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M304.38,-2.34C304.38,-1.26 303.78,-0.6 302.58,-0.36C298.98,0.3 295.23,0.63 291.33,0.63C285.27,0.63 280.56,-1.35 277.2,-5.31C273.84,-9.21 272.16,-14.52 272.16,-21.24L272.16,-28.26C272.16,-34.98 273.81,-40.29 277.11,-44.19C280.53,-48.15 285.27,-50.13 291.33,-50.13C295.23,-50.13 298.98,-49.8 302.58,-49.14C303.78,-48.9 304.38,-48.24 304.38,-47.16L304.38,-43.92C304.38,-43.02 303.87,-42.57 302.85,-42.57L302.49,-42.57C298.77,-42.99 295.05,-43.2 291.33,-43.2C283.83,-43.2 280.08,-38.22 280.08,-28.26L280.08,-21.24C280.08,-11.28 283.83,-6.3 291.33,-6.3C295.05,-6.3 298.77,-6.51 302.49,-6.93L302.85,-6.93C303.87,-6.93 304.38,-6.48 304.38,-5.58L304.38,-2.34Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M349.83,-1.17C349.83,-0.39 349.5,0 348.84,0L342.36,0C341.58,0 340.89,-0.39 340.29,-1.17L322.38,-23.31L322.38,-1.8C322.38,-0.6 321.78,0 320.58,0L316.26,0C315.06,0 314.46,-0.6 314.46,-1.8L314.46,-65.88C314.46,-67.08 315.06,-67.68 316.26,-67.68L320.58,-67.68C321.78,-67.68 322.38,-67.08 322.38,-65.88L322.38,-28.44L340.38,-48.69C340.86,-49.23 341.46,-49.5 342.18,-49.5L348.48,-49.5C349.38,-49.5 349.83,-49.17 349.83,-48.51C349.83,-48.15 349.68,-47.82 349.38,-47.52L329.58,-26.1L349.56,-1.98C349.74,-1.8 349.83,-1.53 349.83,-1.17Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M394.11,-24.21C394.11,-22.89 393.54,-22.23 392.4,-22.23L362.25,-22.23L362.25,-20.97C362.25,-15.75 363.3,-11.97 365.4,-9.63C367.38,-7.41 370.5,-6.3 374.76,-6.3C381.12,-6.3 386.46,-6.63 390.78,-7.29L391.23,-7.29C392.19,-7.29 392.67,-6.87 392.67,-6.03L392.67,-2.97C392.67,-1.83 392.07,-1.14 390.87,-0.9C385.59,0.12 380.22,0.63 374.76,0.63C368.82,0.63 364.11,-0.87 360.63,-3.87C356.43,-7.53 354.33,-13.23 354.33,-20.97L354.33,-29.07C354.33,-35.61 356.04,-40.74 359.46,-44.46C363,-48.24 367.95,-50.13 374.31,-50.13C380.73,-50.13 385.68,-48.21 389.16,-44.37C392.46,-40.71 394.11,-35.61 394.11,-29.07L394.11,-24.21ZM386.1,-29.07C386.1,-38.49 382.17,-43.2 374.31,-43.2C366.27,-43.2 362.25,-38.49 362.25,-29.07L362.25,-28.26L386.1,-28.26L386.1,-29.07Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M428.49,-1.35C428.49,-0.51 427.95,0 426.87,0.18C424.89,0.48 422.94,0.63 421.02,0.63C416.64,0.63 413.58,-0.15 411.84,-1.71C409.8,-3.45 408.78,-6.69 408.78,-11.43L408.78,-42.84L400.05,-43.83C398.91,-43.95 398.34,-44.49 398.34,-45.45L398.34,-47.88C398.34,-48.96 398.91,-49.5 400.05,-49.5L408.78,-49.5L408.78,-58.32C408.78,-59.34 409.32,-59.94 410.4,-60.12L415.35,-60.84C416.25,-60.84 416.7,-60.33 416.7,-59.31L416.7,-49.5L426.42,-49.5C427.62,-49.5 428.22,-48.9 428.22,-47.7L428.22,-44.64C428.22,-43.44 427.62,-42.84 426.42,-42.84L416.7,-42.84L416.7,-11.43C416.7,-9.03 417.06,-7.47 417.78,-6.75C418.38,-6.09 419.64,-5.76 421.56,-5.76L426.6,-5.76C427.86,-5.76 428.49,-5.34 428.49,-4.5L428.49,-1.35Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M468.18,-12.42C468.18,-3.72 462.57,0.63 451.35,0.63C445.53,0.63 440.79,0.18 437.13,-0.72C435.87,-1.02 435.24,-1.62 435.24,-2.52L435.24,-5.67C435.24,-6.57 435.78,-7.02 436.86,-7.02L437.22,-7.02C442.5,-6.36 447.21,-6.03 451.35,-6.03C457.29,-6.03 460.26,-8.16 460.26,-12.42C460.26,-14.7 458.01,-17.19 453.51,-19.89L444.42,-25.29C438.3,-29.01 435.24,-33.3 435.24,-38.16C435.24,-46.14 440.67,-50.13 451.53,-50.13C456.33,-50.13 461.01,-49.74 465.57,-48.96C466.71,-48.78 467.28,-48.18 467.28,-47.16L467.28,-44.19C467.28,-43.17 466.77,-42.66 465.75,-42.66L465.48,-42.66C459.9,-43.14 455.25,-43.38 451.53,-43.38C448.65,-43.38 446.64,-43.08 445.5,-42.48C443.94,-41.7 443.16,-40.26 443.16,-38.16C443.16,-36.06 445.23,-33.78 449.37,-31.32L458.28,-26.01C464.88,-22.11 468.18,-17.58 468.18,-12.42Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                </g>
            </g>
        </g>
    </g>
    <defs>
        <image id=\"_Image1\" width=\"33px\" height=\"77px\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAABNCAYAAAAo0g1OAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAWUlEQVRoge3OMRHAMAwAMbf8ObvTXyEkg4RAz+7uHPaeDsxI/CQiEYlIRCISkYhEJCIRiUhEIhKRiEQkIhGJSEQiEpGIRCQiEYlIRCISkYhEJCIRiUjkisQHlFkElhVBWMoAAAAASUVORK5CYII=\"/>
    </defs>
</svg>";
}