# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WebSocketClient.qm WebSocket client implementation

/*  WebSocketClient.qm Copyright 2013 - 2024 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 2.0

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

# do not require "$" signs for vars, assume local variable scope
%new-style

%requires(reexport) WebSocketUtil >= 1.0
%requires Util >= 1.0
%requires(reexport) ConnectionProvider >= 1.4
%requires(reexport) DataProvider
%requires(reexport) Logger

%try-module yaml >= 0.7.3
%define NoYaml
%endtry

%try-module json >= 1.5
%define NoJson
%endtry

module WebSocketClient {
    version = "2.3";
    desc = "user module for providing client support for the WebSocket protocol";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
    init = sub () {
        # register connections
        ConnectionSchemeCache::registerScheme("ws", WebSocketConnectionObject::ConnectionScheme);
        ConnectionSchemeCache::registerScheme("wss", WebSocketConnectionObject::ConnectionScheme);

        # register the data provider factory
        DataProvider::registerFactory(new WebSocketClientDataProviderFactory());

        # register the data provider application
        DataProviderActionCatalog::registerApp(<DataProviderAppInfo>{
            "name": WebSocketClient::AppName,
            "display_name": "WebSocket Messaging",
            "short_desc": "Send and receive WebSocket messages",
            "desc": "Send and receive WebSocket messages",
            "scheme": "wss",
            "logo": WebSocketsLogoLight,
            "logo_file_name": "generic-websockets-logo.svg",
            "logo_mime_type": MimeTypeSvg,
        });

        # register all supported actions
        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": WebSocketClient::AppName,
            "path": "/",
            "action": "msg-received",
            "display_name": "WebSocket Message Received",
            "short_desc": "A WebSocket message is received",
            "desc": "Receive a WebSocket message from a WebSocket server; react to a WebSocket message",
            "action_code": DPAT_EVENT,
            "action_val": EVENT_WS_DATA,
        });

        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": WebSocketClient::AppName,
            "path": "/",
            "action": "send-msg-data",
            "display_name": "Send WebSocket Message",
            "short_desc": "Send a WebSocket data message",
            "desc": "Send a WebSocket data message to a WebSocket server; the message is serialized for sending",
            "action_code": DPAT_SEND_MESSAGE,
            "action_val": MESSAGE_WS_DATA,
        });

        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": WebSocketClient::AppName,
            "path": "/",
            "action": "send-msg-raw",
            "display_name": "Send Raw WebSocket Message",
            "short_desc": "Send a raw WebSocket message",
            "desc": "Send a raw WebSocket message to a WebSocket server",
            "action_code": DPAT_SEND_MESSAGE,
            "action_val": MESSAGE_WS_RAW,
        });
    };
}

/** @mainpage WebSocketClient Module

    @tableofcontents

    @section websocketclientintro Introduction to the WebSocketClient Module

    The %WebSocketClient module provides client support for
    <a href="http://tools.ietf.org/html/rfc6455">RFC-6455 based WebSocket protocol</a> implementations in %Qore.

    To use this module, use \c "%requires WebSocketClient" in your code.

    This module automatically uses the <a href="../../WebSocketUtil/html/index.html">WebSocketUtil</a> module for
    encoding and decoding web socket messages.

    All the public symbols in the module are defined in the WebSocketClient namespace.

    Currently the module provides the following classes:
    - @ref WebSocketClient::WebSocketClient "WebSocketClient": the web socket client class
    - @ref WebSocketClient::WebSocketConnectionObject "WebSocketConnectionObject": the web socket connection class
      (based on the @ref connectionproviderintro "ConnectionProvider" module)

    <b>Example</b>
    @code{.py}
#!/usr/bin/env qore

%new-style
%enable-all-warnings

%requires WebSocketClient

*string url = shift ARGV;
if (!url) {
    stderr.printf("usage: %s <URL>\n", get_script_name());
    exit(1);
}

code callback = sub (*data d) {
    if (d.typeCode() == NT_BINARY) {
        printf("binary msg received: %y\n", d);
    } else if (d) {
        printf("%s\n", d);
    }
};
WebSocketClient ws(callback, {"url": url});
ws.connect();
# wait forever (or until ctrl-c)
Counter c(1);
c.waitForZero();
    @endcode

    @section websocketclient_relnotes WebSocketClient Module Release History

    @subsection wsc_v2_3 v2.3
    - added the @ref WebSocketClient::WebSocketClientWithSerialization "WebSocketClientWithSerialization" class, added
      support in the @ref WebSocketClient::WebSocketClient "WebSocketClient" class for tokens and a logger instead of
      log closures / callbacks
    - added support for the data provider action catalog API
      (<a href="https://github.com/qorelanguage/qore/issues/4808">issue 4808</a>)
    - added support for protocol version 13

    @subsection wsc_v2_2 v2.2
    - fixed creating example WebSocket client data providers from factories with templated option values
      (<a href="https://github.com/qorelanguage/qore/issues/4716">issue 4716</a>)
    - added a "wait for message" API data provider to the WebSocket client data providers
      (<a href="https://github.com/qorelanguage/qore/issues/4716">issue 4716</a>)

    @subsection wsc_v2_1_1 v2.1.1
    - the data provider factory uses the delayed observable class instead
      (<a href="https://github.com/qorelanguage/qore/issues/4701">issue 4701</a>)

    @subsection wsc_v2_1 v2.1
    - fixed a deadlock deleting the client object when it goes out of scope in the event thread
      (<a href="https://github.com/qorelanguage/qore/issues/4697">issue 4697</a>)
    - added the \c headers option to allow auth headers to be set in WebSocket client connections and data providers
      (<a href="https://github.com/qorelanguage/qore/issues/4694">issue 4694</a>)

    @subsection wsc_v2_0 v2.0
    - added support for events and messages from the DataProvider API
      (<a href="https://github.com/qorelanguage/qore/issues/4557">issue 4557</a>)

    @subsection wsc_v1_9_1 v1.9.1
    - added support for continuation frames
      (<a href="https://github.com/qorelanguage/qore/issues/4073">issue 4073</a>)

    @subsection wsc_v1_9 v1.9
    - implemented support for a data provider scheme cache and rich option information for connections
      (<a href="https://github.com/qorelanguage/qore/issues/4025">issue 4025</a>)

    @subsection wsc_v1_8 v1.8
    - removed the \c WebSocketConnectionObject::getConstructorInfo() and
      \c WebSocketConnectionObject::getConstructorInfoImpl() methods
      (<a href="https://github.com/qorelanguage/qore/issues/3696">issue 3696</a>)
    - added support for socket events
      (<a href="https://github.com/qorelanguage/qore/issues/3425">issue 3425</a>)

    @subsection wsc_v1_7 v1.7
    - all connection clases have unified constructor
    - added the \c WebSocketConnectionObject::getConstructorInfo()
      method to allow connections to be created dynamically, potentially in another process from a network
      call (removed in WebSocketClient 1.8)
      (<a href="https://github.com/qorelanguage/qore/issues/2628">issue 2628</a>)
    - add WebSocketClient handling of WSCC_GoingAway event

    @subsection wsc_v1_6_3 v1.6.3
    - added missing exception handling in the connection close callback
      (<a href="https://github.com/qorelanguage/qore/issues/3225">issue 3225</a>)

    @subsection wsc_v1_6_2 v1.6.2
    - allowed the handling of \c PING messages to be customized
      (<a href="https://github.com/qorelanguage/qore/issues/2887">issue 2887</a>)

    @subsection wsc_v1_6_1 v1.6.1
    - added @ref WebSocketClient::WebSocketClient::pong() "WebSocketClient::pong()" to allow an unsolicited \c PONG
      message to be sent as a unidirectional keep-alive message from the client to the server
      (<a href="https://github.com/qorelanguage/qore/issues/2566">issue 2566</a>)

    @subsection wsc_v1_6 v1.6
    - added the @ref WebSocketClient::WebSocketConnectionObject "WebSocketConnectionObject" class to support the
      <a href="../../ConnectionProvider/html/index.html">ConnectionProvider</a> module
    - updated for complex types
    - fixed a bug where the event loop thread would immediately terminate after a reconnection
      (<a href="https://github.com/qorelanguage/qore/issues/2061">issue 2061</a>)
    - improved client logging
    - fixed a bug where the @ref WebSocketClient::WebSocketClient class did not validate the \c Sec-WebSocket-Accept
      response header according to RFC6455
      (<a href="https://github.com/qorelanguage/qore/issues/2062">issue 2062</a>)
    - added support for the \c yield option in the constructor

    @subsection wsc_v1_5 v1.5
    - added timeout values to @ref Qore::Socket "Socket" and @ref Qore::HTTPClient "HTTPClient" calls
      (<a href="https://github.com/qorelanguage/qore/issues/1725">issue 1725</a>)

    @subsection wsc_v1_4 v1.4
    - fixed a bug parsing and generating the websocket close status code
      (<a href="https://github.com/qorelanguage/qore/issues/1216">issue 1216</a>)

    @subsection wsc_v1_3 v1.3
    - ignore \c SOCKET-NOT-OPEN errors when closing (server already closed the connection)

    @subsection wsc_v1_2 v1.2
    - prepend \c "WebSocketClient: " to log messages

    @subsection wsc_v1_1 v1.1
    - added socket instrumention support from Qore 0.8.9

    @subsection wsc_v1_0 v1.0
    - the initial version of the WebSocketClient module
*/

#! the WebSocketClient namespace contains all the definitions in the WebSocketClient module
public namespace WebSocketClient {
#! known websocket schemes
public const WsSchemes = {
    "ws": {
        "ssl": False,
    },
    "wss": {
        "ssl": True,
    },
};

/** @defgroup WSClientRawCallbackReturnCodes WebSocketClient Raw Callback Return Codes
*/
#! Application name
public const AppName = "WebSockets";

#/@{
#! If the client should process the message normally
public const WSC_Process = 0;

#! If the client should continue listening (message already processed)
public const WSC_Continue = 1;

#! If the client should stop listening (message already processed)
public const WSC_Break = 2;
#/@}

#! default port for connections
public const WsDefaultPort = 80;

#! WebSocket data event constant
/** The event data has the following key:
    - \c data: the message data
*/
public const EVENT_WS_DATA = "ws-data-event";

#! WebSocket ping event constant
/** The event data has the following key:
    - \c data: the message data
*/
public const EVENT_WS_PING = "ws-ping-event";

#! WebSocket pong event constant
/** The event data has the following key:
    - \c data: the message data
*/
public const EVENT_WS_PONG = "ws-pong-event";

#! WebSocket connection closed event constant
/** This event has no data
*/
public const EVENT_WS_CLOSED = "ws-closed-event";

#! WebSocket connected event type
/** This event has no data
*/
public const EVENT_WS_CONNECTED = "ws-connected-event";

#! WebSocket data message type
/** Sends a WebSocket message to the remote end; the message will be serialized according to the serialization option
    on the WebSocketClient object
*/
public const MESSAGE_WS_DATA = "data";

#! WebSocket raw data message type
/** Sends a raw message to the remote end; the message is sent as-is
*/
public const MESSAGE_WS_RAW = "raw";

#! WebSocket ping message type
/** Sends a \c PING message to the server, a PONG event should be generated
*/
public const MESSAGE_WS_PING = "ping";

#! WebSocket pong message type
/** Sends a \c PONG message to the server; should be sent when a \c PING event is received
*/
public const MESSAGE_WS_PONG = "pong";

#! the main websocket client class
/** To use this class, create a @ref WebSocketClient::WebSocketClient "WebSocketClient" object and the call
    @ref WebSocketClient::WebSocketClient::connect() "WebSocketClient::connect()".

    The @ref WebSocketClient::WebSocketClient::connect() "WebSocketClient::connect()" method starts a background
    thread to receive messages, which are then posted to the callback provided in the
    @ref WebSocketClient::WebSocketClient::constructor() "WebSocketClient::constructor()".

    To stop listening for web socket events, call
    @ref WebSocketClient::WebSocketClient::disconnect() "WebSocketClient::disconnect()".

    The @ref WebSocketClient::WebSocketClient "WebSocketClient" class includes support for running in sandboxed
    Program objects with the following parse options set:
    - \c PO_NO_PROCESS_CONTROL: in this case the \c "yield" option is required in
      @ref WebSocketClient::WebSocketClient::constructor() "WebSocketClient::constructor()"
*/
public class WebSocketClient inherits Logger::LoggerWrapper, ConnectionProvider::OptionHelper {
    public {
        #! default socket I/O operation timeout: 15 seconds
        const DefaultTimeout = 15s;

        #! module version
        const Version = "2.3";

        #! default user agent string for HTTP requests
        const DefaultUserAgent = sprintf("Qore-WebSocketClient/%s", WebSocketClient::Version);

        #! support WebSocket protocol versions
        const VersionMap = {
            "8": True,
            "13": True,
        };

        #! Max reconnect retries; negative numbers = infinite
        const MaxReconnectRetries = -1;

        #! Reconnect retry delay
        const ReconnectDelay = 2s;
    }

    private {
        Mutex m();
        Condition sleep_cond();
        HTTPClient hc;
        int stop = 0;

        code callback;
        code raw_callback;
        code pong_callback;
        timeout timeout_ms = DefaultTimeout;

        #! Reconnect flag
        bool reconnect = False;

        #! TID of the event thread; only changed in the log
        /** Threads can wait for it to be cleared using tid_waiting and tid_cond
        */
        int tid;

        #! Event thread waiting count
        int tid_waiting;

        #! Event thread condition variable
        Condition tid_cond();

        #! Unique websocket connection ID; -1 when not connected
        int cid = -1;

        #! callable object to yield the current thread's execution
        *code yield;
        #! callable value to start a new thread; must take a callable object as a parameter and return an integer TID
        *code start_thread;

        #! Total number of connections made
        int num_connects;

        #! protocol version level (8 or 13)
        softint ws_ver;

        #! URL string
        string url;

        #! Flag for a user-initiated reconnect
        bool do_reconnect;

        #! Connection sequence
        static Sequence seq();

        #! Event disposition code: continue processing event loop
        const WSEDC_CONTINUE = 1;

        #! Event disposition code: break event loop
        const WSEDC_BREAK = 2;

        #! Event disposition code: unknown opcode
        const WSEDC_UNKNOWN_OPCODE = 3;
    }

    #! Creates the WebSocket client object from the arguments
    /** @par Example:
        @code{.py}
sub event(*data msg) {
    if (!msg) {
        printf("connection closed\n");
    } else {
        printf("%s msg: %y\n", now_us().format("YYYY-MM-DD HH:mm:SS.xx"), msg);
    }
}
int sub raw_callback(hash<WsMsgInfo> event) {
    printf("raw event: %y\n", event);
    return WSC_Process;
}
WebSocketClient ws(\event(), {
    "url": "ws://example.com:8080/path",
    "raw_callback": \raw_callback(),
});
        @endcode

        @param cb the callback @ref closure "closure" or @ref call_reference "call reference" for received messages
        @param opts an option hash for the @ref Qore::HTTPClient::constructor(hash<auto>) "HTTPClient constructor"
        plus the following keys:
        - \c logger: an optional @ref Logger::LoggerInterface "LoggerInterface" object for internal logging
        - \c raw_callback: an optional @ref closure "closure" or @ref call_reference "call reference" for
          receiving raw WebSocket messages before processing; takes a single <tt>hash&lt;WsMsgInfo&gt;</tt>
          argument and must return one of the following values: @ref WSClientRawCallbackReturnCodes
        - \c reconnect: try to reconnect when the connection is closed or lost (default @ref False)
        - \c yield: an options @ref closure "closure" or @ref call_reference "call reference" for yielding the
            current thread's execution to another thread (default value: @ref Qore::Threads::thread_yield());
            required if @ref Qore::PO_NO_PROCESS_CONTROL is set in the current execution context

        @throw WEBSOCKET-ERROR unknown scheme, missing 'url' key in option hash; invalid option value

        @since
        - WebSocketClient 1.6 added the \c yield option
        - WebSocketClient 1.9.1 added the \c raw_callback option
        - WebSocketClient 2.3 removed logging closures, added LoggerWrapper as a base class, added token option
          support, added support for subclassing
    */
    constructor(code cb, hash<auto> opts) {
        constructorInit(opts);
        callback = cb;
    }

    #! disconnects the connection and stops the event thread if connected
    destructor() {
        if (reconnect) {
            reconnect = False;
        }
        disconnectIntern(WSCC_GoingAway, True);
    }

    #! returns the URL given in the constructor
    string getUrl() {
        return url;
    }

    #! Returns a "safe" URL, without any password info
    string getSafeUrl() {
        return hc.getSafeURL() ?? "";
    }

    #! returns the unique connection ID
    int getConnectionId() {
        return cid;
    }

    #! returns a hash of URL scheme information for URL schemes supported by this object
    hash<auto> getSchemes() {
        return WsSchemes;
    }

    #! Returns the value of the reconnect flag
    bool getReconnect() {
        return reconnect;
    }

    #! Connects to the websocket server
    /** @par Example:
        @code{.py}
sub event(*data msg) {
    if (!msg) {
        printf("connection closed\n");
    } else {
        printf("%s msg: %y\n", now_us().format("YYYY-MM-DD HH:mm:SS.xx"), msg);
    }
}
int sub raw_callback(hash<WsMsgInfo> event) {
    printf("raw event: %y\n", event);
    return WSC_Process;
}
WebSocketClient ws(\event(), {
    "url": "ws://example.com:8080/path",
    "raw_callback": \raw_callback(),
});
ws.connect();
        @endcode

        This method starts a background thread to receive messages, which are then posted to the callback
        @ref closure "closure" or @ref call_reference "call reference" given as an argument.  If the server
        disconnects the web socket connection, the callback will be called with no argument (ie @ref nothing).
        In this case the event thread also terminates and the WebSocketClient object will be in a disconnected state.

        To stop listening for web socket events, call
        @ref WebSocketClient::WebSocketClient::disconnect() "WebSocketClient::disconnect()".

        If this method is called while a connection is already in progress, then the existing connection is first
        implicitly disconnected with close code @ref WebSocketUtil::WSCC_GoingAway "WSCC_GoingAway".

        @param opts a hash with the following keys:
        - \c hdr: (optional) a @ref hash_type "hash" giving header values for the connection request to the web socket
          server
        @param info a @ref reference_type "reference" to a hash which will be set to information about the call setup

        @return a hash with information about the HTTP response from the web socket server corresponding to the
        return value of @ref Qore::Socket::readHTTPHeader()

        @throw WEBSOCKET-ERROR the option hash is missing either the 'url' or 'callback' keys or type error in the
        option hash
    */
    hash<auto> connect(*hash<auto> opts, *reference<hash<auto>> info) {
        return connectIntern(opts, \info);
    }

    #! returns @ref True "True" if the connection is currently open and active, @ref False "False" if not
    bool isOpen() {
        m.lock();
        on_exit m.unlock();

        return hc.isOpen();
    }

    #! Initiate a server reconnect immediately
    /** @return True if the reconnect was started
    */
    bool reconnect() {
        AutoLock al(m);

        if (!tid) {
            return False;
        }

        if (!reconnect) {
            reconnect = True;
        }

        # check if already reconnecting
        if (!stop && !do_reconnect) {
            do_reconnect = True;
            # wake up any sleeping threads
            sleep_cond.broadcast();
        }
        # wait for the event thread to terminate
        waitTidCleared(tid);

        return True;
    }

    #! Disconnect with the given @ref closecodes "close code"
    disconnect(int cmd = WSCC_GoingAway) {
        # do not reconnect if an explicit disconnect is called
        if (reconnect) {
            reconnect = False;
        }

        disconnectIntern(cmd);
    }

    #! Returns @ref True if the client is reconnecting
    bool isReconnecting() {
        return num_connects && !isOpen();
    }

    #! Returns information about the current connection
    /** @returns a hash with the following keys:
        - \c cid: the WebSocket client connection ID
        - \c num_connects: how many times has the client connected to the server
        - \c peer: information about the connected server socket (see
          @ref Qore::Socket::getPeerInfo() "Socket::getPeerInfo()")
        - \c socket: information about the connected local socket (see
          @ref Qore::Socket::getSocketInfo() "Socket::getSocketInfo()")
    */
    *hash<auto> getConnectionInfo() {
        # use += to keep "hash<auto>"
        hash<auto> rv += {
            "cid": cid,
            "num_connects": num_connects,
        };
        try {
            rv += {
                "peer": hc.getPeerInfo(),
                "socket": hc.getSocketInfo(),
            };
        } catch (hash<ExceptionInfo> ex) {
            # ignore exceptions when not connected and return NOTHING
        }
        return rv;
    }

    #! Connects to the websocket server
    private hash<auto> connectIntern(*hash<auto> opts, *reference<hash<auto>> info, *bool reconnect) {
        if (opts.hdr && opts.hdr.typeCode() != NT_HASH) {
            raiseError("option hash to WebSocketClient::connect() 'hdr' key not assigned to a hash; type "
                "received: %y", opts.hdr.fullType());
        }

        m.lock();
        on_exit m.unlock();

        if (hc.isOpen()) {
            disconnectUnlocked();
        }

        hash<auto> h = connectUnlocked(opts.hdr, \info, reconnect);
        on_error {
            clearTid();
        }

%ifdef PO_NO_THREAD_CONTROL
        updateTid(start_thread(\eventLoop()));
%else
        updateTid(start_thread ? start_thread(\eventLoop()) : background eventLoop());
%endif

        logDebug("WS I/O thread started with TID %d", tid);
        return h;
    }

    #! Disconnect with the given @ref closecodes "close code"
    private disconnectIntern(int cmd = WSCC_GoingAway, *bool destroy) {
        AutoLock al(m);

        if (hc.isOpen()) {
            disconnectUnlocked(cmd);
        } else if (destroy && tid && tid != gettid()) {
            # wait for reconnect thread to stop if deleting when disconnected and reconnecting
            stop = cmd;
            # wake up any sleeping threads
            sleep_cond.broadcast();
            # wait for the event thread to terminate
            waitTidCleared(tid);
        }
    }

    #! Removes any warning @ref Qore::Thread::Queue "Queue" object from the Socket
    /** @par Example:
        @code{.py}
ws.clearWarningQueue();
        @endcode

        @see WebSocketClient::setWarningQueue()

        @since %WebSocketClient 1.1
    */
    clearWarningQueue() {
        hc.clearWarningQueue();
    }

    #! Sets a @ref Qore::Thread::Queue "Queue" object to receive socket warnings
    /** @par Example:
        @code{.py}
ws.setWarningQueue(5000, 5000, queue, "socket-1");
        @endcode

        @param warning_ms the threshold in milliseconds for individual socket actions (send, receive, connect), if
        exceeded, a socket warning is placed on the warning queue with the following keys:
        - \c "type": a string with the constant value \c "SOCKET-OPERATION-WARNING"
        - \c "operation": a string giving the operation that caused the warning (ex: \c "connect")
        - \c "us": an integer giving the number of microseconds for the operation
        - \c "timeout": an integer giving the warning threshold in microseconds
        - \c "arg": if any \c "arg" argument is passed to the
          @ref setWarningQueue() "WebSocketClient::setWarningQueue()" method, it will be included in the warning hash
          here
        @param warning_bs value in bytes per second; if any call has performance below this threshold, a socket
        warning is placed on the warning queue with the following keys:
        - \c "type": a string with the constant value \c "SOCKET-THROUGHPUT-WARNING"
        - \c "dir": either \c "send" or \c "recv" depending on the direction of the data flow
        - \c "bytes": the amount of bytes sent
        - \c "us": an integer giving the number of microseconds for the operation
        - \c "bytes_sec": a float giving the transfer speed in bytes per second
        - \c "threshold": an integer giving the warning threshold in bytes per second
        - \c "arg": if any \c "arg" argument is passed to the
          @ref setWarningQueue() "WebSocketClient::setWarningQueue()" method, it will be included in the warning hash
          here
        @param queue the @ref Qore::Thread::Queue "Queue" object to receive warning events
        @param arg an optional argument to be placed in the \c "arg" key in each warning hash (could be used to
        identify the socket for example)
        @param min_ms the minimum transfer time with a resolution of milliseconds for a transfer to be eligible for
        triggering a warning; transfers that take less than this period of time are not eligible for raising a warning

        @throw QUEUE-ERROR the Queue passed has a maximum size set
        @throw SOCKET-SETWARNINGQUEUE-ERROR at least one of \a warning_ms and \a warning_bs must be > 0

        @see WebSocketClient::clearWarningQueue()

        @since %WebSocketClient 1.1
    */
    setWarningQueue(int warning_ms, int warning_bs, Queue queue, auto arg, timeout min_ms = 1s) {
        hc.setWarningQueue(warning_ms, warning_bs, queue, arg, min_ms);
    }

    #! Returns performance statistics for the socket
    /** @par Example:
        @code{.py}
hash<auto> h = ws.getUsageInfo();
        @endcode

        @return a hash with the following keys:
        - \c "bytes_sent": an integer giving the total amount of bytes sent
        - \c "bytes_recv": an integer giving the total amount of bytes received
        - \c "us_sent": an integer giving the total number of microseconds spent sending data
        - \c "us_recv": an integer giving the total number of microseconds spent receiving data
        - \c "arg": (only if warning values have been set with
          @ref setWarningQueue() "WebSocketClient::setWarningQueue()") the optional argument for warning hashes
        - \c "timeout": (only if warning values have been set with
          @ref setWarningQueue() "WebSocketClient::setWarningQueue()") the warning timeout in microseconds
        - \c "min_throughput": (only if warning values have been set with
          @ref setWarningQueue() "WebSocketClient::setWarningQueue()") the minimum warning throughput in bytes/sec

        @since %WebSocketClient 1.1

        @see WebSocketClient::clearStats()
    */
    hash<auto> getUsageInfo() {
        return hc.getUsageInfo();
    }

    #! Clears performance statistics
    /** @par Example:
        @code{.py}
ws.clearStats();
        @endcode

        @since %WebSocketClient 1.1

        @see WebSocketClient::getUsageInfo()
    */
    clearStats() {
        hc.clearStats();
    }

    #! Sets a @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"
    /** @par Example:
        @code{.py}
ws.setEventQueue(queue);
        @endcode

        @param queue the @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"; note that
        the Queue passed cannot have any maximum size set or a QUEUE-ERROR will be thrown
        @param arg an argument that will be included in each event hash in the \a arg key
        @param with_data if @ref True, then the actual raw data transferred / received is also included in the events

        @throw QUEUE-ERROR the Queue passed has a maximum size set

        @see @ref event_handling for more information

        @since %WebSocketClient 1.8
    */
    setEventQueue(Qore::Thread::Queue queue, auto arg, *bool with_data) {
        hc.setEventQueue(queue, arg, with_data);
    }

    #! Removes any @ref Qore::Thread::Queue "Queue" object so that @ref socket_events "socket events" are no longer added to the @ref Qore::Thread::Queue "Queue"
    /** @par Example:
        @code{.py}
ws.setEventQueue();
        @endcode

        @see @ref event_handling for more information

        @since %WebSocketClient 1.8
    */
    setEventQueue() {
        hc.setEventQueue();
    }

    #! Sends a \c PING message to the server as a unidirectional keep-alive message
    /** @since WebSocketClient 2.0
    */
    ping(*data msg) {
        logDebug("sending PING %y (open: %y connected: %y)", msg, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(msg ?? "", WSOP_Ping, True), timeout_ms);
    }

    #! Sends a \c PONG message to the server as a unidirectional keep-alive message
    /** @since WebSocketClient 1.6.1
    */
    pong(*data msg) {
        logDebug("sending PONG %y (open: %y connected: %y)", msg, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(msg ?? "", WSOP_Pong, True), timeout_ms);
    }

    #! Sends string data over the web socket with timeout specified in options; if any errors occur, an exception is thrown
    /**
        @param str Sends the string data over the socket

        @see Socket::send()
    */
    send(string str) {
        logDebug("sending string: %y (open: %y connected: %y)", str, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(str, WSOP_Text, True), timeout_ms);
    }

    #! Sends binary data over the web socket with timeout specified in options; if any errors occur, an exception is thrown
    /**
        @param bin Sends the binary data over the socket

        @see Socket::send()
    */
    send(binary bin) {
        logDebug("sending binary: %y (open: %y connected: %y)", bin, hc.isOpen(), hc.isConnected());
        hc.send2(ws_encode_message(bin, WSOP_Binary, True), timeout_ms);
    }

    #! pushes an unencoded message on the connection's message queue
    /** the message will be encoded with @ref WebSocketUtil::ws_encode_message() before sending
    */
    send(data msg, int op, bool fin) {
        logDebug("sending message: %y op: %d/%y fin: %y (%y %y)", fin, op, WSOPMap{op} ?? "unknown", fin, hc.isOpen(),
            hc.isConnected());
        hc.send2(ws_encode_message(msg, op, True, fin), timeout_ms);
    }

    #! Constructor for child classes with no callback
    private constructor(hash<auto> opts) {
        constructorInit(opts);
    }

    #! Common constructor code
    private constructorInit(hash<auto> opts) {
        if (opts.reconnect) {
            reconnect = True;
        }
        # set logger, if any
        logger = remove opts.logger;

        # set protocol version
        if (opts.version) {
            if (!VersionMap{opts.version}) {
                raiseError("unsupported version %y passed; supported versions: %y", opts.version,
                    map $1.toInt(), keys VersionMap);
            }
            ws_ver = remove opts.version;
        }

        # += to keep "http_opts" "hash<auto>"
        hash<auto> http_opts += opts;
        url = getString(opts, "url", True);

        if (http_opts.hasKey("yield")) {
            if (!http_opts.yield.callp()) {
                raiseError("option hash to WebSocketClient::constructor() has an invalid 'yield' key with type %y; "
                    "must be a callable value", opts.yield.fullType());
            }
            yield = remove http_opts.yield;
        }
%ifdef PO_NO_PROCESS_CONTROL
        else {
            raiseError("option hash to WebSocketClient::constructor() missing 'yield' key giving the thread yield "
                "closure/call reference which is required when PO_NO_PROCESS_CONTROL is in effect");
        }
%endif

        if (http_opts.hasKey("start_thread")) {
            if (!http_opts.start_thread.callp()) {
                raiseError("option hash to WebSocketClient::constructor() has an invalid 'start_thread' key with type %y; "
                    "must be a callable value", opts.start_thread.fullType());
            }
            start_thread = remove http_opts.start_thread;
        }
%ifdef PO_NO_THREAD_CONTROL
        else {
            raiseError("option hash to WebSocketClient::constructor() missing 'start_thread' key giving the a "
                "closure/call reference to start new threads which is required when PO_NO_THREAD_CONTROL is in effect");
        }
%endif

        if (http_opts.hasKey("raw_callback")) {
            if (!http_opts.raw_callback.callp()) {
                raiseError("option hash to WebSocketClient::constructor() has an invalid 'raw_callback' key with "
                    "type %y; must be a callable value", opts.raw_callback.type());
            }
            raw_callback = http_opts.raw_callback;
        }

        if (http_opts.hasKey("pong_callback")) {
            if (!http_opts.pong_callback.callp()) {
                raiseError("option hash to WebSocketClient::constructor() has an invalid 'pong_callback' key with "
                    "type %y; must be a callable value", opts.pong_callback.type());
            }
            pong_callback = http_opts.pong_callback;
        }

        hash<UrlInfo> uh = parse_url(http_opts.url);
        if (uh.protocol) {
            hash<auto> sh = getSchemes();
            *hash<auto> ph = sh{uh.protocol};
            if (!ph) {
                raiseError("schema %y is unknown in %y; known schemes: %y", uh.protocol, http_opts.url, sh.keys());
            }
            # replace websocket scheme with an http scheme
            splice http_opts.url, 0, uh.protocol.size(), "http" + (ph.ssl ? "s" : "");
        }

        # ensure that the timeout value is set correctly and consistently
        if (http_opts."timeout") {
            timeout_ms = http_opts."timeout";
        } else {
            http_opts."timeout" = timeout_ms;
        }
        # remove the "token" option and use it if the Authorization header is not set
        if ((*string token = remove http_opts.token) && !http_opts.headers.Authorization) {
            http_opts.headers.Authorization = sprintf("%s %s", http_opts.token_type ?? "Bearer", token);
        }
        # unconditionally remove any "token_type" option
        remove http_opts.token_type;

        hc = new HTTPClient(http_opts);
    }

    private disconnectUnlocked(int cmd = WSCC_GoingAway) {
        # disconnect only if possible; in case this method is called from the destructor from the event thread, we
        # cannot wait for the event thread to terminate, as there would be a deadlock
        if (tid && (tid != gettid())) {
            stop = cmd;
            # wake up any sleeping threads
            sleep_cond.broadcast();
            # wait for the event thread to terminate
            waitTidCleared(tid);
            cid = -1;
        }
    }

    #! Handles processed messages
    private int handleEvent(string buf) {
        if (callback) {
            callback(buf);
        } else {
            logWarn("Ignoring TEXT message: %y", buf);
        }
        return WSEDC_CONTINUE;
    }

    #! Handles processed messages
    private int handleEvent(binary buf) {
        if (callback) {
            callback(buf);
        } else {
            logWarn("Ignoring BINARY message: %y", buf);
        }
        return WSEDC_CONTINUE;
    }

    #! Handles raw messages
    private int eventRaw(hash<WsMsgInfo> event) {
        if (raw_callback) {
            return raw_callback(event);
        }
        # continue with default processing by default
        return WSC_Process;
    }

    #! Called when the connection is closed
    private closingConnection() {
        if (callback) {
            callback();
        }
    }

    private updateTid(int tid) {
        self.tid = tid;
    }

    #! Clears the tid and stop variables and wakes up any waiting threads
    private clearTid() {
        remove tid;
        stop = 0;
        do_reconnect = False;
        if (tid_waiting) {
            tid_cond.broadcast();
        }
    }

    private waitTidCleared(int old_tid) {
        while (tid && tid != old_tid) {
            ++tid_waiting;
            tid_cond.wait(m);
            --tid_waiting;
        }
    }

    private eventLoop() {
        on_exit {
            # issue #4697: went out of scope in event loop
            if (self) {
                m.lock();
                on_exit m.unlock();
                clearTid();

                logDebug("WS I/O thread with TID %d terminating", gettid());
            }
        }

        # data buffer for fragmented frames
        data buf;
        while (True) {
            # issue #4697: went out of scope in event loop
            if (!self) {
                break;
            }
            if (stop) {
                sendClose(stop);
                logInfo("WS I/O thread stopping on user request (stop code %y: %y)", stop,
                    WSCCMap{stop} ?? "unknown");
                break;
            }
            if (do_reconnect) {
                sendClose(WSCC_NormalClosure);
                logInfo("WS I/O thread for an externally-initiated reconnect");
                break;
            }

            try {
                if (!hc.isDataAvailable(50ms)) {
%ifdef PO_NO_PROCESS_CONTROL
                    yield();
%else
                    yield ? yield() : Qore::thread_yield();
%endif
                    continue;
                }
                hash<WsMsgInfo> h = ws_read_message(hc, timeout_ms);
                {
                    int state = eventRaw(h);
                    if (state == WSC_Continue) {
                        continue;
                    }
                    if (state == WSC_Break) {
                        logInfo("WS I/O thread stopping due to event (stop code %y: %y)", stop,
                            stop ? (WSCCMap{stop} ?? "unknown") : "none");
                        break;
                    }
                }
                int disp = handleMessage(h, \buf);
                if (disp == WSEDC_CONTINUE) {
                    continue;
                } else if (disp == WSEDC_BREAK) {
                    logInfo("WS I/O thread stopping due to message (stop code %y: %y)", stop,
                        stop ? (WSCCMap{stop} ?? "unknown") : "none");
                    break;
                }

                # unrecognized opcode - close the connection
                sendClose(WSCC_UnsupportedData);
                break;
            } catch (hash<ExceptionInfo> ex) {
                string err = sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                try {
                    logError(err);
                } catch (hash<ExceptionInfo> ex) {
                    if (ex.err == "OBJECT-ALREADY-DELETED") {
                        return;
                    }
                    rethrow;
                }
                sendClose(WSCC_InternalServerError, err);
                break;
            }
        }

        # call the callback with NOTHING to signal that the connection has been closed
        try {
            # issue #3225 catch and log any exeptions in the closing callback
            closingConnection();
        } catch (hash<ExceptionInfo> ex) {
            try {
                logError("Exception in closing WebSocketClient callback: %s", get_exception_string(ex));
            } catch (hash<ExceptionInfo> ex) {
                if (ex.err == "OBJECT-ALREADY-DELETED") {
                    return;
                }
                rethrow;
            }
        }
        if (hc.isOpen()) {
            hc.shutdown();
            hc.close();
        }

        if (!self) {
            return;
        }
        if (reconnect && !stop) {
            startReconnect();
        } else {
            if (stop) {
                logInfo("Disconnected websocket connection on external request");
            } else {
                logInfo("Disconnected websocket connection; reconnect flag not set");
            }
        }
    }

    #! Starts a reconnect
    private startReconnect() {
        int tid;
%ifdef PO_NO_THREAD_CONTROL
        tid = start_thread(\doReconnect());
%else
        tid = start_thread ? start_thread(\doReconnect()) : background doReconnect();
%endif
        logInfo("Disconnected websocket connection; starting reconnect in TID %d", tid);
    }

    #! Handles reconnections
    private doReconnect() {
        try {
            reconnectPreamble();

            # connect to the new gateway
            int retries = 0;
            while (!stop) {
                hash<auto> info;
                try {
                    reestablishConnection(\info);
                    break;
                } catch (hash<ExceptionInfo> ex) {
                    ++retries;
                    if (MaxReconnectRetries > 0 && (retries == MaxReconnectRetries)) {
                        logError("Reconnect %d: failed (%s: %s); max retries exhausted", retries, ex.err, ex.desc);
                        rethrow;
                    }
                    logInfo("Reconnect %d: failed to connect to WebSocket server: %s: %s; sleeping for %y and "
                        "retrying", retries, ex.err, ex.desc, ReconnectDelay);

                    # Use the Mutex and Condition variable to delay, because sleep() is protected with
                    # PO_NO_PROCESS_CONTROL
                    AutoLock al(m);
                    sleep_cond.wait(m, ReconnectDelay);
                }
            }
            if (stop) {
                logInfo("Reconnect %d: interrupted by disconnect request", retries);
            }

            reconnectPostamble();
        } catch (hash<ExceptionInfo> ex) {
            try {
                logError("Failed to reconnect: %s", get_exception_string(ex));
            } catch (hash<ExceptionInfo> ex0) {
                if (ex0.err != "OBJECT-ALREADY-DELETED") {
                    rethrow;
                }
            }
        }
    }

    #! Executes before a reconnect
    private reconnectPreamble() {
        # disconnect if still connected
        disconnectIntern();
        # log connect with WS URL
        string wsurl = hc.getURL();
        wsurl =~ s/^http/ws/;
        logInfo("Reconnect to %y", wsurl);
    }

    #! Connects to the server when reconnecting
    private reestablishConnection(reference<hash<auto>> info) {
        connectIntern(NOTHING, \info, True);
    }

    #! Executes after a reconnect
    private reconnectPostamble() {
        # intentionally empty
    }

    #! Handles WebSocket protocol messages
    private int handleMessage(hash<WsMsgInfo> h, reference<data> buf) {
        if (h.op == WSOP_Close) {
            if (!h.close) {
                logDebug("Server sent OpClose without code; closing immediately");
                return WSEDC_BREAK;
            }
            logDebug("Server sent WSOP_Close code %d (%s): %y", h.close, WSCCMap{h.close}, h.msg);
            sendClose(h.close, h.msg);
            return WSEDC_BREAK;
        }

        if (h.op == WSCC_GoingAway) {
            logDebug("Server sent WSOP_GoingAway; closing immediately");
            return WSEDC_BREAK;
        }

        logDebug("Received msg (%s: %d bytes): %s", WSOPMap{h.op} ?? sprintf("unknown opcode %y", h.op),
            h.msg.size(), h.msg ? sprintf("type: %s: %y", h.msg.type(), h.msg) : "n/a");

        if (h.masked) {
            logError("Unmasked client frame received");
            sendClose(WSCC_ProtocolError);
            return WSEDC_BREAK;
        }

        if (h.op == WSOP_Ping) {
            handlePing(h);
            return WSEDC_CONTINUE;
        }

        # issue #4073: handle fragmented frames
        if (!h.fin) {
            if (!exists buf) {
                if (h.op == WSOP_Text || h.op == WSOP_Binary) {
                    buf = h.msg;
                } else {
                    logError("FIN bit not set but opcode is %d: %y", h.op, WSOPMap{h.op} ?? "unknown");
                    sendClose(WSCC_ProtocolError);
                    return WSEDC_BREAK;
                }
            } else {
                if (h.op != WSOP_Continuation) {
                    logError("FIN bit not set with buffer of type %y but opcode is %d: %y", buf.type(), h.op,
                        WSOPMap{h.op} ?? "unknown");
                    sendClose(WSCC_ProtocolError);
                    return WSEDC_BREAK;
                } else {
                    if (buf.typeCode() == NT_STRING) {
                        buf += h.msg.toString();
                    } else {
                        buf += h.msg;
                    }
                }
            }
            return WSEDC_CONTINUE;
        } else if (exists buf && h.op == WSOP_Continuation) {
            if (buf.typeCode() == NT_STRING) {
                buf += h.msg.toString();
            } else {
                buf += h.msg;
            }
            return handleEvent(remove buf);
        } else if (h.op == WSOP_Text || h.op == WSOP_Binary) {
            return handleEvent(h.msg);
        } else if (h.op == WSOP_Pong) {
            receivedPong(h.msg);
            return WSEDC_CONTINUE;
        } else if (h.op == WSOP_Continuation) {
            logError("FIN bit set with %d: %y opcode, but no data has been buffered", h.op,
                WSOPMap{h.op} ?? "unknown");
            sendClose(WSCC_ProtocolError);
            return WSEDC_BREAK;
        }

        return WSEDC_UNKNOWN_OPCODE;
    }

    private receivedPong(*data msg) {
        if (pong_callback) {
            pong_callback(msg);
        }
    }

    private handlePing(hash<auto> h) {
        hc.send2(ws_encode_message(h.msg ?? "heartbeat", WSOP_Pong, True), timeout_ms);
    }

    private logArgs(LoggerLevel level, string message, *softlist<auto> args) {
        try {
            LoggerWrapper::logArgs(level, sprintf("WebSocketClient %s: ", cid) + message, args);
        } catch (hash<ExceptionInfo> ex) {
            stderr.printf("WebSocketClient cannot log: %s: %s: %s msg: %s", ex.err, ex.desc, level.getStr(),
                vsprintf(message, args));
        }
    }

    private logDebug(string fmt, ...) {
        logArgs(LoggerLevel::DEBUG, fmt, argv);
    }

    private logInfo(string fmt, ...) {
        logArgs(LoggerLevel::INFO, fmt, argv);
    }

    private logWarn(string fmt, ...) {
        logArgs(LoggerLevel::WARN, fmt, argv);
    }

    private logError(string fmt, ...) {
        logArgs(LoggerLevel::ERROR, fmt, argv);
    }

    private sendClose(int code, *string txtmsg) {
        if (!WSCCMap{code}) {
            logError("Attempt to send invalid close code %d; expecting one of: %y", code,
                (map $1.toInt(), keys WSCCMap));
            code = WSCC_InternalServerError;
        }

        binary msg = code.encodeMsb(2);

        if (txtmsg) {
            if (txtmsg.encoding() != "UTF-8") {
                txtmsg = convert_encoding(txtmsg, "UTF-8");
            }
        } else {
            txtmsg = WSCCMap{code};
        }
        msg += txtmsg;
        try {
            hc.send2(ws_encode_message(msg, WSOP_Close, True), timeout_ms);
        } catch (hash<ExceptionInfo> ex) {
            # ignore SOCKET-NOT-OPEN errors when closing (server already closed the connection)
            if (ex.err == "SOCKET-NOT-OPEN") {
                return;
            }
            rethrow;
        }
    }

    #! Performs the HTTP socket connection to the WebSocket server
    private hash<auto> connectUnlocked(*hash<auto> hdr0, *reference<hash<auto>> info, *bool reconnect) {
        # in case hdr0 is hash<string, int> or similar
        hash<auto> hdr = {
            "User-Agent": DefaultUserAgent,
        } + hdr0;

        string key = get_random_string(16).toBase64();
        hdr += {
            "Upgrade": "websocket",
            "Connection": "Upgrade",
            # https://tools.ietf.org/html/rfc6455#section-4.1 specifies a 16-byte length for this random nonce
            "Sec-WebSocket-Key": key,
        };
        if (ws_ver == 13) {
            hdr."Sec-SebSocket-Version" = 13;
        }

        hash<auto> rh;
        {
            on_error {
                logArgs(reconnect ? LoggerLevel::DEBUG : LoggerLevel::ERROR, "error connecting to %s: %N",
                    (url, info));
                rethrow $1.err, sprintf("%s: info: %y", $1.desc, info{"request-uri", "response-uri"});
            }
            rh = hc.send(NOTHING, "GET", NOTHING, hdr, NOTHING, \info);
        }

        if (rh.status_code != 101) {
            raiseError("HTTP server at URL %y returned status code '%d %s' to our request; expecting '101 Switching "
                "Protocols'", hc.getURL(), rh.status_code, rh.status_message);
        }

        if (!rh."sec-websocket-accept") {
            raiseError("HTTP server at URL %y did not return the Sec-WebSocket-Accept response header (headers "
                "returned: %y)", hc.getURL(), rh);
        }

        {
            string expected_key = ws_get_response_key(key);
            if (rh."sec-websocket-accept" != expected_key) {
                raiseError("HTTP server at URL %y returned an invalid value in the Sec-WebSocket-Accept response "
                    "header: %y; expecting %y", hc.getURL(), rh."sec-websocket-accept", expected_key);
            }
        }

        logInfo("Connected to %y (open: %y)", hc.getURL(), hc.isOpen());
        ++num_connects;
        cid = seq.next();

        return rh;
    }

    #! throws an exception due to an error
    private raiseError(string fmt, ...) {
        throw "WEBSOCKET-ERROR", vsprintf(fmt, argv);
    }
}

#! WebSocket client with data serialization support
public class WebSocketClientWithSerialization inherits WebSocketClient, DataProvider::DelayedObservable {
    public {
        #! Data serialization support
        const DataSerializationSupport = {
%ifndef NoJson
            "json": True,
%endif
            "none": True,
%ifndef NoYaml
            "yaml": True,
%endif
        };
    }

    private {
        #! data serialization option: none, json, or yaml
        string serialization;

        #! Flag to raise ping events
        bool raise_ping_events;
    }

    #! Creates the WebSocket client object from the arguments
    /** @par Example:
        @code{.py}
WebSocketClientWithSerialization ws({
    "url": "ws://example.com:8080/path",
});
MyObserver observer();
prov.registerObserver(observer);
ws.observersReady();

class MyObserver inherits Observer {
    update(string event_id, hash<auto> data_) {
        printf("event %y: %y\n", event_id, data_);
    }
}
        @endcode

        @param opts an option hash for the @ref Qore::HTTPClient::constructor(hash<auto>) "HTTPClient constructor"
        plus the following keys:
        - \c logger: an optional @ref Logger::LoggerInterface "LoggerInterface" object for internal logging
        - \c raise_ping_events: if @ref True then events will be raised when pings are received
        - \c raw_callback: an optional @ref closure "closure" or @ref call_reference "call reference" for
          receiving raw WebSocket messages before processing; takes a single <tt>hash&lt;WsMsgInfo&gt;</tt>
          argument and must return one of the following values: @ref WSClientRawCallbackReturnCodes
        - \c reconnect: try to reconnect when the connection is closed or lost (default @ref False)
        - \c yield: an options @ref closure "closure" or @ref call_reference "call reference" for yielding the
            current thread's execution to another thread (default value: @ref Qore::Threads::thread_yield());
            required if @ref Qore::PO_NO_PROCESS_CONTROL is set in the current execution context

        @throw WEBSOCKET-ERROR unknown scheme, missing 'url' key in option hash; invalid option value

        @since
        - WebSocketClient 2.3
    */
    constructor(hash<auto> opts) : WebSocketClient(opts - "data") {
        # set serialization option, if any
        serialization = getString(opts, "data", True, "none");
        if (!DataSerializationSupport{serialization}) {
            unsupportedSerialization();
        }
        if (opts.raise_ping_events) {
            raise_ping_events = True;
        }
    }

    #! Called when all observers have been added to the object
    /** This method is meant to trigger event generation
    */
    observersReady() {
        start();
    }

    #! Sends string data over the web socket with timeout specified in options; if any errors occur, an exception is thrown
    /**
        @param value The value to serialize and send over the WebSocket
    */
    sendData(auto value) {
        send(serializeData(value));
    }

    #! Returns the data serialization value (\c "none", \c "json", or \c "yaml")
    string getSerialization() {
        return serialization;
    }

    #! Connects to the websocket server
    private hash<auto> connectIntern(*hash<auto> opts, *reference<hash<auto>> info, *bool reconnect) {
        hash<auto> rv = WebSocketClient::connectIntern(opts, \info, reconnect);
        logDebug("Reconnected; raising reconnect event: %y", observer_map);
        notifyObservers(EVENT_WS_CONNECTED, {});
        return rv;
    }

    #! Connects and starts receiving messages
    private start() {
        hash<auto> info;
        try {
            connect(NOTHING, \info);
        } catch (hash<ExceptionInfo> ex) {
            logError("Failed to connect to WebSocket server: %s", get_exception_string(ex));
            rethrow;
        }
    }

    #! Handles processed messages
    private int handleEvent(string buf) {
        try {
            return handleEventData(deserializeData(buf));
        } catch (hash<ExceptionInfo> ex) {
            logError("Error handling WebSocket event data message: %s (message: %y)", get_exception_string(ex), buf);
            return WSEDC_CONTINUE;
        }
    }

    #! Handles deserialized event data
    private int handleEventData(auto msgdata) {
        notifyObservers(EVENT_WS_DATA, {"data": msgdata});
        return WSEDC_CONTINUE;
    }

    #! Handles processed messages
    private int handleEvent(binary buf) {
        if (serialization == "none") {
            try {
                return handleEventData(buf);
            } catch (hash<ExceptionInfo> ex) {
                logError("Wrror handling binary WebSocket event data message: %s", get_exception_string(ex));
            }
        } else {
            logWarn("Ignoring binary WebSocket event data message: %y; cannot handle when serialization is %y", buf,
                serialization);
        }
        return WSEDC_CONTINUE;
    }

    #! Got a ping message
    private handlePing(hash<auto> h) {
        WebSocketClient::handlePing(h);
        if (raise_ping_events) {
            notifyObservers(EVENT_WS_PING, {"data": h.msg});
        }
    }

    #! Got a pong message
    private receivedPong(*data msg) {
        notifyObservers(EVENT_WS_PONG, {"data": msg});
    }

    #! Called when the connection is closed
    private closingConnection() {
        notifyObservers(EVENT_WS_CLOSED, {});
    }

    #! Serializes data for sending
    private data serializeData(auto value) {
        switch (serialization) {
%ifndef NoJson
            case "json":
                return make_json(value);
%endif
%ifndef NoYaml
            case "yaml":
                return make_yaml(value);
%endif
            case "none":
                switch (value.typeCode()) {
                    case NT_STRING:
                    case NT_BINARY:
                        break;
                    default:
                        raiseError("serialization is %y; cannot send data of type %y without serialization",
                            serialization, value.fullType());
                }
                return value;
        }
        unsupportedSerialization();
    }

    #! Deserializes data received
    private auto deserializeData(string buf) {
        switch (serialization) {
%ifndef NoJson
            case "json":
                return parse_json(buf);
%endif
%ifndef NoYaml
            case "yaml":
                return parse_yaml(buf);
%endif
            case "none":
                return buf;
        }
        unsupportedSerialization();
    }

    #! Throws an UNSUPPORTED-SERIALIZATION error
    private unsupportedSerialization() {
        throw "UNSUPPORTED-SERIALIZATION", sprintf("unsupported data serialization value %y; known serialization "
            "values: %y", serialization, keys DataSerializationSupport);
    }
}

#! class for websocket connections
/** Returns an object of class @ref WebSocketClient for receiving websocket events from a websocket server; supports
    all @ref ConnectionProvider::HttpConnection "HttpConnection" options.

    Also supports the following runtime options in getImpl():
    - \c "logger": a @ref Logger::LoggerInterface "LoggerInterface" object for internal logging
    - \c "start_thread": a closure to start a new thread (signature:
      @verbatim int sub start_thread(code callable) {}@endverbatim)
    - \c "yield": a closure to yield current thread execution
*/
public class WebSocketConnectionObject inherits ConnectionProvider::AbstractConnectionWithInfo {
    public {
        #! Connection entry info
        const ConnectionScheme = <ConnectionSchemeInfo>{
            "display_name": "WebSocket Connection",
            "short_desc": "A connection to a WebSocket server service",
            "desc": "A connection to a WebSocket server service",
            "cls": Class::forName("WebSocketConnectionObject"),
            "schemes": {
                "wss": True,
                "ws": True,
            },
            "options": HttpConnection::ConnectionScheme.options + {
                "data": <ConnectionOptionInfo>{
                    "display_name": "Data Serialization",
                    "short_desc": "Sets the data serialization option",
                    "type": "string",
                    "desc": "Sets the data serialization option",
                    "allowed_values": (
%ifndef NoJson
                        <AllowedValueInfo>{
                            "value": "json",
                            "desc": "use JSON serialization",
                        },
%endif
                        <AllowedValueInfo>{
                            "value": "none",
                            "desc": "no serialization is used",
                        },
%ifndef NoYaml
                        <AllowedValueInfo>{
                            "value": "yaml",
                            "desc": "use only YAML serialization",
                        },
%endif
                    ),
                    "default_value": "none",
                },
                "reconnect": <ConnectionOptionInfo>{
                    "display_name": "Reconnect?",
                    "short_desc": "Try to reconnect when the connection is closed or lost",
                    "type": "bool",
                    "desc": "Try to reconnect when the connection is closed or lost",
                    "default_value": False,
                },
                "raise_ping_events": <ConnectionOptionInfo>{
                    "display_name": "Raise Ping Events?",
                    "short_desc": "Raise events for WebSocket pings?",
                    "type": "bool",
                    "desc": "Raise events for WebSocket pings?",
                    "default_value": False,
                },
                "token": <ConnectionOptionInfo>{
                    "display_name": "Authorization Token",
                    "short_desc": "Set an authorization token",
                    "type": "string",
                    "desc": "Any token to use for the initial HTTP request to authenticate with the server",
                    "sensitive": True,
                },
                "token_type": <ConnectionOptionInfo>{
                    "display_name": "Authorization Token Type",
                    "short_desc": "The type of authorization token",
                    "type": "string",
                    "desc": "The type of `token` to use for the `Authorization` header; ignored if no `token` "
                        "option is set",
                    "default_value": "Bearer",
                },
                "version": <ConnectionOptionInfo>{
                    "display_name": "WebSocket Version",
                    "short_desc": "Sets the WebSocket protocol version",
                    "type": "int",
                    "desc": "The WebSocket protocol version to use in the client",
                    "allowed_values": (
                        <AllowedValueInfo>{
                            "value": 8,
                            "desc": "Version 8",
                        },
                        <AllowedValueInfo>{
                            "value": 13,
                            "desc": "Version 13",
                        },
                    ),
                },
            },
        };
    }

    #! creates the WebSocketConnectionObject connection object
    /** @param name the name of the connection
        @param description connection description
        @param url connection URL (potentially with username and password info for HTTP basic authentication)
        @param attributes various attributes. See below
        @param options connection options

        See @ref AbstractConnection::constructor() for \c attributes and \c options reference.

        @throw CONNECTION-OPTION-ERROR missing or invalid connection option
    */
    constructor(string name, string description, string url, hash<auto> attributes = {}, hash<auto> options = {})
            : AbstractConnectionWithInfo(name, description, url, attributes, options) {
    }

    #! creates the WebSocketConnectionObject connection object
    /** @param config with the following keys:
        - name (required string): the connection name
        - display_name (optional string): the display name
        - short_desc (optional string): a short description in plain text
        - desc (optional string): a long description with markdown formatting
        - url (required string): the connection URL
        - opts (optional hash): connection options
        - logger (optional LoggerInterface object): logger for the connection
        @param attr optional connection attributes
        - monitor (optional bool): should the connection be monitored? Default: True
        - enabled (optional bool): is the connection enabled? Default: True
        - locked (optional bool): is the connection locked? Default: False
        - debug_data (optional bool): debug data? Default: False
        - tags (optional hash): tags for the connection; no default value

        @throw CONNECTION-OPTION-ERROR missing or invalid connection option or attribute
    */
    constructor(hash<auto> config, *hash<auto> attr) : AbstractConnectionWithInfo(config, attr) {
    }

    #! returns \c "ws"
    string getType() {
        return "ws";
    }

    #! returns runtime options
    /** @return a hash with the following keys reflecting support for the corresponding runtime options in getImpl():
        - \c "logger": a @ref Logger::LoggerInterface "LoggerInterface" object for internal logging
        - \c "start_thread": a closure to start a new thread (signature:
          @verbatim int sub start_thread(code callable) {}@endverbatim)
        - \c "yield": a closure to yield current thread execution
    */
    *hash<auto> getRuntimeOptions() {
        return {
            "logger": True,
            "start_thread": True,
            "yield": True,
        };
    }

    private hash<PingInfo> pingIntern(hash<PingInfo> rv) {
        date start = now_us();
        object o = get();
        on_exit o.disconnect();
        return rv += {
            "ok": True,
            "time": now_us() - start,
            "info": "OK",
        };
    }

    #! returns a @ref WebSocketClientWithSerialization object
    /** @param connect if @ref True "True", then @ref WebSocketClient::connect() is called
        @param rtopts supports the following runtime options in getImpl():
        - \c "logger": a @ref Logger::LoggerInterface "LoggerInterface" object for internal logging
        - \c "reconnect": try to reconnect when the connection is closed or lost (default @ref False)
        - \c "start_thread": a closure to start a new thread (signature:
          @verbatim int sub start_thread(code callable) {}@endverbatim)
        - \c "yield": a closure to yield current thread execution

        @return a @ref WebSocketClient object
    */
    private WebSocketClientWithSerialization getImpl(bool connect = True, *hash<auto> rtopts) {
        # to avoid type issues with rtopts
        if (rtopts) {
            rtopts = {} + rtopts;
        }
        hash<auto> opts = {"url": url} + rtopts{"logger", "reconnect", "yield", "start_thread"} + self.opts;
        if (!opts.logger && logger) {
            opts.logger = logger;
        }

        WebSocketClientWithSerialization ws(opts);
        if (connect) {
            ws.connect();
        }
        return ws;
    }

    #! returns an WebSocketClientDataProvider object for this connection
    /** @param constructor_options any additional constructor options for the data provider

        @return an WebSocketClientDataProvider object for this connection

        @see hasDataProvider()
    */
    DataProvider::AbstractDataProvider getDataProvider(*hash<auto> constructor_options) {
        return new WebSocketClientDataProvider({"url": url, "token": opts.token, "token_type": opts.token_type});
    }

    #! returns @ref True, as the connection returns a data provider with the @ref getDataProvider() method
    /** @return @ref True, as the connection returns a data provider with the @ref getDataProvider() method

        @see @ref getDataProvider()
    */
    bool hasDataProvider() {
        return True;
    }

    #! Sets child data provider capabilities
    private setChildCapabilities() {
        children_can_support_observers = True;
        children_can_support_messages = True;
    }

    #! Returns the ConnectionSchemeInfo hash for this object
    private hash<ConnectionSchemeInfo> getConnectionSchemeInfoImpl() {
        return ConnectionScheme;
    }
}

#! Event- and message-based data provider for WebSocket client-side events
/**
*/
public class WebSocketClientDataProviderBase inherits DataProvider::AbstractDataProvider {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "supports_children": True,
            "supports_observable": True,
            "supports_messages": MSG_Async,
            "supports_connections": True,
            "supports_auto_reconnect": True,
            "children_can_support_apis": True,
            "constructor_options": ConstructorOptions,
            "required_constructor_options": RequiredConstructorOptions,
            "desc": "Allows sending and receiving WebSocket messages to and from a WebSocket server",
            "connection_event": EVENT_WS_CONNECTED,
            "disconnection_event": EVENT_WS_CLOSED,
        };

        #! Constructor options
        const ConstructorOptions = {
            "connect_timeout": <DataProviderOptionInfo>{
                "display_name": "Connect Timeout",
                "short_desc": "Connect timeout in milliseconds",
                "type": AbstractDataProviderTypeMap."int",
                "desc": "Connection timeout to use in milliseconds",
            },
            "data": <DataProviderOptionInfo>{
                "display_name": "Data Serialization",
                "short_desc": "Data serialization for string messages",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "data serialization to use:\n"
%ifndef NoJson
                    " - `json`: JSON serialization (default)\n"
%endif
%ifndef NoYaml
                    " - `yaml`: YAML serialization\n"
%endif
                    " - `none`: no serialization; raw messages\n",
                "default_value":
%ifndef NoJson
                    "json"
%else
                    "none"
%endif
                    ,
                "allowed_values": (
%ifndef NoJson
                    <AllowedValueInfo>{
                        "value": "json",
                        "desc": "Use JSON serialization",
                    },
%endif
%ifndef NoYaml
                    <AllowedValueInfo>{
                        "value": "yaml",
                        "desc": "Use YAML serialization",
                    },
%endif
                    <AllowedValueInfo>{
                        "value": "none",
                        "desc": "Use no data serialization",
                    },
                ),
            },
            "headers": <DataProviderOptionInfo>{
                "display_name": "Request Headers",
                "short_desc": "HTTP headers to send in the request",
                "type": AbstractDataProviderTypeMap."hash",
                "desc": "HTTP headers to add in the initial connection request",
            },
            "http_version": <DataProviderOptionInfo>{
                "display_name": "HTTP Version",
                "short_desc": "HTTP version to use",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "HTTP version to use (`1.0` or `1.1`, defaults to `1.1`)",
                "default_value": "1.1",
                "allowed_values": (
                    <AllowedValueInfo>{
                        "value": "1.0",
                        "desc": "Use HTTP version \"1.0\"",
                    }, <AllowedValueInfo>{
                        "value": "1.1",
                        "desc": "Use HTTP version \"1.1\" (the default)",
                    },
                ),
            },
            "logger": <DataProviderOptionInfo>{
                "display_name": "Logger",
                "short_desc": "The logger to use",
                "type": AbstractDataProviderType::get(new Type("Logger::LoggerInterface")),
                "desc": "Any logger to use for information about data provider operations",
            },
            "max_redirects": <DataProviderOptionInfo>{
                "display_name": "Max HTTP Redirects",
                "short_desc": "Maximum HTTP redirects to support",
                "type": AbstractDataProviderTypeMap."int",
                "desc": "Maximum HTTP redirects to support",
            },
            "proxy": <DataProviderOptionInfo>{
                "display_name": "HTTP Proxy",
                "short_desc": "The HTTP proxy to use",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "The proxy URL to use",
            },
            "reconnect": <DataProviderOptionInfo>{
                "display_name": "Reconnect?",
                "short_desc": "Automatically reconnect when the connection is closed or lost",
                "type": AbstractDataProviderTypeMap."bool",
                "desc": "Automatically reconnect when the connection is closed or lost",
                "default_value": False,
            },
            "timeout": <DataProviderOptionInfo>{
                "display_name": "I/O Timeout",
                "short_desc": "Maximum time a single I/O operation can take in milliseconds",
                "type": AbstractDataProviderTypeMap."int",
                "desc": "Maximum time a single I/O operation can take in milliseconds",
            },
            "token": <DataProviderOptionInfo>{
                "display_name": "Authorization Token",
                "short_desc": "Set an authorization token to be included in requests",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "Any bearer token to use for the connection; will be passed as "
                    "`Authorization: Bearer ...`  (assuming that `token_type` is `Bearer`) in request headers; this "
                    "option cannot be used with username and password options or authentication information in the "
                    "URL; if this option is set then OAuth2 options are ignored for login",
                "sensitive": True,
            },
            "token_type": <DataProviderOptionInfo>{
                "display_name": "Authorization Token Type",
                "short_desc": "The type of authorization token",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "The type of `token` to use for the `Authorization` header; ignored if no `token` "
                    "option is set",
                "default_value": "Bearer",
            },
            "url": <DataProviderOptionInfo>{
                "display_name": "URL",
                "short_desc": "The URL to connect to",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "A URL for a WebSocket connection; either this or the `wsclient` option must be provided",
            },
            "wsclient": <DataProviderOptionInfo>{
                "display_name": "WebSocket Client",
                "short_desc": "The WebSocketClientWithSerialization object",
                "type": AbstractDataProviderType::get(new Type("WebSocketClientWithSerialization")),
                "desc": "A `WebSocketClientWithSerialization` for the connection; either this or the `url` option must "
                    "be provided; if this option is provided, then all other options are ignored",
            },
        };

        #! Required constructor option combinations
        const RequiredConstructorOptions = "url|wsclient";

        #! Registered API classes
        const ApiClasses = {
            "wait-for-message": Class::forName("WebSocketClientWaitForMessageDataProvider"),
        };
    }

    private {
        #! The web socket client itself
        WebSocketClientWithSerialization client;

        #! Mutex for wait for message child data provider handling
        Mutex m();

        #! Wait for message API data provider
        WebSocketClientWaitForMessageDataProvider child;

        #! Queued observer
        QueuedObserver queued_observer;
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) {
        hash<auto> copts = checkOptions("CONSTRUCTOR-ERROR", ConstructorOptions, options, RequiredConstructorOptions);
        if (copts.wsclient) {
            client = copts.wsclient;
            if (copts.logger) {
                setLogger(copts.logger);
            }
        } else {
            client = new WebSocketClientWithSerialization(copts);
            if (copts.logger) {
                LoggerWrapper::setLogger(logger);
            }
        }
    }

    destructor() {
        delete client;
    }

    string getName() {
        return "wsclient";
    }

    #! Accepts a LoggerInterface object for logging (or clears it)
    setLogger(*LoggerInterface logger) {
        client.setLogger(logger);
        LoggerWrapper::setLogger(logger);
    }

    #! Regstiger a child data provider
    register(WebSocketClientWaitForMessageDataProvider child) {
        AutoLock al(m);
        if (self.child) {
            throw "WEBSOCKET-ERROR", "A child data provider to wait for a message on this connection already exists; "
                "only one child data provider to wait on messages can exist at a time for a single connection";
        }
        self.child = child;
        queued_observer = new QueuedObserver();
        client.registerObserver(queued_observer);
    }

    #! Dergister a child data provider
    deregister() {
        AutoLock al(m);
        remove child;
        delete queued_observer;
    }

    #! Returs the child message queue
    Queue getQueue() {
        return queued_observer.getQueue();
    }

    #! The method registers the given observer
    registerObserver(object observer, ...) {
        client.registerObserverArgs(observer, argv);
    }

    #! The method deregisters the given observer
    /** @param observer the observer to be deregistered

        @return True if found otherwise False
    */
    bool deregisterObserver(object observer) {
        return client.deregisterObserver(observer);
    }

    #! Called when all observers have been added to the object
    /** This method is meant to trigger event generation
    */
    observersReady() {
        client.observersReady();
    }

    #! Returns True if the object is currently connected
    bool isConnected() {
        return client.isOpen();
    }

    #! Initiate a reconnect action on the client
    reconnect() {
        client.reconnect();
    }

    #! Returns connection info
    /** @return the connection hash; see @ref WebSocketClient::getConnectionInfo() for information about the \c info
        key

        @since DataProvider 3.0
    */
    private *hash<DataProviderConnectionInfo> getConnectionInfoImpl() {
        return <DataProviderConnectionInfo>{
            "connected": client.isOpen(),
            "reconnecting": client.isReconnecting(),
            "auto_reconnect": client.getReconnect(),
            "url": client.getUrl(),
            "info": client.getConnectionInfo(),
        };
    }

    #! Returns a list of child data provider names
    /** @return a list of child data provider names
    */
    private *list<string> getChildProviderNamesImpl() {
        return keys ApiClasses;
    }

    #! Returns the given child provider or @ref nothing if the given child is unknown
    /** @return the given child provider or @ref nothing if the given child is unknown

        @throw CHILD-PROVIDER-ERROR error acquiring child provider

        @see getChildProviderEx()
    */
    private *AbstractDataProvider getChildProviderImpl(string name) {
        *Class cls = ApiClasses{name};
        if (cls) {
            return cls.newObject(self);
        }
    }

    #! Returns a hash of all supported event types
    /** @return a hash of all supported event types

        @note only called if the provider supports the observer pattern / event API
    */
    private hash<string, hash<DataProviderMessageInfo>> getEventTypesImpl() {
        return {
            EVENT_WS_CONNECTED: <DataProviderMessageInfo>{
                "desc": "The event signaling that the channel has been connected",
                "type": new HashDataType(),
            },
            EVENT_WS_DATA: <DataProviderMessageInfo>{
                "desc": "A data event; data will be deserialized according to the serialization option",
                "type": new WebSocketClientEventDataType(),
            },
            EVENT_WS_PING: <DataProviderMessageInfo>{
                "desc": "A `PING` event; after this a `PONG` message should be sent",
                "type": new WebSocketClientEventDataType(),
            },
            EVENT_WS_PONG: <DataProviderMessageInfo>{
                "desc": "A `PONG` event; sent in reply to a `PING` message",
                "type": new WebSocketClientEventDataType(),
            },
            EVENT_WS_CLOSED: <DataProviderMessageInfo>{
                "desc": "The event signaling that the channel was closed",
                "type": new HashDataType(),
            },
        };
    }

    #! Returns the description of an outbound message, if any
    /** @return the message type for this provider

        @note only called if the provider supports sending messages
    */
    private hash<string, hash<DataProviderMessageInfo>> getMessageTypesImpl() {
        return {
            MESSAGE_WS_DATA: <DataProviderMessageInfo>{
                "desc": "An outgoing WebSocket message that will be serialized according to the serialization option",
                "type": client.getSerialization() == "none"
                    ? AbstractDataProviderTypeMap."data"
                    : AbstractDataProviderTypeMap."any",
            },
            MESSAGE_WS_PING: <DataProviderMessageInfo>{
                "desc": "A WebSocket `PING` message; should result in a `PONG` event being raised by the remote end",
                "type": AbstractDataProviderTypeMap."*data",
            },
            MESSAGE_WS_PONG: <DataProviderMessageInfo>{
                "desc": "A WebSocket `PONG` message; sent in reply to a `PING` message",
                "type": AbstractDataProviderTypeMap."*data",
            },
            MESSAGE_WS_RAW: <DataProviderMessageInfo>{
                "desc": "A raw WebSocket message to be sent to the remote end (without serialization)",
                "type": AbstractDataProviderTypeMap."data",
            },
        };
    }

    #! Sends a message from message-capable data providers
    /**
        @param msg the message to send
        @param send_message_options the options for sending the message
    */
    private sendMessageImpl(string message_id, auto msg, *hash<auto> send_message_options) {
        try {
            switch (message_id) {
                case MESSAGE_WS_DATA:
                    client.sendData(msg);
                    break;

                case MESSAGE_WS_RAW:
                    client.send(msg);
                    break;

                case MESSAGE_WS_PING:
                    client.ping(msg);
                    break;

                case MESSAGE_WS_PONG:
                    client.pong(msg);
                    break;

                default:
                    throw "UNSUPPORTED-MESSAGE", sprintf("message_id %y is unsupported; supported messages: %y",
                        keys getMessageTypesImpl());
            }
        } catch (hash<ExceptionInfo> ex) {
            if (logger) {
                logger.error("error sending WebSocket message: %s", get_exception_string(ex));
            }
        }
    }

    #! Returns options from a template
    static hash<auto> getOptionsFromTemplate(hash<auto> template_options, *hash<auto> options) {
        if (exists options && template_options.url) {
            # overwrite the URL with a sample value to ensure that the data provider can be created for configuration
            # information only
            template_options.url = "ws://localhost";
        }
        return template_options + options;
    }
}

#! Event-based data provider for WebSocket messaging
/**
    The event ID raised for WebSocket data events is \c "ws-data-event" (see @ref EVENT_WS_DATA), and, when the
    connection is closed, a \c "ws-closed-event" (see @ref EVENT_WS_CLOSED) is raised.
*/
public class WebSocketClientDataProvider inherits WebSocketClientDataProviderBase, DataProvider::Observable {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "WebSocketClientDataProvider",
        } + WebSocketClientDataProviderBase::ProviderInfo;
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) : WebSocketClientDataProviderBase(options) {
        client.observersReady();
    }

    #! Creates the object from constructor + template options
    constructor(hash<auto> template_options, *hash<auto> options)
            : WebSocketClientDataProviderBase(
                WebSocketClientDataProviderBase::getOptionsFromTemplate(template_options, options)
            ) {
        client.observersReady();
    }

    private hash<DataProviderInfo> getStaticInfoImpl() {
        hash<DataProviderInfo> rv = ProviderInfo;
        string safe_url = client.getSafeUrl();
        safe_url =~ s/^http/ws/;
        rv.desc = sprintf("WebSocket client to URL %y", safe_url);
        rv.supports_auto_reconnect = client.getReconnect();
        return rv;
    }
}

#! Event-based data provider for WebSocket messaging
/**
    The event ID raised for WebSocket data events is \c "ws-data-event" (see @ref EVENT_WS_DATA), and, when the
    connection is closed, a \c "ws-closed-event" (see @ref EVENT_WS_CLOSED) is raised.
*/
public class WebSocketClientDelayedDataProvider inherits WebSocketClientDataProviderBase,
        DataProvider::DelayedObservable {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "WebSocketClientDelayedDataProvider",
        } + WebSocketClientDataProviderBase::ProviderInfo;
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) : WebSocketClientDataProviderBase(options) {
    }

    #! Creates the object from constructor + template options
    constructor(hash<auto> template_options, *hash<auto> options)
            : WebSocketClientDataProviderBase(
                WebSocketClientDataProviderBase::getOptionsFromTemplate(template_options, options)
            ) {
    }

    private hash<DataProviderInfo> getStaticInfoImpl() {
        hash<DataProviderInfo> rv = ProviderInfo;
        string safe_url = client.getSafeUrl();
        safe_url =~ s/^http/ws/;
        rv.desc = sprintf("WebSocket client to URL %y", safe_url);
        rv.supports_auto_reconnect = client.getReconnect();
        return rv;
    }
}

#! WebSocket event data description
public class WebSocketClientEventDataType inherits HashDataType {
    #! Creates the type
    constructor() {
        # add members for base hashdecl
        addField(new QoreDataField("data", "The message data", AbstractDataProviderType::anyType));
    }
}

#! WebSocket client wait for message from server API data provider
public class WebSocketClientWaitForMessageDataProvider inherits AbstractDataProvider {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "WebSocketClientWaitForMessageDataProvider",
            "supports_request": True,
            "desc": "Waits for a WebSocket message to be received from the server within a timeout period and "
                "returns the message if one is received in the timeout perdiod, or an exception is thrown",
        };

        #! Request type
        const RequestType = new WebSocketClientWaitForMessageRequestDataType();

        #! Response type
        const ResponseType = AbstractDataProviderTypeMap."any";
    }

    private {
        WebSocketClientDataProviderBase base;
    }

    #! Creates the object
    constructor(WebSocketClientDataProviderBase base) {
        base.register(self);
        self.base = base;
    }

    #! Deletes the object
    destructor() {
        if (base) {
            base.deregister();
        }
    }

    #! Returns the data provider name
    string getName() {
        return "wait-for-message";
    }

    #! Makes a request and returns the response
    /** @param req the request to serialize and make according to the request type
        @param request_options the request options; will be processed by validateRequestOptions()

        @return the response to the request
    */
    private auto doRequestImpl(auto req, *hash<auto> request_options) {
        Queue q = base.getQueue();
        on_error if ($1.err == "QUEUE-TIMEOUT") {
            rethrow "WEBSOCKET-RECV-TIMEOUT", sprintf("timed out waiting for WebSocket message: %s: %s", $1.err,
                $1.desc);
        }
        return q.get(req."timeout");
    }

    #! Returns the description of a successful request message, if any
    /** @return the request type for this provider
    */
    private *AbstractDataProviderType getRequestTypeImpl() {
        return RequestType;
    }

    #! Returns the description of a response message, if this object represents a response message
    /** @return the response type for this response message
    */
    private *AbstractDataProviderType getResponseTypeImpl() {
        return ResponseType;
    }

    #! Returns data provider static info
    hash<DataProviderInfo> getStaticInfoImpl() {
        return ProviderInfo;
    }
}

#! Data type for delete order calls
public class WebSocketClientWaitForMessageRequestDataType inherits HashDataType {
    public {
        #! Field descriptions
        const Fields = {
            "timeout": {
                "type": IntType,
                "desc": "The number of milliseconds to wait for an incoming message; after this point, if no "
                    "WebSocket message has been received, an exception will be thrown",
                "required": True,
                "default_value": 10000,
            },
        };
    }

    #! Creates the object
    constructor() {
        map addField(new QoreDataField($1.key, $1.value.desc, $1.value.type, $1.value.default_value)),
            Fields.pairIterator();
    }
}

#! The WebSocket data provider factory
public class WebSocketClientDataProviderFactory inherits AbstractDataProviderFactory {
    private {
        #! Data provider type info
        static Class cls = new Class("WebSocketClientDelayedDataProvider");

        #! Factory info
        const FactoryInfo = <DataProviderFactoryInfo>{
            "name": "wsclient",
            "desc": "WebSocket client data provider factory",
            "children_can_support_observers": True,
            "children_can_support_messages": True,
        };
    }

    #! Returns static factory information without \a provider_info
    /** @return static factory information without \a provider_info which is provided by @ref getProviderInfo()
    */
    private hash<DataProviderFactoryInfo> getInfoImpl() {
        return FactoryInfo;
    }

    #! Returns static provider information
    /** @note the \c name and \c children attributes are not returned as they are dynamic attributes
    */
    private hash<DataProviderInfo> getProviderInfoImpl() {
        return WebSocketClientDataProvider::ProviderInfo;
    }

    #! Returns the class for the data provider object
    private Class getClassImpl() {
        return cls;
    }
}
}

namespace Priv {
const WebSocketsLogoLight = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>
<svg
   width=\"100%\"
   height=\"100%\"
   viewBox=\"0 0 567 567\"
   version=\"1.1\"
   xml:space=\"preserve\"
   style=\"fill-rule:evenodd;clip-rule:evenodd;\"
   id=\"svg12\"
   sodipodi:docname=\"WebSockets-icon.svg\"
   inkscape:version=\"1.3.2 (091e20ef0f, 2023-11-25)\"
   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"
   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"
   xmlns:xlink=\"http://www.w3.org/1999/xlink\"
   xmlns=\"http://www.w3.org/2000/svg\"
   xmlns:svg=\"http://www.w3.org/2000/svg\"
   xmlns:serif=\"http://www.serif.com/\"><sodipodi:namedview
   id=\"namedview12\"
   pagecolor=\"#ffffff\"
   bordercolor=\"#666666\"
   borderopacity=\"1.0\"
   inkscape:showpageshadow=\"2\"
   inkscape:pageopacity=\"0.0\"
   inkscape:pagecheckerboard=\"0\"
   inkscape:deskcolor=\"#d1d1d1\"
   inkscape:zoom=\"2.7897686\"
   inkscape:cx=\"292.49737\"
   inkscape:cy=\"283.53606\"
   inkscape:window-width=\"3732\"
   inkscape:window-height=\"2077\"
   inkscape:window-x=\"108\"
   inkscape:window-y=\"52\"
   inkscape:window-maximized=\"1\"
   inkscape:current-layer=\"svg12\" />
    <g
   id=\"Layer-1\"
   serif:id=\"Layer 1\"
   transform=\"matrix(1.15,0,0,1.15,-42.279825,-42.675075)\">
        <g
   id=\"g5\"
   transform=\"translate(0,-21)\">
            <path
   id=\"rect1\"
   d=\"m 445.886,268.502 c 0,-34.436 -27.957,-62.393 -62.393,-62.393 H 182.735 c -34.436,0 -62.393,27.957 -62.393,62.393 V 457.2 c 0,34.435 27.957,62.393 62.393,62.393 h 200.758 c 34.436,0 62.393,-27.958 62.393,-62.393 z\"
   style=\"fill:#b3d9ff;stroke:#ffffff;stroke-width:2.31px\" />
            <rect
   id=\"rect2\"
   x=\"186.959\"
   y=\"280.08301\"
   width=\"33.727001\"
   height=\"80.473\"
   style=\"fill:#ffffff;stroke:#ffffff;stroke-width:2.31px\" />
            <g
   id=\"g3\"
   transform=\"matrix(1.44,0,0,1.44,60.276,91.5143)\">
                <ellipse
   id=\"path2\"
   cx=\"156.45799\"
   cy=\"231.332\"
   rx=\"13.39\"
   ry=\"15.519\"
   style=\"fill:#ffffff;stroke:#ffffff;stroke-width:1.57px\" />
                <rect
   id=\"rect3\"
   x=\"143.371\"
   y=\"230.964\"
   width=\"26.707001\"
   height=\"25.537001\"
   style=\"fill:#ffffff;stroke:#ffffff;stroke-width:1.64px\" />
            </g>
            <g
   id=\"image1\"
   transform=\"matrix(1.08,0,0,1.08,340.423,278.93)\">
                <use
   xlink:href=\"#_Image1\"
   x=\"0\"
   y=\"0\"
   width=\"33\"
   height=\"77\"
   id=\"use1\" />
            </g>
        </g>
        <g
   transform=\"translate(46.2005,136.933)\"
   id=\"g12\">
            <g
   id=\"text5\">
                <g
   id=\"g11\">
                    <path
   d=\"m 61.2,-4.23 c -0.54,3.06 -2.4,4.59 -5.58,4.59 h -3.87 c -2.64,0 -4.35,-1.5 -5.13,-4.5 l -8.82,-33.3 c -0.12,-0.54 -0.3,-0.81 -0.54,-0.81 h -0.18 c -0.24,0 -0.42,0.27 -0.54,0.81 l -8.91,33.3 c -0.78,3 -2.49,4.5 -5.13,4.5 h -3.78 c -3.18,0 -5.04,-1.53 -5.58,-4.59 L 3.15,-65.34 c 0,-1.02 0.51,-1.53 1.53,-1.53 H 9.9 c 0.84,0 1.35,0.51 1.53,1.53 l 8.73,57.33 c 0.18,0.9 0.33,1.35 0.45,1.35 0.24,0 0.45,-0.45 0.63,-1.35 l 8.82,-33.3 c 0.6,-2.4 2.01,-3.6 4.23,-3.6 h 5.76 c 2.22,0 3.63,1.2 4.23,3.6 l 8.82,33.3 c 0.18,0.9 0.39,1.35 0.63,1.35 0.12,0 0.27,-0.45 0.45,-1.35 l 8.73,-57.33 c 0.18,-1.02 0.69,-1.53 1.53,-1.53 h 5.22 c 1.02,0 1.53,0.51 1.53,1.53 z\"
   style=\"fill:#b3d9ff;fill-rule:nonzero\"
   id=\"path1\" />
                    <path
   d=\"m 115.74,-24.21 c 0,1.32 -0.57,1.98 -1.71,1.98 H 83.88 v 1.26 c 0,5.22 1.05,9 3.15,11.34 1.98,2.22 5.1,3.33 9.36,3.33 6.36,0 11.7,-0.33 16.02,-0.99 h 0.45 c 0.96,0 1.44,0.42 1.44,1.26 v 3.06 c 0,1.14 -0.6,1.83 -1.8,2.07 -5.28,1.02 -10.65,1.53 -16.11,1.53 -5.94,0 -10.65,-1.5 -14.13,-4.5 -4.2,-3.66 -6.3,-9.36 -6.3,-17.1 v -8.1 c 0,-6.54 1.71,-11.67 5.13,-15.39 3.54,-3.78 8.49,-5.67 14.85,-5.67 6.42,0 11.37,1.92 14.85,5.76 3.3,3.66 4.95,8.76 4.95,15.3 z m -8.01,-4.86 c 0,-9.42 -3.93,-14.13 -11.79,-14.13 -8.04,0 -12.06,4.71 -12.06,14.13 v 0.81 h 23.85 z\"
   style=\"fill:#b3d9ff;fill-rule:nonzero\"
   id=\"path3\" />
                    <path
   d=\"m 164.61,-21.6 c 0,14.82 -6.54,22.23 -19.62,22.23 -5.76,0 -11.28,-0.51 -16.56,-1.53 -1.26,-0.24 -1.89,-0.93 -1.89,-2.07 v -63 c 0,-1.14 0.54,-1.71 1.62,-1.71 h 4.59 c 1.14,0 1.71,0.57 1.71,1.71 v 16.74 c 3.24,-0.6 6.75,-0.9 10.53,-0.9 13.08,0 19.62,7.35 19.62,22.05 z m -7.92,-6.48 c 0,-5.04 -0.84,-8.76 -2.52,-11.16 -1.86,-2.64 -4.92,-3.96 -9.18,-3.96 -4.68,0 -8.19,0.21 -10.53,0.63 v 35.73 c 4.08,0.36 7.59,0.54 10.53,0.54 4.26,0 7.32,-1.32 9.18,-3.96 1.68,-2.4 2.52,-6.18 2.52,-11.34 z\"
   style=\"fill:#b3d9ff;fill-rule:nonzero\"
   id=\"path4\" />
                    <path
   d=\"m 214.11,-17.37 c 0,12 -7.41,18 -22.23,18 -4.68,0 -9.66,-0.42 -14.94,-1.26 -1.14,-0.18 -1.71,-0.72 -1.71,-1.62 v -3.6 c 0,-0.96 0.51,-1.44 1.53,-1.44 h 0.27 c 4.14,0.36 9.09,0.54 14.85,0.54 9.12,0 13.68,-3.54 13.68,-10.62 0,-2.22 -0.78,-4.17 -2.34,-5.85 -1.44,-1.56 -4.26,-3.63 -8.46,-6.21 l -8.73,-5.31 c -8.28,-5.04 -12.42,-10.65 -12.42,-16.83 0,-10.62 7.17,-15.93 21.51,-15.93 5.88,0 11.1,0.36 15.66,1.08 1.02,0.18 1.53,0.69 1.53,1.53 v 3.87 c 0,0.96 -0.51,1.44 -1.53,1.44 h -0.18 c -5.28,-0.36 -10.44,-0.54 -15.48,-0.54 -4.74,0 -8.1,0.6 -10.08,1.8 -2.1,1.26 -3.15,3.51 -3.15,6.75 0,3.3 3.27,6.93 9.81,10.89 l 8.28,4.95 c 9.42,5.58 14.13,11.7 14.13,18.36 z\"
   style=\"fill:#b3d9ff;fill-rule:nonzero\"
   id=\"path5\" />
                    <path
   d=\"m 263.16,-21.33 c 0,6.78 -1.68,12.09 -5.04,15.93 -3.54,4.02 -8.55,6.03 -15.03,6.03 -6.48,0 -11.46,-2.01 -14.94,-6.03 -3.36,-3.84 -5.04,-9.15 -5.04,-15.93 v -6.84 c 0,-6.78 1.68,-12.09 5.04,-15.93 3.48,-4.02 8.46,-6.03 14.94,-6.03 6.48,0 11.49,2.01 15.03,6.03 3.36,3.84 5.04,9.15 5.04,15.93 z m -7.92,-6.84 c 0,-10.02 -4.05,-15.03 -12.15,-15.03 -8.04,0 -12.06,5.01 -12.06,15.03 v 6.84 c 0,10.02 4.02,15.03 12.06,15.03 8.1,0 12.15,-5.01 12.15,-15.03 z\"
   style=\"fill:#B3D9FF;fill-rule:nonzero\"
   id=\"path6\" />
                    <path
   d=\"m 304.38,-2.34 c 0,1.08 -0.6,1.74 -1.8,1.98 -3.6,0.66 -7.35,0.99 -11.25,0.99 -6.06,0 -10.77,-1.98 -14.13,-5.94 -3.36,-3.9 -5.04,-9.21 -5.04,-15.93 v -7.02 c 0,-6.72 1.65,-12.03 4.95,-15.93 3.42,-3.96 8.16,-5.94 14.22,-5.94 3.9,0 7.65,0.33 11.25,0.99 1.2,0.24 1.8,0.9 1.8,1.98 v 3.24 c 0,0.9 -0.51,1.35 -1.53,1.35 h -0.36 c -3.72,-0.42 -7.44,-0.63 -11.16,-0.63 -7.5,0 -11.25,4.98 -11.25,14.94 v 7.02 c 0,9.96 3.75,14.94 11.25,14.94 3.72,0 7.44,-0.21 11.16,-0.63 h 0.36 c 1.02,0 1.53,0.45 1.53,1.35 z\"
   style=\"fill:#B3D9FF;fill-rule:nonzero\"
   id=\"path7\" />
                    <path
   d=\"m 349.83,-1.17 c 0,0.78 -0.33,1.17 -0.99,1.17 h -6.48 c -0.78,0 -1.47,-0.39 -2.07,-1.17 L 322.38,-23.31 V -1.8 c 0,1.2 -0.6,1.8 -1.8,1.8 h -4.32 c -1.2,0 -1.8,-0.6 -1.8,-1.8 v -64.08 c 0,-1.2 0.6,-1.8 1.8,-1.8 h 4.32 c 1.2,0 1.8,0.6 1.8,1.8 v 37.44 l 18,-20.25 c 0.48,-0.54 1.08,-0.81 1.8,-0.81 h 6.3 c 0.9,0 1.35,0.33 1.35,0.99 0,0.36 -0.15,0.69 -0.45,0.99 l -19.8,21.42 19.98,24.12 c 0.18,0.18 0.27,0.45 0.27,0.81 z\"
   style=\"fill:#B3D9FF;fill-rule:nonzero\"
   id=\"path8\" />
                    <path
   d=\"m 394.11,-24.21 c 0,1.32 -0.57,1.98 -1.71,1.98 h -30.15 v 1.26 c 0,5.22 1.05,9 3.15,11.34 1.98,2.22 5.1,3.33 9.36,3.33 6.36,0 11.7,-0.33 16.02,-0.99 h 0.45 c 0.96,0 1.44,0.42 1.44,1.26 v 3.06 c 0,1.14 -0.6,1.83 -1.8,2.07 -5.28,1.02 -10.65,1.53 -16.11,1.53 -5.94,0 -10.65,-1.5 -14.13,-4.5 -4.2,-3.66 -6.3,-9.36 -6.3,-17.1 v -8.1 c 0,-6.54 1.71,-11.67 5.13,-15.39 3.54,-3.78 8.49,-5.67 14.85,-5.67 6.42,0 11.37,1.92 14.85,5.76 3.3,3.66 4.95,8.76 4.95,15.3 z m -8.01,-4.86 c 0,-9.42 -3.93,-14.13 -11.79,-14.13 -8.04,0 -12.06,4.71 -12.06,14.13 v 0.81 h 23.85 z\"
   style=\"fill:#B3D9FF;fill-rule:nonzero\"
   id=\"path9\" />
                    <path
   d=\"m 428.49,-1.35 c 0,0.84 -0.54,1.35 -1.62,1.53 -1.98,0.3 -3.93,0.45 -5.85,0.45 -4.38,0 -7.44,-0.78 -9.18,-2.34 -2.04,-1.74 -3.06,-4.98 -3.06,-9.72 v -31.41 l -8.73,-0.99 c -1.14,-0.12 -1.71,-0.66 -1.71,-1.62 v -2.43 c 0,-1.08 0.57,-1.62 1.71,-1.62 h 8.73 v -8.82 c 0,-1.02 0.54,-1.62 1.62,-1.8 l 4.95,-0.72 c 0.9,0 1.35,0.51 1.35,1.53 v 9.81 h 9.72 c 1.2,0 1.8,0.6 1.8,1.8 v 3.06 c 0,1.2 -0.6,1.8 -1.8,1.8 h -9.72 v 31.41 c 0,2.4 0.36,3.96 1.08,4.68 0.6,0.66 1.86,0.99 3.78,0.99 h 5.04 c 1.26,0 1.89,0.42 1.89,1.26 z\"
   style=\"fill:#B3D9FF;fill-rule:nonzero\"
   id=\"path10\" />
                    <path
   d=\"m 468.18,-12.42 c 0,8.7 -5.61,13.05 -16.83,13.05 -5.82,0 -10.56,-0.45 -14.22,-1.35 -1.26,-0.3 -1.89,-0.9 -1.89,-1.8 v -3.15 c 0,-0.9 0.54,-1.35 1.62,-1.35 h 0.36 c 5.28,0.66 9.99,0.99 14.13,0.99 5.94,0 8.91,-2.13 8.91,-6.39 0,-2.28 -2.25,-4.77 -6.75,-7.47 l -9.09,-5.4 c -6.12,-3.72 -9.18,-8.01 -9.18,-12.87 0,-7.98 5.43,-11.97 16.29,-11.97 4.8,0 9.48,0.39 14.04,1.17 1.14,0.18 1.71,0.78 1.71,1.8 v 2.97 c 0,1.02 -0.51,1.53 -1.53,1.53 h -0.27 c -5.58,-0.48 -10.23,-0.72 -13.95,-0.72 -2.88,0 -4.89,0.3 -6.03,0.9 -1.56,0.78 -2.34,2.22 -2.34,4.32 0,2.1 2.07,4.38 6.21,6.84 l 8.91,5.31 c 6.6,3.9 9.9,8.43 9.9,13.59 z\"
   style=\"fill:#B3D9FF;fill-rule:nonzero\"
   id=\"path11\" />
                </g>
            </g>
        </g>
    </g>
    <defs
   id=\"defs12\">
        <image
   id=\"_Image1\"
   width=\"33px\"
   height=\"77px\"
   xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAABNCAYAAAAo0g1OAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAWUlEQVRoge3OMRHAMAwAMbf8ObvTXyEkg4RAz+7uHPaeDsxI/CQiEYlIRCISkYhEJCIRiUhEIhKRiEQkIhGJSEQiEpGIRCQiEYlIRCISkYhEJCIRiUjkisQHlFkElhVBWMoAAAAASUVORK5CYII=\" />
    </defs>
</svg>";
#! Logo for the WebSockets app
const WebSocketsLogoDark = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>
<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">
<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 567 567\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" xmlns:serif=\"http://www.serif.com/\" style=\"fill-rule:evenodd;clip-rule:evenodd;\">
    <g id=\"Layer-1\" serif:id=\"Layer 1\">
        <g id=\"g5\" transform=\"matrix(1,0,0,1,0,-21)\">
            <path id=\"rect1\" d=\"M445.886,268.502C445.886,234.066 417.929,206.109 383.493,206.109L182.735,206.109C148.299,206.109 120.342,234.066 120.342,268.502L120.342,457.2C120.342,491.635 148.299,519.593 182.735,519.593L383.493,519.593C417.929,519.593 445.886,491.635 445.886,457.2L445.886,268.502Z\" style=\"fill:rgb(0,12,60);stroke:white;stroke-width:2.31px;\"/>
            <rect id=\"rect2\" x=\"186.959\" y=\"280.083\" width=\"33.727\" height=\"80.473\" style=\"fill:white;stroke:white;stroke-width:2.31px;\"/>
            <g id=\"g3\" transform=\"matrix(1.44,0,0,1.44,60.276,91.5143)\">
                <ellipse id=\"path2\" cx=\"156.458\" cy=\"231.332\" rx=\"13.39\" ry=\"15.519\" style=\"fill:white;stroke:white;stroke-width:1.57px;\"/>
                <rect id=\"rect3\" x=\"143.371\" y=\"230.964\" width=\"26.707\" height=\"25.537\" style=\"fill:white;stroke:white;stroke-width:1.64px;\"/>
            </g>
            <g id=\"image1\" transform=\"matrix(1.08,0,0,1.08,340.423,278.93)\">
                <use xlink:href=\"#_Image1\" x=\"0\" y=\"0\" width=\"33px\" height=\"77px\"/>
            </g>
        </g>
        <g transform=\"matrix(1,0,0,1,46.2005,136.933)\">
            <g id=\"text5\">
                <g>
                    <path d=\"M61.2,-4.23C60.66,-1.17 58.8,0.36 55.62,0.36L51.75,0.36C49.11,0.36 47.4,-1.14 46.62,-4.14L37.8,-37.44C37.68,-37.98 37.5,-38.25 37.26,-38.25L37.08,-38.25C36.84,-38.25 36.66,-37.98 36.54,-37.44L27.63,-4.14C26.85,-1.14 25.14,0.36 22.5,0.36L18.72,0.36C15.54,0.36 13.68,-1.17 13.14,-4.23L3.15,-65.34C3.15,-66.36 3.66,-66.87 4.68,-66.87L9.9,-66.87C10.74,-66.87 11.25,-66.36 11.43,-65.34L20.16,-8.01C20.34,-7.11 20.49,-6.66 20.61,-6.66C20.85,-6.66 21.06,-7.11 21.24,-8.01L30.06,-41.31C30.66,-43.71 32.07,-44.91 34.29,-44.91L40.05,-44.91C42.27,-44.91 43.68,-43.71 44.28,-41.31L53.1,-8.01C53.28,-7.11 53.49,-6.66 53.73,-6.66C53.85,-6.66 54,-7.11 54.18,-8.01L62.91,-65.34C63.09,-66.36 63.6,-66.87 64.44,-66.87L69.66,-66.87C70.68,-66.87 71.19,-66.36 71.19,-65.34L61.2,-4.23Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M115.74,-24.21C115.74,-22.89 115.17,-22.23 114.03,-22.23L83.88,-22.23L83.88,-20.97C83.88,-15.75 84.93,-11.97 87.03,-9.63C89.01,-7.41 92.13,-6.3 96.39,-6.3C102.75,-6.3 108.09,-6.63 112.41,-7.29L112.86,-7.29C113.82,-7.29 114.3,-6.87 114.3,-6.03L114.3,-2.97C114.3,-1.83 113.7,-1.14 112.5,-0.9C107.22,0.12 101.85,0.63 96.39,0.63C90.45,0.63 85.74,-0.87 82.26,-3.87C78.06,-7.53 75.96,-13.23 75.96,-20.97L75.96,-29.07C75.96,-35.61 77.67,-40.74 81.09,-44.46C84.63,-48.24 89.58,-50.13 95.94,-50.13C102.36,-50.13 107.31,-48.21 110.79,-44.37C114.09,-40.71 115.74,-35.61 115.74,-29.07L115.74,-24.21ZM107.73,-29.07C107.73,-38.49 103.8,-43.2 95.94,-43.2C87.9,-43.2 83.88,-38.49 83.88,-29.07L83.88,-28.26L107.73,-28.26L107.73,-29.07Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M164.61,-21.6C164.61,-6.78 158.07,0.63 144.99,0.63C139.23,0.63 133.71,0.12 128.43,-0.9C127.17,-1.14 126.54,-1.83 126.54,-2.97L126.54,-65.97C126.54,-67.11 127.08,-67.68 128.16,-67.68L132.75,-67.68C133.89,-67.68 134.46,-67.11 134.46,-65.97L134.46,-49.23C137.7,-49.83 141.21,-50.13 144.99,-50.13C158.07,-50.13 164.61,-42.78 164.61,-28.08L164.61,-21.6ZM156.69,-28.08C156.69,-33.12 155.85,-36.84 154.17,-39.24C152.31,-41.88 149.25,-43.2 144.99,-43.2C140.31,-43.2 136.8,-42.99 134.46,-42.57L134.46,-6.84C138.54,-6.48 142.05,-6.3 144.99,-6.3C149.25,-6.3 152.31,-7.62 154.17,-10.26C155.85,-12.66 156.69,-16.44 156.69,-21.6L156.69,-28.08Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M214.11,-17.37C214.11,-5.37 206.7,0.63 191.88,0.63C187.2,0.63 182.22,0.21 176.94,-0.63C175.8,-0.81 175.23,-1.35 175.23,-2.25L175.23,-5.85C175.23,-6.81 175.74,-7.29 176.76,-7.29L177.03,-7.29C181.17,-6.93 186.12,-6.75 191.88,-6.75C201,-6.75 205.56,-10.29 205.56,-17.37C205.56,-19.59 204.78,-21.54 203.22,-23.22C201.78,-24.78 198.96,-26.85 194.76,-29.43L186.03,-34.74C177.75,-39.78 173.61,-45.39 173.61,-51.57C173.61,-62.19 180.78,-67.5 195.12,-67.5C201,-67.5 206.22,-67.14 210.78,-66.42C211.8,-66.24 212.31,-65.73 212.31,-64.89L212.31,-61.02C212.31,-60.06 211.8,-59.58 210.78,-59.58L210.6,-59.58C205.32,-59.94 200.16,-60.12 195.12,-60.12C190.38,-60.12 187.02,-59.52 185.04,-58.32C182.94,-57.06 181.89,-54.81 181.89,-51.57C181.89,-48.27 185.16,-44.64 191.7,-40.68L199.98,-35.73C209.4,-30.15 214.11,-24.03 214.11,-17.37Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M263.16,-21.33C263.16,-14.55 261.48,-9.24 258.12,-5.4C254.58,-1.38 249.57,0.63 243.09,0.63C236.61,0.63 231.63,-1.38 228.15,-5.4C224.79,-9.24 223.11,-14.55 223.11,-21.33L223.11,-28.17C223.11,-34.95 224.79,-40.26 228.15,-44.1C231.63,-48.12 236.61,-50.13 243.09,-50.13C249.57,-50.13 254.58,-48.12 258.12,-44.1C261.48,-40.26 263.16,-34.95 263.16,-28.17L263.16,-21.33ZM255.24,-28.17C255.24,-38.19 251.19,-43.2 243.09,-43.2C235.05,-43.2 231.03,-38.19 231.03,-28.17L231.03,-21.33C231.03,-11.31 235.05,-6.3 243.09,-6.3C251.19,-6.3 255.24,-11.31 255.24,-21.33L255.24,-28.17Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M304.38,-2.34C304.38,-1.26 303.78,-0.6 302.58,-0.36C298.98,0.3 295.23,0.63 291.33,0.63C285.27,0.63 280.56,-1.35 277.2,-5.31C273.84,-9.21 272.16,-14.52 272.16,-21.24L272.16,-28.26C272.16,-34.98 273.81,-40.29 277.11,-44.19C280.53,-48.15 285.27,-50.13 291.33,-50.13C295.23,-50.13 298.98,-49.8 302.58,-49.14C303.78,-48.9 304.38,-48.24 304.38,-47.16L304.38,-43.92C304.38,-43.02 303.87,-42.57 302.85,-42.57L302.49,-42.57C298.77,-42.99 295.05,-43.2 291.33,-43.2C283.83,-43.2 280.08,-38.22 280.08,-28.26L280.08,-21.24C280.08,-11.28 283.83,-6.3 291.33,-6.3C295.05,-6.3 298.77,-6.51 302.49,-6.93L302.85,-6.93C303.87,-6.93 304.38,-6.48 304.38,-5.58L304.38,-2.34Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M349.83,-1.17C349.83,-0.39 349.5,0 348.84,0L342.36,0C341.58,0 340.89,-0.39 340.29,-1.17L322.38,-23.31L322.38,-1.8C322.38,-0.6 321.78,0 320.58,0L316.26,0C315.06,0 314.46,-0.6 314.46,-1.8L314.46,-65.88C314.46,-67.08 315.06,-67.68 316.26,-67.68L320.58,-67.68C321.78,-67.68 322.38,-67.08 322.38,-65.88L322.38,-28.44L340.38,-48.69C340.86,-49.23 341.46,-49.5 342.18,-49.5L348.48,-49.5C349.38,-49.5 349.83,-49.17 349.83,-48.51C349.83,-48.15 349.68,-47.82 349.38,-47.52L329.58,-26.1L349.56,-1.98C349.74,-1.8 349.83,-1.53 349.83,-1.17Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M394.11,-24.21C394.11,-22.89 393.54,-22.23 392.4,-22.23L362.25,-22.23L362.25,-20.97C362.25,-15.75 363.3,-11.97 365.4,-9.63C367.38,-7.41 370.5,-6.3 374.76,-6.3C381.12,-6.3 386.46,-6.63 390.78,-7.29L391.23,-7.29C392.19,-7.29 392.67,-6.87 392.67,-6.03L392.67,-2.97C392.67,-1.83 392.07,-1.14 390.87,-0.9C385.59,0.12 380.22,0.63 374.76,0.63C368.82,0.63 364.11,-0.87 360.63,-3.87C356.43,-7.53 354.33,-13.23 354.33,-20.97L354.33,-29.07C354.33,-35.61 356.04,-40.74 359.46,-44.46C363,-48.24 367.95,-50.13 374.31,-50.13C380.73,-50.13 385.68,-48.21 389.16,-44.37C392.46,-40.71 394.11,-35.61 394.11,-29.07L394.11,-24.21ZM386.1,-29.07C386.1,-38.49 382.17,-43.2 374.31,-43.2C366.27,-43.2 362.25,-38.49 362.25,-29.07L362.25,-28.26L386.1,-28.26L386.1,-29.07Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M428.49,-1.35C428.49,-0.51 427.95,0 426.87,0.18C424.89,0.48 422.94,0.63 421.02,0.63C416.64,0.63 413.58,-0.15 411.84,-1.71C409.8,-3.45 408.78,-6.69 408.78,-11.43L408.78,-42.84L400.05,-43.83C398.91,-43.95 398.34,-44.49 398.34,-45.45L398.34,-47.88C398.34,-48.96 398.91,-49.5 400.05,-49.5L408.78,-49.5L408.78,-58.32C408.78,-59.34 409.32,-59.94 410.4,-60.12L415.35,-60.84C416.25,-60.84 416.7,-60.33 416.7,-59.31L416.7,-49.5L426.42,-49.5C427.62,-49.5 428.22,-48.9 428.22,-47.7L428.22,-44.64C428.22,-43.44 427.62,-42.84 426.42,-42.84L416.7,-42.84L416.7,-11.43C416.7,-9.03 417.06,-7.47 417.78,-6.75C418.38,-6.09 419.64,-5.76 421.56,-5.76L426.6,-5.76C427.86,-5.76 428.49,-5.34 428.49,-4.5L428.49,-1.35Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                    <path d=\"M468.18,-12.42C468.18,-3.72 462.57,0.63 451.35,0.63C445.53,0.63 440.79,0.18 437.13,-0.72C435.87,-1.02 435.24,-1.62 435.24,-2.52L435.24,-5.67C435.24,-6.57 435.78,-7.02 436.86,-7.02L437.22,-7.02C442.5,-6.36 447.21,-6.03 451.35,-6.03C457.29,-6.03 460.26,-8.16 460.26,-12.42C460.26,-14.7 458.01,-17.19 453.51,-19.89L444.42,-25.29C438.3,-29.01 435.24,-33.3 435.24,-38.16C435.24,-46.14 440.67,-50.13 451.53,-50.13C456.33,-50.13 461.01,-49.74 465.57,-48.96C466.71,-48.78 467.28,-48.18 467.28,-47.16L467.28,-44.19C467.28,-43.17 466.77,-42.66 465.75,-42.66L465.48,-42.66C459.9,-43.14 455.25,-43.38 451.53,-43.38C448.65,-43.38 446.64,-43.08 445.5,-42.48C443.94,-41.7 443.16,-40.26 443.16,-38.16C443.16,-36.06 445.23,-33.78 449.37,-31.32L458.28,-26.01C464.88,-22.11 468.18,-17.58 468.18,-12.42Z\" style=\"fill:rgb(0,0,70);fill-rule:nonzero;\"/>
                </g>
            </g>
        </g>
    </g>
    <defs>
        <image id=\"_Image1\" width=\"33px\" height=\"77px\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAABNCAYAAAAo0g1OAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAWUlEQVRoge3OMRHAMAwAMbf8ObvTXyEkg4RAz+7uHPaeDsxI/CQiEYlIRCISkYhEJCIRiUhEIhKRiEQkIhGJSEQiEpGIRCQiEYlIRCISkYhEJCIRiUjkisQHlFkElhVBWMoAAAAASUVORK5CYII=\"/>
    </defs>
</svg>";

class QueuedObserver inherits DataProvider::Observer {
    private {
        Queue q();
    }

    Queue getQueue() {
        return q;
    }

    #! This method is called when an event is raised
    update(string event_id, hash<auto> data_) {
        q.push(data_."data");
    }
}
}