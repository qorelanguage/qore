# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file HttpServerUtil.qm HTTP server base code

/*  HttpServerUtil.qm Copyright (C) 2014 - 2023 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%requires qore >= 1.0
%requires Mime >= 1.0
%requires(reexport) Util >= 1.0
%requires Logger
%requires FileLocationHandler

%new-style
%require-types
%strict-args
%enable-all-warnings

module HttpServerUtil {
    version = "1.1";
    desc = "HttpServerUtil class definition";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage HttpServerUtil Module

    @tableofcontents

    @section httpserverutilintro HttpServerUtil Introduction

    The %HttpServerUtil module provides a base code for the <a href="../../HttpServer/html/index.html">HttpServer</a>
    module and code requiring HttpServer definitions but not the entire
    <a href="../../HttpServer/html/index.html">HttpServer</a> module itself.

    To use this module, use \c "%requires HttpServerUtil" in your code.

    All the public symbols in the module are defined in the HttpServer namespace

    The main classes are:
    - @ref HttpServer::AbstractAuthenticator "AbstractAuthenticator": can be implemented to provide authentication and
      authorization info to the server
    - @ref HttpServer::AbstractHttpRequestHandler "AbstractHttpRequestHandler": this class must be subclassed to
      provide the real work of the HttpServer handling connections
    - @ref HttpServer::AbstractHttpSocketHandler "AbstractHttpSocketHandler": this class must be subclassed to
      implement a dedicated socket handler for protcol changes (for an example, see the
      <a href="../../WebSocketHandler/html/index.html">WebSocketHandler</a> module)
    - @ref HttpServer::AbstractLogger "AbstractLogger": this abstract class provides an interface for classes
      providing basic logging methods
    - @ref HttpServer::AbstractStreamRequest "AbstractStreamRequest": this class is used to directly handle HTTP
      chunked requests and responses
    - @ref HttpServer::AbstractUrlHandler "AbstractUrlHandler": this class serves as a base class for handler classes
      that serve requests anchored at a particular URL
    - @ref HttpServer::HttpListenerInterface "HttpListenerInterface": this abstract class provides the interface for
      the private HttpListener class implemented in the <a href="../../HttpServer/html/index.html">HttpServer</a>
      module
    - @ref HttpServer::PermissiveAuthenticator "PermissiveAuthenticator": this class implements a dummy authenticator
      that accepts all requests

    See also:
    - <a href="../../RestHandler/html/index.html">RestHandler</a>: a module providing a handler framework for this
      module for implementing server-side REST services
    - <a href="../../WebSocketHandler/html/index.html">WebSocketHandler</a>: a module providing a handler framework
      for this module for implementing server-side WebSocket services
    - <a href="../../WebUtil/html/index.html">WebUtil</a>: a module providing higher-level HTTP services using this
      module as a base as well as providing support for dynamic template-based HTML rendering (ie rendering qhtml
      files which are a mix of HTML and Qore code)
    - <a href="http://www.qore.org/manual/modules/json/current/JsonRpcHandler/html/index.html">JsonRpcHandler</a>:
      provides infrastructure for implementing JSON-RPC server-side services using the HttpServer module
    - <a href="http://www.qore.org/manual/modules/yaml/current/YamlRpcHandler/html/index.html">YamlRpcHandler</a>:
      provides infrastructure for implementing YAML-RPC server-side services using the HttpServer module
    - <a href="http://www.qore.org/manual/modules/xml/current/XmlRpcHandler/html/index.html">XmlRpcHandler</a>:
      provides infrastructure for implementing XML-RPC server-side services using the HttpServer module
    - <a href="http://www.qore.org/manual/modules/xml/current/SoapHandler/html/index.html">SoapHandler</a>: provides
      infrastructure for implementing SOAP server-side services using the HttpServer module

    @section httpserverutil_relnotes HttpServerUtil Module Release Notes

    @subsection httputil1_1 HttpServerUtil 1.1
    - implemented support for reloading X.509 certificate information without manually restarting listeners
      (<a href="https://github.com/qorelanguage/qore/issues/4574">issue 4574</a>)

    @subsection httputil1_0_12 HttpServerUtil 1.0.12
    - updated version to match %Qore and server version

    @subsection httputil1_0 HttpServerUtil 1.0
    - fixed a bug handling wildcard address binds in
      @ref HttpServer::http_get_url_from_bind() "http_get_url_from_bind()"
      (<a href="https://github.com/qorelanguage/qore/issues/4266">issue 4266</a>)
    - added a definition for the <tt>308 Permanent Redirect</tt> response
      (<a href="https://github.com/qorelanguage/qore/issues/4169">issue 4169</a>)
    - added support for the Logger module for logging
      (<a href="https://github.com/qorelanguage/qore/issues/4157">issue 4157</a>)

    @subsection httputil0911 HttpServerUtil 0.9.11
    - fixed a bug where it was not possible to include CORS headers or any context-sensitive information in a 401
      response
      (<a href="https://github.com/qorelanguage/qore/issues/4136">issue 4136</a>)
    - fixed a bug that left hanging threads in HTTP operations with I/O callbacks with \c HEAD requests and a
      <tt>Transfer-Encoding: chunked</tt> header in the response
      (<a href="https://github.com/qorelanguage/qore/issues/4109">issue 4109</a>)

    @subsection httputil095 HttpServerUtil 0.9.5
    - aligned version with the HttpServer module version

    @subsection httputil094 HttpServerUtil 0.9.4
    - added support for sending chunked replies from an @ref Qore::InputStream "InputStream"
      (<a href="https://github.com/qorelanguage/qore/issues/3702">issue 3702</a>)

    @subsection httputil03121 HttpServerUtil 0.3.12.1
    - improved sensitive data masking in log messages
      (<a href="https://github.com/qorelanguage/qore/issues/2621">issue 2621</a>)

    @subsection httputil0312 HttpServerUtil 0.3.12
    - fixed a bug in AbstractAuthenticator::do401() where the \a msg argument was ignored
      (<a href="https://github.com/qorelanguage/qore/issues/1047">issue 1047</a>)
    - added logic to allow sensitive data to be masked in log messages
      (<a href="https://github.com/qorelanguage/qore/issues/1086">issue 1086</a>)
    - updated for complex types (<a href="https://github.com/qorelanguage/qore/issues/1724">issue 1724</a>)
    - moved @ref HttpServer::parse_uri_query() to the @ref utilintro "Util" module

    @subsection httputil03112 HttpServerUtil 0.3.11.2
    - eliminated excess logging of each HTTP chunk sent or received

    @subsection httputil03111 HttpServerUtil 0.3.11.1
    - aligned version with HttpServer module version

    @subsection httputil0311 HttpServerUtil 0.3.11
    - initial version of the module
    - implemented support for notifying persistent connections when the connection is terminated while a persistent
      connection is in place
    - removed unused AbstractStreamRequestHandler class
    - fixed @ref HttpServer::parse_uri_query() to always return \a params as a hash
      (<a href="https://github.com/qorelanguage/qore/issues/569">issue 569</a>)
    - added \c root_path to the context hash if the path was matched by a URL path prefix
      (<a href="https://github.com/qorelanguage/qore/issues/570">issue 570</a>)
    - implemented support for custom timeout values in stream handlers
      (<a href="https://github.com/qorelanguage/qore/issues/719">issue 719</a>)
 */

#! the main namespace for the HttpServer and HttpServerUtil modules
/** To use this module, use \c "%requires HttpServerUtil" in your code.

    All the public symbols in the module are defined in this namespace
 */
public namespace HttpServer {
#! version of the HttpServer's implementation
public const HttpServerVersion = "1.1";

#! default HTTP server string
public const HttpServerString = sprintf("Qore-HTTP-Server/%s", HttpServerVersion);

#! default timeout in ms
public const DefaultTimeout = 30s;  # recvs timeout after 30 seconds

#! read timeout in ms
public const ReadTimeout = DefaultTimeout;

#! maximum X.509 and private key file length
/** there is no real maximum size for these files, however an upper limit is used here to ensure that
    huge files are not used for the SSL cert and key files which could cause a crash or memory problems;
    currently set to 1M which is orders of magnitude higher than any real files currently in existence
*/
public const MaxSslFileLen = 1024 * 1024;

#! map of HTTP result codes and text messages
public const HttpCodes = {
    # 100s: Informational
    "100": "Continue",
    "101": "Switching Protocols",

    # RFC 2518: WebDAV
    "102": "Processing",

    # 200s: Success
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",

    # RFC 4918: WebDAV: The message body that follows is an XML message and can contain a number of separate response
    #           codes, depending on how many sub-requests were made
    "207": "Multi-Status",

    # RFC 5842: WebDAV: The members of a DAV binding have already been enumerated in a previous reply to this request,
    #           and are not being included again
    "208": "Already Reported",

    # RFC 3229
    "226": "IM Used",

    # 300s: Redirection
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    #"306": "(Reserved)",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",

    # 400s: Client Errors
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Request Entity Too Large",
    "414": "Request-URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Requested Range Not Satisfiable",
    "417": "Expectation Failed",

    # RFC 2324: http://tools.ietf.org/html/rfc2324
    "418": "I'm a teapot",

    # Returned by the Twitter Search and Trends API when the client is being rate limited
    "420": "Enhance Your Calm",

    # RFC 4918: WebDAV: The request was well-formed but was unable to be followed due to semantic errors
    "422": "Unprocessable Entity",

    # RFC 4918: WebDAV: The resource that is being accessed is locked
    "423": "Locked",

    # RFC 4918: WebDAV: The request failed due to failure of a previous request (e.g. a PROPPATCH)
    "424": "Failed Dependency",

    # Internet draft: Defined in drafts of "WebDAV Advanced Collections Protocol", but not present in "Web Distributed
    #                 Authoring and Versioning (WebDAV) Ordered Collections Protocol"
    "425": "Unordered Collection",

    # RFC 2817: The client should switch to a different protocol such as TLS/1.0
    "426": "Upgrade Required",

    # RFC 6585: The origin server requires the request to be conditional. Intended to prevent "the 'lost update'
    #           problem, where a client GETs a resource's state, modifies it, and PUTs it back to the server, when
    #           meanwhile a third party has modified the state on the server, leading to a conflict."
    "428": "Precondition Required",

    # RFC 6585: The user has sent too many requests in a given amount of time. Intended for use with rate limiting
    #           schemes
    "429": "Too Many Requests",

    # RFC 6585
    "431": "Request Header Fields Too Large",

    # 500s: Server Errors
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "509": "Bandwidth Limit Exceeded",

    # RFC 2774: Further extensions to the request are required for the server to fulfill it
    "510": "Not Extended",

    # RFC 6585: The client needs to authenticate to gain network access. Intended for use by intercepting proxies used
    #           to control access to the network (e.g. "captive portals" used to require agreement to Terms of Service
    #           before granting full Internet access via a Wi-Fi hotspot)
    "511": "Network Authentication Required",
};

/** @defgroup HttpServerLoggingOptions HttpServer Logging Options
*/
#/@{
#! bit for logging argument
public const LP_LOGPARAMS = 1 << 16;

#! mask for the log level
public const LP_LEVELMASK = LP_LOGPARAMS - 1;
#/@}

#! the return value of HTTP handler methods where any message body has been serialized for sending over the HTTP socket
public hashdecl HttpResponseInfo {
    #! the HTTP return code (see @ref HttpServer::HttpCodes for possible values)
    int code;

    #! the message body to return in the response
    /** if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and
        sendImpl() are not called

        @note if both \a body and \a chunked_body are set, then \a body is used, anc \a chunked_body is ignored
    */
    *data body;

    #! the message body to return in the response as a chunked response
    /** if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and
        sendImpl() are not called

        @note if both \a body and \a chunked_body are set, then \a body is used, anc \a chunked_body is ignored
    */
    *InputStream chunked_body;

    #! set this key to @ref True "True" if the connection should be unconditionally closed when the handler returns
    softbool close = False;

    #! set this key to a hash of extra header information to be returned with the response
    *hash<auto> hdr;

    #! this key can be set to @ref True "True" if the reply has already been sent (by a chunked callback for example)
    bool reply_sent = False;

    #! a string can be returned here which will be logged in the HTTP server's log file (if any)
    string log;

    #! a string can be returned here which will be logged in the HTTP server's error log file (if any)
    string errlog;

    #! additional info to be added to the context (cx) variable's \a user_state key if the connection is not closed
    *hash<auto> user_state;
}

#! the return value of HTTP handler methods with potentially unserialized message bodies
public hashdecl HttpHandlerResponseInfo {
    #! the HTTP return code (see @ref HttpServer::HttpCodes for possible values)
    int code;

    #! the message body to return in the response
    /** For higher-level handlers this can be any data type that will later be serialized for sending over the HTTP
        socket
    */
    auto body;

    #! set this key to @ref True "True" if the connection should be unconditionally closed when the handler returns
    softbool close = False;

    #! set this key to a hash of extra header information to be returned with the response
    /** @note The default \c NullRestSchemaValidator class will try use any \c Content-Type header if set here to
        serialize the response if the MIME type is supported and acceptable by the client
    */
    *hash<auto> hdr;

    #! this key can be set to @ref True "True" if the reply has already been sent (by a chunked callback for example)
    bool reply_sent = False;

    #! a string can be returned here which will be logged in the HTTP server's log file (if any)
    string log;

    #! a string can be returned here which will be logged in the HTTP server's error log file (if any)
    string errlog;

    #! additional info to be added to the context (cx) variable's \a user_state key if the connection is not closed
    *hash<auto> user_state;
}

# hashdecl for SSL info
public hashdecl HttpCertInfo {
    #! The X.509 certificate file location
    /** For use when re-reading the certificate file from its original location
    */
    *string cert_loc;

    #! The private key file location for the X.509 certificate
    /** For use when re-reading the private key file from its original location
    */
    *string key_loc;

    #! The private key password, if any
    /** For use when re-reading the private key file from its original location
    */
    *string key_password;

    #! X.509 certificate
    *SSLCertificate cert;
    #! private key for cert
    *SSLPrivateKey key;
}

#! options for new listeners
public hashdecl HttpListenerOptionInfo {
    #! the node value for the bind
    *string node;

    #! the service value for the bind
    *softstring service;

    #! the name of the listener
    *string name;

    #! The X.509 certificate file location
    /** For use when re-reading the certificate file from its original location
    */
    *string cert_loc;

    #! The private key file location for the X.509 certificate
    /** For use when re-reading the private key file from its original location
    */
    *string key_loc;

    #! The private key password, if any
    /** For use when re-reading the private key file from its original location
    */
    *string key_password;

    #! SSL cert
    *Qore::SSLCertificate cert;

    #! SSL key
    *Qore::SSLPrivateKey key;

    #! handler info
    *hash<string, hash<HttpHandlerConfigInfo>> handler_info;

    #! logger interface
    *LoggerInterface logger;

    #! stopc stop notification closure
    *code stopc;

    #! network family
    int family = AF_UNSPEC;

    #! ask for remote client certificates (causes browsers to prompt for a client cert on new connections)
    /** ignored if no SSL certificate provided, otherwise @ref Qore::SSL_VERIFY_PEER "SSL_VERIFY_PEER" is
        automatically added to \a ssl_verify_flags
    */
    bool get_remote_certs = False;

    #! SSL certificate verification constants; see @ref ssl_mode_constants
    /** ignored if no SSL certificate provided
    */
    int ssl_verify_flags = 0;

    #! set to False to use openssl CA validation for client certificates
    /** client certificates are requested if \a ssl_verify_flags contains @ref Qore::SSL_VERIFY_PEER "SSL_VERIFY_PEER"
    */
    bool ssl_accept_all_certs = True;

    #! Additional info added to the notification callback when listeners are started
    hash<auto> ext_info;
}

#! hash providing HTTP handler configuration info
public hashdecl HttpHandlerConfigInfo {
    #! the URI path for the handler
    string path = "/";

    #! if the URI path is a regular expression pattern
    bool isregex = False;

    #! the Content-Type that the handler handles (optional)
    softlist<softstring> content_types;

    #! the handler itself (required)
    AbstractHttpRequestHandler handler;

    #! a list of headers that indicate that a request should be handled by the handler (optional)
    softlist<softstring> headers;
}

#! returns a complete URL from a bind address
/** @param bind the bind address; if for any reason there is a path in the bind address, it will be ignored
    @param host the hostname to use in case the bind string is only a port number; if none is passed or the value
    passed is equal to the return value of @ref Qore::gethostname(), then \c "localhost" is used
*/
public string sub http_get_url_from_bind(softstring bind, *string host) {
    hash<UrlInfo> h = parse_url(bind);
    # if there is only a port number, it will appear in the "host" key
    if (h.size() == 1 && h.host && int(h.host) == h.host) {
        h.port = int(h.host);
        delete h.host;
    }

    if (!h.host) {
        if (!h.port && h.path) {
            h.host = "socket=" + remove h.path;
            h.host =~ s/ /%20/g;
            h.host =~ s/\//%2f/g;
        } else {
            h.host = (!host || host == gethostname()) ? "localhost" : host;
        }
    }

    # issue #4266: return a usable address when an explicit wildcard address is used
    if (h.host == "0.0.0.0") {
        # try to get the first non-loopback IPv4 address
        h.host = host ?? (map $1.address, get_netif_list(), $1.family == AF_INET && $1.address != "127.0.0.1")[0]
            ?? "127.0.0.1";
    } else if (h.host == "::") {
        # try to get the first non-loopback IPv6 address
        h.host = host ?? (map $1.address, get_netif_list(), $1.family == AF_INET6 && $1.address != "::1")[0]
            ?? "::1";
    }

    # encose IPv6 addresses in "[]"
    if (h.host =~ /^[[:xdigit:]:]+$/) {
        h.host = "[" + h.host + "]";
    }

    string login = h.password ? (h.password + ":") : "";
    if (h.username) {
        login += sprintf("%s@", h.password);
    }

    return sprintf("%s://%s%s%s", h.protocol ? h.protocol : "http", login, h.host,
        h.port ? sprintf(":%d", h.port) : "");
}

#! parses a URI path for a arguments and a method
/** @param path the URI path to parse; where the method is the part of the path before the first \c "?" character, and
    arguments are after

    @return a @ref Util::UriQueryInfo hash

    @since
    - 0.3.11 the \a params key value is always returned as a hash
    - 0.3.12 the actual implementation is in @ref Util::parse_uri_query()

    @note provided by @ref Util::parse_uri_query()
*/
public hash<Util::UriQueryInfo> sub parse_uri_query(string path) {
    return Util::parse_uri_query(path);
}

#! helper function for setting HTTP response headers
public nothing sub http_set_reply_headers(Socket s, hash<auto> cx, reference<auto> rv, *string server_string) {
    if (!rv.hdr.Connection) {
        if (rv.close) # RFC 2616 section 14.10 is "close" in all lower-case
            rv.hdr.Connection = "close";
        else
            rv.hdr.Connection = "Keep-Alive";
    }

    if (!rv.hdr.Date) # RFC 2616 sec 14.18 date format
        rv.hdr.Date = gmtime().format("Dy, DD Mon YYYY HH:mm:SS") + " GMT";

    if (!rv.hdr.Server)
        rv.hdr.Server = server_string ?? HttpServerString;

    string old_encoding = s.getEncoding();

    on_exit if (s.getEncoding() != cx."response-encoding")
        s.setEncoding(cx."response-encoding");

    if (!cx."response-encoding")
        cx."response-encoding" = old_encoding.lwr();
    else if (cx."response-encoding".lwr() != old_encoding.lwr())
        s.setEncoding(cx."response-encoding");

    # "rv" may be a HttpHandlerResponseInfo hashdecl, so we can't access "chunked_body" directly in that case
    if (rv.body || rv.hasKey("chunked_body") || rv.hdr."Transfer-Encoding" == "chunked") {
        if (!rv.hdr."Content-Type") {
            rv.hdr."Content-Type" = MimeTypeHtml + ";charset=" + cx."response-encoding";
        } else if (rv.hdr."Content-Type" !~ /charset=/
            && ((rv.body.typeCode() == NT_STRING)
                || (rv.hasKey("chunked_body") && (rv.chunked_body instanceof StringInputStream)))) {
            rv.hdr."Content-Type" += ";charset=" + cx."response-encoding";
        }
    }
}

#! this function can be used to mask data in log messages
/** @par Example:
    @code
    string msg = http_mask_data(msg);
    @endcode

    @param msg a log message with potentially sensitive data; expected to be a string of serialized data

    @return a string with sensitive data removed; currently the function masks data after
    \c 'pass', \c 'password', \c 'sensitive', and \c 'sensitive_data'' followed by a colon,
    an equals sign, and optionally whitespace

    @note this algorithm can have false positives and also can miss sensitive data
*/
public string sub http_mask_data(string msg) {
    msg =~ s/((?:pass(?:[^a-zA-Z_]|(?:word)))"?[=:>\s]*).*/$1<masked>.../;
    return msg;
}

#! returns a listener option info hash from flat arguments
/** @param node the node name or address (at least one of either \a node or \a service must be provided to make a bind)
    @param service the service port (at least one of either \a node or \a service must be provided to make a bind)
    @param cert_loc the location of an X.509 certificate file (this is actually a file location; supports schemes for
      file locations; ex: file:///path/to/file; if no scheme is present, defaults to \c file://)
    @param key_loc the location of a private key file; if not present, then the certificate is assumed to also have
    the private key in it (this is actually a file location; supports schemes for file locations; ex:
        file:///path/to/file; if no scheme is present, defaults to \c file://)
    @param key_password the password to the private key, if any

    @return a listener option info hash
*/
public hash<HttpListenerOptionInfo> sub http_get_listener_options(*string node, *softstring service,
        *string cert_loc, *string key_loc, *string key_password) {
    hash<HttpListenerOptionInfo> rv({
        "node": node,
        "service": service,
    });
    if (cert_loc) {
        rv += http_get_ssl_objects(cert_loc, key_loc, key_password);
    }
    return rv;
}

#! returns a listener option info hash from flat arguments
/** @param bind a bind address as host:port or just port or a filepath for a UNIX domain socket
    @param cert_loc the location of an X.509 certificate file (this is actually a file location; supports schemes for
      file locations; ex: file:///path/to/file; if no scheme is present, defaults to \c file://)
    @param key_loc the location of a private key file; if not present, then the certificate is assumed to also have
    the private key in it (this is actually a file location; supports schemes for file locations; ex:
        file:///path/to/file; if no scheme is present, defaults to \c file://)
    @param key_password the password to the private key, if any

    @return a listener option info hash
*/
public hash<HttpListenerOptionInfo> sub http_get_listener_options_from_bind(*softstring bind, *string cert_loc,
        *string key_loc, *string key_password) {
    hash<HttpListenerOptionInfo> rv();
    if (cert_loc) {
        rv += http_get_ssl_objects(cert_loc, key_loc, key_password);
    }

    if (bind =~ /:\w+/) {
        (rv.node, rv.service) = (bind =~ x/(.+):(\w+)/);
    } else if (bind =~ /^[0-9]+$/) {
        rv.service = bind;
    } else {
        rv.node = bind;
    }

    return rv;
}

#! returns a listener option info hash from flat arguments
/** @param bind a bind address as host:port or just port or a filepath for a UNIX domain socket
    @param listener_params parameters for the listener; processed by @ref http_get_ssl_objects()
    @param opts listener options

    @return a listener option info hash
*/
public hash<HttpListenerOptionInfo> sub http_get_listener_options_from_bind(*softstring bind,
        hash<auto> listener_params, hash<HttpListenerOptionInfo> opts = <HttpListenerOptionInfo>{}) {
    hash<HttpCertInfo> cert_info = http_get_ssl_objects(listener_params);
    if (cert_info.cert) {
        opts += cert_info;
    }

    if (bind =~ /:\w+/) {
        (opts.node, opts.service) = (bind =~ x/(.+):(\w+)/);
    } else if (bind =~ /^[0-9]+$/) {
        opts.service = bind;
    } else {
        opts.node = bind;
    }

    return opts;
}

#! converts a hash to HTTP certificate info if possible
/** @param listener_params can have the following keys:
    - \c cert_path: the location of an X.509 certificate file (this is actually a file location; supports schemes for
      file locations; ex: file:///path/to/file; if no scheme is present, defaults to \c file://)
    - \c key_path: the location of a private key file; if not present, then the certificate is assumed to also have
        the private key in it (this is actually a file location; supports schemes for file locations; ex:
        file:///path/to/file; if no scheme is present, defaults to \c file://)
    - \c key_password: the password to the private key file

    @return an @ref HttpServer::HttpCertInfo "HttpCertInfo" hash
*/
public hash<HttpCertInfo> sub http_get_ssl_objects(hash<auto> listener_params) {
    if (listener_params.cert_path && !listener_params.cert) {
        return http_get_ssl_objects(listener_params.cert_path, listener_params.key_path,
            listener_params.key_password);
    }

    hash<HttpCertInfo> ssl_info();
    if (listener_params.cert) {
        if (!(listener_params.cert instanceof SSLCertificate)) {
            throw "HTTPSERVER-ADDLISTENER-ERROR", sprintf("invalid 'cert' entry in listener description; "
                "expecting a 'SSLCertificate' object, got type '%s' instead", listener_params.cert.fullType());
        }
        ssl_info.cert = listener_params.cert;
        if (listener_params.key) {
            if (!(listener_params.key instanceof SSLPrivateKey)) {
                throw "HTTPSERVER-ADDLISTENER-ERROR", sprintf("invalid 'key' entry in listener description; "
                    "expecting a 'SSLPrivateKey' object, got type '%s' instead", listener_params.key.fullType());
            }
            ssl_info.key = listener_params.key;
        }
    }
    return ssl_info;
}

#! converts a hash to HTTP certificate info if possible
/**
    @param cert_loc the location of an X.509 certificate file (this is actually a file location; supports schemes for
      file locations; ex: file:///path/to/file; if no scheme is present, defaults to \c file://)
    @param key_loc the location of a private key file; if not present, then the certificate is assumed to also have
    the private key in it (this is actually a file location; supports schemes for file locations; ex:
        file:///path/to/file; if no scheme is present, defaults to \c file://)
    @param pwd the password to the private key file

    @return an @ref HttpServer::HttpCertInfo "HttpCertInfo" hash
*/
public hash<HttpCertInfo> sub http_get_ssl_objects(string cert_loc, *string key_loc, *string pwd) {
    SSLCertificate cert;
    data cert_data;
    try {
        # read in X.509 certificate file
        cert_data = cert_loc =~ /\.der$/
            ? FileLocationHandler::getBinaryFileFromLocation(cert_loc)
            : FileLocationHandler::getTextFileFromLocation(cert_loc);
        if (cert_data.size() > MaxSslFileLen) {
            throw "HTTPSERVER-SSL-SETUP-ERROR", sprintf("certificate file %y is %d bytes, exceeding the maximum "
                "length of %d bytes", cert_loc, cert_data.size(), MaxSslFileLen);
        } else if (!cert_data.size()) {
            throw "HTTPSERVER-SSL-SETUP-ERROR", sprintf("certificate file %y is empty; cannot setup X.509 "
                "certificate from empty file", cert_loc);
        }
        # create certificate object
        cert = new SSLCertificate(cert_data);
    } catch (hash<ExceptionInfo> ex) {
        # rethrow user-friendly exception
        throw "HTTPSERVER-SSL-SETUP-ERROR", sprintf("cannot setup X.509 certificate from location %y: %s: %s",
            cert_loc, ex.err, ex.desc);
    }

    SSLPrivateKey key;
    try {
        # read in private key file
        if (key_loc.val()) {
            # read in private key file
            bool der = key_loc =~ /\.der$/;
            data key_data = der
                ? FileLocationHandler::getBinaryFileFromLocation(key_loc)
                : FileLocationHandler::getTextFileFromLocation(key_loc);
            if (key_data.size() > MaxSslFileLen) {
                throw "HTTPSERVER-SSL-SETUP-ERROR", sprintf("private key file %y is %d bytes, exceeding the "
                    "maximum length of %d bytes", key_loc, key_data.size(), MaxSslFileLen);
            } else if (!key_data.size()) {
                throw "HTTPSERVER-SSL-SETUP-ERROR", sprintf("private key file %y is empty; cannot setup private "
                    "key from empty file", key_loc);
            }
            # create private key
            key = der ? new SSLPrivateKey(key_data) : new SSLPrivateKey(key_data, pwd);
        } else {
            key = new SSLPrivateKey(cert_data, pwd);
        }
    } catch (hash<ExceptionInfo> ex) {
        # rethrow user-friendly exception
        throw "HTTPSERVER-SSL-SETUP-ERROR", sprintf("cannot setup private key from from location %y: %s: %s",
            key_loc.val() ? key_loc : cert_loc, ex.err, ex.desc);
    }

    return <HttpCertInfo>{
        "cert_loc": cert_loc,
        "key_loc": key_loc,
        "key_password": pwd,
        "cert": cert,
        "key": key,
    };
}

#! this abstract class defines the interface for classes that provide logging methods
public class AbstractLogger {
    #! called to log information to the registered log code
    /** @param fmt the message to log, can be a format string, in which case additional arguments are processed with
        vsprintf()
    */
    abstract log(string fmt, ...);

    #! called to log error information to the registered error log code
    /** @param fmt the error message to log, can be a format string, in which case additional arguments are processed
        with vsprintf()
    */
    abstract logError(string fmt, ...);

    #! calls log() with the given args
    /** @param args a single string or a list of arguments used to call the log() method
    */
    logArgs(*softlist<auto> args) {
        if (args)
            call_object_method_args(self, "log", args);
    }

    #! calls logError() with the given args
    /** @param args a single string or a list of arguments used to call the logError() method
    */
    logErrorArgs(*softlist<auto> args) {
        if (args)
            call_object_method_args(self, "logError", args);
    }
}

#! this abstract class defines the public interface of the private HttpListener class defined in the HttpServer module
public class HttpListenerInterface inherits AbstractLogger {
    #! method to log a response message
    /** @param cx the call context
        @param rv the response hash
    */
    logResponse(hash<auto> cx, hash<auto> rv) {
        # no implementation in the base class
    }

    #! Removes a dedicated socket handler from the listener
    removeExternalDedicatedSocket(softstring id) {
        throw "UNIMPLEMENTED";
    }

    #! adds user-defined data to be returned in the \c "uctx" context key when serving requests from this listener
    /** @param uctx user-defined data to be returned in the \c "uctx" context key when serving requests from this
        listener
    */
    abstract addUserThreadContext(hash<auto> uctx);

    #! removes the given key from the \c "uctx" context key
    /** @param k the key to remove from the \c "uctx" context hash; if no argument is provided, then the \c "uctx"
        context hash is removed entirely
    */
    abstract auto removeUserThreadContext(*string k);
}

#! abstract base class for external authentication
/** This class should be inherited by a class providing real authentication
*/
public class AbstractAuthenticator {
    #! called to check if the connection requires authentication
    /** @return @ref True "True" if authentication is enabled, @ref False "False" if not (@ref False "False" is the
        default value returned)
    */
    bool requiresAuthentication() {
        return False;
    }

    #! returns the authentication realm as a string
    /** @return the authentication realm as a string (default: \c "Default Authentication Realm")
    */
    string getRealm() {
        return "Default Authentication Realm";
    }

    #! called to authenticate a user for a connection
    /** This method will only be called if requiresAuthentication() returns @ref True "True"
        @param user the username to authenticate
        @param pass the password for the user

        @throw AUTHENTICATION-ERROR subclasses should throw this exception if the user cannot be authenticated (must
        be overridden in child classes; this parent method will never throw any exceptions; all connections are
        accepted by default)
    */
    authenticate(string user, string pass = "") {
    }

    #! called when the connection requires authentication, but no authentication credentials were supplied, to try to authenticate the connection based on the source IP address
    /** This method will only be called if requiresAuthentication() returns @ref True "True" and no authentication
        credentials are supplied with the request
        @param ip the IP address of the source connection
        @param user a reference to a string that will be populated with the username to use if the request can be
        authenticated based on the source IP address (this method returns the string \c "admin")

        @throw AUTHENTICATION-ERROR subclasses should throw this exception if the user cannot be authenticated
        (however this base class method as implemented here will never throw any exceptions
    */
    authenticateByIP(string ip, reference<string> user) {
    }

    #! returns a hash with one item - \c WWW-Authenticate header set to correct realm
    /** @note This version is never called by Qore; it is provided only for backwards compatibility
    */
    hash<auto> getAuthHeader() {
        return {
            "WWW-Authenticate": sprintf("Basic realm=%y", getRealm()),
        };
    }

    #! returns a hash with one item - \c WWW-Authenticate header set to correct realm
    /** @param cx the call context
    */
    hash<auto> getAuthHeader(hash<auto> cx) {
        return {
            "WWW-Authenticate": sprintf("Basic realm=%y", getRealm()),
        };
    }

    #! returns a 401 repsonse with the given string argument as the message body
    /** @param msg message body to return
        @param cx the call context
    */
    hash<HttpResponseInfo> do401(string msg = "Authentication is required to access this server", *hash<auto> cx) {
        return <HttpResponseInfo>{
            "code": 401,
            "body": msg,
            "hdr": getAuthHeader(cx),
        };
    }

    #! primary method called to authenticate each request
    /** @param listener an HttpListenerInterface object for the listener serving the request for logging purposes
        @param hdr a hash of request headers
        @param cx a reference to the call context hash; set the \c "user" key to the user name if a user was
        identified and authorized; this hash will have the following keys:
        - \c header-info: a hash of information about the request header with the following keys:
          - \c accept-charset: this key will be set to an appropriate value from any \c "Accept-Charset" header; if
            any of \c "*", \c "utf8", or \c "utf-8" are present, then this will be set to \c "utf8", otherwise it will
            be set to the first requested character encoding in the list
          - \c accept-encoding: a hash where keys are values from any \c "Accept-Encoding" header and the values are
            @ref True
          - \c body-content-type: this is the \c "Content-Type" header without any charset declaration
          - \c charset: if there is a charset declaration in the \c "Content-Type" header, the value is returned in
            this key
          - \c client-cert: if the server is configured to capture remote client certificates, and the client supplied
            a certificate, this key will be populated with the @ref Qore::SSLCertificate "SSLCertificate" for the client
          - \c close: set to @ref True "True" if the connection should be closed after responding,
            @ref False "False" if not (as derived from the request header)
          - \c headers-raw: a hash of raw request headers without any case conversions or other processing
          - \c request-uri: gives the request URI in an HTTP request
        - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
        - \c socket-info: a hash of socket information for the listening socket (as returned by
          @ref Qore::Socket::getSocketInfo())
        - \c peer-info: a hash of socket information for the remote socket (as returned by
          @ref Qore::Socket::getPeerInfo())
        - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
        - \c id: the unique HTTP connection ID
        - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
        - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
        - \c user: the current RBAC username (if any)
        - \c root_path: the root URL path matched if the request was matched by a URL prefix

        @return returns @ref nothing if there were no errors, otherwise returns a hash with the following keys to
        indicate an authentication or authorization error:
        - \c "code": the HTTP response code
        - \c "body": the error message body
        - \c "hdr": an optional hash of headers for the error response
    */
    *hash<HttpResponseInfo> authenticateRequest(HttpListenerInterface listener, hash<auto> hdr,
            reference<hash<auto>> cx) {
        #printf("HTTP DEBUG %s::authenticateRequest() called\n", self.className());
        if (!requiresAuthentication())
            return;

        if (hdr.authorization) {
            if (hdr.authorization !~ /basic /i)
                return do401("Only basic authentication is supported", cx);

            *string bstr = (hdr.authorization =~ x/basic (.*)/i)[0];
            if (!bstr)
                return do401(NOTHING, cx);

            string str = parse_base64_string_to_string(bstr);
            int i = str.find(":");
            if (i < 1 || i == (str.size() -1))
                return do401(NOTHING, cx);

            string user = str.substr(0, i);
            *string pass = str.substr(i + 1);

            try
                authenticate(user, pass);
            catch (hash<ExceptionInfo> ex) {
                if (ex.err == "AUTHENTICATION-ERROR")
                    return do401(NOTHING, cx);
                else
                    rethrow;
            }

            cx.user = user;
            return;
        }

        string user;
        # only try ip-based authentication if the connection is not already authenticated
        try {
            authenticateByIP(cx."peer-info".address, \user);
            cx.user = user;
            return;
        } catch (hash<ExceptionInfo> ex) {
            # log the error
            string str = sprintf("%s: %s: %s: received from %s", get_ex_pos(ex), ex.err, ex.desc, cx."peer-info".address_desc);
            listener.logError(str);
        }
        return do401(NOTHING, cx);
    }
}

#! class providing automatic authentication for all requests
public class PermissiveAuthenticator inherits AbstractAuthenticator {
    #! primary method called to authenticate each request
    /** @param listener an HttpListenerInterface object for the listener serving the request for logging purposes
        @param hdr a hash of request headers
        @param cx a reference to the call context hash; set the \c "user" key to the user name if a user was
        identified and authorized; this hash will have the following keys:
        - \c header-info: a hash of information about the request header with the following keys:
          - \c accept-charset: this key will be set to an appropriate value from any \c "Accept-Charset" header; if
            any of \c "*", \c "utf8", or \c "utf-8" are present, then this will be set to \c "utf8", otherwise it will
            be set to the first requested character encoding in the list
          - \c accept-encoding: a hash where keys are values from any \c "Accept-Encoding" header and the values are
            @ref True
          - \c body-content-type: this is the \c "Content-Type" header without any charset declaration
          - \c charset: if there is a charset declaration in the \c "Content-Type" header, the value is returned in
            this key
          - \c client-cert: if the server is configured to capture remote client certificates, and the client supplied
            a certificate, this key will be populated with the @ref Qore::SSLCertificate "SSLCertificate" for the client
          - \c close: set to @ref True "True" if the connection should be closed after responding,
            @ref False "False" if not (as derived from the request header)
          - \c headers-raw: a hash of raw request headers without any case conversions or other processing
          - \c request-uri: gives the request URI in an HTTP request
        - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
        - \c socket-info: a hash of socket information for the listening socket (as returned by
          @ref Qore::Socket::getSocketInfo())
        - \c peer-info: a hash of socket information for the remote socket (as returned by @ref Qore::Socket::getPeerInfo())
        - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
        - \c id: the unique HTTP connection ID
        - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
        - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
        - \c user: the current RBAC username (if any)
        - \c root_path: the root URL path matched if the request was matched by a URL prefix

        @return returns @ref nothing indicating that the request is authenticated
    */
    *hash<HttpResponseInfo> authenticateRequest(HttpListenerInterface listener, hash<auto> hdr, reference<hash> cx) {
        return;
    }
}

#! abstract class for streaming HTTP chunked requests/responses
/** This class is the base class for handling HTTP stream requests; i.e. with chunked data

    The calling order is as follows:
    - constructor(): this is called when the request is received
    - recv(): this is called once for each HTTP chunk (if data is sent chunked), and then once with any message
      trailer.  If data is sent non-chunked, then this method is called with the monolithic message body and then
      again with @ref nothing to signify the end of the transfer and to simulate a chunked transfer.  The simulation
      of a chunked transfer or the actual chunked receive with the callbacks is made by the handleRequest() method.
      Subclasses should re-implement recvImpl() which is called by this method
    - getResponseHeaderMessage(): this is called after the message body has been received to get the response headers
      and optionally a message body.  Subclasses should reimplement getResponseHeaderMessageImpl() which is called by
      this method
    - send(): this is called if no message body is returned by getResponseHeaderMessage(); each time this method
      returns data, the data is sent in a response chunk; when this method returns @ref nothing, then no more data is
      sent.  Subclasses should re-implement sendImpl() which is called by this method
*/
public class AbstractStreamRequest {
    public {}

    private {
        #! an HttpListenerInterface object for the listener serving the request for logging purposes
        HttpListenerInterface listener;
        #! the request handler for the request
        AbstractHttpRequestHandler handler;
        #! the Socket object for the response
        Socket s;
        #! the call context variable
        hash<auto> cx;
        #! a hash of request headers
        hash<auto> hdr;
        #! any message body given in a non-chunked request; could already be deserialized
        auto body;
        #! send and receive timeout
        timeout timeout_ms = HttpServer::DefaultTimeout;
    }

    #! creates the object with the given attributes
    /** @param listener an HttpListenerInterface object for the listener serving the request for logging purposes
        @param handler the handler serving the request
        @param s the Socket for serving the request
        @param cx a call context hash
        @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys
        will be present:
        - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
        - \c path: the HTTP path given in the request, after processing by @ref Qore::decode_uri_request()
        - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")
        @param body any message body in the request already received from the incoming socket
    */
    constructor(HttpListenerInterface listener, AbstractHttpRequestHandler handler, Socket s, hash<auto> cx,
            hash<auto> hdr, auto body) {
        self.listener = listener;
        self.handler = handler;
        self.s = s;
        self.cx = cx;
        self.hdr = hdr;
        self.body = body;
    }

    #! handles the request
    hash<HttpHandlerResponseInfo> handleRequest() {
        # handle message body
        if (exists body) {
            hash<auto> dh = {
                "data": body,
                "chunked": False
            };
            if (cx.deserialized)
                dh.deserialized = True;
            recv(dh);
            # signal end of data
            recvImpl({"hdr": NOTHING});
        } else {
            if (hdr."transfer-encoding" == "chunked") {
                if (hdr."content-encoding")
                    s.readHTTPChunkedBodyBinaryWithCallback(\recv(), timeout_ms);
                else
                    s.readHTTPChunkedBodyWithCallback(\recv(), timeout_ms);
            } else # signal end of data
                recvImpl({"hdr": NOTHING});
        }

        return sendResponse();
    }

    #! called to either create the response hash or send a chunked response directly
    /** This method calls getResponseHeaderMessageImpl() to get the response code, headers and optionally a response
        message body.

        If a \c "Transfer-Encoding: chunked" header is included, then the response is sent chunked using the send()
        callback; in this case the \c "reply_sent" key in the response is set to @ref True "True".

        Otherwise, any message body is immediately encoded (if accepted by the requestor).
    */
    private hash<HttpHandlerResponseInfo> sendResponse() {
        hash<HttpHandlerResponseInfo> rv = getResponseHeaderMessage();
        # issue #4109: do not start async I/O with a HEAD request
        if (rv.hdr."Transfer-Encoding" != "chunked" || hdr.method == "HEAD")
            return rv;

        http_set_reply_headers(s, cx, \rv);

        # send chunked response
        s.sendHTTPResponseWithCallback(\send(), rv."code", HttpServer::HttpCodes{rv."code"}, "1.1", rv.hdr,
            timeout_ms);
        rv.reply_sent = True;
        listener.logResponse(cx, rv);
        return rv;
    }

    #! this method returns the response message description hash by calling getResponseHeaderMessageImpl()
    /**
        @return a hash with the following keys:
        - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
        - \c "body": the message body to return in the response; if this key is returned, then the reply is sent
          immediately; a chunked reply is not made, and send() and sendImpl() are not called
        - \c "close": (optional) set this key to @ref True "True" if the connection should be unconditionally closed
          when the handler returns
        - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

        @note this method is called after the message body has been received
    */
    private hash<HttpHandlerResponseInfo> getResponseHeaderMessage() {
        return cast<hash<HttpHandlerResponseInfo>>(getResponseHeaderMessageImpl());
    }

    #! this is the primary callback for receiving chunked data; data will be logged, and then recvImpl() is called
    /** content decoding is not possible with chunked data because only the entire message can be decoded
    */
    private nothing recv(hash<auto> v) {
        if (exists v."data") {
            logChunk(False, v."data".size());

            if (cx.deserialized)
                v.deserialized = True;
        }
        recvImpl(v);
    }

    #! this is the primary callback for sending chunked responses
    /** first sendImpl() is called to get the raw data, and then any chunked data is encoded by this method if
        required
    */
    private auto send() {
        auto v = sendImpl();
        switch (v.typeCode()) {
            case NT_STRING:
            case NT_BINARY: {
                logChunk(True, v.size());
                break;
            }
        }
        return v;
    }

    #! this method can be overridden in base classes to log each HTTP chunk sent
    /** @par
        @code{.py}
private logChunk(bool send, int size) {
    listener.log("cid %d %s CHUNK %d bytes", cx.id, send ? "send" : "recv", size);
}
        @endcode

        By default this method does nothing
    */
    private logChunk(bool send, int size) {
    }

    #! this method should return the response message description hash
    /** The default implementation in this class is to return a 501 Not Implemented response; override in subclasses
        to return a custom response.
        Omit the \c "body" key to ensure that a chunked response is sent and the send() and sendImpl() callbacks are
        called.

        @return a hash with the following keys:
        - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
        - \c "body": the message body to return in the response; if this key is returned, then the reply is sent
          immediately; a chunked reply is not made, and send() and sendImpl() are not called
        - \c "close": (optional) set this key to @ref True "True" if the connection should be unconditionally closed
          when the handler returns
        - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

        @note this method is called after the message body has been received
    */
    private hash<HttpResponseInfo> getResponseHeaderMessageImpl() {
        return <HttpResponseInfo>{
            "code": 501,
            "body": sprintf("default handler (%s) has no implementation", self.className()),
            "close": True,
        };
    }

    #! callback method for receiving chunked data; the default implementation in this base class does nothing
    /**
        @param v the first time this method is called with a hash of the message headers in the \c "hdr" key, and then
        with any message body in the \c "data"; if a chunked HTTP message is received, then this method is called once
        for each chunk; when the message has been received, then this method is called with a hash representing any
        trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body
        or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data
        calls have the following keys:
        - \c "data": the string or binary data
        - \c "chunked": @ref True "True" if the data was received with chunked transfer encoding, @ref False "False"
          if not
        .
        Header or trailer data is placed in a hash with the following keys:
        - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no
          trailers were included in a chunked message
        - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as,
          for example, socket character encoding)
    */
    private nothing recvImpl(hash<auto> v) {
    }

    #! callback method for sending chunked data
    /**
        The default implementation in this base class does nothing and returns nothing

        @return The chunked HTTP data to send; this method must return either a string or a binary value each time it
        is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can
        be returned or simply @ref nothing which will close the chunked message
    */
    private auto sendImpl() {
    }
}

#! abstract class that all HTTP request handler objects must inherit from
/** Reimplement handleRequest() in subclasses

    For handlers supporting chunked data (both for receiving and sending), set \a stream to @ref True "True" in the
    constructor() method and implement getStreamRequestImpl() to return the HTTP stream request handler.

    @see AbstractStreamRequest for information about HTTP stream request handlers
  */
public class AbstractHttpRequestHandler {
    public {
        #! the optional AbstractAuthenticator for requests to this handler
        *AbstractAuthenticator auth;

        #! if POSTed data should be decompressed automatically if there is content-encoding
        bool decompress = True;

        #! if automatically decompressed POSTed data should be converted to a string
        /** if @ref False "False", then it will be decompressed to a binary
        */
        bool decompress_to_string = True;

        #! if the handler supports streaming requests/responses with chunked data
        bool stream;

        #! send and receive socket timeout in milliseconds
        timeout timeout_ms = HttpServer::DefaultTimeout;

        #! thread-local key string for notification callbacks
        const NotificationThreadKey = "_AHRH_pc";

        #! thread-local key string for the persistent flag
        const PersistenceThreadKey = "_AHRH_p";
    }

    #! create the object optionally with the given AbstractAuthenticator
    /** @param n_auth the authentication object to use to authenticate connections (see AbstractAuthenticator); if no
        AbstractAuthenticator object is passed, then by default no authentication will be required
        @param n_stream if @ref True "True" then stream (i.e. HTTP chunked) requests and responses are handled and
        getStreamRequestImpl() will be used to return a valid AbstractStreamRequest object to handle requests
    */
    constructor(*AbstractAuthenticator n_auth, softbool n_stream = False) {
        auth = n_auth;
        stream = n_stream;
    }

    #! returns @ref True "True" if the current connection is persistent, @ref False "False" if not
    bool isPersistent() {
        return boolean(get_thread_data(PersistenceThreadKey));
    }

    #! called externally to notify the handler that the connection will be persistent
    setPersistent(bool p = True) {
        if (p) {
            save_thread_data((PersistenceThreadKey: True));
            set_thread_resource(\AbstractHttpRequestHandler::staticPersistenceCleanup());
        } else
            remove_thread_data(PersistenceThreadKey);
    }

    #! calls the argument when the persistent connection is closed
    notifyClosed(*code c) {
        if (c) {
            save_thread_data((NotificationThreadKey: c));
            set_thread_resource(\AbstractHttpRequestHandler::staticNotificationCleanup());
        } else {
            remove_thread_data(NotificationThreadKey);
        }
    }

    #! this method can be used to mask data in debug messages
    /** @param msg the log message to be subjected to masking

        @return a string with sensitive information masked
    */
    string maskData(string msg) {
        return http_mask_data(msg);
    }

    #! removes the thread-local data key in case the object is destroyed in another thread
    static staticNotificationCleanup() {
        remove_thread_data(NotificationThreadKey);
    }

    #! removes the thread-local data key in case the object is destroyed in another thread
    static staticPersistenceCleanup() {
        remove_thread_data(PersistenceThreadKey);
    }

    #! called externally when a persistent connection is closed
    nothing persistentClosed() {
        *code c = get_thread_data(NotificationThreadKey);
        if (c) {
            try {
                c();
            } catch (hash<ExceptionInfo> ex) {
                if (ex.err != "OBJECT-ALREADY-DELETED")
                    rethrow;
            }
        }
    }

    #! this method will throw an exception if a persistent connection cannot be granted
    private nothing checkPersistent(hash<auto> cx, hash<auto> hdr) {
        # Socket::readHTTPHeader() sets the value in cx.close according to the HTTP version and the Connection header
        if (cx.close)
            throw "PERSISTENT-ERROR", sprintf("a persistent connection cannot be granted because the requesting HTTP "
                "level is %y and the Connection header is %y", hdr.http_version, hdr.connection);
    }

    #! Called if the request contains an \c "Expect: 100-continue" header
    /**
        @param cx call context hash; this hash will have the following keys:
        - \c header-info: a hash of information about the request header with the following keys:
          - \c accept-charset: this key will be set to an appropriate value from any \c "Accept-Charset" header; if
            any of \c "*", \c "utf8", or \c "utf-8" are present, then this will be set to \c "utf8", otherwise it will
            be set to the first requested character encoding in the list
          - \c accept-encoding: a hash where keys are values from any \c "Accept-Encoding" header and the values are
            @ref True
          - \c body-content-type: this is the \c "Content-Type" header without any charset declaration
          - \c charset: if there is a charset declaration in the \c "Content-Type" header, the value is returned in
            this key
          - \c client-cert: if the server is configured to capture remote client certificates, and the client supplied
            a certificate, this key will be populated with the @ref Qore::SSLCertificate "SSLCertificate" for the
            client
          - \c close: set to @ref True "True" if the connection should be closed after responding,
            @ref False "False" if not (as derived from the request header)
          - \c headers-raw: a hash of raw request headers without any case conversions or other processing
          - \c request-uri: gives the request URI in an HTTP request
        - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
        - \c socket-info: a hash of socket information for the listening socket (as returned by
          @ref Qore::Socket::getSocketInfo())
        - \c peer-info: a hash of socket information for the remote socket (as returned by
          @ref Qore::Socket::getPeerInfo())
        - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
        - \c id: the unique HTTP connection ID
        - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
        - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
        - \c user: the current RBAC username (if any)
        - \c root_path: the root URL path matched if the request was matched by a URL prefix
        @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys
        will be present:
        - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
        - \c path: the HTTP path given in the request, after processing by @ref Qore::decode_uri_request()
        - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")

        @return a hash with the following keys:
        - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
        - \c "body": the message body to return in the response
        - \c "close": (optional) set this key to @ref True "True" if the connection should be unconditionally closed
          when the handler returns
        - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

        @note the default implementation simply returns a <tt>100 Continue</tt> response for all requests; reimplement
        this method in a subclass to provide the required functionality
    */
    hash<HttpResponseInfo> handleExpectHeader(hash<auto> cx, hash<auto> hdr) {
        return <HttpResponseInfo>{
            "code": 100,
        };
    }

    #! will be called when a request is received that should be directed to the handler
    /**
        @param cx call context hash; this hash will have the following keys:
        - \c header-info: a hash of information about the request header with the following keys:
          - \c accept-charset: this key will be set to an appropriate value from any \c "Accept-Charset" header; if
            any of \c "*", \c "utf8", or \c "utf-8" are present, then this will be set to \c "utf8", otherwise it will
            be set to the first requested character encoding in the list
          - \c accept-encoding: a hash where keys are values from any \c "Accept-Encoding" header and the values are
            @ref True
          - \c body-content-type: this is the \c "Content-Type" header without any charset declaration
          - \c charset: if there is a charset declaration in the \c "Content-Type" header, the value is returned in
            this key
          - \c client-cert: if the server is configured to capture remote client certificates, and the client supplied
            a certificate, this key will be populated with the @ref Qore::SSLCertificate "SSLCertificate" for the client
          - \c close: set to @ref True "True" if the connection should be closed after responding,
            @ref False "False" if not (as derived from the request header)
          - \c headers-raw: a hash of raw request headers without any case conversions or other processing
          - \c request-uri: gives the request URI in an HTTP request
        - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
        - \c socket-info: a hash of socket information for the listening socket (as returned by
          @ref Qore::Socket::getSocketInfo())
        - \c peer-info: a hash of socket information for the remote socket (as returned by
          @ref Qore::Socket::getPeerInfo())
        - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
        - \c id: the unique HTTP connection ID
        - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
        - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
        - \c user: the current RBAC username (if any)
        - \c root_path: the root URL path matched if the request was matched by a URL prefix
        @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys
        will be present:
        - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
        - \c path: the HTTP path given in the request, after processing by @ref Qore::decode_uri_request()
        - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")
        @param body message body, if any

        @return a hash with the following keys:
        - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
        - \c "body": the message body to return in the response
        - \c "close": (optional) set this key to @ref True "True" if the connection should be unconditionally closed
          when the handler returns
        - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

        @note the default implementation simply returns a 501 error code for all requests; reimplement this method in
        a subclass to provide the required functionality
    */
    hash<HttpResponseInfo> handleRequest(hash<auto> cx, hash<auto> hdr, *data body) {
        return <HttpResponseInfo>{
            "code": 501,
            "body": sprintf("default handler (%s) has no implementation", self.className()),
            "close": True,
        };
    }

    #! top-level request handling method
    hash<HttpResponseInfo> handleRequest(HttpListenerInterface listener, Socket s, hash<auto> cx, hash<auto> hdr,
            *data body) {
        # classic, non-streaming interface
        if (!stream) {
            auto rv = handleRequest(cx, hdr, body ?? getMessageBody(s, hdr, body));
            switch (rv.typeCode()) {
                case NT_HASH: return cast<hash<HttpResponseInfo>>(rv);
                case NT_STRING:
                case NT_BINARY: return cast<hash<HttpResponseInfo>>(("code": 200, "body": rv));
                default:
                throw "HANDLER-ERROR", sprintf("handler returned type %s; expecting \"hash\"; value: %y", rv.type(), rv);
            }
        }

        AbstractStreamRequest req = getStreamRequestImpl(listener, s, cx, hdr, body);
        return cast<hash<HttpResponseInfo>>(req.handleRequest());
    }

    #! returns the AbstractStreamRequest object for handling chunked requests
    private AbstractStreamRequest getStreamRequestImpl(HttpListenerInterface listener, Socket s, hash<auto> cx,
            hash<auto> hdr, *data body) {
        return new AbstractStreamRequest(listener, self, s, cx, hdr, body);
    }

    #! decodes a message body with content-encoding
    static data decodeBody(string content_encoding, binary body, *string string_encoding) {
        switch (content_encoding) {
            case "deflate":
            case "x-deflate":
                return string_encoding
                    ? uncompress_to_string(binary(body), string_encoding)
                    : uncompress_to_binary(body);
            case "gzip":
            case "x-gzip":
                return string_encoding ? gunzip_to_string(binary(body), string_encoding) : gunzip_to_binary(body);
            case "bzip2":
            case "x-bzip2":
                return string_encoding ? bunzip2_to_string(binary(body), string_encoding) : bunzip2_to_binary(body);
            case "identity":
                return string_encoding ? binary_to_string(body, string_encoding) : body;
        }
        throw "UNSUPPORTED-CONTENT-ENCODING", sprintf("don't know how to handle content-encoding %y",
            content_encoding);
    }

    #! encodes a message body with content-encoding
    static binary encodeBody(string content_encoding, data body) {
        switch (content_encoding) {
            case "deflate":
                return compress(body);
            case "gzip":
                return gzip(body);
            case "bzip2":
                return bzip2(body);
            case "identity":
                return body;
        }
        throw "UNSUPPORTED-CONTENT-ENCODING", sprintf("don't know how to handle content-encoding %y",
            content_encoding);
    }

    #! optionally retrieves and post-processes any message body
    *data getMessageBody(Socket s, hash<auto> hdr, *data body, bool decode = True) {
        if (!body && hdr."transfer-encoding" == "chunked") {
            hdr += (hdr."content-encoding"
                ? s.readHTTPChunkedBodyBinary(timeout_ms)
                : s.readHTTPChunkedBody(timeout_ms));
            body = remove hdr.body;
        }

        if (decode && body && hdr."content-encoding" && decompress)
            body = AbstractHttpRequestHandler::decodeBody(hdr."content-encoding", body,
                decompress_to_string ? s.getEncoding() : NOTHING);

        return body;
    }

    #! helper method for handling log messages
    /** @param cx the call context hash; this hash will have the following keys:
        - \c header-info: a hash of information about the request header with the following keys:
          - \c accept-charset: this key will be set to an appropriate value from any \c "Accept-Charset" header; if
            any of \c "*", \c "utf8", or \c "utf-8" are present, then this will be set to \c "utf8", otherwise it will
            be set to the first requested character encoding in the list
          - \c accept-encoding: a hash where keys are values from any \c "Accept-Encoding" header and the values are
            @ref True
          - \c body-content-type: this is the \c "Content-Type" header without any charset declaration
          - \c charset: if there is a charset declaration in the \c "Content-Type" header, the value is returned in
            this key
          - \c client-cert: if the server is configured to capture remote client certificates, and the client supplied
            a certificate, this key will be populated with the @ref Qore::SSLCertificate "SSLCertificate" for the client
          - \c close: set to @ref True "True" if the connection should be closed after responding,
            @ref False "False" if not (as derived from the request header)
          - \c headers-raw: a hash of raw request headers without any case conversions or other processing
          - \c request-uri: gives the request URI in an HTTP request
        - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
        - \c socket-info: a hash of socket information for the listening socket (as returned by
          @ref Qore::Socket::getSocketInfo())
        - \c peer-info: a hash of socket information for the remote socket (as returned by
          @ref Qore::Socket::getPeerInfo())
        - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
        - \c id: the unique HTTP connection ID
        - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
        - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
        - \c user: the current RBAC username (if any)
        - \c root_path: the root URL path matched if the request was matched by a URL prefix
        @param api the API description hash
        @param params a reference to the call parameters; the call context hash will be added as the first argument
        @param args an optional reference to a string describing the arguments

        @return a string if the message should be logged, otherwise @ref nothing
    */
    static *string getLogMessage(hash<auto> cx, hash api, reference params, *reference<string> args) {
        on_exit {
            if (params.typeCode() == NT_LIST)
                unshift params, cx;
            else if (exists params)
                params = (cx, params);
            else
                params = cx;
        }

        if ((api.logopt & HttpServer::LP_LEVELMASK) > 1 || !cx.logfunc)
            return;

        string msg = cx.method;

        # add arguments to log message
        args = "";
        if (api.logopt & HttpServer::LP_LOGPARAMS) {
            args += "(";
            int i = 0;
            hash amh;
            if (api.maskargs)
                map amh.$1 = True, api.maskargs;
            foreach auto arg in (params) {
                if (amh.(i++))
                    args += "<masked>, ";
                else if (arg.typeCode() == NT_HASH && arg) {
                    args += "{";
                    args += foldl $1 + "," + $2,
                        (map $1 == api.maskkey
                            ? sprintf("%s: <masked>", $1)
                            : sprintf("%s: %y", $1, arg.$1), keys arg);
                    args += "}, ";
                } else
                    args += sprintf("%y, ", arg);
            }
            # remove the last two characters from the string if any were added
            args =~ s/, $//;
            args += ")";
        }

        return sprintf("%s(%s)", msg, args);
    }

    #! called before handleRequest()
    /** Any data returned here will be given to restoreThreadLocalData() after the handleRequest() call

        @note the default implementation does nothing
    */
    *hash<auto> saveThreadLocalData() {
    }

    #! called after handleRequest() with any data returned from saveThreadData()
    /** @note the default implementation does nothing
    */
    restoreThreadLocalData(*hash<auto> data) {
    }

    #! creates a hash for an HTTP response with the response code and the response message body as a formatted string
    static hash<HttpResponseInfo> makeResponse(int code, string fmt, ...) {
        return <HttpResponseInfo>{
            "code": code,
            "body": vsprintf(fmt, argv),
        };
    }

    #! creates a hash for an HTTP response with the response code and the response message body as a formatted string
    static hash<HttpResponseInfo> makeResponse(hash<auto> hdr, int code, string fmt, ...) {
        return <HttpResponseInfo>{
            "code": code,
            "body": vsprintf(fmt, argv),
            "hdr": hdr,
        };
    }

    #! creates a hash for an HTTP response with the response code and the response message body as binary data
    static hash<HttpResponseInfo> makeResponse(int code, binary body) {
        return <HttpResponseInfo>{
            "code": code,
            "body": body,
        };
    }

    #! creates a hash for an HTTP response with the response code and the response message body as binary data
    static hash<HttpResponseInfo> makeResponse(hash<auto> hdr, int code, binary body) {
        return <HttpResponseInfo>{
            "code": code,
            "body": body,
            "hdr": hdr,
        };
    }

    #! creates a hash for an HTTP response with the response code and a literal response message body
    static hash<HttpResponseInfo> makeResponse(int code, *data body, *hash<auto> hdr) {
        return <HttpResponseInfo>{
            "code": code,
            "body": body,
            "hdr": hdr,
        };
    }

    #! creates a hash for an HTTP response with the response code and a response message body from an input stream
    /** @since %HttpServerUtil 0.9.4
    */
    static hash<HttpResponseInfo> makeResponse(int code, *InputStream chunked_body, *hash<auto> hdr) {
        return <HttpResponseInfo>{
            "code": code,
            "chunked_body": chunked_body,
            "hdr": hdr,
        };
    }

    #! creates a hash for an HTTP 200 OK error response with the response message body as a string
    static hash<HttpResponseInfo> make200(string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(200, vsprintf(fmt, argv));
    }

    #! creates a hash for an HTTP 200 OK error response with the response message body as a string
    static hash<HttpResponseInfo> make200(hash<auto> hdr, string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(200, vsprintf(fmt, argv), hdr);
    }

    #! creates a hash for an HTTP 200 OK error response with the response message body from an input stream
    static hash<HttpResponseInfo> make200(hash<auto> hdr, InputStream chunked_body) {
        return AbstractHttpRequestHandler::makeResponse(200, chunked_body, hdr);
    }

    #! creates a hash for an HTTP 200 OK error response with the response message body from an input stream
    static hash<HttpResponseInfo> make200(InputStream chunked_body) {
        return AbstractHttpRequestHandler::makeResponse(200, chunked_body);
    }

    #! creates a hash for an HTTP 400 error response with the response message body as a string
    static hash<HttpResponseInfo> make400(string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(400, vsprintf(fmt, argv));
    }

    #! creates a hash for an HTTP 400 error response with the response message body as a string
    static hash<HttpResponseInfo> make400(hash<auto> hdr, string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(400, vsprintf(fmt, argv), hdr);
    }

    #! creates a hash for an HTTP 500 error response with the response message body as a string
    static hash<HttpResponseInfo> make500(string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(500, vsprintf(fmt, argv));
    }

    #! creates a hash for an HTTP 500 error response with the response message body as a string
    static hash<HttpResponseInfo> make500(hash<auto> hdr, string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(500, vsprintf(fmt, argv), hdr);
    }

    #! creates a hash for an HTTP 501 error response with the response message body as a string
    static hash<HttpResponseInfo> make501(string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(501, vsprintf(fmt, argv));
    }

    #! creates a hash for an HTTP 501 error response with the response message body as a string
    static hash<HttpResponseInfo> make501(hash<auto> hdr, string fmt, ...) {
        return AbstractHttpRequestHandler::makeResponse(501, vsprintf(fmt, argv), hdr);
    }

    #! generates a redirect hash for the given path
    static hash<HttpResponseInfo> redirect(hash<auto> cx, hash<auto> request_hdr, string path, int status_code = 301,
            *hash<auto> response_hdr) {
        # make sure no forward slashes are doubled in the path
        path =~ s/\/+/\//g;
        string uri = sprintf("http%s://%s/%s", cx.ssl ? "s" : "", request_hdr.host, path);
        return <HttpResponseInfo>{
            "code": status_code,
            "hdr": response_hdr + {"Location": uri},
            "body": request_hdr.method != "HEAD" ? sprintf("redirecting to %s", uri) : NOTHING,
        };
    }
}

#! abstract class for HTTP request handlers anchored at a specific URL
public class AbstractUrlHandler inherits HttpServer::AbstractHttpRequestHandler {
    public {
        #! root part of URL for matching requests
        string url_root;
    }

    #! creates the object based on the URL root and optional authenticator
    /** @param url_root the root part of the URL path without the leading \c "/"
        @param auth the authentication object to use to authenticate connections (see AbstractAuthenticator); if no
        AbstractAuthenticator object is passed, then by default no authentication will be required
     */
    constructor(string url_root, *AbstractAuthenticator auth) : AbstractHttpRequestHandler(auth) {
        url_root =~ s/^\/.+//;
        self.url_root = url_root;
    }

    #! returns the relative path anchored from the url_root if possible
    /** URI query arguments are stripped off, if the url_root cannot be matched then the path is returned with URI
        query arguments removed
    */
    string getRelativePath(string path) {
        if (url_root && path.equalPartialPath(url_root))
            path = path.substr(url_root.size() + 1);
        # strip URI query args from path
        path =~ s/\?.*$//;
        return path;
    }
}

#! Abstract class for HTTP handlers for handling protocol switching
/** To accept a new dedicated socket connection, make sure the return value of the \c handleRequest() method returns
    code \c 101 (ie <tt>Switching Protocols</tt>); after which this class's start() and then startImpl() methods are
    called.

    To accept a dedicated socket connection, \c handleRequest() must return a hash (ideally an
    @ref HttpServer::HttpResponseInfo hash) with the following keys:
    - \c "code": assign to 101 (ie \c "Switching Protocols"); if this is returned, then the start() method will be
      called with the @ref Qore::Socket "Socket object" for the new connection
    - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response
    \n
    or, to handle the request without a dedicated connection, return a hash with the following keys:
    - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
    - \c "body": the message body to return in the response
    - \c "close": (optional) set this key to @ref True "True" if the connection should be unconditionally closed when
      the handler returns
    - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response
*/
public class AbstractHttpSocketHandlerInterface {
    private {
        #! stop listener flag
        bool stop = False;

        #! hash of listener references; this is to stop all connections associated with a particular listener
        hash<string, int> lh;

        #! hash of listener stop flags
        hash<string, bool> lsh;

        #! listener reference hash mutex
        Mutex m();
    }

    #! Returns a closure that can be used to confirm that the connection has been closed
    code setExternallyManaged(softstring lid, hash<auto> cx, Socket s) {
        # get local vars that will be bound in the closure
        HttpServer::HttpListenerInterface listener = cx.listener;
        int cid = cx.id;

        # return a closure to confirm that the connection has been closed
        return sub () {
            handlerStopped(lid);
            listener.removeExternalDedicatedSocket(cid);
            s.shutdown();
            s.close();
        };
    }

    #! called from the HTTP server after the handleRequest() method indicates that a dedicated connection should be established
    /** This method should not return until the connection is closed or the stop() method is called

        @param lid the listener ID
        @param cx call context hash; this hash will have the following keys:
        - \c header-info: a hash of information about the request header with the following keys:
          - \c accept-charset: this key will be set to an appropriate value from any \c "Accept-Charset" header; if
            any of \c "*", \c "utf8", or \c "utf-8" are present, then this will be set to \c "utf8", otherwise it will
            be set to the first requested character encoding in the list
          - \c accept-encoding: a hash where keys are values from any \c "Accept-Encoding" header and the values are
            @ref True
          - \c body-content-type: this is the \c "Content-Type" header without any charset declaration
          - \c charset: if there is a charset declaration in the \c "Content-Type" header, the value is returned in
            this key
          - \c client-cert: if the server is configured to capture remote client certificates, and the client supplied
            a certificate, this key will be populated with the @ref Qore::SSLCertificate "SSLCertificate" for the client
          - \c close: set to @ref True "True" if the connection should be closed after responding,
            @ref False "False" if not (as derived from the request header)
          - \c headers-raw: a hash of raw request headers without any case conversions or other processing
          - \c request-uri: gives the request URI in an HTTP request
        - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
        - \c socket-info: a hash of socket information for the listening socket (as returned by
          @ref Qore::Socket::getSocketInfo())
        - \c peer-info: a hash of socket information for the remote socket (as returned by @ref Qore::Socket::getPeerInfo())
        - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
        - \c id: the unique HTTP connection ID
        - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
        - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
        - \c user: the current RBAC username (if any)
        - \c root_path: the root URL path matched if the request was matched by a URL prefix
        @param hdr a hash of headers in the request
        @param s the @ref Qore::Socket "Socket" object for the dedicated connection

        @return True if externally managed
    */
    bool start(softstring lid, hash<auto> cx, hash<auto> hdr, Socket s) {
        {
            m.lock();
            on_exit m.unlock();
            ++lh{lid};
        }
        on_error handlerStopped(lid);
        return startImpl(lid, cx, hdr, s);
    }

    #! called from the HTTP server when the socket should be closed due to an HTTP listener being stopped
    /** The start() method for all connections on the particular listener should return as soon as possible after this
        method is called.

        Child classes should implement the stopImpl(string) method which is called from this method to implement
        custom stop actions for particular listeners.

        @param lid the listener ID
    */
    stop(softstring lid) {
        {
            m.lock();
            on_exit m.unlock();
            if (!lh{lid})
                return;

            lsh{lid} = True;
        }

        stopImpl(lid);
    }

    #! called from the HTTP server when the socket should be closed due to an external request
    /** The start() method should return as soon as possible after this method is called

        Child classes should implement the stopImpl() method which is called from this method to implement custom stop
        actions.
    */
    stop() {
        stop = True;
        stopImpl();
    }

    #! Called when the handler stops
    private handlerStopped(softstring lid) {
        m.lock();
        on_exit m.unlock();
        if (!--lh{lid}) {
            delete lh{lid};
            delete lsh{lid};
        }
    }

    #! called from the HTTP server after the handleRequest() method indicates that a dedicated connection should be established
    /** This method should not return until the connection is closed or the stop() (and therefore stopImpl()) method
        is called

        @param lid the listener ID
        @param cx call context hash; this hash will have the following keys:
        - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
        - \c socket-info: a hash of socket information for the listening socket (as returned by
          @ref Qore::Socket::getSocketInfo())
        - \c peer-info: a hash of socket information for the remote socket (as returned by
          @ref Qore::Socket::getPeerInfo())
        - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
        - \c id: the unique HTTP connection ID
        - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
        - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
        - \c user: the current RBAC username (if any)
        - \c root_path: the root URL path matched if the request was matched by a URL prefix
        @param hdr a hash of headers in the request
        @param s the @ref Qore::Socket "Socket" object for the dedicated connection

        @return True if externally managed
     */
    private abstract bool startImpl(softstring lid, hash<auto> cx, hash<auto> hdr, Socket s);

    #! called from the HTTP server when the socket should be closed because the listener is stopping
    /** The start() method for all connections handled by the given listener should return as soon as possible after
        this method is called

        @param lid the listener ID
    */
    private stopImpl(string lid) {
    }

    #! called from the HTTP server when the socket should be closed due to an external request
    /** The start() method should return as soon as possible after this method is called
    */
    private stopImpl() {
    }
}

#! abstract class that all HTTP dedicated socket handler objects must inherit from
/** reimplement at least handleRequest() and startImpl() in subclasses
  */
public class AbstractHttpSocketHandler inherits AbstractHttpRequestHandler, AbstractHttpSocketHandlerInterface {
    #! create the object optionally with the given AbstractAuthenticator
    /** @param auth the authentication object to use to authenticate connections (see AbstractAuthenticator); if no
        AbstractAuthenticator object is passed, then by default no authentication will be required
    */
    constructor(*AbstractAuthenticator auth) : AbstractHttpRequestHandler(auth) {
    }
}
}
