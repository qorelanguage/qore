# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file PgsqlSqlUtil.qm Qore user module for working with PostgreSQL SQL data

/*  PgsqlSqlUtil.qm Copyright (C) 2013 - 2019 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.9.4

# requires the SqlUtil module
%requires SqlUtil >= 1.5

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module PgsqlSqlUtil {
    version = "1.4.1";
    desc = "user module for working with PostgreSQL SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

# version history is included below in the docs

/** @mainpage PgsqlSqlUtil Module

    @tableofcontents

    @section pgsqlsqlutilintro PgsqlSqlUtil Module Introduction

    The %PgsqlSqlUtil module provides a high level API for working with PostgreSQL database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires PgsqlSqlUtil" in your code.

    All the public symbols in the module are defined in the PgsqlSqlUtil namespace

    @note This module requires the <a href="https://github.com/qorelanguage/module-pgsql">pgsql</a> binary module for communication with PostgreSQL databases

    @section pgsql_schema_management Schema Management on PostgreSQL

    @subsection pgsql_type_mapping Type Mapping

    Column types are mapped from %Qore types as follows:

    <b>PostgreSQL Column Type Mappings</b>
    |!Generic Type Name|!PostgreSQL Type Used
    |\c float|\c double
    |\c integer|\c bigint
    |\c number|\c numeric
    |\c string|\c varchar
    |\c date|\c timestamp
    |\c binary|\c bytea
    |\c bool|\c boolean
    |@ref SqlUtil::BLOB|\c bytea
    |@ref SqlUtil::CHAR|\c char
    |@ref SqlUtil::CLOB|\c text
    |@ref SqlUtil::NUMERIC|\c numeric
    |@ref SqlUtil::VARCHAR|\c varchar

    To use other types, use the \c "native_type" @ref SqlUtil::AbstractTable::ColumnDescOptions "column description option" with the
    native PostgreSQL type name instead (under the \c "driver" and \c "pgsql" keys for schemas supporting multiple databases).

    @subsection pgsql_other_objects Additional Object Types Supported

    The following additional schema objects can be managed with %PgsqlSqlUtil:
    - @ref pgsql_types "types"

    @subsection pgsql_types Types

    The @ref schema_desc_hash takes an optional key, \c "types" that allows types in PostgreSQL schemas to be managed along with other objects.

    The \c "types" should be assigned to a hash, each key name is the name of the type, and the values are strings giving the type definition.

    The \c "types" key can go in the top level of the @ref schema_desc_hash for PostgreSQL-only schemas, or, for schemas targeting multiple database types, under the \c "driver" and \c "pgsql" keys as in the following example:

    @code{.py}
my hash $schema = (
    "driver": (
        "pgsql": (
            "types": (
                "info_record": "id numeric, ind numeric, status char",
            ),
        ),
    ),
);
    @endcode

    @subsection pgsql_functions Function Handling

    @par Function Names and Matching
    PostgreSQL functions are identified by their name and arguments; the algorithm implemented in this
    module is fairly simple; the argument names and types are used when trying to find functions, so they
    must match almost exactly.\n\n
    The only exception to the exact matching algorithm is that some simple substitutions are done on
    user-supplied arguments to try and use the verbose type names as retrieved by
    <a href="http://www.postgresql.org/docs/9.2/static/functions-info.html">pg_catalog.pg_get_function_identity_arguments()</a>,
    which always returns verbose type names (ie \c "character varying" instead of \c "varchar").\n\n
    Substitutions are made according to the inverse value of @ref PgsqlSqlUtil::PgsqlTable::PgsqlNameMap.\n\n
    This is done so that a user-supplied function name like \c "update_queue(qkey varchar, qdata text)" will match the
    value returned by <a href="http://www.postgresql.org/docs/9.2/static/functions-info.html">pg_catalog.pg_get_function_identity_arguments()</a>, which would be \c "update_queue(character varying queue)"

    @par Schema Management with Functions
    There is some simple logic in the driver that attempts to reorder function definitions so that they match the format returned by
    <a href="http://www.postgresql.org/docs/9.2/static/functions-info.html">pg_catalog.pg_get_functiondef()</a>
    which requires the following string to follow the function name and arguments:
    - <tt><b>returns</b></tt> <i>type</i> <tt><b>language</b></tt> <i>lang</i> <tt><b>as $function$ </b></tt>
    .
    The logic in the module attempts to move any language and volatility declarations from the end of the declaration to the beginning.  Additionally, dollar-quoting is detected automatically and substituted with \c "$function$" automatically.\n\n
    If your function is reported as needing updating even though it's already in the database correctly, then the logic in this module
    needs to be update to provide more flexibility (please report to david@qore.org).  Until the module can be enhanced, try the format as
    in the following example:
    @code{.py}
update_queue_data(qkey varchar, qdata text) returns integer language plpgsql as $function$
declare
  rowcount integer;
begin
  update queue_data set data = qdata, queue_data_status = 'R' where queuekey = qkey and queue_data_status = 'W';
  get diagnostics rowcount = row_count;
  return rowcount;
end;
$function$
    @endcode
    @note Future versions of the module may provide more intelligence to reformat user-supplied functions to match the
    format retrieved from the database, however currently functions should be provided in the format above in order
    to use functionality like @ref SqlUtil::AbstractDatabase::getAlignFunctionSql() "AbstractDatabase::getAlignFunctionSql()" for example.

    @section pgsql_relnotes Release Notes

    @subsection pgsqlsqlutilv14 PgsqlSqlUtil v1.4.1
    - fixed a bug generating literal date/time values for SQL queries
      (<a href="https://github.com/qorelanguage/qore/issues/3948">issue 3948</a>)

    @subsection pgsqlsqlutilv14 PgsqlSqlUtil v1.4
    - added support for the DataProvider module
      (<a href="https://github.com/qorelanguage/qore/issues/3545">issue 3545</a>)

    @subsection pgsqlsqlutilv131 PgsqlSqlUtil v1.3.1
    - fixed compatibility with PostgreSQL 12
      (<a href="https://github.com/qorelanguage/qore/issues/3589">issue 3589</a>)
    - fixed comparison of triggers with column restrictions with table alignment
      (<a href="https://github.com/qorelanguage/qore/issues/3466">issue 3466</a>)
    - fixed quoting of reserved words in column names in table alignment
      (<a href="https://github.com/qorelanguage/qore/issues/3400">issue 3400</a>)

    @subsection pgsqlsqlutilv13 PgsqlSqlUtil v1.3
    - added support for serializing and deserializing @ref SqlUtil::AbstractTable "AbstractTable" objects (<a href="https://github.com/qorelanguage/qore/issues/2663">issue 2663</a>)

    @subsection pgsqlsqlutilv121 PgsqlSqlUtil v1.2.1
    - implemented support for custom column operators (<a href="https://github.com/qorelanguage/qore/issues/2314">issue 2314</a>)
    - fixed a bug where default column values were compared incorrectly leading to false positives when comparing and aligning DB schemas (<a href="https://github.com/qorelanguage/qore/issues/2527">issue 2527</a>)

    @subsection pgsqlsqlutilv12 PgsqlSqlUtil v1.2
    - updated for complex types

    @subsection pgsqlsqlutilv112 PgsqlSqlUtil v1.1.2
    - fixed a bug in setting a \c comment for a table column (<a href="https://github.com/qorelanguage/qore/issues/1886">issue 1886</a>)
    - implemented @ref cop_trunc_date() operator (<a href="https://github.com/qorelanguage/qore/issues/2032">issue 2032</a>)

    @subsection pgsqlsqlutilv111 PgsqlSqlUtil v1.1.1
    - implemented the \a force option (i.e. cascade) for dropping code objects (<a href="https://github.com/qorelanguage/qore/issues/1314">issue 1314</a>)

    @subsection pgsqlsqlutilv11 PgsqlSqlUtil v1.1
    - added support for \c cop_cast operator (<a href="https://github.com/qorelanguage/qore/issues/535">feature 535</a>)
    - added support for the following datatypes and aliases: bool, float, int, timetz, timestamptz, varbit
    - fixed support for the following datatypes and aliases: bit, bit varying, char, character, character varying, char varying, oid, varchar
    - fixed bugs handling "bigint" and "double precision" column types with schema alignments
    - fixed a bug with PgsqlTable::tryInsertImpl(); added an explicit "begin" call to make the savepoint work with PostgreSQL 9.3+ servers
    - fixed a bug retrieving foreign constraints; columns were not guaranteed to be returned in declaration order
    - implemented support for the \c "returning" clause as an insert option
    - fixed a bug handling tablespaces in unique constraints
    - fixed bugs in @ref SqlUtil::cop_seq() and @ref SqlUtil::cop_seq_currval() (<a href="https://github.com/qorelanguage/qore/issues/624">issue 624</a>)
    - added support for listing PostgreSQL types and materialized views (<a href="https://github.com/qorelanguage/qore/issues/699">issue 699</a>)

    @subsection pgsqlsqlutilv10 PgsqlSqlUtil v1.0
    - initial release
*/

#! the PgsqlSqlUtil namespace contains all the objects in the PgsqlSqlUtil module
public namespace PgsqlSqlUtil {
    #! returns a PgsqlTable object corresponding to the arguments
    public PgsqlTable sub get_table(AbstractDatasource nds, string nname, *hash<auto> opts) {
        return new PgsqlTable(nds, nname, opts);
    }

    #! returns a PgsqlDatabase object corresponding to the arguments
    public PgsqlDatabase sub get_database(AbstractDatasource nds, *hash<auto> opts) {
        return new PgsqlDatabase(nds, opts);
    }

    #! the data type for PostgreSQL NUMBER columns
    public class PgsqlNumberDataType inherits SqlUtil::AbstractNumericDataType {
        #! creates the object
        constructor(string native_type, bool nullable, *hash<auto> options) : AbstractNumericDataType(native_type, nullable, options) {
            # cannot bind a string to a numeric column
            base_type_hash -= NT_STRING.toString();
        }
    }

    sub parse_schema_name(string nname, reference<string> schema, reference<string> name) {
        *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
        if (sstr) {
            schema = sstr;
            splice nname, 0, schema.size() + 1;
            name = nname;
        } else {
            schema = "public";
            name = nname;
        }
    }

    #! PostgreSQL savepoint helper
    public class PgsqlSavepointHelper inherits AbstractSavepointHelper {
        #! Creates the object
        constructor(AbstractDatasource ds, *string savepoint) : AbstractSavepointHelper(ds, savepoint) {
        }

        #! Creates the savepoint
        private createSavepointImpl() {
            ds.exec("savepoint " + savepoint);
        }

        #! Rolls back to the savepoint
        private rollbackImpl() {
            ds.exec("rollback to savepoint " + savepoint);
        }

        #! Deletes the savepoint
        private deleteSavepointImpl() {
            ds.exec("release savepoint " + savepoint);
        }
    }

    #! represents a PostgreSQL type
    public class PgsqlType inherits Serializable {
        public {
            #! the name of the type
            string name;

            #! the source of the type
            string src;
        }

        #! creates the type from the supplied arguments
        constructor(string n_name, string n_src) {
            name = n_name;
            src = n_src;
        }

        list getTypeList() {
            list sl = src.split(",");
            trim sl;

            list l = ();
            foreach string str in (sl) {
                (*string tname, *string type) = (str =~ x/(\w+) (.*)/);
                if (!tname || !type)
                    throw "TYPE-COMPONENT-ERROR", sprintf("type %y: can't find element name and type in element %d %y of source %y", name, $# + 1, str, src);
                l += (
                    "name": tname,
                    "type": type,
                );
            }
            return l;
        }

        list getModifySql(PgsqlType old, *hash opt) {
            list sqll = ();

            list tl = getTypeList();
            list oldtl = old.getTypeList();

            #printf("tl: %N\noldtl: %N\n", tl, oldtl);

            # process differences in old attributes
            foreach hash oldh in (oldtl.iterator()) {
                if ($# >= tl.size()) {
                    sqll += sprintf("alter type %s drop attribute %s", name, oldh.name);
                    continue;
                }
                hash h = tl[$#];
                if (oldh.type != h.type)
                    sqll += sprintf("alter type %s alter attribute %s type %s%s", name, oldh.name, h.type, opt.force ? " cascade" : "");
                if (oldh.name != h.name)
                    sqll += sprintf("alter type %s rename attribute %s to %s", name, oldh.name, h.name);
            }
            # add any new attributes
            for (int i = oldtl.size(); i < tl.size(); ++i)
                sqll += sprintf("alter type %s add attribute %s %s", name, tl[i].name, tl[i].type);

            return sqll;
        }

        #! returns a string that can be used to create the type in the database
        string getCreateSql(*hash opt) {
            return sprintf("create type %s as (%s)", name, src);
        }

        #! returns a string that can be used to drop the function from the database
        /** @param opt drop options; if \a force is @ref True "True", then the \c CASCADE option will be used in the drop statement
         */
        string getDropSql(*hash opt) {
            return sprintf("drop type %s%s", name, opt.force ? " cascade" : "");
        }

        #! returns a string that can be used to rename a type
        /** @param new_name the new name of the object
            @param opt this argument is ignored
         */
        string getRenameSql(string new_name, *hash opt) {
            return sprintf("alter type %s rename to %s", name, new_name);
        }

        #! returns @ref True if the types are equal
        bool equal(PgsqlType type) {
            return name == type.name && src == type.src;
        }
    }

    #! represents a PostgreSQL-specific index
    public class PgsqlIndex inherits SqlUtil::AbstractIndex {
        public {
            #! the tablespace name of the index
            *string tablespace;
        }

        #! creates the object from the arguments
        constructor(string n_name, bool n_unique, hash n_cols, *string n_tablespace) : AbstractIndex(n_name, n_unique, n_cols) {
            tablespace = n_tablespace;
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.getSqlColumnNameIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);
            return sql;
        }

        #! returns @ref True "True" if the argument is equal to the current index, @ref False "False" if not
        private bool equalImpl(AbstractIndex ix) {
            return True;
        }

        #! returns a string that can be used to rename the index in the database
        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter index %s rename to %s", name, new_name);
        }

    }

    #! represents a PostgreSQL-specific foreign constraint
    public class PgsqlForeignConstraint inherits SqlUtil::AbstractForeignConstraint {
        #! creates the constraint from the supplied arguments
        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractForeignConstraint(n, c, t) {
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string table_name, *hash opt) {
            return getCreateSql(name, table_name, opt);
        }

        softlist getRenameSql(string table_name, string new_name) {
            # the following is only valid with PostgreSQL 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            list l += getDropSql(table_name);
            l += getCreateSql(new_name, table_name);
            return l;
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string name, string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, h.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }
    }

    #! represents a PostgreSQL-specific check constraint
    public class PgsqlCheckConstraint inherits SqlUtil::AbstractCheckConstraint {
        #! creates the constraint from the supplied arguments
        constructor(string n, string n_src) : AbstractCheckConstraint(n, n_src) {
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string table_name, *hash opt) {
            return getCreateSql(name, table_name, opt);
        }

        list getRenameSql(string table_name, string new_name) {
            # the following is only valid with PostgreSQL 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            list l += getDropSql(table_name);
            l += getCreateSql(new_name, table_name);
            return l;
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string name, string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }
    }

    #! represents a PostgreSQL-specific column
    public class PgsqlColumn inherits SqlUtil::AbstractColumn {
        public {
            #! byte size of the column
            int byte_size;
        }

        #! empty constructor for subclasses
        private constructor() {
        }

        #! creates the column from the supplied arguments
        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, softint bs) : AbstractColumn(n, nt, qt, sz, nul, dv, cm) {
            byte_size = bs;
        }

        #! returns a string giving the native type of the column
        string getNativeTypeString() {
            string sql = native_type;
            switch (native_type) {
                case =~ /^timestamptz/: return splice sql, 11, 0, "(" + string(size) + ")";
                case =~ /^timestamp/: return splice sql, 9, 0, "(" + string(size) + ")";
                case =~ /^timetz/: return splice sql, 6, 0, "(" + string(size) + ")";
                case =~ /^time/: return splice sql, 4, 0, "(" + string(size) + ")";
            }
            if (size)
                sql += sprintf("(%d)", size);
            return sql;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code{.py}
list l = col.getAddColumnSql(t);
            @endcode

            @param t the SqlUtil::AbstractTable object to modify
         */
        list getAddColumnSql(AbstractTable t) {
            list l += sprintf("alter table %s add %s", t.getSqlName(), AbstractColumn::getCreateSql(t));
            if (comment)
                l += sprintf("comment on column %s.%s is %s", t.getSqlName(), ddl_name, t.getSqlValue(comment));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code{.py}
list l = col.getModifySql(t, newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the SqlUtil::AbstractTable object to modify
            @param col the new column definition
            @param opt column modification options (none are supported by this class)

            @return a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
         */
        list getModifySqlImpl(AbstractTable t, AbstractColumn col, *hash opt) {
            list l = ();
            PgsqlColumn c = col;

            # get new native type declaration string
            string nts = c.getNativeTypeString();
            if (getNativeTypeString() != nts) {
                #printf("ME: %s\nDB: %s\n", nts, getNativeTypeString());
                # first drop any default value if it's changing
                if (def_val !== c.def_val)
                    l += sprintf("alter table %s alter %s drop default", t.getSqlName(), ddl_name);

                l += sprintf("alter table %s alter %s type %s", t.getSqlName(), ddl_name, nts);

                if (def_val !== c.def_val && exists c.def_val && c.def_val !== NULL)
                    l += sprintf("alter table %s alter %s set default %s", t.getSqlName(), ddl_name, c.def_val);
            }
            else if (def_val !== c.def_val) {
                # issue #2527: ensure that mismatches are not due to server type info
                bool ok;
                if (c.def_val.val() && c.def_val !~ /::/ && def_val =~ /::/) {
                    string ndv = def_val;
                    ndv =~ s/::.*//;
                    if (ndv == c.def_val)
                        ok = True;
                }
                if (!ok) {
                    #printf("L: %N\nXXXXXXXXXXXXXXX\nR: %N\n\n", self, c);
                    if (exists c.def_val && c.def_val !== NULL)
                        l += sprintf("alter table %s alter %s set default %s", t.getSqlName(), ddl_name, c.def_val);
                    else
                        l += sprintf("alter table %s alter %s drop default", t.getSqlName(), ddl_name);
                }
            }
            if (nullable != c.nullable) {
                l += sprintf("alter table %s alter %s %s not null", t.getSqlName(), ddl_name, c.nullable ? "drop" : "set");
            }

            if (c.comment != comment)
                l += sprintf("comment on column %s.%s is %s", t.getSqlName(), ddl_name, t.getSqlValue(c.comment));
            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code{.py}
string str = col.getRenameSql(t, "new_name");
            @endcode

            @param t the SqlUtil::AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("alter table %s rename %s to %s", t.getSqlName(), ddl_name, getDdlName(new_name));
        }

        #! returns the column name with quoting in case the column name is a reserved word
        /** the name returned here will be used when executing DDL
        */
        string getDdlName(string name) {
            return PgsqlDatabase::PgsqlReservedWords{name.lwr()} ? ("\"" + name + "\"") : name;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractColumn c) {
            return True;
        }
    }

    #! represents a PostgreSQL-specific numeric column
    public class PgsqlNumericColumn inherits PgsqlColumn, SqlUtil::NumericColumnInfo {
        #! creates the column from the supplied arguments
        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, softint bs, softint n_scale) : PgsqlColumn(n, nt, qt, sz, nul, dv, cm, bs), NumericColumnInfo(n_scale) {
        }

        #! returns a string giving the native type of the column
        string getNativeTypeString() {
            switch (native_type) {
                # do not return with numeric precision
                case "bigint":
                case "double precision":
                    return native_type;
            }
            return NumericColumnInfo::getNativeTypeString(native_type, size);
        }
    }

    #! common base class for unique constraints
    public class PgsqlUniqueConstraintCommon inherits SqlUtil::AbstractUniqueConstraint {
        private {
            #! any tablespace for the unique key index
            *string tablespace;
        }

        #! creates the constraint with an optional tablespace name
        constructor(*string ts) {
            tablespace = ts;
        }

        #! returns the tablespace name used for this constraint, if known
        *string getTablespace() {
            return tablespace;
        }

        #! sets or clears the tablespace name
        setTablespace(*string ts) {
            tablespace = ts;
        }

        #! sets the supporting index name
        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        #! adds index options onto the sql creation string
        getIndexSql(reference<string> sql, string name, *hash opts) {
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                sql += sprintf(" (%s)", (foldl $1 + ", " + $2, getSqlColumnNameIterator()));

                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts)
                    sql += sprintf(" using index tablespace %s", ts);
            }
        }
    }

    #! class modeling a unique constraint
    public class PgsqlUniqueConstraint inherits SqlUtil::AbstractUniqueConstraint, PgsqlUniqueConstraintCommon {
        private {
            #! @ref True "True" if the constraint is enabled, @ref False "False" if not
            bool enabled;
        }

        #! creates the object with the given attributes
        /** @param n name of the constraint
            @param n_cols column hash
            @param e the enabled status of the constraint
            @param ts optional tablespace name
        */
        constructor(string n, hash n_cols, bool e = True, *string ts) : AbstractUniqueConstraint(n, n_cols), PgsqlUniqueConstraintCommon(ts) {
            enabled = e;
        }

        #! returns the PgsqlColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        PgsqlColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        #! returns a string that can be used to create the constraint
        string getCreateSql(string table_name, *hash opts) {
            return getCreateSql(name, table_name, opts);
        }

        list getRenameSql(string table_name, string new_name) {
            # the following is only valid with PostgreSQL 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            list l += getDropSql(table_name);
            l += getCreateSql(new_name, table_name);
            return l;
        }

        #! returns a string that can be used to rename the constraint
        string getCreateSql(string name, string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s unique ", table_name, name);
            getIndexSql(\sql, name, opts);
            return sql;
        }

        #! returns @ref True "True" if the constraint is enabled, @ref False "False" if not
        bool isEnabled() {
            return enabled;
        }
    }

    #! represents a PostgreSQL-specific primary key constraint
    public class PgsqlPrimaryKey inherits SqlUtil::AbstractPrimaryKey, PgsqlUniqueConstraintCommon {
        #! creates an empty primary key object
        constructor() {
        }

        #! creates the object with the given attributes
        /** @param n name of the constraint
            @param c column hash
            @param ts optional tablespace name
        */
        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c), PgsqlUniqueConstraintCommon(ts) {
        }

        #! returns the PgsqlColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        PgsqlColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        #! returns a string that can be used to create the constraint
        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key", table_name, name);
            getIndexSql(\sql, name, opts);
            return sql;
        }

        #! returns a string that can be used to rename the constraint
        softlist getRenameSql(string table_name, string new_name) {
            # the following is only valid with PostgreSQL 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            return sprintf("alter index %s rename to %s", name, new_name);
        }
    }

    #! class for PostgreSQL sequences
    public class PgsqlSequence inherits SqlUtil::AbstractSequence {
        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_end) : AbstractSequence(n_name, n_start, n_increment, n_end) {
        }

        #! returns a string that can be used to create the sequence in the database
        string getCreateSql(*hash opt) {
            string sql = sprintf("create sequence %s start with %d increment by %d ", name, start, increment);
            sql += max ? sprintf("maxvalue %d", max) : "no maxvalue";
            return sql;
        }

        #! returns a string that can be used to rename the sequence in the database
        /** The object is renamed in place with this call
            @param new_name the new name of the object
            @param opt this option is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("alter sequence %s rename to %s", name, new_name);
        }
    }

    #! represents a PostgreSQL view
    public class PgsqlView inherits SqlUtil::AbstractView {
        public {
            #! Owner of the view
            *string viewowner;
        }

        #! creates the object from the arguments
        constructor(string n_name, string n_src, *string n_schemaname,
                    *string n_viewowner)
                : AbstractView(n_name, n_src) {
            schema = n_schemaname;
            viewowner = n_viewowner;
            updatable = False;
        }

        #! returns a string that can be used to create the view in the database
        string getCreateSql(*hash opt) {
            # TODO/FIXME: more pgsql options - what's allows in "opt"?
            return sprintf("create %s%sview %s as %s",
                           opt.replace ? "or replace " : "",
                           opt.temp ? "temp " : "",
                           name,
                           src
                          );
        }

        #! returns a string that can be used to rename the view in the database
        /** The object is renamed in place with this call
            @param new_name the new name of the object
            @param opt this option is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("alter view %s rename to %s", name, new_name);
        }
    }

    #! represents a PostgreSQL-specific trigger
    public class PgsqlTrigger inherits SqlUtil::AbstractTrigger {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractTrigger(n, n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        softlist getCreateSql(string table_name, *hash opt) {
            return sprintf("create trigger %s %s", name, src);
        }

        #! returns a string that can be used to drop the trigger from the database
        softlist getDropSql(string table_name) {
            return sprintf("drop trigger %s on %s", name, table_name);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the trigger in the database
        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter trigger %s on %s rename to %s", name, table_name, new_name);
        }

        #! returns normalized source for comparisons
        string getNormalizedSource(string src) {
            # remove all line comments
            src =~ s/--.*//gm;
            src = AbstractTrigger::getNormalizedSource(src);
            # remove all block comments
            src =~ s/\/\*.*\*\///g;
            # replace multiple whitespace chars with a single space
            src =~ s/\s+/ /g;
            # make everything lower case
            src =~ tr/A-Z/a-z/;
            # issue #3589: PostgreSQL 12+ compatibility
            # make sure text always says "execute function" and not "execute procedure"
            src =~ s/execute function/execute procedure/;
            return src;
        }
    }

    #! represents a PostgreSQL-specific function
    public class PgsqlFunction inherits SqlUtil::AbstractFunction {
        public {
            *string args;
        }

        constructor(string n, string n_src, *string a) : AbstractFunction(n, "function", n_src) {
            args = a;
        }

        #! returns a string that can be used to create the function in the database
        softlist getCreateSql(*hash opt) {
            return sprintf("create%s function %s %s", opt.replace ? " or replace" : "", name, src);
        }

        #! returns a string that can be used to drop the function from the database
        /** @param opt drop options; if \a force is @ref True "True", then the \c CASCADE option will be used in the drop statement
         */
        string getDropSql(*hash opt) {
            return sprintf("drop function %s%s", name, opt.force ? " cascade" : "");
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the function in the database
        /** @param new_name the new name of the object
            @param opt this argument is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("alter function %s rename to %s(%s)", name, new_name, args);
        }

        #! sets the new name of the function
        setName(string new_name) {
            name = sprintf("%s(%s)", new_name, args);
        }
    }

    #! represents a PostgreSQL-specific trigger function
    public class PgsqlTriggerFunction inherits PgsqlFunction {
        public {
            #! trigger name
            string trigger;
        }

        constructor(string n, string n_src, string n_trigger) : PgsqlFunction(n, n_src) {
            trigger = n_trigger;
        }
    }

    #! provides the PostgreSQL-specific implementation of the AbstractDatabase interface
    public class PgsqlDatabase inherits SqlUtil::AbstractDatabase {
       public {
            #! PostgreSQL-specific schema description keys
            const PgsqlSchemaDescriptionOptions = AbstractDatabase::SchemaDescriptionOptions + (
                "types": Type::Hash,
                "type_map": Type::Hash,
                );

            const PGSQL_TempSavepoint = "qore_pgsql_tmp_savepoint";

            #! Options for reclaimSpace()
            const PgsqlReclaimSpaceOptions = ReclaimSpaceOptions + (
                "full"              : Type::Boolean,
                "analyze"           : Type::Boolean,
                );

            #! hash (set) of reserved words
            const PgsqlReservedWords = {
                "all": True,
                "analyse": True,
                "analyze": True,
                "and": True,
                "any": True,
                "as": True,
                "asc": True,
                "authorization": True,
                "between": True,
                "binary": True,
                "both": True,
                "case": True,
                "cast": True,
                "check": True,
                "collate": True,
                "column": True,
                "constraint": True,
                "create": True,
                "cross": True,
                "currentdate": True,
                "currenttime": True,
                "currenttimestamp": True,
                "currentuser": True,
                "default": True,
                "deferrable": True,
                "desc": True,
                "distinct": True,
                "do": True,
                "else": True,
                "end": True,
                "except": True,
                "false": True,
                "for": True,
                "foreign": True,
                "freeze": True,
                "from": True,
                "full": True,
                "grant": True,
                "group": True,
                "having": True,
                "ilike": True,
                "in": True,
                "initially": True,
                "inner": True,
                "intersect": True,
                "into": True,
                "is": True,
                "isnull": True,
                "join": True,
                "leading": True,
                "left": True,
                "like": True,
                "limit": True,
                "localtime": True,
                "localtimestamp": True,
                "natural": True,
                "new": True,
                "not": True,
                "notnull": True,
                "null": True,
                "off": True,
                "offset": True,
                "old": True,
                "on": True,
                "only": True,
                "or": True,
                "order": True,
                "outer": True,
                "overlaps": True,
                "placing": True,
                "primary": True,
                "references": True,
                "right": True,
                "select": True,
                "sessionuser": True,
                "similar": True,
                "some": True,
                "table": True,
                "then": True,
                "to": True,
                "trailing": True,
                "true": True,
                "union": True,
                "unique": True,
                "user": True,
                "using": True,
                "verbose": True,
                "when": True,
                "where": True,
            };
        }

        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
        }

        private list<string> featuresImpl() {
            return (DB_FUNCTIONS, DB_PROCEDURES, DB_SEQUENCES,
                    DB_TABLES, DB_TYPES, DB_VIEWS, DB_MVIEWS);
        }

        PgsqlType makeType(string name, string src, *hash opts) {
            return new PgsqlType(name, src);
        }

        *PgsqlType getType(string name) {
            *hash qh = ds.select("select attname, pg_catalog.format_type(a.atttypid, a.atttypmod) typedef from pg_class c, pg_catalog.pg_attribute a where relkind = 'c' and attrelid = c.oid AND a.attnum > 0 AND NOT a.attisdropped and relname = %v order by attnum", name);
            if (!qh.attname)
                return;

            string src = foldl $1 + ", " + $2, (map sprintf("%s %s", $1.attname, $1.typedef), qh.contextIterator());

            # replace common type names with verbose type names as stored in PostgreSQL
            foreach hash<auto> h in (PgsqlTable::PgsqlNameMap.pairIterator()) {
                src = replace(src, h.key, h.value);
            }
            # remove invalid "(1)" strings
            src = replace(src, "(1)", "");

            return new PgsqlType(name, src);
        }

        private PgsqlSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return new PgsqlSequence(name, start, increment, end);
        }

        private *AbstractSequence getSequenceImpl(string name) {
            *hash<auto> row = ds.selectRow("select relname from pg_class where relkind = 'S' and relname = %v", name);
            if (!row)
                return;

            row = ds.selectRow("select * from %s", name);
            return new PgsqlSequence(name, row.start, row.increment, row.max == 9223372036854775807 ? NOTHING : row.max);
        }

        private *AbstractView getViewImpl(string name) {
            string schema;
            parse_schema_name(name, \schema, \name);

            *hash<auto> row = ds.selectRow("select * from pg_views where schemaname = %v and viewname = %v", schema, name);
            if (!row)
                return;

            return new PgsqlView(name, row.definition, row.schemaname, row.viewowner);
        }

        private PgsqlFunction makeFunctionImpl(string name, string src, *hash opts) {
            string nc = name;

            trim src;

            # change $ quoting to standard form
            *string dq = (src =~ x/as (\$.*\$)/i)[0];
            if (dq)
                src = replace(src, dq, "$function\$");

            # move trailing "language xxx" and type to start of declaration
            if (src =~ / as /i) {
               *string type = (src =~ x/(stable|volatile|immutable)$/)[0];
               if (type)
                   splice src, -(type.size() + 1);

               *string tlang = (src =~ x/language (.*)$/i)[0];
               if (tlang) {
                   src =~ s/language .*$//i;
                   src = regex_subst(src, " as ", " language " + tlang + " as ", RE_Caseless);
               }
               if (type)
                   src = regex_subst(src, " as ", " " + type + " as ", RE_Caseless);
            }

            *string args = PgsqlDatabase::getFunctionArgs("FUNCTION-ERROR", \nc);

            if (args) {
                # remove " in " in arg list & name since it's the default and not returned by pg_get_function_identity_arguments()
                args =~ s/ in / /ig;

                # replace verbose type names with short type names
                foreach hash<auto> h in (PgsqlTable::PgsqlNameMap.pairIterator()) {
                    args = replace(args, h.key, h.value);
                }

                # use our args in name
                name = regex_subst(name, "\\((.*)\\)", "(" + args + ")");
            }

            trim src;
            return new PgsqlFunction(name, src, args);
        }

        private PgsqlFunction makeProcedureImpl(string name, string src, *hash opts) {
            return makeFunctionImpl(name, src, opts);
        }

        private *AbstractFunction getFunctionImpl(string name) {
            *hash qh;
            # try to find a unique function without arguments
            if (name !~ /\(/) {
                qh = ds.select("select p.proname, t1.typname return_type, a.rolname procedure_owner, l.lanname lang, prosrc body, pg_catalog.pg_get_functiondef(proname::regproc) hdr, pg_catalog.pg_get_function_identity_arguments(proname::regproc) args, case provolatile when 'i' then 'IMMUTABLE' when 's' then 'STABLE' when 'v' then 'VOLATILE' end stability from pg_proc p left join pg_type t1 on p.prorettype = t1.oid left join pg_roles a on p.proowner = a.oid left join pg_language l on p.prolang = l.oid where proname = %v", name);
                if (!qh.proname)
                    return;
                if (qh.proname.size() > 1)
                    throw "FUNCTION-ERROR", sprintf("found %d matches for function name %y: %y; use the full argument list in the name to match only function (ex: \"%s(%s)\"", qh.proname.size(), name, (foldl $1 + ", " + $2, (map sprintf("%s(%s)", name, $1.args), qh.contextIterator())), name, qh.args[0]);
                # assign first row to qh
                context (qh) qh = %%;
            }
            else {
                string nc = name;
                *string args = PgsqlDatabase::getFunctionArgs("FUNCTION-ERROR", \nc);
                nc = name.substr(0, name.find('('));
                # replace common type names with verbose type names as stored in PostgreSQL
                if (args) {
                    foreach hash<auto> h in (PgsqlTable::PgsqlNameMap.pairIterator()) {
                        args = regex_subst(args, " " + h.value + "(,|$)", " " + h.key + "$1", RE_Caseless|RE_Global);
                    }
                    # remove " in " in argument list since it's the default and not returned by pg_get_function_identity_arguments()
                    args =~ s/ in / /ig;
                }

                qh = ds.selectRow("select p.proname, t1.typname return_type, a.rolname procedure_owner, l.lanname lang, prosrc body, pg_catalog.pg_get_functiondef(p.oid) hdr, pg_catalog.pg_get_function_identity_arguments(p.oid) args, case provolatile when 'i' then 'IMMUTABLE' when 's' then 'STABLE' when 'v' then 'VOLATILE' end stability from pg_proc p left join pg_type t1 on p.prorettype = t1.oid left join pg_roles a on p.proowner = a.oid left join pg_language l on p.prolang = l.oid where proname = %v and pg_catalog.pg_get_function_identity_arguments(p.oid) = %v", nc, args);
                if (!qh)
                    return;
            }

            return PgsqlDatabase::processFunction(qh, native_case);
        }

        private AbstractFunction getProcedureImpl(string name) {
            return getFunctionImpl(name);
        }

        static *string getFunctionArgs(string err, reference<string> src) {
            # remove function name and "(" at beginning of hdr
            int i = src.find("(");
            if (i == -1)
                throw err, sprintf("cannot find function arguments: %y", src);
            int e = src.find(")", i + 1);
            if (e == -1)
                throw err, sprintf("cannot find function arguments: %y", src);

            string tmp = extract src, 0, e + 1;
            trim src;
            return extract tmp, i + 1, e - i - 1;
        }

        static PgsqlFunction processFunction(hash<auto> row, bool native_case) {
            if (!native_case)
                map row.$1 = row.$1.lwr(), ("stability");

            trim row.hdr;
            # remove "create or replace function" from the beginning of hdr
            if (row.hdr !~ /^create or replace function /i)
                throw "FUNCTION-ERROR", sprintf("function does not begin with 'create or replace function': %y", row.hdr);

            # get and remove arguments
            *string args = PgsqlDatabase::getFunctionArgs("FUNCTION-ERROR", \row.hdr);

            if (args) {
                # replace verbose type names with short type names
                foreach hash<auto> h in (PgsqlTable::PgsqlNameMap.pairIterator()) {
                    args = replace(args, h.key, h.value);
                }
            }

            # fix return type
            *string rt = (row.hdr =~ x/returns (.*)/i)[0];
            if (rt) {
                string ort;
                # replace verbose type names with short type names
                foreach hash<auto> h in (PgsqlTable::PgsqlNameMap.pairIterator()) {
                    rt = replace(rt, h.key, h.value);
                }
                if (ort != rt)
                    row.hdr = regex_subst(row.hdr, "returns .*", "returns " + rt, RE_Caseless);
            }

            #printf("args: %y\n", args);
            if (!native_case) {
                row.hdr =~ s/^RETURNS /returns /;
                row.hdr =~ s/ SETOF / setof /;
                row.hdr =~ s/\n LANGUAGE / language /;
                row.hdr =~ s/\n STABLE/ stable/;
                row.hdr =~ s/\n IMMUTABLE/ immutable/;
                row.hdr =~ s/\nAS / as /;
            }

            string name = sprintf("%s(%s)", row.proname, args);
            return row.trigger_name ? new PgsqlTriggerFunction(name, row.hdr, row.trigger_name) : new PgsqlFunction(name, row.hdr, args);
        }

        private list getDropSchemaSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                return l;
            }

            list tl = dropSqlUnlocked("type", schema_hash, \getType(), \makeType(), opt, Type::String);
            if (tl) l += tl;

            return l;
        }

        private list getAlignSqlImpl(hash schema_hash, *hash opt) {
            string drv = getDriverName();
            list l = ();
            if (opt.start) {
                hash type_cache;

                # rename any types
                AbstractDatabase::checkDriverOptions(\schema_hash.type_map, drv);
                foreach hash<auto> th in (schema_hash.type_map.pairIterator()) {
                    if (th.value.typeCode() != NT_STRING)
                        throw "SCHEMA-DESCRIPTION-ERROR", sprintf("type_map %y value is not a string in the schema description hash; got type %y instead (%y)", th.key, th.value.type(), th.value);

                    *PgsqlType type = getType(th.key);
                    if (type) {
                        l += AbstractDatabase::doCallback(opt, type.getRenameSql(th.value), AbstractDatabase::AC_Rename, "type", th.key, NOTHING, th.value);
                        type.name = th.value;
                        type_cache{th.value} = type;
                    }
                }

                # create missing types; update different types
                AbstractDatabase::checkDriverOptions(\schema_hash.types, drv);
                foreach string name in (schema_hash.types.keyIterator()) {
                    if (schema_hash.types{name}.typeCode() != NT_STRING)
                        throw "SCHEMA-DESCRIPTION-ERROR", sprintf("type %y value is not a string in the schema description hash; got type %y instead (%y)", name, schema_hash.types{name}.type(), schema_hash.types{name});

                    string src = schema_hash.types{name};

                    PgsqlType templateType(name, src);

                    # see if type exists
                    *PgsqlType type;
                    if (type_cache{name})
                        type = type_cache{name};
                    else {
                        type = getType(name);
                        if (!type) {
                            l += AbstractDatabase::doCallback(opt, templateType.getCreateSql(opt), AbstractDatabase::AC_Create, "type", name);
                            continue;
                        }
                    }

                    if (!templateType.equal(type)) {
                        l += AbstractDatabase::doCallback(opt, templateType.getModifySql(type, opt + ("force": True)), AbstractDatabase::AC_Modify, "type", name);
                    }
                }
                return l;
            }
            return l;
        }

        #! returns a list of string table names in the database
        private list<string> listTablesImpl() {
            string sql = "select n.nspname as schema, c.relname as name, pg_catalog.pg_get_userbyid(c.relowner) as owner,"
                               " case c.relkind when 'r' then 'table' when 'v' then 'view' when 'i' then 'index' when 'S' then 'sequence' when 's' then 'special' when 'f' then 'foreign table' end as type"
                          " from pg_catalog.pg_class c left join pg_catalog.pg_namespace n ON n.oid = c.relnamespace"
                         " where c.relkind in ('r','') and n.nspname <> 'pg_catalog' and n.nspname <> 'information_schema' and n.nspname !~ '^pg_toast' and pg_catalog.pg_table_is_visible(c.oid) order by 1,2";
            return ds.select(sql).name;
        }

        #! returns a list of string function names in the database
        /** The function names will include arguments in parentheses after the names

            @return a list of string function names in the database
        */
        private list<string> listFunctionsImpl() {
            string sql = "select n.nspname as schema, p.proname as name, pg_catalog.pg_get_function_result(p.oid) as result_type, pg_catalog.pg_get_function_arguments(p.oid) as args,"
                               " case when p.proisagg then 'agg' when p.proiswindow then 'window' when p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype then 'trigger' else 'normal' end as type"
                          " from pg_catalog.pg_proc p left join pg_catalog.pg_namespace n on n.oid = p.pronamespace"
                         " where n.nspname ~ '^(public)$' order by 1, 2, 4";
            *hash qh = ds.select(sql);

            return map sprintf("%s(%s)", $1.name, $1.args), qh.contextIterator();
        }

        #! since PostgreSQL only supports functions, this method is identical to listFunctionsImpl()
        /** @see listFunctionsImpl()
        */
        private list<string> listProceduresImpl() {
            return listFunctionsImpl();
        }

        private list<string> listSequencesImpl() {
            return ds.select("select relname from pg_class where relkind = 'S' order by 1").relname;
        }

        private list<string> listViewsImpl() {
            return ds.select("select table_name from information_schema.views where table_schema = any (current_schemas(false)) order by 1").table_name;
        }

        #! returns a list of string materialized view names in the database
        list<string> listMaterializedViews() {
            string sql = "select relname from pg_class"
                         " where relkind = 'r' and relnamespace in"
                               " (select oid from pg_namespace"
                                 " where nspname != 'information_schema' and nspname not like 'pg\_%')"
                         " order by 1";
            return ds.select(sql).relname;
        }

        #! returns an iterator listing the string materialized view names in the database
        ListIterator materializedViewIterator() {
            return listMaterializedViews().iterator();
        }

        #! returns a list of string type names in the database
        list<string> listTypes() {
            return ds.select("select user_defined_type_name as name from information_schema.user_defined_types order by 1").name;
        }

        #! returns an iterator listing the string type names in the database
        ListIterator typeIterator() {
            return listTypes().iterator();
        }

        #! returns a string that can be used to create the schema in the database
        private string getCreateSqlImpl(list l) {
            return PgsqlDatabase::getCreateSql(l);
        }

        #! returns a string that can be used to create the schema in the database
        static string getCreateSql(list l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l);
        }

        #! returns driver-specific options to the base abstract class
        private hash getSchemaDescriptionOptions() {
            return PgsqlSchemaDescriptionOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getReclaimSpaceOptions() {
            return PgsqlReclaimSpaceOptions;
        }

        #! returns the next value in the given sequence
        private softint getNextSequenceValueImpl(string name) {
            return ds.selectRow("select nextval(%v)", name).nextval;
        }

        #! returns the last value issued for the given sequence in the current session
        private softint getCurrentSequenceValueImpl(string name) {
            return ds.selectRow("select currval(%v)", name).nextval;
        }

        #! returns @ref True "True" if the database supports sequences
        private bool supportsSequencesImpl() {
            return True;
        }

        #! returns @ref True "True" if the database supports named types
        private bool supportsTypesImpl() {
            return True;
        }

        #! returns @ref True "True" if the database supports packages
        private bool supportsPackagesImpl() {
            return False;
        }

        #! rebuild index implementation. See @ref SqlUtil::AbstractDatabase::rebuildIndex()
        private bool rebuildIndexImpl(string name, *hash options) {
            string sql = sprintf("reindex index %s", name);
            ds.select(sql);
            return True;
        }

        #! compute statistics implementation. See @ref SqlUtil::AbstractDatabase::computeStatistics()
        private computeStatisticsImpl(*hash options) {
            softlist tables = options.tables ? options.tables : listTables();

            string sql = "analyze %s";

            foreach string i in (tables)
                ds.select(sql, i);
        }

        #! reclaim space implementation. See @ref SqlUtil::AbstractDatabase::reclaimSpace()
        private reclaimSpaceImpl(*hash options) {
            softlist tables = options.tables ? options.tables : listTables();

            string sql = sprintf("vacuum %s%s%s", options.full ? "full " : "",
                                                  options.analyze ? "analyze " : "");

            if (options.tables) {
                foreach string i in (tables)
                    ds.select(sql, i);
            }
            else {
                ds.select(sql, "");
            }
        }

        #! @ref SqlUtil::AbstractDatabase.getPhysicalSize()
        private int getPhysicalSizeImpl() {
            *string dbname = ds.getDBName();
            if (!exists dbname) {
                return GET_PHYSICAL_DB_SIZE_NOVAL;
            }
            return ds.selectRow("select pg_database_size(%v) as val", dbname).val ?? GET_PHYSICAL_DB_SIZE_NOVAL;
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private auto tryExecArgsImpl(string sql, *softlist<auto> args) {
            return PgsqlDatabase::tryExecArgs(ds, sql, args);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private auto tryExecRawImpl(string sql, *softlist<auto> args) {
            return PgsqlDatabase::tryExecRaw(ds, sql);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        static auto tryExecArgs(AbstractDatasource ds, string sql, *softlist<auto> args) {
            ds.exec("savepoint " + PGSQL_TempSavepoint);

            auto rv;
            try {
                rv = ds.vexec(sql, args);
                ds.exec("release savepoint " + PGSQL_TempSavepoint);
            } catch (hash<ExceptionInfo> ex) {
                ds.exec("rollback to savepoint " + PGSQL_TempSavepoint);
                rethrow;
            }
            return rv;
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        static auto tryExecRaw(AbstractDatasource ds, string sql) {
            ds.exec("savepoint " + PGSQL_TempSavepoint);

            auto rv;
            try {
                rv = ds.execRaw(sql);
                ds.exec("release savepoint " + PGSQL_TempSavepoint);
            } catch (hash<ExceptionInfo> ex) {
                ds.exec("rollback to savepoint " + PGSQL_TempSavepoint);
                rethrow;
            }
            return rv;
        }
    }

    #! provides the PostgreSQL-specific implementation of the SqlUtil::AbstractTable interface
    public class PgsqlTable inherits SqlUtil::AbstractTable {
        public {
            #! maps PostgreSQL type names to type configurations
            const PgsqlTypeMap = (
                "abstime": ("qore": Type::Date,),
                "bigint": ("qore": Type::Int,),
                "bigserial": ("qore": Type::Int,),
                "bit": ("qore": Type::Binary, "size": SZ_OPT,),
                "bit varying": ("qore": Type::Binary, "size": SZ_OPT,),
                "bool": ("qore": Type::Boolean,),
                "boolean": ("qore": Type::Boolean,),
                "bytea": ("qore": Type::Binary,),
                "char": ("qore": Type::String, "size": SZ_OPT,),
                "character": ("qore": Type::String, "size": SZ_OPT,),
                "character varying": ("qore": Type::String, "size": SZ_OPT,),
                "cidr": ("qore": Type::String,),
                "date": ("qore": Type::Date,),
                "decimal": ("qore": Type::Number, "size": SZ_NUM,),
                "double precision": ("qore": Type::Float,),
                "float": ("qore": Type::Float,),
                "inet": ("qore": Type::String,),
                "int": ("qore": Type::Int,),
                "integer": ("qore": Type::Int,),
                "interval": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "macaddr": ("qore": Type::String,),
                "money": ("qore": Type::Number,),
                "numeric": ("qore": Type::Number, "size": SZ_NUM,),
                "oid": ("qore": Type::Int,),
                "real": ("qore": Type::Float,),
                "reltime": ("qore": Type::Date,),
                "serial": ("qore": Type::Int,),
                "smallint": ("qore": Type::Int,),
                "smallserial": ("qore": Type::Int,),
                "text": ("qore": Type::String,),
                "time": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "time with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "time without time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "timetz": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "timestamp with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "timestamp without time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "timestamptz": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "varbit": ("qore": Type::Binary, "size": SZ_OPT,),
                "varchar": ("qore": Type::String, "size": SZ_OPT,),
            );

            #! maps from verbose type names to simple type names
            const PgsqlNameMap = (
                "bit varying": "varbit",
                "character": "char",
                "character varying": "varchar",
                "char varying": "varchar",
                "double precision": "float",
                "time with time zone": "timetz",
                "time without time zone": "time",
                "timestamp with time zone": "timestamptz",
                "timestamp without time zone": "timestamp",
            );

            #! maps qore type names to PostgreSQL type names
            const QoreTypeMap = (
                "integer": "bigint",
                "float": "double precision",
                "number": "numeric",
                "string": "varchar",
                "date": "timestamp",
                "binary": "bytea",
                "bool": "boolean",
                SqlUtil::CHAR: "char",
                SqlUtil::CLOB: "text",
                SqlUtil::BLOB: "bytea",
            );

            #! extends @ref SqlUtil::AbstractTable::TableDescriptionHashOptions with \c "functions" for table functions required by triggers on the table
            const PgsqlTableDescriptionHashOptions = AbstractTable::TableDescriptionHashOptions + (
                "functions": Type::Hash,
            );

            const PgsqlColumnDescOptions = AbstractTable::ColumnDescOptions;

            const PgsqlIndexOptions = AbstractTable::IndexOptions;

            const PgsqlConstraintOptions = AbstractTable::ConstraintOptions + PgsqlIndexOptions + (
                "index": Type::String,
            );

            const PgsqlTableCreationOptions = AbstractTable::TableCreationOptions + PgsqlConstraintOptions + (
                "omit_trigger_functions": Type::Boolean,
            );

            const PgsqlAlignTableOptions = AbstractTable::AlignTableOptions + PgsqlTableCreationOptions;

            #! column operator specializations for PostgreSQL
            const PgsqlCopMap = {
                COP_CAST: (
                    "code": string sub (string cve, list<auto> args) {
                        string name = QoreTypeMap{args[0]} ?? args[0];
                        hash desc = PgsqlTypeMap{name};
                        string sql = sprintf ("cast (%s as %s", cve, name);
                        switch (name) {
                            default:
                                if (desc.size == SZ_MAND) {
                                    if (!exists args[1] && !exists desc.size_range)
                                        throw "OPERATOR-ERROR", sprintf ("op_cast operator missing size for type %s", name);
                                    sql += sprintf("(%d)", args[1] ?? desc.size_range[1]);
                                }
                                else if (desc.size == SZ_NUM && exists args[1]) {
                                    sql += sprintf("(%d", args[1]);
                                    sql += exists args[2] ? sprintf(",%d)", args[2]) : ")";
                                }
                                else if (desc.size == SZ_OPT && exists args[1]) {
                                    sql += sprintf("(%d)", args[1]);
                                }
                        }
                        sql += ")";
                        return sql;
                    },
                ),
                COP_YEAR: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY')", arg1);
                    }
                ),
                COP_YEAR_MONTH: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY-MM')", arg1);
                    }
                ),
                COP_YEAR_DAY: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY-MM-DD')", arg1);
                    }
                ),
                COP_YEAR_HOUR: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY-MM-DD HH24')", arg1);
                    }
                ),
                COP_SEQ: (
                    "nocolumn": True,
                    "withalias": True,
                    "code": string sub (*string cve, hash arg, reference<hash> psch) {
                        string sql = sprintf("nextval('%s')", arg.seq);
                        if (arg.as) {
                            psch{arg.as} = sql;
                            sql += " " + arg.as;
                        }
                        return sql;
                    }
                ),
                COP_SEQ_CURRVAL: (
                    "nocolumn": True,
                    "withalias": True,
                    "code": string sub (*string cve, hash arg, reference<hash> psch) {
                        string sql = sprintf("currval('%s')", arg.seq);
                        if (arg.as) {
                            psch{arg.as} = sql;
                            sql += " " + arg.as;
                        }
                        return sql;
                    }
                ),
                COP_TRUNC_DATE: (
                    "code": string sub(string arg1, auto arg) {
                        if (!PgsqlTruncDate.hasKey(arg)) {
                            throw "COP-TRUNC-DATE-ERROR", sprintf("Not allowed format argument: %n: allowed: %n", arg, PgsqlTruncDate.keys());
                        }
                        return sprintf("date_trunc(%s, %s)", PgsqlTruncDate{arg}, arg1);
                    }
                ),
            };

            #! Map @ref SqlUtil::cop_trunc_date() constants to PostgreSQL internal masks
            const PgsqlTruncDate = (
                    DT_YEAR     : "'year'",
                    DT_MONTH    : "'month'",
                    DT_DAY      : "'day'",
                    DT_HOUR     : "'hour'",
                    DT_MINUTE   : "'minute'",
                    DT_SECOND   : "'second'",
                );

            #! a hash of default value operator descriptions for PostgreSQL
            const PgsqlIopMap = DefaultIopMap + (
                IOP_SEQ: (
                    "arg": Type::String,
                    "placeholder": "nextval(%v)",
                ),
                IOP_SEQ_CURRVAL: (
                    "arg": Type::String,
                    "placeholder": "currval(%v)",
                ),
            );

            #! a hash of default update operator definitions for PostgreSQL
            const PgsqlUopMap = DefaultUopMap + (
                COP_SEQ: (
                    "nocolumn": True,
                    "code": string sub (*string cve, string arg) {
                        return sprintf("nextval('%s')", arg);
                    }
                ),
                COP_SEQ_CURRVAL: (
                    "nocolumn": True,
                    "withalias": True,
                    "code": string sub (*string cve, string arg) {
                        return sprintf("currval('%s')", arg);
                    }
                ),
            );
        }

        private {
            #! tablespace name for the table, if known
            *string tablespace;

            #! schema name for the table
            string schema;

            #! contains any trigger functions supporting triggers on the table
            Functions triggerFunctions;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a schema in the name
            parse_schema_name(nname, \schema, \name);

            # get table info
            *hash<auto> row = ds.selectRow("select * from pg_tables where schemaname = %v and tablename = %v", schema, name);
            tablespace = row.tablespace ? row.tablespace : NOTHING;
        }

        #! returns the schema name
        string getSchemaName() {
            return schema;
        }

        #! returns the data tablespace name for the table or @ref nothing if none is known
        *string getTablespaceName() {
            return tablespace;
        }

        PgsqlFunction addTriggerFunction(string tfname, string src, string trigger) {
            l.lock();
            on_exit l.unlock();

            return addTriggerFunctionUnlocked(tfname, src, trigger);
        }

        #! returns @ref False "False" because the pgsql driver does not support array binds / bulk DML operations
        bool hasArrayBind() {
            return False;
        }

        #! returns the column name for use in SQL strings; subclasses can return a special string in case the column name is a reserved word
        string getColumnSqlName(string col) {
            return PgsqlDatabase::PgsqlReservedWords{col.lwr()} ? ("\"" + col + "\"") : col;
        }

        #! returns a list of column names for use in SQL strings; subclasses can process the argument list in case a column name is a reserved word
        list getColumnSqlNames(softlist cols) {
            return map (PgsqlDatabase::PgsqlReservedWords{$1.lwr()} ? ("\"" + $1 + "\"") : $1), cols;
        }

        private PgsqlFunction addTriggerFunctionUnlocked(string tfname, string src, string trigger) {
            if (!triggerFunctions)
                triggerFunctions = new Functions();
            else if (triggerFunctions.hasKey(tfname))
                throw "TRIGGERFUNCTION-ERROR", sprintf("table %y: already has a trigger function %y associated with it", name, tfname);

            trim src;
            string tn = tfname;
            *string args = PgsqlDatabase::getFunctionArgs("TRIGGERFUNCTION-ERROR", \tn);

            if (args)
                throw "TRIGGERFUNCTION-ERROR", sprintf("table %y trigger function %y: trigger function cannot have any arguments: args: %y", name, tfname, args);

            PgsqlTriggerFunction f(tfname, src, trigger);

            triggerFunctions.add(tfname, f);
            return f;
        }

        #! returns the name of the table to be used in SQL (with a possible qualifiers for schema, etc)
        string getSqlName() {
            return schema + "." + name;
        }

        private hash getTableCreationOptions() {
            return PgsqlTableCreationOptions;
        }

        private hash getTableDescriptionHashOptions() {
            return PgsqlTableDescriptionHashOptions;
        }

        private hash getColumnDescOptions() {
            return PgsqlColumnDescOptions;
        }

        private hash getIndexOptions() {
            return PgsqlIndexOptions;
        }

        private hash getConstraintOptions() {
            return PgsqlConstraintOptions;
        }

        private hash getAlignTableOptions() {
            return PgsqlAlignTableOptions;
        }

        #! returns the column operator map for this object
        private hash getColumnOperatorMapImpl() {
            return PgsqlCopMap;
        }

        #! returns the insert operator map for this object
        private hash getInsertOperatorMap() {
            return PgsqlIopMap;
        }

        #! returns the raw (default) update operator map for this object
        private hash getRawUpdateOperatorMap() {
            return PgsqlUopMap;
        }

        private bool checkExistenceImpl() {
            *hash qh = ds.selectRow("select * from pg_catalog.pg_statio_all_tables where schemaname = %v and relname = %v", schema, name);
            if (qh)
                return inDb = True;
            return False;
        }

        private Columns describeImpl() {
            # get column descriptions
            *hash qh = ds.select("select column_name, data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_scale, datetime_precision, is_nullable, column_default, description from information_schema.columns c join pg_catalog.pg_statio_all_tables st on (c.table_schema = st.schemaname and c.table_name = st.relname) left join pg_catalog.pg_description pgd on (st.relid = pgd.objoid and pgd.objsubid = c.ordinal_position) where table_schema = %v and table_name = %v order by ordinal_position", schema, name);
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                *hash th = PgsqlTypeMap.(row.data_type);
                softint size = row.character_maximum_length ? row.character_maximum_length : row.numeric_precision;
                if (!size)
                    size = row.datetime_precision;
                # use short names in descriptions
                *string an = PgsqlNameMap{row.data_type};
                if (an)
                    row.data_type = an;
                switch (th.qore) {
                    case Type::Int:
                    case Type::Float: {
                        size = 0;
                        row.numeric_precision = 0;
                        break;
                    }
                }

                PgsqlColumn c;
                *string defval = row.column_default;
                # normalize default value expressions
                if (defval =~ /::bpchar$/)
                    defval =~ s/::bpchar$//;
                if (row.numeric_precision)
                    c = new PgsqlNumericColumn(row.column_name, row.data_type, th.qore, row.numeric_precision, row.is_nullable == "YES", defval, row.description ? row.description : NOTHING, 0, row.numeric_scale);
                else
                    c = new PgsqlColumn(row.column_name, row.data_type, th.qore, exists size ? size : 0, row.is_nullable == "YES", defval, row.description ? row.description : NOTHING, row.character_octet_length);

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private PgsqlPrimaryKey getPrimaryKeyImpl() {
            hash rv;

            # get primary key description
            *hash qh = ds.select("select c1.relname index_name, a.attname, pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE) AS column_name, pg_catalog.format_type(a.atttypid, a.atttypmod), tablespace from pg_class c, pg_index i, pg_attribute a, pg_class c1, pg_indexes ix where c.oid = %v::regclass and c.oid = i.indrelid and i.indisprimary and i.indexrelid = a.attrelid and c1.oid = i.indexrelid and c1.relname = ix.indexname and i.indisvalid and not a.attisdropped order by a.attnum", schema + "." + name);
            if (!qh.index_name)
                return new PgsqlPrimaryKey();

            #printf("PgsqlTable::getPrimaryKeyImpl(): %s: %N\n", getName(), qh);
            foreach string col in (qh.column_name)
                rv{col} = columns{col};

            return new PgsqlPrimaryKey(qh.index_name[0], rv, qh.tablespace[0] ? qh.tablespace[0] : NOTHING);
        }

        private Indexes getIndexesImpl() {
            hash rv;

            # get index descriptions
            *hash qh = ds.select("SELECT i.relname index_name, d.indisunique, d.indisprimary, pg_get_indexdef(i.oid, a.attnum, false) column_name, tablespace FROM pg_class t, pg_class i, pg_index d, pg_attribute a, pg_indexes xs WHERE i.relkind = 'i' and i.relname = xs.indexname AND d.indexrelid = i.oid and t.oid = d.indrelid AND i.relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname IN (%v)) AND a.attrelid = i.oid AND t.relname = %v ORDER BY i.relname, attnum", schema, name);

            if (qh.index_name) {
                hash<auto> ih;
                foreach hash<auto> row in (qh.contextIterator()) {
                    if (!ih.(row.index_name)) {
                        ih.(row.index_name) = (
                            "unique": row.indisunique,
                            "tablespace": row.tablespace,
                            "primary": row.indisprimary,
                        );
                    }
                    # send "blank" column for function index
                    if (row.column_name =~ /\(.*\)/ || !columns.hasKey(row.column_name))
                        ih.(row.index_name).columns{row.column_name} = {};
                    else
                        ih.(row.index_name).columns{row.column_name} = columns{row.column_name};
                }

                foreach hash<auto> i in (ih.pairIterator()) {
                    # check primary key index and add tablespace to primary key definition
                    if (i.primary && !primaryKey.empty()) {
                        PgsqlPrimaryKey pk = cast<PgsqlPrimaryKey>(primaryKey);
                        if (i.value.tablespace && !pk.tablespace)
                            pk.tablespace = i.value.tablespace;
                        continue;
                    }
                    # check unique indexes to make sure they are not matched with a unique constraint
                    if (i.value.unique && constraints.hasKey(i.key) && (constraints{i.key} instanceof AbstractUniqueConstraint)) {
                        PgsqlUniqueConstraint uk = cast<PgsqlUniqueConstraint>(constraints{i.key});
                        if (uk.matchKeys(i.value.columns)) {
                            # set tablespace in constraint
                            if (i.value.tablespace && !uk.getTablespace())
                                uk.setTablespace(i.value.tablespace);
                            continue;
                        }
                    }
                    rv.(i.key) = new PgsqlIndex(i.key, i.value.unique, i.value.columns, i.value.tablespace ? i.value.tablespace : NOTHING);
                }
            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl(*hash opts) {
            hash rv;
            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, att2.attname source_column, cl.relname target_table, att.attname target_column from (select con1.conname constraint_name, generate_subscripts(con1.conkey, 1) AS rn, unnest(con1.conkey) parent, unnest(con1.confkey) child, con1.confrelid, con1.conrelid from pg_class cl join pg_namespace ns on cl.relnamespace = ns.oid join pg_constraint con1 on con1.conrelid = cl.oid where cl.relname = %v and ns.nspname = %v and con1.contype = 'f' order by conname, rn) con join pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child join pg_class cl on cl.oid = con.confrelid join pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent order by att.attnum", name, schema);
            if (qh.constraint_name) {
                hash ch;
                foreach hash<auto> row in (qh.contextIterator()) {
                    reference<hash> c = \ch.(row.constraint_name);
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                foreach hash c in (ch.pairIterator()) {
                    # get a description of the target table's columns
                    Columns targ_columns = getReferencedTableColumnsUnlocked(c.value.target.table, opts.table_cache);
                    ForeignConstraintTarget fct(c.value.target.table, targ_columns.subset(c.value.target.columns.keys()));
                    rv.(c.key) = new PgsqlForeignConstraint(c.key, new Columns(c.value.columns), fct);
                }
            }

            return new ForeignConstraints(rv);
        }

        private Constraints getConstraintsImpl() {
            # get check constraints
            *hash qh = ds.select("select
                c.conname as constraint_name,
                case when c.condeferrable = 'f' then 0 else 1 end as is_deferrable,
                case when c.condeferred = 'f' then 0 else 1 end as is_deferred,
                t.relname as table_name,
                array_to_string(c.conkey, ' ') as constraint_key,
                case confupdtype
                    when 'a' then 'NO ACTION'
                    when 'r' then 'RESTRICT'
                    when 'c' then 'CASCADE'
                    when 'n' then 'SET NULL'
                    when 'd' then 'SET DEFAULT'
                end as on_update,
                case confdeltype
                    when 'a' then 'NO ACTION'
                    when 'r' then 'RESTRICT'
                    when 'c' then 'CASCADE'
                    when 'n' then 'SET NULL'
                    when 'd' then 'SET DEFAULT'
                end as on_delete,
                case confmatchtype
                    when 'u' then 'UNSPECIFIED'
                    when 'f' then 'FULL'
                    when 'p' then 'PARTIAL'
                end as match_type,
                t2.relname as references_table,
                array_to_string(c.confkey, ' ') as fk_constraint_key,
                pg_get_constraintdef(c.oid) as consrc
            from pg_constraint c
                left join pg_class t on c.conrelid = t.oid
                left join pg_class t2 on c.confrelid = t2.oid
                join pg_catalog.pg_namespace n on n.oid = t.relnamespace
            where
                c.contype = 'c' and n.nspname = %v and t.relname = %v", schema, name);
            hash rv;
            foreach hash<auto> row in (qh.contextIterator())
                rv.(row.constraint_name) = new PgsqlCheckConstraint(row.constraint_name, row.consrc);

            Constraints c = new Constraints(rv);

            # get unique constraints
            qh = ds.select("select tc.constraint_name, kcu.column_name from information_schema.table_constraints tc join information_schema.key_column_usage kcu on (tc.table_schema = kcu.table_schema and tc.table_name = kcu.table_name and tc.constraint_name = kcu.constraint_name) where constraint_type = 'UNIQUE' and tc.table_schema = %v and tc.table_name = %v order by ordinal_position", schema, name);
            delete rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                reference<PgsqlUniqueConstraint> ch = \rv.(row.constraint_name);
                if (!ch)
                    ch = new PgsqlUniqueConstraint(row.constraint_name, {}, row.status == "ENABLED");
                ch.add(row.column_name, columns{row.column_name});
            }

            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();

            return c;
        }

        private Triggers getTriggersImpl() {
            hash<string, PgsqlTrigger> rv;

            # get trigger description
            *hash<auto> qh = ds.select("select * from information_schema.triggers where event_object_schema = %v and "
                "event_object_table = %v", schema, name);

            # list of trigger functions
            list<string> fl = ();
            # map trigger function name -> trigger name
            hash<string, string> tfh;
            foreach hash<auto> row in (qh.contextIterator()) {
                *string f = (row.action_statement =~ x/EXECUTE (?:PROCEDURE|FUNCTION) (\w+)\(\)$/)[0];
                if (f) {
                    fl += f;
                    tfh{f} = row.trigger_name;
                }

                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("event_manipulation", "action_statement", "action_timing", "action_orientation");
                if (rv{row.trigger_name}) {
                    # add event to trigger
                    *string px = (rv{row.trigger_name}.src =~ x/(.+) on/i)[0];
                    if (!px)
                        throw "PGSQL-TRIGGER-ERROR", sprintf("cannot find beginning of trigger source: %s", rv{row.trigger_name}.src);
                    splice rv{row.trigger_name}.src, px.size(), 0, " or " + row.event_manipulation;
                    continue;
                }

                # issue #3466: get any column restrictions
                *hash<auto> cols = ds.select("select * from information_schema.triggered_update_columns where "
                    "event_object_schema = %v and trigger_name = %v", schema, row.trigger_name);
                string src = sprintf("%s %s", row.action_timing, row.event_manipulation);
                if (cols.event_object_column) {
                    src += " of ";
                    src += foldl $1 + ", " + $2, cols.event_object_column;
                }
                src += sprintf(" on %s for each %s %s", name, row.action_orientation, row.action_statement);
                rv{row.trigger_name} = new PgsqlTrigger(row.trigger_name, src);
            }

            if (fl) {
                hash<auto> fh;
                # also get trigger functions
                qh = ds.select("select p.proname, t1.typname return_type, a.rolname procedure_owner, l.lanname lang, prosrc body, pg_catalog.pg_get_functiondef(proname::regproc) hdr, pg_catalog.pg_get_function_arguments(proname::regproc) args, case provolatile when 'i' then 'IMMUTABLE' when 's' then 'STABLE' when 'v' then 'VOLATILE' end stability from pg_proc p left join pg_type t1 on p.prorettype = t1.oid left join pg_roles a on p.proowner = a.oid left join pg_language l on p.prolang = l.oid where proname in (%s)", (foldl $1 + "," + $2, (map sprintf("'%s'", $1), fl)));

                # create trigger function map
                map fh{$1.proname + "()"} = PgsqlDatabase::processFunction($1 + ("trigger_name": tfh{$1.proname}), native_case), qh.contextIterator();

                triggerFunctions = new Functions(fh);
            }

            #printf("gTI triggerFunctions: %N\n", triggerFunctions);

            return new Triggers(rv);
        }

        #! returns a string that can be used to create the table in the database
        private string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(self), columns.iterator());
            sql += "\n)";

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        private *list getCreateMiscSqlImpl(*hash opt, bool cache) {
            if (cache) {
                getColumnsUnlocked();
                getTriggersUnlocked();
            }

            list l = map AbstractDatabase::doCallback(opt, sprintf("comment on column %s.%s is %s", name, $1.ddl_name, getSqlValueImpl($1.comment)), AbstractDatabase::AC_Add, "column comment", $1.name, name), columns.iterator(), $1.comment;

            if (!opt.omit_trigger_functions && !triggerFunctions.empty()) {
                map l += AbstractDatabase::doCallback(opt, $1.getCreateSql(opt), AbstractDatabase::AC_Create, "trigger function", $1.name, name), triggerFunctions.iterator();
            }

            #printf("gCMSI triggerFunctions: %N\n", triggerFunctions);
            return l;
        }

        private *list getAlignSqlImpl(AbstractTable table, *hash<auto> opt) {
            PgsqlTable t = cast<PgsqlTable>(table);

            list l = ();
            # check for trigger functions in the template that are not present or different in the current table
            foreach AbstractFunction f in (t.triggerFunctions.iterator()) {
                if (!triggerFunctions.hasKey(f.name)) {
                    # create trigger function
                    l += AbstractDatabase::doCallback(opt, f.getCreateSql(opt), AbstractDatabase::AC_Create, "trigger function", f.name, name);
                } else if (!f.equal(triggerFunctions{f.name})) {
                    # replace current trigger function
                    l += AbstractDatabase::doCallback(opt, f.getCreateSql(opt + ("replace": True)), AbstractDatabase::AC_Recreate, "trigger function", f.name, name);
                }
            }

            # check for trigger functions not in the template and drop them
            foreach PgsqlTriggerFunction f in (triggerFunctions.iterator()) {
                if (!t.triggerFunctions.hasKey(f.name)) {
                    if (triggers{f.trigger}) {
                        l += AbstractDatabase::doCallback(opt, triggers{f.trigger}.getDropSql(name), AbstractDatabase::AC_Drop, "trigger", f.trigger, name);
                        triggers.take(f.trigger);
                    }
                    l += AbstractDatabase::doCallback(opt, f.getDropSql(opt), AbstractDatabase::AC_Drop, "trigger function", f.name, name);
                }
            }

            return l ? l : NOTHING;
        }

        #! returns a string that can be used to create the table in the database
        private string getCreateSqlImpl(list l) {
            return PgsqlDatabase::getCreateSql(l);
        }

        private string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            if (opt.precision)
                return new PgsqlNumericColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable, opt.default_value, opt.comment, 0, opt.scale);
            return new PgsqlColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value, opt.comment, 0);
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new PgsqlPrimaryKey(cname, ch, opt.index_tablespace);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new PgsqlIndex(iname, enabled, ch, opt.index_tablespace);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new PgsqlForeignConstraint(cname, new Columns(ch), fct);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new PgsqlCheckConstraint(cname, src);
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt) {
            return new PgsqlUniqueConstraint(cname, ch, True, opt.index_tablespace);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new PgsqlTrigger(tname, src);
        }

        private bool tryInsertImpl(string sql, hash<auto> row) {
            ds.exec("begin");
            ds.exec("savepoint " + PgsqlDatabase::PGSQL_TempSavepoint);

            try {
                ds.vexec(sql, row.values());
                ds.exec("release savepoint " + PgsqlDatabase::PGSQL_TempSavepoint);
            } catch (hash<ExceptionInfo> ex) {
                if (ex.desc =~ /duplicate key value/) {
                    ds.exec("rollback to savepoint " + PgsqlDatabase::PGSQL_TempSavepoint);
                    return False;
                }
                rethrow;
            }
            return True;
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return PgsqlTypeMap;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(auto v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toString();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "true" : "false";

                case NT_DATE: return "timestamptz " + v.format("'YYYY-MM-DD HH:mm:SS.usZ'");
            }
        }

        private bool emptyImpl() {
            return triggerFunctions.empty();
        }

        #! clears PostgreSQL-specific table information
        private clearImpl() {
            delete triggerFunctions;
        }

        private softlist getDropSqlImpl() {
            getTriggers();
            list l = ();
            l += sprintf("drop table %s", getSqlName());
            map l += $1.getDropSql(), triggerFunctions.iterator();
            return l;
        }

        private setupTableImpl(hash<auto> desc, *hash<auto> opt) {
            # add trigger functions to table
            AbstractDatabase::checkDriverOptions(\desc.functions, ds.getDriverName());

            foreach string fn in (keys desc.functions) {
                if (desc.functions{fn}.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to function key %y is not a string giving the function source code, got type %y instead (%y)", name, fn, desc.functions{fn}.type(), desc.functions{fn});

                string src = desc.functions{fn};
                addTriggerFunctionUnlocked(fn, src, fn);
            }
        }

        #! returns @ref True "True" if the database links constraints to indexes (ie dropping the constraint drops the index, etc)
        private bool constraintsLinkedToIndexesImpl() {
            return True;
        }

        #! returns @ref True "True" if the database automatically creates a unique constraint when a unique index is created (ex: mysql)
        private bool uniqueIndexCreatesConstraintImpl() {
            return False;
        }

        #! returns @ref True "True" if the database support tablespaces
        private bool supportsTablespacesImpl() {
            return True;
        }

        #! processes a string for use in SQL select statements when there is a "limit" argument, but no "orderby" or "offset" arguments
        private doSelectLimitOnlyUnlockedImpl(reference<string> sql, reference<list> args, *hash qh) {
           sql += " limit %v";
           args += qh.limit;
        }

        #! processes a string for use in SQL select statements when there is an "order by" and "offset" argument
        private doSelectOrderByWithOffsetSqlUnlockedImpl(reference<string> sql, reference<list> args, *hash qh, *hash jch, *hash ch, *hash psch, list coll) {
            doSelectOrderBySqlUnlocked(\sql, \args, qh, jch, ch, psch, coll);
            if (qh.limit) {
                sql += " limit %v";
                args += qh.limit;
            }

            if (qh.offset) {
                sql += " offset %v";
                args += qh.offset;
            }
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private auto tryExecArgsImpl(string sql, *softlist<auto> args) {
            return PgsqlDatabase::tryExecArgs(ds, sql, args);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private auto tryExecRawImpl(string sql, *softlist<auto> args) {
            return PgsqlDatabase::tryExecRaw(ds, sql);
        }

        #! db-specific copy actions
        private copyImpl(AbstractTable old) {
            if (triggerFunctions)
                triggerFunctions = triggerFunctions.copy();
        }

        private *hash doReturningImpl(hash opt, reference<string> sql, list<auto> args) {
            list l = ();
            foreach auto v in (opt.returning) {
                hash rh;
                switch (v.typeCode()) {
                    case NT_STRING: rh.key = v; break;
                    case NT_HASH: rh = v; break;
                    default: throw "RETURNING-ERROR", sprintf("got type %y in \"returning\" option; expected \"string\" or \"hash\"", v.type());
                }
                if (!rh.key.val() || rh.key.typeCode() != NT_STRING)
                    throw "RETURNING-ERROR", sprintf("got %y for \"returning\" option key value instead of name of output column", rh.key.type());
                *PgsqlColumn c = columns{rh.key};
                if (!c)
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column for the \"returning\" clause (valid columns: %y)", name, rh.key, columns.keys());
                l += rh.key;
                args += rh.type ?* c.qore_type ?* Type::String;
            }
            sql += sprintf(" returning %s", (foldl $1 + "," + $2, l));

            *hash h = execData(opt, sql, args);
            return h ? map {$1.key: $1.value[0]}, h.pairIterator() : h;
        }

        private list getGroupOrderByListUnlocked(string key, hash qh, *hash jch, *hash ch, *hash psch, list coll) {
            list ce = ();
            foreach auto cv in (qh{key}) {
                switch (cv.typeCode()) {
                    case NT_STRING: {
                        if (cv.toInt() == cv)
                            ce += cv;
                        else
                            ce += getColumnNameIntern(cv, jch, boolean(qh.join), ch, psch);
                        break;
                    }

                    case NT_HASH: {
                        ce += doColumnOperatorIntern(cv, jch, boolean(qh.join), ch, psch);
                        break;
                    }

                    case NT_INT: {
                        ce += cv.toString();
                        break;
                    }

                    default:
                        throw "SELECT-ERROR", sprintf("%s: don't know how to parse argument type %y (value: %y) in group by list, expecting \"string\" or \"hash\"", getDesc(), cv.type(), cv);
                }
            }
            return ce;
        }

        #! returns the type for number / numeric columns for the database so that data conversions can be handled properly
        private AbstractDataProviderType getNumericTypeImpl(string native_type, bool nullable, *hash<auto> options) {
            return new PgsqlNumberDataType(native_type, nullable, options);
        }

        #! get DB-specific savepoint helper
        /** @param savepoint the savepoint string, if not given a unique savepoint string will be generated

            @since SqlUtil 1.6
        */
        private AbstractSavepointHelper getSavepointHelperImpl(*string savepoint) {
            return new PgsqlSavepointHelper(ds, savepoint);
        }
    }
}
