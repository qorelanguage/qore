# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file HttpServer.qm HTTP multi-threaded server module definition

/*  HttpServer.qm Copyright (C) 2012 - 2024 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%requires qore >= 1.0
# need mime definitions
%requires Mime >= 1.0
%requires Util >= 1.0
%requires(reexport) HttpServerUtil >= 1.0
%requires Logger

%new-style
%allow-weak-references

module HttpServer {
    version = "1.3";
    desc = "HttpServer class definition";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage HttpServer Module

    @tableofcontents

    @section httpserverintro HttpServer Introduction

    The %HttpServer module provides a multi-threaded HTTP server to Qore programs.

    The %HttpServer implemented is designed for serving REST, RPC-style, and file-system-based requests as well as
    other types of traffic with an appropriate handler (for example handlers requiring protocol changes such as with
    the WebSocket protocol are supported as well).

    To use this module, use \c "%requires HttpServer" in your code.  See examples/httpserver.q for an example program
    using this module

    All the public symbols in the module are defined in the HttpServer namespace.

    The main classes is (see @ref httpserverutilintro "HttpServerUtil" for supporting definitions; note that the
    @ref httpserverutilintro "HttpServerUtil" module's definitions are also imported into @ref Qore::Program "Program"
    objects @ref requires "requiring" this module):
    - @ref HttpServer::HttpServer "HttpServer": this class implements the main interface to the HTTP server provided
      by this module

    See also:
    - <a href="../../RestHandler/html/index.html">RestHandler</a>: a module providing a handler framework for this
      module for implementing server-side REST services
    - <a href="../../WebSocketHandler/html/index.html">WebSocketHandler</a>: a module providing a handler framework
      for this module for implementing server-side WebSocket services
    - <a href="../../WebUtil/html/index.html">WebUtil</a>: a module providing higher-level HTTP services using this
      module as a base as well as providing support for dynamic template-based HTML rendering (ie rendering qhtml
      files which are a mix of HTML and Qore code)
    - <a href="http://www.qore.org/manual/modules/json/current/JsonRpcHandler/html/index.html">JsonRpcHandler</a>:
      provides infrastructure for implementing JSON-RPC server-side services using the HttpServer module
    - <a href="http://www.qore.org/manual/modules/yaml/current/YamlRpcHandler/html/index.html">YamlRpcHandler</a>:
      provides infrastructure for implementing YAML-RPC server-side services using the HttpServer module
    - <a href="http://www.qore.org/manual/modules/xml/current/XmlRpcHandler/html/index.html">XmlRpcHandler</a>:
      provides infrastructure for implementing XML-RPC server-side services using the HttpServer module
    - <a href="http://www.qore.org/manual/modules/xml/current/SoapHandler/html/index.html">SoapHandler</a>: provides
      infrastructure for implementing SOAP server-side services using the HttpServer module

    @par Example:
    @code{.py}
#!/usr/bin/env qore

%requires HttpServer
%requires Mime

%new-style

class MyHandler inherits AbstractHttpRequestHandler {
    hash<HttpResponseInfo> handleRequest(hash<auto> cx, hash<auto> hdr, *data body) {
        # NOTE: change "%y" to "%N" to get a more readable multi-line output format for container values
        log("request received on %s from %s: context: %y hdr: %y body size: %d byte%s", cx."peer-info".desc,
            cx."socket-info".desc, cx, hdr, body.size(), body.size() == 1 ? "" : "s");
        return {
            "code": 200,
            "body": sprintf("<title>Test Page</title><body><h1>Qore HTTP server v%s</h1><p>%y on %s PID %s TID %d "
                "connection %d</p><p>Qore %s</p></body>", HttpServer::Version, now_us(), gethostname(), getpid(),
                gettid(), cx.id, Qore::VersionString),
            "close": True,
        };
    }
}

sub log(string str, ...) {
    printf("%y: %s\n", now_us(), vsprintf(str, argv));    - fixed a bug reloading X.509 certificates on running listeners
      (<a href="https://github.com/qorelanguage/qore/issues/4720">issue 4720</a>)

}

const MyHttpPort = 19001;

# create our handler object
MyHandler myHandler();

# create the http server object
HttpServer hs(\log(), \log());

# add our handler to the server
hs.setHandler("my-handler", "/", MimeTypeHtml, myHandler);

# set our handler as the default handler
hs.setDefaultHandler("my-handler", myHandler);

# start a listener
hash<auto> lh = hs.addListener(MyHttpPort);

# output a log message
log("started listener on %s", lh.desc);
    @endcode

    @section http_relnotes HttpServer Module Release Notes

    @subsection http1_3 HttpServer 1.3
    - fixed a bug where idle connections were never disconnected
      (<a href="https://github.com/qorelanguage/qore/issues/4878">issue 4878</a>)

    @subsection http1_2 HttpServer 1.2
    - allow handlers to remove thread-local auth information after requests have been handled

    @subsection http1_1_2 HttpServer 1.1.2
    - allow context info to be cleared after handling each request to ensure that context info (like thread-local
      data) does not leak into other connections on the same thread
      (<a href="https://github.com/qorelanguage/qore/issues/4802">issue 4802</a>)

    @subsection http1_1_1 HttpServer 1.1.1
    - fixed a bug reloading X.509 certificates on running listeners
      (<a href="https://github.com/qorelanguage/qore/issues/4720">issue 4720</a>)

    @subsection http1_1 HttpServer 1.1
    - implemented support for reloading X.509 certificate information without manually restarting listeners
      (<a href="https://github.com/qorelanguage/qore/issues/4574">issue 4574</a>)

    @subsection http1_0_12 HttpServer 1.0.12
    - fixed a bug where incorrect URI decoding was applied to URLs in received HTTP messages instead of URL decoding
      (<a href="https://github.com/qorelanguage/qore/issues/4363">issue 4363</a>)

    @subsection http1_0_2 HttpServer 1.0.2
    - @ref HttpServer::HttpServer::addListeners() "HttpServer::addListeners()" has no mechanism for returning errors
      to the caller
      (<a href="https://github.com/qorelanguage/qore/issues/4312">issue 4312</a>)

    @subsection http1_0_1 HttpServer 1.0.1
    - allow dynamic handlers to be removed without waiting for all connections to terminate
      (<a href="https://github.com/qorelanguage/qore/issues/4273">issue 4273</a>)
    - allow for full logging of authentication errors if HTTP server debugging is enabled
      (<a href="https://github.com/qorelanguage/qore/issues/4217">issue 4217</a>)

    @subsection http1_0 HttpServer 1.0
    - allow dynamic handlers to be disabled before being removed
      (<a href="https://github.com/qorelanguage/qore/issues/4173">issue 4173</a>)
    - added support for the Logger module for logging
      (<a href="https://github.com/qorelanguage/qore/issues/4157">issue 4157</a>)
    - removed deprecated APIs

    @subsection http0911 HttpServer 0.9.11
    - fixed a bug shutting down dedicated socket I/O handlers
      (<a href="https://github.com/qorelanguage/qore/issues/4130">issue 4130</a>)
    - fixed a bug where invalid HTTP responses were send with error messages and chunked transfer encoding
      (<a href="https://github.com/qorelanguage/qore/issues/4124">issue 4124</a>)
    - fixed a bug where it was not possible for an HTTP stream handler to support switching protocols
      (<a href="https://github.com/qorelanguage/qore/issues/4111">issue 4111</a>)

    @subsection http095 HttpServer 0.9.5
    - fixed a bug where the HTTP server would not always stop the ThreadPool which caused process shutdowns to hang
      (<a href="https://github.com/qorelanguage/qore/issues/3999">issue 3999</a>)

    @subsection http094 HttpServer 0.9.4
    - added support for sending chunked replies from an @ref Qore::InputStream "InputStream"
      (<a href="https://github.com/qorelanguage/qore/issues/3702">issue 3702</a>)

    @subsection http03131 HttpServer 0.3.13.1
    - enable remote certificates to be retrieved in listeners and handlers by default; added new API entry points for
      listeners and handlers with more flexible and saner parameters, deprecated old complex methods
      (<a href="https://github.com/qorelanguage/qore/issues/3512">issue 3512</a>)
    - shut down dedicated socket conenctions last in order to allow for effective keep-alive implementations with
      WebSocket for example
      (<a href="https://github.com/qorelanguage/qore/issues/3488">issue 3488</a>)
    - fixed certificate and key errors for HTTPS listeners to generate user-friendly exceptions
      (<a href="https://github.com/qorelanguage/qore/issues/3397">issue 3397</a>)

    @subsection http0313 HttpServer 0.3.13
    - added the \c "header-info" hash to the context argument when calling handlers
      (<a href="https://github.com/qorelanguage/qore/issues/3026">issue 3026</a>)
    - added support for adding new HTTP methods to the server with the
      @ref HttpServer::HttpServer::addHttpMethod() "HttpServer::addHttpMethod()" method
      (<a href="https://github.com/qorelanguage/qore/issues/2805">issue 2805</a>)

    @subsection http03121 HttpServer 0.3.12.1
    - fixed \c HEAD and other responses that cannot have a message body
      (<a href="https://github.com/qorelanguage/qore/issues/3116">bug 3116</a>)

    @subsection http0312 HttpServer 0.3.12
    - added a minimal substring of string bodies received to the log message when logging HTTP requests
    - added logic to allow sensitive data to be masked in log messages (<a href="https://github.com/qorelanguage/qore/issues/1086">issue 1086</a>)
    - added support for the HTTP \c "PATCH" method

    @subsection http03111 HttpServer 0.3.11.1
    - fixed a bug where @ref HttpServer::HttpServer::addListener() would not accept port 0 meaning bind on any random open port (<a href="https://github.com/qorelanguage/qore/issues/1284">bug 1284</a>)

    @subsection http0311 HttpServer 0.3.11
    - fixed a bug setting the response encoding in @ref HttpServer::HttpServer::setReplyHeaders() where the Socket encoding was not set properly and therefore the encoding in the \c Content-Type in the response header did not necessarily match the encoding of the response
    - added support for private keys with passwords
    - added the @ref HttpServer::PermissiveAuthenticator "PermissiveAuthenticator" class
    - moved base code to the @ref httpserverutilintro "HttpServerUtil" module (imported with the \c reexport option) and santized APIs, made HttpListener class private/internal again
    - fixed a socket / connection performance problem with HTTPS listeners where the SSL connection was being negotiated inline with the accept instead of in the connection thread, thereby blocking new connections from being accepted
    - new methods implemented in HttpServer:
      - @ref HttpServer::HttpServer::setListenerLogOptions()
      - @ref HttpServer::HttpServer::setListenerLogOptionsID()
    - performance improvement of matching handlers to request URIs (not used for RegExp matching)
    - changed the order of path-based handler matching:
      - the old implementation selects the first (in order of their registration) handler whose path matches the request URI, regexp and path matching have the same priority
      - the new implementation has two stages:
        - first, handlers without regexp are considered - if there are some handler with their path matching the request, the one with the longest path is selected
        - otherwise, the first (in order of their registration) handler with regexp that matches the request URI is chosen
      - if no path matches the request, the same logic as before applies
    - added @ref HttpServer::HttpServer::addListeners() "HttpServer::addListeners(string, hash, *code, *code, *code, *string, int)"
    - fixed a bug in @ref HttpServer::HttpServer::addListener() with an integer argument; a UNIX socket was opened instead of a wildcard listener on the given port
    - added the @ref HttpServer::HttpServer::listenerStarted() method to allow for reporting when listeners are actually running since they are started asynchronously
    - added the \c "ssl" key to the listener socket info hash
    - fixed typos causing bugs in HTTP error logging (<a href="https://github.com/qorelanguage/qore/issues/308">bug 308</a>)
    - fixed bugs handling persistent connections

    @subsection http0310 HttpServer 0.3.10
    - if an error occurs receiving a message with chunked transfer encoding, send the response immediately before reading the rest of the chunked transfer

    @subsection http039 HttpServer 0.3.9
    - when binding a wildcard address with @ref Qore::AF_UNSPEC "AF_UNSPEC" on Windows with @ref HttpServer::HttpServer::addListeners()
      and both IPv6 and IPv4 addresses are returned, bind both addresses since Windows doesn't direct the IPv4 requests to the wildcard-bound IPv6 listener

    @subsection http038 HttpServer 0.3.8
    - moved more message handling code to HttpServer::AbstractHttpRequestHandler so that chunked transfers can be efficiently supported by handlers
    - added a minimum body size threshold for \c Content-Encoding compression to HttpServer
    - added the following classes to facilitate handling chunked requests and responses:
      - HttpServer::AbstractStreamRequestHandler
      - HttpServer::AbstractStreamRequest
    - added support for persistent connections to a given handler to the HTTP server

    @subsection http037 HttpServer 0.3.7
    - fixed a bug in parsing arguments in @ref HttpServer::parse_uri_query() "parse_uri_query()"
    - updated @ref HttpServer::parse_uri_query() "parse_uri_query()" to accept both \c "&" and \c ";" as argument separators
    - added support for the \c PUT and \c DELETE methods and for optional message bodies independent of the HTTP method
    - fixed handler matching to use a score for each handler and to check dynamic handlers also for a match if the fixed handlers don't provide a perfect match
    - fixed response handling to not overwrite the \c Connection header if present from the handler
    - fixed response handling to only return error reponses with codes >= 400
    - implemented the  @ref HttpServer::AbstractHttpSocketHandler "AbstractHttpSocketHandler" handler class to support dedicated socket connections when switching protocols in handlers
    - do not add HTML to the msg body from explicit error responses from handlers
    - improved HTTP server log messages
    - added "family" argument to HttpServer::add*Listener*() methods
    - turned of \c TCP_NODELAY by default and use socket shutdown when closing sockets instead
    - set the listen backlog queue size to 100 by default (previously was hardcoded internally in %Qore to 5)
    - use the new @ref Qore::Thread::ThreadPool "ThreadPool" class introduced in %Qore 0.8.8 to pre-allocate threads to reduce latency for new socket connections
    - improved handler matching algorithm
    - implemented many performance improvements
    - implemented support for simple string path matching when finding a handler for a request
    - added static @ref HttpServer::AbstractHttpRequestHandler::redirect() to help in generating 301 Moved Permanently messages

    @subsection http036 HttpServer 0.3.6
    - fixed a race condition in tracking active requests in dynamic HTTP handlers and removing dynamic HTTP handlers

    @subsection http035 HttpServer 0.3.5
    - fixed bugs in regexes in the @ref HttpServer::HttpServer::addListeners() "HttpServer::addListeners()" and
      \c HttpServer::addListenersWithHandler() methods
    - updated module example code in summary
    - added \c "listener-id" to request context hash

    @subsection http034 HttpServer 0.3.4
    - added public @ref HttpServer::parse_uri_query() "parse_uri_query()" function

    @subsection http033 HttpServer 0.3.3
    - updated to a user module
    - added support for custom redirects from user handlers
    - use the <a href="../../Mime/html/index.html">Mime</a> module for mime definitions

    @subsection http032 HttpServer 0.3.2
    - added support for listeners with specific handler lists
    - added the ability to manage dynamic content handlers
    - implemented content-encoding handling flags in @ref HttpServer::AbstractHttpRequestHandler "AbstractHttpRequestHandler"
    - implemented support for \c "identity" encoding (if anyone ever sends it)

    @subsection http031 HttpServer 0.3.1
    - added IPv6 support in qore 0.8.2

    @subsection http030 HttpServer 0.3.0
    - added the ability to start and stop listeners on demand

    @subsection http029 HttpServer 0.2.9
    - updates for new SSL and timeout behavior with with @ref Qore::Socket "Socket" class with qore 0.8.1+
    - set socket encoding to UTF-8 by default
    - add \c "charset=utf-8" to \c Content-Type header if not already present
    - add \c "text/html" to \c Content-Type header if no content-type is given by the handler
    - fixed setting X.509 certificate and private key for HTTPS listeners
    - require qore >= 0.8.1 for new Socket features

    @subsection http028 HttpServer 0.2.8
    - converted to hard typing for use with %require-types
    - require qore >= 0.8.0 for new @ref Qore::Socket "Socket" features

    @subsection http027 HttpServer 0.2.7
    - set \c TCP_NODELAY on all sockets to ensure that clients get all data before closing the socket, especially in case of errors
    - require qore >= 0.7.4 for new @ref Qore::Socket "Socket" features

    @subsection http026 HttpServer 0.2.6
    - minor fixes for SOAP support
    - improved handler matching

    @subsection http025 HttpServer 0.2.5
    - minor fixes for SOAP support

    @subsection http024 HttpServer 0.2.4
    - improved \c Content-Type handling
    - improved URL/path support

    @subsection http023 HttpServer 0.2.3
    - bzip2 \c Content-Encoding support

    @subsection http022 HttpServer 0.2.2
    - basic authentication

    @subsection http021 HttpServer 0.2.1
    - implementing logic to handle \c "deflate" and \c "gzip" content-encoding
    - chunked content-encoding supported for POSTs
    - Date: header always sent as per HTTP 1.1 spec

    @subsection http020 HttpServer 0.2.0
    - modular/multiple listener support added
    - https support added
 */

#! the main namespace for the HttpServer module
/** To use this module, use \c "%requires HttpServer" in your code.

    See examples/httpserver.q for an example program using this module

    All the public symbols in the module are defined in this namespace
 */
public namespace HttpServer {
#! returns a multi-line string from the exception hash argument suitable for logging or output on the console
/** @param ex the exception hash to process

    @return a multi-line string from the exception hash argument suitable for logging or output on the console

    @note reexported from the Util module
*/
public string sub get_exception_string(hash<auto> ex) {
    return Util::get_exception_string(ex);
}

#! Hash for HttpServer options
public hashdecl HttpServerOptionInfo {
    #! HTTP server name
    string name = HttpServer::HttpServerString;

    #! Debug flag
    bool debug = False;

    #! Do not allow the last listener to be stopped
    bool protect_last_listener = False;

    #! Headers to add in responses
    hash<auto> hdr = {
        "X-Powered-By": "Qore/" + Qore::VersionString,
    };

    #! Idle disconnect time; the default is 75 seconds
    date ttl = HttpServer::DefaultTtl;

    #! HTTP server logger
    *LoggerInterface logger;
}

#! The HttpServer class implements a multithreaded HTTP server
public class HttpServer inherits HttpServer::AbstractLogger {
    public {
        #! version of the HttpServer's implementation
        const Version = HttpServer::HttpServerVersion;
        #! default read timeout in ms
        const ReadTimeout = HttpServer::ReadTimeout;  # recvs timeout after 30 seconds
        #! default poll timeout in ms
        const PollTimeout = 250ms;

        # logging options
        const LP_LOGPARAMS = HttpServer::LP_LOGPARAMS;
        const LP_LEVELMASK = HttpServer::LP_LEVELMASK;

        #! address info flags
        const AIFlags = AI_PASSIVE | AI_ADDRCONFIG;

        #! HTTP methods supported by default
        const HttpMethods = {
            "HEAD": True,
            "POST": True,
            "PUT": True,
            "DELETE": True,
            "GET": True,
            "OPTIONS": True,
            "PATCH": True,
            #"TRACE": True,
            #"CONNECT": True,
        };

        #! map of HTTP result codes and text messages
        const HttpCodes = HttpServer::HttpCodes;

        #! content-encodings supported; this is a hash to simulate a set with O(ln(n)) access times
        const ContentEncodings = {
            "gzip": "gzip",
            "deflate": "deflate",
            "bzip2": "bzip2",
            "x-gzip": "gzip",
            "x-deflate": "deflate",
            "x-bzip2": "bzip2",
        };

        #! default number of idle threads to have waiting for new connections (accross all listeners)
        const DefaultIdleThreads = 10;

        #! default threadhold for data compressions; transfers smaller than this size will not be compressed
        const CompressionThreshold = 1024;

        /** @defgroup ListenerLogOptions Listener Log Options
            Options to control how listener headers and body options are logged
            @see
            - HttpServer::getListenerLogOptions()
            - HttpServer::getListenerLogOptionsID()
            - HttpServer::setListenerLogOptions()
            - HttpServer::setListenerLogOptionsID()
         */
        #/@{
        #! listener log option: log recv headers
        const LLO_RECV_HEADERS = (1 << 0);

        #! listener log option: log recv message body
        const LLO_RECV_BODY = (1 << 1);

        #! listener log option: log send headers
        const LLO_SEND_HEADERS = (1 << 2);

        #! listener log option: log sent message body
        const LLO_SEND_BODY = (1 << 3);
        #/@}

        #! Default connection time-to-live
        const DefaultTtl = 75s;
    }

    #! @cond nodoc
    private {
        # for masking HTTP request log msgs
        *code maskfunc;

        # quit server flag
        bool exit = False;

        # if True then verbose exception info will be logged
        bool debug;

        Sequence seqSessions();
        Sequence seqListeners();

        bool stopped = False;

        # permanent handlers; these handlers are never removed
        HttpHandlerList handlers();

        # default handler
        hash<auto> defaultHandler;

        # hash of listeners keyed by listener ID
        hash<string, HttpListener> listeners;

        # map of bind addresses to listener IDs
        hash<string, int> smap;

        # map of listener names to listener IDs
        hash<string, int> nmap;

        # listener Gate
        Gate lm();

        # running listener counter
        Counter c();

        # dynamic handlers
        DynamicHttpHandlerList dhandlers();

        # connection thread pool
        ThreadPool threadPool(-1, DefaultIdleThreads);

        # other misc response headers
        hash<auto> hdr;

        #! override message body encoding if none is received from the sender
        /** @note http://tools.ietf.org/html/rfc2616#section-3.7.1 states that it must be iso-8850-1
        */
        *string override_encoding;

        #! the name the HTTP server will report itself as
        string http_server_string;

        #! valid HTTP methods
        hash<string, bool> http_methods = HttpMethods;

        #! logger
        *LoggerInterface logger;

        #! Do not allow last listener to be stopped
        bool protect_last_listener = False;

        #! Idle disconnect (TTL) for connections
        date ttl = DefaultTtl;
    }
    #! @endcond

    #! creates the HttpServer
    /** call @ref addListener() to add and start listeners

        @param logfunc an optional closure or call reference that will be called with logging information; must take
        an initial string with optional arguments; ex:
        @code{.py} code log = sub (string fmt, ...) { vprintf(fmt, argv); }@endcode
        @param errlogfunc an optional closure or call reference that will be called with error information; must
        take an initial string with optional arguments; ex:
        @code{.py} code errloglog = sub (string fmt, ...) { vprintf(fmt, argv); }@endcode
        @param dbg if this parameter is set to @ref True "True", then additional information will be logged when
        errors occur; note that this parameter is only used if \a log is not provided
        @param name the name of the HTTP server as returned in the Server header (should be formatted according to
        <a href="http://tools.ietf.org/html/rfc2616#section-3.8">RFC 2616 section 3.8</a>)
        @param hdr a hash of headers to return in every response by default; to clear the default send an empty hash
        as the argument here

        @note A new Logger object is created for the HTTP server using either \a logfunc or \a errfunc; if both are
        given then only \a logfunc is used and all log messages (including errors) are directed to \a logfunc.  The
        Logger object's logging level is set according to which of these parameters is included.  If neither are
        included, then no logging is performed

        @deprecated use constructor(hash<HttpServerOptionInfo>) instead
    */
    deprecated constructor(*code logfunc, *code errlogfunc, bool dbg = False,
            string name = HttpServer::HttpServerString,
            hash<auto> hdr = {"X-Powered-By": "Qore/" + Qore::VersionString}) {
        http_server_string = name;
        debug = dbg;
        hdr = {
            "Server": name,
        } + hdr;

        logger = new Logger(http_server_string);
        if (logfunc || errlogfunc) {
            logger.addAppender(new HttpServerCallbackAppender(logfunc ?? errlogfunc));
            if (logfunc) {
                logger.setLevel(LoggerLevel::INFO);
            } else {
                logger.setLevel(LoggerLevel::ERROR);
            }
        } else {
            logger.setLevel(LoggerLevel::INFO);
        }
    }

    #! Creates the server with the given options
    /** @param opts see @ref HttpServerOptionInfo for more info
    */
    constructor(hash<HttpServerOptionInfo> opts) {
        http_server_string = opts.name;
        debug = opts.debug;
        hdr = opts.hdr;
        protect_last_listener = opts.protect_last_listener ?? False;
        logger = opts.logger ?? new Logger(http_server_string, LoggerLevel::getLevelInfo());
        if (opts.ttl) {
            setTtl(opts.ttl);
        }
    }

    #! Creates the server with default options and an empty logger
    constructor() {
        hash<HttpServerOptionInfo> opts();
        http_server_string = opts.name;
        debug = opts.debug;
        hdr = opts.hdr;
        protect_last_listener = opts.protect_last_listener;
        logger = opts.logger ?? new Logger(http_server_string, LoggerLevel::getLevelInfo());
        ttl = opts.ttl;
    }

    #! calls stop() and destroys the object
    destructor() {
        stop();
    }

    #! Returns the TTL value
    date getTtl() {
        return ttl;
    }

    #! Sets the connection TTL value
    setTtl(date ttl) {
        if (ttl.absolute()) {
            throw "TTL-ARG-ERROR", sprintf("Idle disconnect (ttl) value is an absolute date: %y; it must be "
                "relative", ttl);
        }
        if (ttl <= 0us) {
            throw "TTL-ARG-ERROR", sprintf("Idle disconnect (ttl) value is not greater then zero: %y", ttl);
        }
        self.ttl = ttl;
    }

    #! add a new supported HTTP method
    /** @param m the HTTP method to add; the string is converted to upper case if necessary
    */
    addHttpMethod(string m) {
        http_methods{m.upr()} = True;
    }

    #! returns the HTTP server version string
    static string getHttpServerVersionString() {
        return HttpServer::HttpServerVersion;
    }

    setDefaultTextEncoding(string enc) {
        override_encoding = enc;
    }

    string getDefaultTextEncoding() {
        return override_encoding ? override_encoding : "iso-8859-1";
    }

    #! To call a listener's stop callback
    callListenerStopCallback(code stopc, string name, hash<auto> socket_info) {
        try {
            call_function(stopc, name);
        } catch (hash<ExceptionInfo> ex) {
            logError("%y (%s): error calling stop notification closure: %s: %s: %s", name, socket_info.desc,
                get_ex_pos(ex), ex.err, ex.desc);
        }
    }

    #! adds one or more dedicated listeners to the server with the given bind address
    /** @param bind the bind address for the dedicated listener; this can be a port number or an address (or
        hostname) and a port number separated by a colon (ex: \c "192.168.20.4:8021"); the bind address will overwrite
        any \a node and \a service addresses in the \a info hash; all possible addresses will be bound to new
        listeners
        @param info a listener information hash
        @param errmap an optional reference to a hash of error information keyed by bind address

        @return a list of listener info hashes; see the return value of HttpServer::getListenerInfo() for the
        description of each hash element in the list returned by this method

        @throw HTTPSERVER-ADDLISTENER-ERROR duplicate bind address

        @note if \c bind begins with a "/" character then it is assumed to be a UNIX socket path and the \a family
        key of the \a info hash is ignored

        @since HttpServer 0.3.13.1
    */
    final list<hash<auto>> addListeners(string bind, hash<HttpListenerOptionInfo> info,
            *reference<hash<string, string>> errmap) {
        if (bind !~ /:\w+/) {
            if (bind =~ /^\//) {
                info.node = bind;
                remove info.service;
                return list(addListenerIntern(info).getInfo());
            }

            # assume service only
            remove info.node;
            info.service = bind;
            return addINETListenersIntern(info, \errmap);
        }

        # add node and service
        (info.node, info.service) = (bind =~ x/(.+):(\w+)/);
        return addINETListenersIntern(info, \errmap);
    }

    #! adds one or more dedicated listeners to the server with the given bind address
    /** @param info a listener information hash
        @param errmap an optional reference to a hash of error information keyed by bind address

        @return a list of listener info hashes; see the return value of HttpServer::getListenerInfo() for the
        description of each hash element in the list returned by this method

        @throw HTTPSERVER-ADDLISTENER-ERROR duplicate bind address

        @note if \c bind begins with a "/" character then it is assumed to be a UNIX socket path and the \a family
        key of the \a info hash is ignored

        @since HttpServer 0.3.13.1
    */
    final list<hash<auto>> addListeners(hash<HttpListenerOptionInfo> info, *reference<hash<string, string>> errmap) {
        if (exists info.node && !exists info.service) {
            # try to bind without a service, can be a UNIX domain socket
            return list(addListenerIntern(info).getInfo());
        }
        return addINETListenersIntern(info, \errmap);
    }

    #! adds a single global listener to the server
    /** @param port the port number

        @return a listener info hash; see the return value of HttpServer::HttpServer::getListenerInfo() for the
        description of the hash returned by this method

        @throw HTTPSERVER-ADDLISTENER-ERROR invalid options; duplicate bind address
     */
    hash<auto> addListener(int port) {
        return addListenerIntern(<HttpListenerOptionInfo>{
            "service": port,
        }).getInfo();
    }

    #! adds a single global listener to the server
    /** @param opts the listener options

        @return a listener info hash; see the return value of HttpServer::HttpServer::getListenerInfo() for the
        description of the hash returned by this method

        @throw HTTPSERVER-ADDLISTENER-ERROR invalid options; duplicate bind address

        @note if \a sock begins with a "/" character then it is assumed to be a UNIX socket path and the \a family
        key is ignored
     */
    hash<auto> addListener(hash<HttpListenerOptionInfo> opts) {
        return addListenerIntern(opts).getInfo();
    }

    #! throws an exception; these objects do not support copying
    copy() {
        throw "COPY-ERROR", "this object cannot be copied";
    }

    #! returns a hash of listener information
    /** @return a hash of listener info hashes keyed by listener ID; see the return value of HttpServer::getListenerInfo() for the description of each hash value
     */
    hash<string, hash<auto>> getListeners() {
        return (map {$1.key: $1.value.getInfo()}, listeners.pairIterator()) ?? {};
    }

    #! returns a hash of information about the listener given the listener ID
    /** @param id the listener ID

        @return a hash of listener information with the following keys:
        - \c name: the listener name
        - \c hostname: the listening interface name if available (ex: "localhost"; note that this key is not present when retrieving information about UNIX sockets)
        - \c hostname_desc: a descriptive string giving the hostname and the address family if the hostname is available (ex: "ipv6[localhost]"; note that this key is not present when retrieving information about UNIX sockets)
        - \c address: a string giving the address (ex: "::ffff:0.0.0.0")
        - \c address_desc: a descriptive string giving the address and the address family (ex: "ipv6[::ffff:0.0.0.0]")
        - \c port: an integer port number if available (note that this key is not present when retrieving information about UNIX sockets)
        - \c family: the network address family (see @ref network_address_family_constants "Network Address Family Constants")
        - \c familystr: a string describing the network address family (ex: "ipv4")
        - \c proto: the protocol used; either \c "http" or \c "https" for secure listeners
        - \c id: the listener ID
        - \c bind: the bind specification used

        @throw INVALID-LISTENER-ERROR invalid listener ID
     */
    hash<auto> getListenerInfo(softint id) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id)) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);
        }

        return listeners{id}.getInfo();
    }

    #! returns a hash of information about the listener given the listener name or bind ID
    /** @param name the listener name or bind ID

        @return a hash of listener information with the following keys:
        - \c name: the listener name
        - \c hostname: the listening interface name if available (ex: "localhost"; note that this key is not present
          when retrieving information about UNIX sockets)
        - \c hostname_desc: a descriptive string giving the hostname and the address family if the hostname is
          available (ex: "ipv6[localhost]"; note that this key is not present when retrieving information about UNIX
          sockets)
        - \c address: a string giving the address (ex: "::ffff:0.0.0.0")
        - \c address_desc: a descriptive string giving the address and the address family (ex: "ipv6[::ffff:0.0.0.0]")
        - \c port: an integer port number if available (note that this key is not present when retrieving information
          about UNIX sockets)
        - \c family: the network address family (see
          @ref network_address_family_constants "Network Address Family Constants")
        - \c familystr: a string describing the network address family (ex: "ipv4")
        - \c proto: the protocol used; either \c "http" or \c "https" for secure listeners
        - \c id: the listener ID
        - \c bind: the bind specification used

        @throw INVALID-LISTENER-ERROR invalid listener name or bind ID
     */
    hash<auto> getListenerInfoName(string name) {
        lm.enter();
        on_exit lm.exit();

        softstring id = getListenerIdFromBindUnlocked(name);
        return listeners{id}.getInfo();
    }

    #! Reloads an HTTPS certificate from the original location for the given listener from the listener ID
    /** @param id the listener ID

        Subsequent connections will use the new certificate definition; the listener must have been started with the
        location information for the X.509 certificate and private key, or a REFRESH-CERTIFICATE-ERROR exception is
        raised

        @throw REFRESH-CERTIFICATE-ERROR not an HTTPS listener or certificate location information not present

        @since HttpServer 1.1
    */
    reloadListenerCertificate(int id) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id)) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);
        }

        listeners{id}.reloadCertificate();
    }

    #! Reloads an HTTPS certificate from the original location for the given listener from the listener name
    /** @param name the listener name or bind address

        Subsequent connections will use the new certificate definition; the listener must have been started with the
        location information for the X.509 certificate and private key, or a REFRESH-CERTIFICATE-ERROR exception is
        raised

        @throw REFRESH-CERTIFICATE-ERROR not an HTTPS listener or certificate location information not present

        @since HttpServer 1.1
    */
    reloadListenerCertificateName(string name) {
        lm.enter();
        on_exit lm.exit();

        listeners{getListenerIdFromBindUnlocked(name)}.reloadCertificate();
    }

    #! returns the number of running HTTP listeners
    int getListenerCount() {
        return listeners.size();
    }

    #! stops all listeners; does not wait for all connections on the listeners to close
    /** do not call stop() after calling stopNoWait(); it can cause a deadlock
     */
    stopNoWait() {
        # stop all listeners
        lm.enter();
        on_exit lm.exit();

        map $1.stopNoWait(), listeners.iterator();

        threadPool.stop();
    }

    #! waits for all listeners to be stopped; call after calling HttpServer::stopNoWait()
    waitStop() {
        c.waitForZero();
    }

    #! called from listener when the actual listener thread is running
    /** @param id the listener ID
        @param sinfo a socket information hash as returned by @ref Qore::Socket::getSocketInfo()

        @since HttpServer 0.3.11
     */
    listenerStarted(int id, hash<auto> sinfo) {
        log("HTTP listener %d started on %s", id, sinfo.desc);
    }

    # only called from the listeners - do not call externally
    listenerStopped(HttpListener l) {
        # decrement listener count
        on_exit c.dec();

        lm.enter();
        on_exit lm.exit();

        delete smap.(l.getAddress());
        remove listeners.(l.getID());
        remove nmap.(l.getName());
        #printf("stopped %s c=%y\n", l.getAddress(), c.getCount());
    }

    #! stops all listeners; only returns when all connections are closed on all listeners
    /** do not call stop() after calling stopNoWait(); it can cause a deadlock
     */
    stop() {
        # shutdown all listeners
        lm.enter();
        on_exit lm.exit();

        map $1.stop(), listeners.iterator();
        c.waitForZero();

        threadPool.stop();
    }

    #! stops a single listener based on its name or bind address; does not return until all connections on the listener have closed
    /** @param bind listener bind address

        @throw INVALID-LISTENER-ERROR invalid listener bind address
        @throw HTTP-SERVER-ERROR cannot stop last listener
    */
    stopListener(softstring bind) {
        lm.enter();
        on_exit lm.exit();

        *int id = smap{bind};
        if (!id) {
            id = nmap{bind};
        }

        if (!id) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with name or bind address %y", bind);
        }

        if (protect_last_listener && (elements smap == 1)) {
            throw "HTTP-SERVER-ERROR", "cannot stop last listener";
        }

        listeners{id}.stop();
    }

    #! stops a single listener based on its listener ID; does not return until all connections on the listener have closed
    /** @param id listener id

        @throw INVALID-LISTENER-ERROR invalid listener ID
        @throw HTTP-SERVER-ERROR cannot stop last listener
    */
    stopListenerID(softint id) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id)) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);
        }

        if (protect_last_listener && (smap.size() == 1)) {
            throw "HTTP-SERVER-ERROR", "cannot stop last listener";
        }

        listeners{id}.stop();
    }

    #! starts the shutdown process for a listener based on its listener ID; returns immediately
    /** @param id listener id

        @throw INVALID-LISTENER-ERROR invalid listener ID
        @throw HTTP-SERVER-ERROR cannot stop last listener
    */
    stopListenerIDNoWait(softint id) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id)) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);
        }

        if (protect_last_listener && (smap.size() == 1)) {
            throw "HTTP-SERVER-ERROR", "cannot stop last listener";
        }

        background listeners{id}.stop();
    }

    #! gets the TID of a listener based on its listener ID
    int getListenerTID(softint id) {
        return listeners{id}.tid;
    }

    #! sets the default request handler when no other handler can be matched
    setDefaultHandler(string name, HttpServer::AbstractHttpRequestHandler obj) {
        defaultHandler = {
            "name": name,
            "obj": obj,
        };
    }

    #! sets a request handler according to the arguments given
    setHandler(string name, hash<HttpHandlerConfigInfo> info) {
        handlers.setHandler(name, info);
    }

    #! sets a request handler according to the arguments given
    setHandler(string name, string path, *softlist<softstring> content_types, HttpServer::AbstractHttpRequestHandler obj, *softlist<softstring> special_headers, bool isregex = True) {
        handlers.setHandler(name, <HttpHandlerConfigInfo>{
            "path": path,
            "isregex": isregex,
            "content_types": content_types,
            "handler": obj,
            "headers": special_headers,
        });
    }

    #! sets a dynamic request handler according to the arguments given
    setDynamicHandler(string name, hash<HttpHandlerConfigInfo> info) {
        dhandlers.setHandler(name, info);
    }

    #! sets a dynamic request handler according to the arguments given
    setDynamicHandler(string name, string path, *softlist<softstring> content_types,
            HttpServer::AbstractHttpRequestHandler obj, *softlist<softstring> special_headers, bool isregex = True) {
        dhandlers.setHandler(name, <HttpHandlerConfigInfo>{
            "path": path,
            "isregex": isregex,
            "content_types": content_types,
            "handler": obj,
            "headers": special_headers,
        });
    }

    #! sets a request handler according to the arguments given
    setHandler(string name, HttpServer::AbstractUrlHandler obj) {
        handlers.setHandler(name, <HttpHandlerConfigInfo>{
            "path": obj.url_root,
            "isregex": False,
            "handler": obj,
        });
    }

    #! sets a dynamic request handler according to the arguments given
    setDynamicHandler(string name, HttpServer::AbstractUrlHandler obj) {
        dhandlers.setHandler(name, <HttpHandlerConfigInfo>{
            "path": obj.url_root,
            "isregex": False,
            "handler": obj,
        });
    }

    #! adds a request handler to a listener given the listener's name or bind address
    addHandlerToListener(softstring bind, string name, hash<HttpHandlerConfigInfo> info) {
        lm.enter();
        on_exit lm.exit();

        softstring id = getListenerIdFromBindUnlocked(bind);
        listeners{id}.addHandlers({name: info});
    }

    #! adds a request handler to a listener given the listener's id
    /** @param id listener id
        @param name handler name
        @param info the handler configuration info to add to the listener

        @throw INVALID-LISTENER-ERROR invalid listener id passed
    */
    addHandlerToListenerID(softint id, string name, hash<HttpHandlerConfigInfo> info) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id)) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);
        }

        listeners{id}.addHandlers({name: info});
    }

    #! adds a request handler to a listener given the listener's id
    /** @param id listener id
        @param name handler name
        @param path handler path
        @param content_type handler's content type
        @param obj handler object
        @param special_headers headers to match
        @param isregex is the path a regular expression

        @throw INVALID-LISTENER-ERROR invalid listener id passed
    */
    addHandlerToListenerID(softint id, string name, string path, *softlist content_type,
            HttpServer::AbstractHttpRequestHandler obj, *softlist special_headers, bool isregex = True) {
        addHandlerToListenerID(id, name, <HttpHandlerConfigInfo>{
            "path": path,
            "isregex": isregex,
            "content_types": content_type,
            "handler": obj,
            "headers": special_headers,
        });
    }

    #! adds a request handler to a listener given the listener's name or bind address
    addHandlerToListener(softstring bind, string name, HttpServer::AbstractUrlHandler obj) {
        lm.enter();
        on_exit lm.exit();

        softstring id = getListenerIdFromBindUnlocked(bind);

        hash<string, hash<HttpHandlerConfigInfo>> h = {
            name: <HttpHandlerConfigInfo>{
                "path": obj.url_root,
                "isregex": False,
                "handler": obj,
            },
        };
        listeners{id}.addHandlers(h);
    }

    #! adds a request handler to a listener given the listener's id
    /** @param id listener id
        @param name handler name
        @param obj handler object

        @throw INVALID-LISTENER-ERROR invalid listener id passed
    */
    addHandlerToListenerID(softint id, string name, HttpServer::AbstractUrlHandler obj) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id))
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);

        hash<string, hash<HttpHandlerConfigInfo>> h = {
            name: <HttpHandlerConfigInfo>{
                "path": obj.url_root,
                "isregex": False,
                "handler": obj,
            },
        };
        listeners{id}.addHandlers(h);
    }

    #! remove request handler from a listener given the listener's id
    /** @param id listener id
        @param handler_name name of handler to remove;
        @return whether listener was stopped

        @throw INVALID-LISTENER-ERROR invalid listener id passed
    */
    bool removeHandlerFromListenerID(softstring id, string handler_name) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id)) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);
        }
        listeners{id}.removeHandler(handler_name);
        return HttpServer::HttpListener::stopIfNoHandlers(listeners{id});
    }

    #! remove request handler from a listener given the listener's id
    /** @param id listener id
        @param handler handler to remove;
        @return whether listener was stopped

        @throw INVALID-LISTENER-ERROR invalid listener id passed
    */
    bool removeHandlerFromListenerID(softstring id, HttpServer::AbstractHttpRequestHandler handler) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id)) {
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);
        }
        listeners{id}.removeHandler(handler);
        return HttpServer::HttpListener::stopIfNoHandlers(listeners{id});
    }

    #! turns on or off header and body logging options for receive operations for the given listener
    /** @par Example:
        @code{.py}
http.setListenerLogOptions("app", LLO_RECV_HEADERS|LLO_SEND_HEADERS);
        @endcode

        @param bind the name of the listener or bind string
        @param code a binary-or'ed product of @ref ListenerLogOptions "listener log options"; bits set enable logging; bits not set disable logging

        @since HttpServer 0.3.11
     */
    setListenerLogOptions(softstring bind, softint code) {
        lm.enter();
        on_exit lm.exit();

        setListenerLogOptionsUnlocked(getListenerIdFromBindUnlocked(bind), code);
    }

    #! turns on or off header and body logging options for receive operations for the given listener
    /** @par Example:
        @code{.py}
http.setListenerLogOptionsID(0, LLO_RECV_HEADERS|LLO_SEND_HEADERS);
        @endcode

        @param id the unique listener ID
        @param code a binary-or'ed product of @ref ListenerLogOptions "listener log options"; bits set enable logging; bits not set disable logging

        @throw INVALID-LISTENER-ERROR invalid listener id passed

        @since HttpServer 0.3.11
     */
    setListenerLogOptionsID(softint id, softint code) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id))
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);

        setListenerLogOptionsUnlocked(id, code);
    }

    #! returns a binary-or'ed product of @ref ListenerLogOptions "listener log options" corresponding to enabled log options for the given listener
    /**
        @throw INVALID-LISTENER-ERROR invalid listener id passed

        @since HttpServer 0.3.11
    */
    int getListenerLogOptions(softstring bind) {
        lm.enter();
        on_exit lm.exit();

        return getListenerLogOptionsUnlocked(getListenerIdFromBindUnlocked(bind));
    }

    #! returns a binary-or'ed product of @ref ListenerLogOptions "listener log options" corresponding to enabled log options for the given listener
    /**
        @throw INVALID-LISTENER-ERROR invalid listener id passed

        @since HttpServer 0.3.11
    */
    int getListenerLogOptionsID(softint id) {
        lm.enter();
        on_exit lm.exit();

        if (!listeners.hasKey(id))
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with ID %d", id);

        return getListenerLogOptionsUnlocked(id);
    }

    #! Disable dynamic handler
    /** @throw DISABLEHANDLER-ERROR if the given dynamic handler does not exist
    */
    disableDynamicHandler(string name) {
        dhandlers.disableHandler(name);
    }

    #! remove dynamic handler
    /** @throw REMOVEHANDLER-ERROR if the given dynamic handler does not exist
    */
    removeDynamicHandler(string name, *bool force_immediate) {
        dhandlers.removeHandler(name, force_immediate);
    }

    #! called to log information to the registered log code
    log(string fmt, ...) {
        logger.logArgs(LoggerLevel::INFO, "HttpServer: " + fmt, argv);
    }

    #! called to log error information to the registered error log code
    logError(string fmt, ...) {
        logger.logArgs(LoggerLevel::ERROR, "HttpServer: " + fmt, argv);
    }

    #! sends an HTTP error message on the socket
    sendHttpError(HttpListener listener, hash<auto> cx, Socket s, int code, *data msg, *InputStream chunked_msg, *hash<auto> extra_hdrs, *string encoding, bool head) {
        if (!s.isOpen()) {
            listener.log("cid %d: connection closed by peer", cx.id);
            return;
        }

        data response_msg;
        if (msg || !chunked_msg) {
            # issue #3116: do not send a reply body if the response code does not allow it
            /** http://tools.ietf.org/html/rfc2616#section-4.4
                1.Any response message which "MUST NOT" include a message-body (such
                as the 1xx, 204, and 304 responses and any response to a HEAD
                request) is always terminated by the first empty line after the
                header fields, regardless of the entity-header fields present in
                the message.
            */
            if (!head && (code >= 200) && (code != 204) && (code != 304)) {
                if (msg.typeCode() == NT_STRING) {
                    response_msg = !extra_hdrs."Content-Type"
                        ? sprintf("<html><head><title>%s %s</title></head><body><h1>%s</h1><pre>%s</pre><p><hr><address>%s on "
                            "%s</address></body></html>",
                                code, HttpServer::HttpCodes{code}, HttpServer::HttpCodes{code}, html_encode(msg),
                                http_server_string, gethostname())
                        : msg;
                } else {
                    response_msg = msg;
                }
            }
        } else {
            if (chunked_msg instanceof StringInputStream) {
                # ignore any encoding passed in case of a string input stream response body, and use its encoding
                encoding = cast<StringInputStream>(chunked_msg).getEncoding();
            }
            extra_hdrs."Transfer-Encoding" = "chunked";
        }

        # restore encoding on exit
        string old_encoding = s.getEncoding();
        on_exit if (old_encoding != s.getEncoding())
            s.setEncoding(old_encoding);

        if (!encoding)
            encoding = s.getEncoding().lwr();
        else if (encoding != s.getEncoding().lwr())
            s.setEncoding(encoding);

        hash<auto> v_hdr;
        v_hdr += hdr;

        if (!extra_hdrs."Content-Type")
            v_hdr."Content-Type" = MimeTypeHtml + ";charset=" + encoding;
        else if (extra_hdrs."Content-Type" !~ /charset=/)
            extra_hdrs."Content-Type" += ";charset=" + encoding;

        if (cx.close)
            v_hdr += ("Connection": "close");
        else
            v_hdr += ("Connection": "Keep-Alive");

        if (extra_hdrs)
            v_hdr += extra_hdrs;

        # log exceptions if not "SOCKET-SEND-ERROR" (probably broken pipe)
        try {
            s.sendHTTPResponse(code, HttpServer::HttpCodes{code}, "1.1", v_hdr, response_msg ?? chunked_msg);
            listener.logResponse(cx, code, response_msg ?? chunked_msg, v_hdr);
        } catch (hash<ExceptionInfo> ex) {
            if (ex.err != "SOCKET-SEND-ERROR") {
                string estr = sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                logError(estr);
            }
        }
    }

    #! masks log messages by removing sensitive data
    /** @see setMaskCode()

        @since %HttpServer 0.3.12
    */
    string maskData(string msg) {
        return maskfunc ? maskfunc(msg) : http_mask_data(msg);
    }

    #! sets the @ref closure "closure" or @ref call_reference "call reference" that will be used to mask sensitive data in log messages
    /** @par Example
        @code{.py}
        http_server.setMaskCode(string sub (string msg) { return do_mask(msg); });
        @endcode

        @param maskfunc a @ref closure "closure" or @ref call_reference "call reference" that takes a single string argument and returns the masked string

        @see maskData()

        @since %HttpServer 0.3.12
    */
    setMaskCode(code maskfunc) {
        self.maskfunc = maskfunc;
    }

    #! returns a complete URL from a bind address
    /** @param bind the bind address; if for any reason there is a path in the bind address, it will be ignored
        @param host the hostname to use in case the bind string is only a port number; if none is passed or the value passed is equal to the return value of @ref Qore::gethostname(), then \c "localhost" is used

        @note reexported from @ref HttpServer::http_get_url_from_bind()
     */
    static string getURLFromBind(softstring bind, *string host) {
        return HttpServer::http_get_url_from_bind(bind, host);
    }

    #! turns on or off debugging; when debugging is enabled more verbose error messages are reported
    setDebug(bool dbg = True) {
        debug = dbg;
    }

    #! returns the current status of the debug flag
    bool getDebug() {
        return debug;
    }

    startConnection(code c) {
        threadPool.submit(c);
    }

    #! This method is called after each request to clear context info so that it does not leak into other requests
    /** Reimplement in subclasses if necessarily

        @since HttpServer 1.1.2
    */
    clearContextInfo() {
        # this method left intentionally blank
    }

    #! returns the listener ID from the bind name or throws an exception if not valid
    /** @throw INVALID-LISTENER-ERROR invalid listener bind address
    */
    private int getListenerIdFromBindUnlocked(string bind) {
        *int id;
        if (!(id = (smap{bind} ?? nmap{bind}))){
            throw "INVALID-LISTENER-ERROR", sprintf("there is no listener with name or bind address %y", bind);
        }
        return id;
    }

    #! turns on or off header and body logging options for the given listener according to the option code
    private setListenerLogOptionsUnlocked(softstring id, int code) {
        HttpListener l = listeners{id};
        l.logRecvHeaders(code & LLO_RECV_HEADERS);
        l.logRecvBody(code & LLO_RECV_BODY);
        l.logSendHeaders(code & LLO_SEND_HEADERS);
        l.logSendBody(code & LLO_RECV_BODY);
    }

    #! returns header and body logging options for the given listener as a binary-or'ed value of @ref ListenerLogOptions "listener log option codes"
    private int getListenerLogOptionsUnlocked(softstring id) {
        HttpListener l = listeners{id};
        hash<auto> h = l.getLogOptions();
        return
            (h.recv_headers ? LLO_RECV_HEADERS : 0)
            | (h.recv_body ? LLO_RECV_BODY : 0)
            | (h.send_headers ? LLO_SEND_HEADERS : 0)
            | (h.send_body ? LLO_SEND_BODY : 0);
    }

    #! helper method to set HTTP response headers
    static nothing setReplyHeaders(Socket s, hash<auto> cx, reference<hash<auto>> rv) {
        return HttpServer::http_set_reply_headers(s, cx, \rv);
    }

    #! @cond nodoc
    # don't reimplement this method; fix/enhance it in the module
    final private HttpListener addListenerIntern(*string node, *softstring service, *Qore::SSLCertificate cert,
            *Qore::SSLPrivateKey key, *hash<string, hash<HttpHandlerConfigInfo>> handler_info, *LoggerInterface logger,
            *code stopc, *string name, int family = AF_UNSPEC) {
        return addListenerIntern(<HttpListenerOptionInfo>{
            "node": node,
            "service": service,
            "cert": cert,
            "key": key,
            "handler_info": handler_info,
            "logger": logger,
            "stopc": stopc,
            "family": family,
        });
    }

    final private HttpListener addListenerIntern(hash<HttpListenerOptionInfo> info) {
        if (!exists info.node && !exists info.service) {
            throw "HTTPSERVER-ADDLISTENER-ERROR", sprintf("missing both \"node\" and \"service\" from listener option hash: %y", info);
        }

        string sock = (exists info.service ? sprintf("%s:%s", info.node ?? "*", info.service) : info.node);

        lm.enter();
        on_exit lm.exit();

        if (smap{sock}) {
            throw "HTTPSERVER-ADDLISTENER-ERROR", sprintf("cannot add listener on %y; there is already an existing listener with this bind address", sock);
        }

        int id = seqListeners.next();
        if (!info.name) {
            info.name = "listener";
        }
        info.name += sprintf("-%d", id);

        if (nmap{info.name}) {
            throw "HTTPSERVER-ADDLISTENER-ERROR", sprintf("there is already an active listener with name %y", info.name);
        }

        c.inc();
        #printf("HttpServer::addListenerIntern() %y c=%y\n", sock, c.getCount());
        on_error c.dec();

        HttpListener l(self, info.name, id, seqSessions, info);
        listeners{id} = l;
        smap{sock} = id;
        nmap{info.name} = id;

        # rename listener if a wildcard service was provided
        if (info.service == "0") {
            int port = l.getInfo().port;
            string nsock = sprintf("%s:%s", info.node ?? "*", port);
            smap{nsock} = remove smap{sock};
        }
        return l;
    }

    # don't reimplement this method; fix/enhance it in the module
    final private list<hash<auto>> addINETListenersIntern(hash<HttpListenerOptionInfo> info,
            *reference<hash<string, string>> errmap) {
        list<auto> al = getaddrinfo(info.node, info.service, info.family, AIFlags);

        # sort ipv6 addresses first in list
        al = sort(al, int sub (hash<auto> l, hash<auto> r) {
            return l.family === AF_INET6 ? -1 : 0;
        });

        list<hash<auto>> rv = ();
        foreach hash<auto> h in (al) {
            try {
                hash<HttpListenerOptionInfo> new_info = info;
                new_info += {
                    "node": h.address,
                    "service": h.port,
                };
                rv += addListenerIntern(new_info).getInfo();
%ifdef Windows
                if (!info.node && (info.family != AF_UNSPEC)) {
                    break;
                }
%else
                # exit after the first listener is bound if the node address is missing (= bind on all addresses)
                if (!info.node) {
                    break;
                }
%endif
            } catch (hash<ExceptionInfo> ex) {
                string errstr = sprintf("%s:%s: %s: %s: %s", h.address_desc, h.port, get_ex_pos(ex), ex.err, ex.desc);
                string bind;
                if (exists info.node) {
                    if (exists info.service) {
                        bind = sprintf("%s:%s", info.node, info.service);
                    } else {
                        bind = info.node;
                    }
                } else {
                    bind = info.service;
                }
                errmap{bind ?* "unknown"} = errstr;
                if (ex.err != "HTTPLISTENER-BIND-ERROR" && ex.err != "SOCKET-BIND-ERROR") {
                    logError("add listener %s", errstr);
                    rethrow;
                }

                log("cannot add listener on %s", errstr);
            }
        }

        return rv;
    }

    # don't reimplement this method; fix/enhance it in the module
    final private hash<HttpResponseInfo> noHandlerError(hash<auto> cx, hash<auto> hdr, auto body) {
        string str = "";
        if (hdr.path)
            str = sprintf("url=%y", hdr.path);
        else
            str = "<no URL>";

        if (hdr."content-type")
            str += sprintf(", content-type=%y", hdr."content-type");
        else
            str += ", <no content-type>";

        log("no handler for %s (from %s) hdr: %y", str, cx."peer-info".address_desc, hdr);
        return new hash<HttpResponseInfo>({
            "code" : 501,
            "body" : sprintf("no handler has been registered for %s", str),
        });
    }

    # handles an incoming request - do not call externally; this method is called by the listeners when a request is received
    # don't reimplement this method; fix/enhance it in the module
    final handleRequest(HttpListener listener, Socket s, reference<hash<auto>> cx, hash<auto> hdr, bool head = False,
            HttpPersistentHandlerInfo phi, hash<auto> info, reference<bool> dedicated, reference<bool> dedicated_external) {
        if (!http_methods{hdr.method}) {
            string err = sprintf("unknown / unsupported HTTP method %n", hdr.method);
            string str = sprintf("%s: received from %s via %s", err, info.address_desc,
                listener.getListenerSocketInfo().address_desc);
            listener.logError(str);
            cx.close = True;
            sendHttpError(listener, cx, s, 501, err, NOTHING, NOTHING, cx."response-encoding", head);
            return;
        }

        # get first supported encoding for response
        foreach string enc in (cx."header-info"."accept-encoding") {
            *string e = ContentEncodings{enc};
            if (!e)
                continue;
            cx.encoding = e;
            break;
        }

        # convert "accept-encoding" to a hash
        cx."header-info"."accept-encoding" = map {$1: True}, cx."header-info"."accept-encoding";

        # erase the encoding string on exit
        on_exit remove cx.encoding;

        hash url = {
            "path": hdr.path,
        };

        # add logging functions and url
        cx += {
            "logger": logger,
            "url": url,
            "debug": debug,
        };

        # clear any context info set during handling the request so it does not leak into other requests
        on_exit try {
            clearContextInfo();
        } catch (hash<ExceptionInfo> ex) {
            # log the error
            string desc = "error clearing request context data: " + !debug
                ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                : get_exception_string(ex);
            desc += sprintf(": received from %s", cx."peer-info".address_desc);
            listener.logError("%s", desc);
        }

        HttpServer::AbstractHttpRequestHandler handler;
        # the dynamic handler helper maintains the request count for dynamic handlers so any call to remove the handler will only return after all in-progress requests are completed; the object is only allocated if needed
        DynamicHandlerHelper dhh;

        if (phi.handler) {
            handler = phi.handler;
        } else {
            # find a handler for the request
            *HandlerInfo hi;
            int score = 0;
            string root_path;
            if (listener.hasHandlers()) {
                hi = listener.findHandler(hdr, \score, True, \root_path);
                if (!hi) {
                    if (listener.defaultHandler)
                        hi = listener.defaultHandler;
                    else {
                        sendHttpError(listener, cx, s, 404, "Not found", NOTHING, NOTHING,
                            cx."response-encoding", head);
                        return;
                    }
                }
            } else {
                hi = handlers.findHandler(hdr, \score, False, \root_path);
                if (score < 3) {
                    *HandlerInfo dhi = dhandlers.findHandler(hdr, \score, \dhh, \root_path);
                    if (dhi)
                        hi = dhi;
                }
            }

            if (hi) {
                handler = hi.obj;
                cx.handler_name = hi.name;
                if (root_path)
                    cx.root_path = root_path;
            }
        }

        try {
            if (!handler && defaultHandler) {
                handler = defaultHandler.obj;
                cx.handler_name = defaultHandler.name;
            }

            if (handler && hdr.expect) {
                if (hdr.expect == "100-continue") {
                    hash<HttpResponseInfo> resp = handler.handleExpectHeader(cx, hdr);
                    sendReply(listener, s, handler, resp, \cx, hdr, head, \dedicated, \dedicated_external);
                } else {
                    string etxt = sprintf("unrecognized 'Expect' header: %y", hdr.expect);
                    string str = sprintf("%s: received from %s via %s (header: %y)", etxt,
                        cx."peer-info".address_desc, cx."socket-info".address_desc, hdr);
                    listener.logError(str);
                    cx.close = True;
                    sendHttpError(listener, cx, s, 400, etxt, NOTHING, NOTHING, cx."response-encoding",
                        hdr.method == "HEAD");
                    return;
                }
            }

            *data body;
            # if we need to get a body
            if (hdr."content-length") {
                try {
                    if (hdr."content-encoding" || hdr."content-type" == MimeTypeOctetStream)
                        body = s.recvBinary(hdr."content-length", HttpServer::ReadTimeout);
                    else
                        body = s.recv(hdr."content-length", HttpServer::ReadTimeout);
                    #printf("HTTP DEBUG: %s\n", body);
                } catch (hash<ExceptionInfo> ex) {
                    string etxt = sprintf("error reading body in %s (Content-Length: %d): %s: %s", hdr.method,
                        hdr."content-length", ex.err, ex.desc);
                    string str = sprintf("%s: received from %s via %s (header: %y)", etxt,
                        cx."peer-info".address_desc, cx."socket-info".address_desc, hdr);
                    listener.logError(str);
                    cx.close = True;
                    sendHttpError(listener, cx, s, 400, etxt, NOTHING, NOTHING, cx."response-encoding",
                        hdr.method == "HEAD");
                    return;
                }
            }

            # override assumed "iso-8859-1" character encoding if necessary
            if (body.typeCode() == NT_STRING && override_encoding && hdr."_qore_orig_content_type" !~ /charset=/) {
                body = force_encoding(body, override_encoding);
            }

            listener.doLogRecvBody(body, cx, hdr, info);

            hash<HttpResponseInfo> rv;

            #printf("HTTP DEBUG: B: handler: %y strict-bool-eval: %y\n", cx.handler_name, get_parse_options() & PO_STRICT_BOOLEAN_EVAL);
            #printf("HTTP DEBUG: B: handler: %y: context: %y, hdr: %y, body: %y\n", cx.handler_name, cx, hdr, body);
            #printf("HTTP DEBUG: BEFORE handler=%s", dbg_node_info(handlers.(cx.handler_name)));

            #printf("HTTP DEBUG: A: cid: %d handler: %y auth: %y\n", cx.id, cx.handler_name, boolean(handler.auth));

            if (!handler) {
                cx.handler_name = "error";
                rv = noHandlerError(cx, hdr, body);
            } else {
                # check for authentication info
                #printf("HTTP DEBUG: handler: %y (auth: %y) hdr: %y\n", cx.handler_name, exists handler.auth && handler.auth.requiresAuthentication(), hdr);

                # allow the handler to remove any authentication information in thread-local data, for example
                on_exit if (handler.auth) {
                    handler.auth.endRequest();
                }

                if (handler.auth) {
                    try {
                        *hash<auto> ah = handler.auth.authenticateRequest(listener, hdr, \cx);
                        # return an error if authentication failed
                        if (ah) {
                            if (!ah.code)
                                ah.code = 401;
                            if (!ah.body && !ah.hasKeyValue("chunked_body"))
                                ah.body = "Authentication is required to access this server";
                            cx.close = True;
                            sendHttpError(listener, cx, s, ah.code, ah.body,
                                ah.hasKey("chunked_body") ? ah.chunked_body : NOTHING, ah.hdr, cx."response-encoding",
                                head);
                            return;
                        }
                    } catch (hash<ExceptionInfo> ex) {
                        # log the error
                        string desc = !debug
                            ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                            : get_exception_string(ex);
                        desc += sprintf(": received from %s", cx."peer-info".address_desc);
                        listener.logError("%s", desc);
                        cx.close = True;
                        sendHttpError(listener, cx, s, 501, "Server Authentication Error", NOTHING, NOTHING, NOTHING,
                            head);
                        return;
                    }
                    if (exists cx.user) {
                        listener.log("authenticated with user %y", cx.user);
                    } else {
                        listener.log("authenticated without a user context");
                    }
                } else {
                    listener.log("no authentication required");
                }

                *hash<auto> tld_save = handler.saveThreadLocalData();
                on_exit handler.restoreThreadLocalData(tld_save);

                # decode body if applicable
                if (body && hdr."content-encoding" && handler.decompress)
                    body = AbstractHttpRequestHandler::decodeBody(hdr."content-encoding", body,
                        handler.decompress_to_string ? s.getEncoding() : NOTHING);

                rv = cast<hash<HttpResponseInfo>>(handler.handleRequest(listener, s, cx, hdr, body));

                # manage persistent handler info, if applicable
                if (!phi.handler) {
                    if (handler.isPersistent()) {
                        phi.assign(dhh, handler);
                        if (!cx.persistent && !rv.close) {
                            cx.persistent = True;
                        }
                    }
                } else if (!handler.isPersistent()) {
                    phi.clear();
                } else if (!cx.persistent && !rv.close) {
                    cx.persistent = True;
                }

                if (rv.reply_sent) {
                    return;
                }
            }

            sendReply(listener, s, handler, rv, \cx, hdr, head, \dedicated, \dedicated_external);
        } catch (hash<ExceptionInfo> ex) {
            string desc = !debug
                ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                : get_exception_string(ex);

            string str = sprintf("handler: %s: %s", cx.handler_name, desc);

            if (ex.err == "ENCODING-CONVERSION-ERROR") {
                s.setEncoding("utf8");
                cx."response-encoding" = "utf8";
            }

            cx.close = True;
            remove cx.persistent;

            # if there is a pending chunked body that has not yet been read on exit, then read it and discard before sending any response
            on_exit if (s.pendingHttpChunkedBody())
                s.readHTTPChunkedBodyBinary(HttpServer::ReadTimeout);

            sendHttpError(listener, cx, s, 500, str, NOTHING, NOTHING, cx."response-encoding", head);
            logError(str);
        }
    }

    # sends a reply to a request
    # don't reimplement this method; fix/enhance it in the module
    final sendReply(HttpListener listener, Socket s, *HttpServer::AbstractHttpRequestHandler handler, hash<auto> rv,
            reference<hash> cx, hash<auto> hdr, bool head, reference<bool> dedicated,
            reference<bool> dedicated_external) {
        if (exists rv.close)
            cx.close = boolean(rv.close);

        rv.close = cx.close;

        # if there is a pending chunked body that has not yet been read on exit, then read it and discard before sending any response
        on_exit if (s.pendingHttpChunkedBody())
            s.readHTTPChunkedBodyBinary(HttpServer::ReadTimeout);

        if (!HttpCodes.(rv.code)) { # if the handler returns an invalid hash
            string str = sprintf("%s handler returned an invalid response rv: %y", cx.handler_name, rv);
            cx.close = True;
            remove cx.persistent;

            sendHttpError(listener, cx, s, 500, str, NOTHING, NOTHING, cx."response-encoding", head);
            return;
        }

        #printf("HTTP DEBUG: handler %s returned: %n\n", cx.handler_name, rv);

        # currently enforced by the handlers:
        # RFC 2616 section 4.3: http://tools.ietf.org/html/rfc2616#section-4.3
        # All 1xx (informational), 204 (no content), and 304 (not modified) responses
        # MUST NOT include a message-body. All other responses do include a
        # message-body, although it MAY be of zero length.

        rv.hdr = self.hdr + rv.hdr;

        if ((exists rv.body || (bool chunked_body = rv.hasKeyValue("chunked_body")))
            && (head
                || (rv.code < 200
                    || (rv.code == 204
                    || rv.code == 304)))) {
            remove rv.body;
            if (chunked_body) {
                remove rv.chunked_body;
            }
        }

        HttpServer::http_set_reply_headers(s, cx, \rv);

        if (rv.code >= 300 && rv.code < 400) {
            # handle redirect msgs (RFC 2616 section 10.3 http://tools.ietf.org/html/rfc2616#section-10.3)
            doResponse(listener, s, cx, rv);
        } else if (rv.code >= 400) {
            if (!rv.body && !rv.hasKeyValue("chunked_body")) {
                rv.body = sprintf("unknown error in %s handler", cx.handler_name);
            }
            sendHttpError(listener, cx, s, rv.code, rv.body, rv.hasKey("chunked_body") ? rv.chunked_body : NOTHING,
                rv.hdr, cx."response-encoding", head);
            remove cx.persistent;
        } else {
            #printf("**** RESPONSE: %d ct: %s (te: %y) encoding: %y: %N\n", rv.code, rv.hdr."Content-Type",
            #    rv.hdr."Transfer-Encoding", cx.encoding, rv.body);

            # compress body if eligible for compression
            if (rv.body && !rv.hdr."Content-Encoding" && rv.body.size() > CompressionThreshold) {
                if (cx.encoding == "deflate") {
                    rv.hdr."Content-Encoding" = "deflate";
                    rv.body = compress(rv.body);
                } else if (cx.encoding == "gzip") {
                    rv.hdr."Content-Encoding" = "gzip";
                    rv.body = gzip(rv.body);
                } else if (cx.encoding == "bzip2") {
                    rv.hdr."Content-Encoding" = "bzip2";
                    rv.body = bzip2(rv.body);
                }
            }

            doResponse(listener, s, cx, rv);
        }

        if (rv.log)
            listener.log("cid %d: %s (from %s): %s", cx.id, cx.handler_name, cx."peer-info".address_desc, rv.log);
        if (rv.errlog)
            listener.logError("cid %d: %s (from %s): %s", cx.id, cx.handler_name, cx."peer-info".address_desc,
                rv.errlog);

        if (!rv.close && rv.user_state) {
            cx.user_state += rv.user_state;
        }

        if (rv."code" == 101) {
            if (rv.close)
                listener.logError("cid %d: 101 Switching Protocols returned from handler %y, but the connection "
                    "close flag is set", cx.id, cx.handler_name);
            else if (!(handler instanceof HttpServer::AbstractHttpSocketHandlerInterface)) {
                listener.logError("cid %d: 101 Switching Protocols returned from handler %y, but the handler does "
                    "not inherit AbstractHttpSocketHandlerInterface (class: %y)", cx.id, cx.handler_name,
                    handler.className());
            } else {
                if (listener.registerDedicatedSocket(cx.id, handler, \dedicated)) {
                    on_exit cx.close = True;
                    AbstractHttpSocketHandlerInterface sockhandler = cast<HttpServer::AbstractHttpSocketHandlerInterface>(handler);
                    try {
                        dedicated_external = sockhandler.start(listener.getID(), cx + {"listener": listener}, hdr, s);
                    } catch (hash<ExceptionInfo> ex) {
                        if (ex.err == "SOCKET-NOT-OPEN") {
                            listener.logError("cid %d: dedicated socket handler %y: socket closed by remote", cx.id,
                                cx.handler_name);
                        } else {
                            string desc = !debug
                                ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                                : get_exception_string(ex);
                            listener.logError("cid %d: error in dedicated socket handler %y: %s", cx.id,
                                cx.handler_name, desc);
                        }
                    }
                    if (dedicated_external) {
                        listener.log("cid %d: dedicated socket handler %y managed externally", cx.id, cx.handler_name);
                    } else {
                        listener.removeDedicatedSocket(cx.id);
                        listener.log("cid %d: stopped dedicated socket handler: %y", cx.id, cx.handler_name);
                    }
                } else {
                    listener.logError("cid %d: cannot start dedicated socket handler %y because the listener is "
                        "shutting down", cx.id, cx.handler_name);
                }
            }
        }
    }

    # rv is "hash" to strip types
    private:internal doResponse(HttpListener listener, Socket s, hash<auto> cx, hash rv) {
        if ((rv.body || !rv.hasKeyValue("chunked_body"))
            && !rv.hdr."Transfer-Encoding"
            && !(rv.body instanceof InputStream)) {

            s.sendHTTPResponse(rv.code, HttpServer::HttpCodes{rv."code"}, "1.1", rv.hdr ?? {}, rv.body);
        } else {
            if (exists rv.chunked_body) {
                rv.body = rv.chunked_body;
            }
            if (rv.body instanceof StringInputStream) {
                StringInputStream input_stream = cast<StringInputStream>(rv.body);
                if ((string stream_encoding = input_stream.getEncoding()) != s.getEncoding()) {
                    rv.body = new EncodingConversionInputStream(input_stream, stream_encoding, s.getEncoding());
                }
            } else if ((rv.body instanceof string) || (rv.body instanceof binary)) {
                rv.body = new BinaryInputStream(rv.body);
            }
            if (rv.body instanceof InputStream) {
                rv.hdr."Transfer-Encoding" = "chunked";
            }
            s.sendHTTPResponse(rv.code, HttpServer::HttpCodes{rv."code"}, "1.1", rv.hdr, rv.body);
        }
        listener.logResponse(cx, rv);
    }
    #! @endcond
}

class HttpPersistentHandlerInfo {
    public {
        *DynamicHandlerHelper dhh;
        *HttpServer::AbstractHttpRequestHandler handler;
    }

    destructor() {
        try {
            clear();
        } catch (hash<ExceptionInfo> ex) {
            # ignore PROGRAM-ERROR exceptions in the destructor
            if (ex.err != "PROGRAM-ERROR") {
                rethrow;
            }
        }
    }

    assign(*DynamicHandlerHelper n_dhh, HttpServer::AbstractHttpRequestHandler n_handler) {
        dhh = n_dhh;
        handler = n_handler;
    }

    clear() {
        if (handler) {
            if (handler.isPersistent())
                handler.persistentClosed();
            remove handler;
            remove dhh;
        }
    }
}

#! this class implements the listeners for the @ref HttpServer::HttpServer "HttpServer" class
/** this class is private; it's not exported in the module API
*/
class HttpListener inherits Qore::Socket, HttpServer::HttpListenerInterface {
    private {
        HttpServer serv;
        Sequence ss;

        *hash<HttpListenerOptionInfo> opts;

        #*SSLCertificate cert;
        #*SSLPrivateKey key;
        bool ssl = False;
        auto socket;
        hash socket_info;

        # connection counter for normal connection threads
        Counter cThreads();
        # connection counter for dedicated socket threads
        Counter dThreads();

        bool exit = False;
        bool stopped = False;
        int id;

        # socket handler hash
        hash<string, AbstractHttpSocketHandlerInterface> shh;

        # mutex
        Mutex m();

        #! listener-specific logger; if not present, then the server's logger will be used
        *LoggerInterface logger;

        # stop notification closure
        *code stopc;

        string name;

        # log recv headers flag
        bool log_recv_headers = False;

        # log recv body flag
        bool log_recv_body = False;

        # log send headers flag
        bool log_send_headers = False;

        # log send body flag
        bool log_send_body = False;

        #! get remote certificates
        bool get_remote_certs = False;

        #! SSL verify flags
        int ssl_verify_flags = SSL_VERIFY_NONE;

        #! accept all certificates
        bool ssl_accept_all_certs = True;

        #! thread waiting on lock
        int lock_waiting;

        const PollInterval = 250ms;
        const ListenQueue = 100;
        const BodyLogLimit = 40;

        # handler ref count
        int handler_ref_cnt = 0;

        # listener-specific handlers
        HttpHandlerList handlers();

        #! map for converting ssl verify flags to strings
        const SslVerifyMap = {
            SSL_VERIFY_PEER: "SSL_VERIFY_PEER",
            SSL_VERIFY_FAIL_IF_NO_PEER_CERT: "SSL_VERIFY_FAIL_IF_NO_PEER_CERT",
            SSL_VERIFY_CLIENT_ONCE: "SSL_VERIFY_CLIENT_ONCE",
        };
    }

    public {
        # TID of the background listener thread
        int tid;

        # default handler info
        *HandlerInfo defaultHandler;
    }

    #! creates the object with the given parameters
    /**
        @param server the HTTP server
        @param name the listener name
        @param id the listener ID
        @param ss the listener connection sequence
        @param opts listener options
    */
    constructor(HttpServer server, string name, int id, Sequence ss, *hash<HttpListenerOptionInfo> opts) {
        self.name = name;
        if (opts.cert_loc && !opts.cert) {
            opts += http_get_ssl_objects(opts.cert_loc, opts.key_loc, opts.key_password);
        }
        self.opts = opts;

        # we originally set for utf-8 and then per-connection the encoding is set according to the client's
        # content-type header (with iso-8859-1 as the default)
        # according to RFC 2616 section 3.7.1 (http://tools.ietf.org/html/rfc2616#section-3.7.1)
        setEncoding("utf-8");

        # save a weak reference to the server object
        serv := server;

        # set other params
        self.id = id;
        self.ss = ss;
        self.logger = opts.logger;
        self.stopc = opts.stopc;

        if (opts.handler_info) {
            addHandlers(opts.handler_info);
        }

        # create SSL certificate and private key objects from PEM files if passed
        if (opts.cert) {
            setupSslIntern();
            if (opts.get_remote_certs) {
                # issue #3512: enable remote certificates to be retrieved by default for HTTPS listeners
                captureRemoteCertificates();
                # get certificates from peers
                ssl_verify_flags = opts.ssl_verify_flags |= SSL_VERIFY_PEER;
                get_remote_certs = True;
            }
            if (opts.ssl_verify_flags) {
                setSslVerifyMode(ssl_verify_flags = opts.ssl_verify_flags);
            }
            if (exists opts.ssl_accept_all_certs) {
                # accept all certificates
                acceptAllCertificates(ssl_accept_all_certs = opts.ssl_accept_all_certs);
            }
            ssl = True;
        }

        # make INET (tcp) bind
        if (exists opts.service) {
            bindINET(opts.node, opts.service, True, opts.family);
            socket = sprintf("%s:%s", opts.node ?? "*", opts.service);
        } else {
            socket = opts.node;
            if (opts.node =~ /^\//) {
                # try to unlink the file first if it's a UNIX domain socket
                unlink(opts.node);
                bindUNIX(opts.node);
            } else {
                if (bind(opts.node, True)) {
                    throw "HTTPLISTENER-BIND-ERROR", strerror();
                }
            }
        }

        # save socket port/path
        socket_info = getSocketInfo() + {
            "ssl": ssl,
            "name": name,
            "id": id,
        } + opts.ext_info;

        # make 'desc' key for logging
        socket_info.desc = socket_info.address_desc;
        if (socket_info.port) {
            socket_info.desc += ":" + socket_info.port;
        }

        # set listening state on socket
        if (listen(ListenQueue)) {
            throw "HTTP-LISTEN-ERROR", sprintf("listen error %d on socket %s: %s", errno(), socket, strerror());
        }

        # start main listener thread
        cThreads.inc();

        tid = background mainThread();
    }

    #! Reloads the HTTPS certificate from the original location
    /** Subsequent connections will use the new certificate definition; the listener must have been started with the
        location information for the X.509 certificate and private key, or a REFRESH-CERTIFICATE error is raised

        @throw REFRESH-CERTIFICATE-ERROR not an HTTPS listener or certificate location information not present

        @since HttpServer 1.1
    */
    reloadCertificate() {
        if (!ssl) {
            throw "REFRESH-CERTIFICATE-ERROR", sprintf("listener %y (id %d) is not an HTTPS listener", name, id);
        }
        if (!opts.cert_loc) {
            throw "REFRESH-CERTIFICATE-ERROR", sprintf("listener %y (id %d) cannot reload the certificate from the "
                "source location as no source location was provided for the current certificate; the certificate was "
                "provided in binary format when the listener was started; in order to reload certificates at "
                "runtime, make sure to use APIs that provide the certificate location when starting the listener",
                name, id);
        }

        on_error rethrow "REFRESH-CERTIFICATE-ERROR", sprintf("%s: %s", $1.err, $1.desc);
        hash<HttpCertInfo> info = http_get_ssl_objects(opts.cert_loc, opts.key_loc, opts.key_password);
        # signal to connection thread that it should allow the lock to be acquired by this thread
        ++lock_waiting;
        on_exit --lock_waiting;
        setCertificateAndPrivateKey(info.cert, info.key);
    }

    #! add handlers to the listener
    addHandlers(hash<string, hash<HttpHandlerConfigInfo>> handler_info) {
        AutoLock al(m);
        #printf("HttpListener::addHandlers() hi: %y\n", hi);
        bool def = handlers.empty();
        map handlers.setHandler($1.key, $1.value), handler_info.pairIterator();
        map ++handler_ref_cnt, handler_info.iterator();
        if (def) {
            setDefaultHandler(handler_info.firstKey());
        }
    }

    /** Remove handler from the listener.
        @throw INVALID-HANDLER-ERROR handler is not present in the listener's handler list
    */
    removeHandler(string handler_name) {
        AutoLock al(m);
        --handler_ref_cnt;

        if (defaultHandler && defaultHandler.name == handler_name) {
            remove defaultHandler;
        }
        handlers.removeHandler(handler_name);
    }

    /** Remove handler from the listener.
        @throw INVALID-HANDLER-ERROR handler is not present in the listener's handler list
    */
    removeHandler(HttpServer::AbstractHttpRequestHandler handler) {
        AutoLock al(m);
        --handler_ref_cnt;

        if (defaultHandler && defaultHandler.obj == handler) {
            remove defaultHandler;
        }
        handlers.removeHandler(handler);
    }

    setDefaultHandler(string name) {
        if (!handlers.handlers{name})
            throw "HTTPLISTENER-SETDEFAULTHANDLER-ERROR", sprintf("handler %y is unknown (known handlers: %y)", name,
                handlers.handlers.keys());

        defaultHandler = handlers.handlers{name};
    }

    *HandlerInfo findHandler(hash<auto> hdr, reference<int> score, bool finalv = False, *reference<string> root_path) {
        return handlers.findHandler(hdr, \score, finalv, root_path ? \root_path : NOTHING);
    }

    bool hasHandlers() {
        return !handlers.empty();
    }

    #! stop listeners if there are no handlers
    /** @param listener listener to stop
        @return whether listener was stopped
    */
    static bool stopIfNoHandlers(HttpServer::HttpListener listener) {
        listener.m.lock();
        on_error listener.m.unlock();

        if (listener.handler_ref_cnt == 0) {
            listener.m.unlock();
            listener.stop();
            return True;
        }
        listener.m.unlock();
        return False;
    }

    hash getListenerSocketInfo() {
        return socket_info;
    }

    copy() {
        throw "COPY-ERROR", "this object cannot be copied";
    }

    destructor() {
        stop();
    }

    logRecvHeaders(softbool flag = True) {
        log_recv_headers = flag;
    }

    logRecvBody(softbool flag = True) {
        log_recv_body = flag;
    }

    logSendHeaders(softbool flag = True) {
        log_send_headers = flag;
    }

    logSendBody(softbool flag = True) {
        log_send_body = flag;
    }

    doLogRecvBody(*data body, hash<auto> cx, hash<auto> hdr, hash<auto> info) {
        if (body) {
            string lstr = sprintf("cid %d src %y: %s %s HTTP/%s body (%db): ", cx.id, cx."peer-info".address_desc,
                hdr.method, cx.masked_path, hdr.http_version, body.size());
            if (body.typeCode() == NT_STRING) {
                try {
                    string bstr = body.size() > BodyLogLimit ? body.substr(0, BodyLogLimit) + "..." : body;
                    # attempt to mask sensitive data in the message body
                    bstr = serv.maskData(bstr);
                    bstr = replace(bstr, "\n", "\\n");
                    bstr = replace(bstr, "\r", "\\r");
                    bstr = replace(bstr, "\t", "\\t");
                    lstr += sprintf("'%s'", bstr);
                } catch (hash<ExceptionInfo> ex) {
                    if (ex.err == "INVALID-ENCODING") {
                        lstr += sprintf("error logging msg body: %s: %s", ex.err, ex.desc);
                        string etxt = serv.getDebug()
                            ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                            : get_exception_string(ex);
                        string str = sprintf("%s: received from %s via %s", etxt, info.address_desc,
                            socket_info.address_desc);
                        logError(str);
                        logError(sprintf("hdr=%y", hdr));
                    }
                }
            } else {
                lstr += "<bin>";
            }
            log("%s", lstr);
        }

        if (log_recv_body) {
            if (body && (hdr."content-type" == MimeTypeOctetStream || hdr."content-encoding")) {
                log("cid %d: RECV BODY: <%s>", cx.id, body.toHex());
            } else {
                log("cid %d: RECV BODY: %y", cx.id, body);
            }
        }
    }

    hash<auto> getLogOptions() {
        return {
            "recv_headers": log_recv_headers,
            "recv_body": log_recv_body,
            "send_headers": log_send_headers,
            "send_body": log_send_body,
        };
    }

    string getName() {
        return name;
    }

    auto getAddress() {
        return socket;
    }

    int getID() {
        return id;
    }

    bool isSecure() {
        return ssl;
    }

    hash<auto> getInfo() {
        return {
            "name": name,
         } + socket_info + {
            "proto": ssl ? "https" : "http",
            "id": id,
            "bind": socket,
            "get_remote_certs": get_remote_certs,
            "ssl_verify_flags": getSslVerifyModeList(),
            "ssl_accept_all_certs": ssl_accept_all_certs,
         };
    }

    private setupSslIntern() {
        if (!opts.key) {
            throw "HTTP-ADDLISTENER-ERROR", sprintf("SSL certificate given without private key for listener %y",
                name);
        }
        # set SSL cert and key
        setCertificate(opts.cert);
        setPrivateKey(opts.key);
    }

    private softlist<string> getSslVerifyModeList() {
        return (map $1.value, SslVerifyMap.pairIterator(), ssl_verify_flags & $1.key.toInt()) ?* "SSL_VERIFY_NONE";
    }

    auto removeUserThreadContext(*string k) {
        if (!exists k) {
            remove_thread_data("uctx");
            return;
        }
        *hash<auto> h = get_thread_data("uctx");
        auto rv = remove h{k};
        save_thread_data("uctx", h);
        return rv;
    }

    addUserThreadContext(hash<auto> uctx) {
        save_thread_data("uctx", get_thread_data("uctx") + uctx);
    }

    stopNoWait() {
        background stop();
    }

    stop() {
        {
            m.lock();
            on_exit m.unlock();

            if (stopped)
                return;

            if (exit)
                return;

            exit = True;
        }

        # wait for all connection threads to terminate
        cThreads.waitForZero();

        # stop all dedicated socket connections
        {
            *hash<string, AbstractHttpSocketHandlerInterface> shh_copy;
            {
                m.lock();
                on_exit m.unlock();

                shh_copy = remove shh;
            }

            foreach AbstractHttpSocketHandlerInterface handler in (shh_copy.iterator()) {
                try {
                    handler.stop(id);
                } catch (hash<ExceptionInfo> ex) {
                    logError("error stopping handler on listener %d: %s: %s", id, ex.err, ex.desc);
                }
            }
        }

        # wait for all dedicated connection threads to terminate
        dThreads.waitForZero();

        stopped = True;
        log("stopped listener");

        serv.listenerStopped(self);
        if (stopc) {
            serv.callListenerStopCallback(stopc, name, socket_info);
        }
    }

    logResponse(hash<auto> cx, int code, *data body, *hash<auto> hdr) {
        # do log msg
        string lstr = sprintf("cid %d: HTTP/1.1 %d %s", cx.id, code, HttpServer::HttpCodes{code});
        if (cx.handler_name)
            lstr += sprintf(" handler: %y", cx.handler_name);
        if (cx.user)
            lstr += sprintf(" user: %y", cx.user);
        if (body)
            lstr += sprintf(" size: %d", body.size());
        if (hdr."Content-Type")
            lstr += sprintf(" CT: %y", hdr."Content-Type");
        log(lstr);

        if (log_send_headers)
            log("cid %d: SEND HDR: HTTP code %d: %y", cx.id, code, hdr);
        if (log_send_body)
            log("cid %d: SEND BODY: %y", cx.id, body);
    }

    logResponse(hash<auto> cx, int code, InputStream body, *hash<auto> hdr) {
        # do log msg
        string lstr = sprintf("cid %d: HTTP/1.1 %d %s", cx.id, code, HttpServer::HttpCodes{code});
        if (cx.handler_name)
            lstr += sprintf(" handler: %y", cx.handler_name);
        if (cx.user)
            lstr += sprintf(" user: %y", cx.user);
        if (hdr."Content-Type")
            lstr += sprintf(" CT: %y", hdr."Content-Type");
        log(lstr);

        if (log_send_headers)
            log("cid %d: SEND HDR: HTTP code %d: %y", cx.id, code, hdr);
        if (log_send_body)
            log("cid %d: SENT CHUNKED BODY (%s)", cx.id, body.className());
    }

    logResponse(hash<auto> cx, hash<auto> rv) {
        #  "rv" can be a "HttpHandlerResponseInfo", so we can't access "chunked_body" directly
        if (rv.body || !rv.hasKeyValue("chunked_body")) {
            logResponse(cx, rv.code, rv.body, rv.hdr);
        } else {
            logResponse(cx, rv.code, rv.chunked_body, rv.hdr);
        }
    }

    log(string fmt, ...) {
        softlist<auto> args = fmt;
        if (argv)
            args += argv;
        args[0] = sprintf("%y (%s): %s", name, socket_info.desc, args[0]);
        if (logger) {
            args[0] = "HTTP" + (ssl ? "S" : "") + " " + args[0];
            try {
                logger.logArgs(LoggerLevel::INFO, args[0], args[1..]);
            } catch (hash<ExceptionInfo> ex) {
                args[0] = sprintf("cannot write to listener log: %s: %s: msg: %s", ex.err, ex.desc, args[0]);
                serv.logErrorArgs(args);
            }
        } else
            serv.logArgs(args);
    }

    logError(string fmt, ...) {
        softlist<auto> args = fmt;
        if (argv)
            args += argv;
        args[0] = sprintf("%y (%s): %s", name, socket_info.desc, args[0]);
        if (logger) {
            args[0] = "HTTP " + args[0];
            try {
                logger.logArgs(LoggerLevel::ERROR, args[0], args[1..]);
            } catch (hash<ExceptionInfo> ex) {
                args[0] = sprintf("cannot write to listener log: %s: %s: msg: %s", ex.err, ex.desc, args[0]);
                serv.logErrorArgs(args);
            }
        } else
            serv.logErrorArgs(args);
    }

    private mainThread() {
        on_exit cThreads.dec();

        serv.listenerStarted(id, socket_info);
        # DEBUG
        #printf("HTTP DEBUG: %y: mainThread() started TID %d\n", socket, gettid());

        # start listening
        while (!exit) {
            *Socket r;
            try {
                r = accept(PollInterval);
                if (!r) {
                    # allow another thread to grab the socket lock and do something if necessary
                    if (lock_waiting) {
                        thread_yield();
                    }
                    continue;
                }
            } catch (hash<ExceptionInfo> ex) {
                #printf("HTTP DEBUG: %s: %s: %s\n", get_ex_pos(ex), ex.err, ex.desc);
                if (ex.err != "SOCKET-CLOSED")
                    log("error accepting %sconnection: %s: %s", ssl ? "secure " : "", ex.err, ex.desc);
                continue;
            }

            if (exit)
                break;

            # DEBUG
            #printf("HTTP DEBUG: %y: accepting HTTP connection from %s\n", socket_info.address_desc, r.getPeerInfo().address_desc);
            #log("accepting HTTP connection from %s", r.getPeerInfo().address_desc);

            cThreads.inc();
            try {
                # use the thread pool to start the connection
                serv.startConnection(sub () { connectionThread(r); });
            } catch (hash<ExceptionInfo> ex) {
                cThreads.dec();
                string err = sprintf("failed to start connection thread: %s: %s", ex.err, ex.desc);
                serv.sendHttpError(self, {"id": -1, "close": True}, r, 500, err, NOTHING, NOTHING, NOTHING, True);
            }
        }

        #printf("HTTP DEBUG: HttpListener::mainThread() closing socket %s\n", socket_info.address_desc);
        shutdown();
        close();
        #printf("HTTP DEBUG: HttpListener::mainThread() TID %d terminating\n", gettid());
    }

    # thread for handling communication per connection
    private connectionThread(Socket s) {
        bool dedicated;
        bool dedicated_external;
        on_exit {
            if (!dedicated) {
                cThreads.dec();
            } else {
                dThreads.dec();
            }
        }

        if (ssl) {
            try {
                s.upgradeServerToSSL(HttpServer::ReadTimeout);
            } catch (hash<ExceptionInfo> ex) {
                log("error upgrading secure connection to SSL: %s: %s", ex.err, ex.desc);
                return;
            }
        }

        hash<auto> info;
        try {
            info = s.getPeerInfo();
        } catch (hash<ExceptionInfo> ex) {
            log("error getting peer socket info: %s: %s", ex.err, ex.desc);
            return;
        }
        # make 'desc' key for logging
        info.desc = info.address_desc;
        if (info.port)
            info.desc += ":" + info.port;

        # static listener context
        hash<auto> cx_listener = {
            "socket": socket,
            "socket-info": socket_info,
            "peer-info": info,
            "id": ss.next(),
            "ssl": ssl,
            "listener-id": id,
        };

        hash<auto> hdr;
        auto body;

        # set TCP_NODELAY on incoming socket
        #s.setNoDelay(True);

        HttpPersistentHandlerInfo phi();

        # per-request context
        hash<auto> cx;

        try {
            date start;
            bool persistent;
            while (!exit) {
                delete body;
                delete hdr;

                if (!s.isOpen()) {
                    #printf("HTTP DEBUG: T%d cid %d peer closed connection\n", gettid(), cx.id);
                    break;
                }

                if (!start) {
                    start = now_us();
                }
                date poll_interval = HttpServer::PollTimeout;
                if (!persistent && poll_interval > (date ttl = serv.getTtl())) {
                    poll_interval = ttl;
                }
                if (!s.isDataAvailable(poll_interval)) {
                    if (!persistent && ((date delta = now_us() - start) > (date ttl = serv.getTtl()))) {
                        log("Disconnecting idle connection after: %y", ttl);
                        break;
                    }
                    continue;
                }
                remove start;

                cx = cx_listener;

                hash<auto> header_info;
                try {
                    hdr = s.readHTTPHeader(HttpServer::ReadTimeout, \header_info);
                } catch (hash<ExceptionInfo> ex) {
                    # according to RFC 2616 sec 8.1.2.1 (http://tools.ietf.org/html/rfc2616#section-8.1.2), clients
                    # claiming http 1.1 protocol compatibility SHOULD only close the connection after
                    # sending a "connection: close" header, but in
                    # case they don't, we simply close the connection silently
                    if (ex.err == "SOCKET-CLOSED") {
                        #printf("HTTP DEBUG: socket closed id=%d source: %y\n", cx.id, info.address_desc);
                        break;
                    } else if (ex.err == "SOCKET-TIMEOUT") {
                        # log error and close connection on timeout
                        string err = sprintf("timed out reading HTTP header after %d ms", HttpServer::ReadTimeout);
                        string str = sprintf("%s from %s via %s", err, info.address_desc, socket_info.address_desc);
                        logError(str);
                        cx.close = True;
                        serv.sendHttpError(self, cx, s, 400, err, NOTHING, NOTHING, NOTHING, False);
                        break;
                    }
                    string etxt = sprintf("ERROR reading HTTP header: %s: %s", ex.err, ex.desc);
                    #if (ex.arg)
                    #    etxt += printf(" (%s)", ex.arg);
                    string str = sprintf("%s: received from %s via %s", etxt, info.address_desc,
                        socket_info.address_desc);
                    logError(str);
                    cx.close = True;
                    serv.sendHttpError(self, cx, s, 400, etxt, NOTHING, NOTHING, NOTHING, False);
                    break;
                }

                if (log_recv_headers)
                    log("RECV HEADER: %y", hdr);

                # DEBUG:
                #printf("HTTP DEBUG: id: %d, hdr: %y, header_info: %y\n", cx.id, hdr, header_info);

                # process ascii encodings in url if present
                cx.raw_path = hdr.path;
                hdr.path = decode_url(hdr.path);
                cx += {
                    "orig_path": hdr.path,
                    "masked_path": serv.maskData(hdr.path),
                };

                # remove leading / if present in path
                if (hdr.path =~ /^\//)
                    splice hdr.path, 0, 1;

                if (hdr.authorization)
                    cx.auth = hdr.authorization;

                # save original content-type
                if (hdr."content-type") {
                    hdr."_qore_orig_content_type" = hdr."content-type";
                }
                hdr."content-type" = header_info."body-content-type";
                if (hdr."content-type".typeCode() == NT_LIST) {
                    hdr."content-type" = hdr."content-type"[0];
                }

                # copy headers to the context var
                cx.hdr = hdr;

                # the Socket's encoding is set in Socket::readHTTPHeader() according to any charset declaration in the
                # Content-Type
                cx.char_encoding = s.getEncoding();
                cx."response-encoding" = header_info."accept-charset";

                # check if we need to close the connection
                # RFC 2068 19.7.1: Persistent connections in HTTP/1.0 must be explicitly negotiated as they are not
                # the default behavior
                # RFC 1945 1.3: Except for experimental applications, current practice requires that the connection be
                # established by the client prior to each request and closed by the server after sending the response.
                # so we MUST close the connection when a request is received by an HTTP 1.0 client without an explicit
                # request to keep the connection open: the above rules are followed by Socket::readHTTPHeader()
                cx.close = header_info.close;

                {
                    # attempt to mask sensitive data in the URI path
                    string lstr = sprintf("cid %d src %y: %s %s HTTP/%s (agent: %y", cx.id,
                        cx."peer-info".address_desc, hdr.method, cx.masked_path, hdr.http_version, hdr."user-agent");
                    if (hdr."transfer-encoding" == "chunked")
                        lstr += " body: chunked";
                    if (hdr."_qore_orig_content_type")
                        lstr += sprintf(" Content-Type: %y", hdr."_qore_orig_content_type");
                    if (ssl)
                        lstr += sprintf(" %s %s", s.getSSLCipherName(), s.getSSLCipherVersion());
                    lstr += ")";
                    log(lstr);
                }

                cx.uctx = get_thread_data("uctx");
                cx."header-info" = header_info;

                # add client certificate if requested and available
                if (get_remote_certs) {
                    cx."client-cert" = s.getRemoteCertificate();
                }

                serv.handleRequest(self, s, \cx, hdr, hdr.method == "HEAD", phi, info, \dedicated,
                    \dedicated_external);

                #log("DBG cid %d: cx.close: %y", cx.id, cx.close);

                if (cx.close) {
                    break;
                } else if (!persistent && cx.persistent) {
                    log("cid %d: set persistent connection; ignoring idle disconnect", cx.id);
                    persistent = True;
                } else if (persistent && !cx.persistent) {
                    log("cid %d: removed persistent connection; resuming idle disconnect", cx.id);
                    remove persistent;
                }
            }
        } catch (hash<ExceptionInfo> ex) {
            string etxt = serv.getDebug()
                ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                : get_exception_string(ex);
            string str = sprintf("%s: received from %s via %s", etxt, info.address_desc, socket_info.address_desc);
            logError(str);
            logError(sprintf("hdr=%y", hdr));
            cx.close = True;
            serv.sendHttpError(self, cx, s, 500, etxt, NOTHING, NOTHING, cx."response-encoding", False);
        }

        #log("cid %d: closing connection (status: %s)", cx.id, s.isOpen() ? "open" : "closed");
        if (!dedicated_external) {
            s.shutdown();
            s.close();
        }
    }

    bool registerDedicatedSocket(softstring id, HttpServer::AbstractHttpSocketHandlerInterface h,
            reference<bool> dedicated) {
        m.lock();
        on_exit m.unlock();

        if (exit) {
            return False;
        }

        # handover counter value and set dedicated flag
        dThreads.inc();
        cThreads.dec();
        dedicated = True;

        # save handler
        shh{id} = h;

        return True;
    }

    removeExternalDedicatedSocket(softstring id) {
        removeDedicatedSocket(id, True);
    }

    removeDedicatedSocket(softstring id, *bool managed_externally) {
        m.lock();
        on_exit m.unlock();

        remove shh{id};
    }
}
}

#! Private namespace
namespace Priv {
# class containing handler info
class HandlerInfo {
    public {
        string name;
        HttpServer::AbstractHttpRequestHandler obj;
        string path;
        bool isregex;
        # content type map
        *hash<string, bool> content_type_map;
        *list<string> special_header_list;
    }

    #! Creates the object from the parameters
    /** @throw HANDLER-ERROR the handler is missing from the \a info argument
    */
    constructor(string name, hash<HttpHandlerConfigInfo> info) {
        self.name = name;
        if (!info.handler) {
            throw "HANDLER-ERROR", sprintf("missing \"handler\" from handler config: %y", info);
        }
        obj = info.handler;
        path = info.path;
        isregex = info.isregex;
        content_type_map = map {$1: True}, info.content_types;
        special_header_list = map $1.lwr(), info.headers;
    }

    bool matchContentType(string ct) {
        return content_type_map{ct} ? True : False;
    }

    #! called when matching a request; returns a code giving the match level; 0 = no match, 1 = only the Content-Type matches, 2 = special header matches, 3 = URL matches
    int matchRequest(hash<auto> hdr, int score) {
        if (path && hdr.path && isregex && regex(hdr.path, path)) {
            return 3;
        }
        # the case where isregex is False was already handled by HttpHandlerList::findHandler using TreeMap
        # we get here only if the path does not match

        if (score >= 2) {
            return 0;
        }

        if (hdr{special_header_list}) {
            return 2;
        }

        if (score || !content_type_map) {
            return 0;
        }

        return content_type_map.(hdr."content-type") ? 1 : 0;
    }

    stop() {
        # stop handler if it is a dedicated socket handler
        if (obj instanceof HttpServer::AbstractHttpSocketHandlerInterface) {
            cast<HttpServer::AbstractHttpSocketHandlerInterface>(obj).stop();
        }
    }
}

# class to implement handler-handling (private)
class HttpHandlerList {
    public {
        hash<string, HandlerInfo> handlers;
        TreeMap treeMap();
    }

    /*
    private static checkSpecialHeaders(reference sh) {
        foreach auto h in (\sh) {
            if (h.typeCode() != NT_STRING)
                throw "SETHANDLER-ERROR", sprintf("entry %d in the special header list is not a string; type: %s", $#, h.type());
            # make sure header is in lower case for matching
            h = tolower(h);
        }
    }
    */

    #! sets a request handler according to the arguments given
    setHandler(string name, hash<HttpHandlerConfigInfo> info) {
        if (handlers{name}) {
            throw "SETHANDLER-ERROR", sprintf("HTTP request handler %y already exists", name);
        }
        # paths are passed without the leading "/", so they have to be like this in the treemap
        if (info.path =~ /^\//) {
            info.path = info.path.substr(1);
        }
        # for backwards-compatibility, isregex = True if not set
        if (!exists info.isregex) {
            info.isregex = True;
        }

        HandlerInfo handlerInfo(name, info);
        handlers{name} = handlerInfo;

        if (!info.isregex && info.path) {
            treeMap.put(info.path, handlerInfo);
        }
    }

    #! remove handler from the list by its name
    /**
        @throw INVALID-HANDLER-ERROR invalid handler name passed
    */
    removeHandler(string handler_name) {
        if (!handlers.hasKey(handler_name)) {
            throw "INVALID-HANDLER-ERROR", sprintf("handler with name %y is not present", handler_name);
        }

        HandlerInfo hi = handlers{handler_name};
        treeMap.take(hi.path);
        remove handlers{handler_name};
        hi.stop();
    }

    #! remove handler from the list
    /**
        @throw INVALID-HANDLER-ERROR invalid handler passed
    */
    removeHandler(HttpServer::AbstractHttpRequestHandler handler) {
        *string name;
        foreach hash<auto> h in (handlers.pairIterator()) {
            if (h.value.obj == handler) {
                name = h.key;
                break;
            }
        }
        if (name == NOTHING) {
            throw "INVALID-HANDLER-ERROR", "handler not present";
        }

        HandlerInfo hi = handlers{name};
        treeMap.take(hi.path);
        remove handlers{name};
        hi.stop();
    }

    # matches a handler to the request
    *HandlerInfo findHandler(hash<auto> hdr, reference<int> score, bool finalv = False, *reference<string> root_path) {
        if (!handlers)
            return;

        # if there is only one handler and final is true, then return the only handler
        if (finalv && handlers.size() == 1)
            return handlers.firstValue();

        *HandlerInfo handlerInfo = treeMap.get(hdr.path);
        if (handlerInfo) {
            # must set score to 3 to stop searching; a path match trumps all other matches
            score = 3;
            root_path = handlerInfo.path;
            return handlerInfo;
        }

        # find a handler for the request
        HandlerInfo rv;

        foreach HandlerInfo hi in (handlers.iterator()) {
            int scr = hi.matchRequest(hdr, score);
            #printf("findHandler() path: %s ct: %y %y score: %d (regex: %y)\n", hdr.path, hdr."content-type", hi.name, scr, hi.isregex);
            if (scr > score) {
                rv = hi;
                score = scr;
                if (scr == 3)
                    break;
            }
        }
        return rv;
    }

    bool empty() {
        return handlers.empty();
    }

    int size() {
        return handlers.size();
    }
}

# class containing dynamic handler info
class DynamicHandlerInfo inherits HandlerInfo {
    public {
        Counter counter();
    }

    constructor(string name, hash<HttpHandlerConfigInfo> info) : HandlerInfo(name, info) {
    }
}

# maintains the request count for dynamic handlers (private)
class DynamicHandlerHelper {
    public {}

    private {
        Counter c;
    }

    constructor(Counter n_c) {
        c = n_c;
        c.inc();
    }

    destructor() {
        c.dec();
    }
}

# for dynamic handler-handling (private)
class DynamicHttpHandlerList inherits HttpHandlerList {
    private {
        RWLock dhl();

        # issue #4173: allow dynamic handlers to be disabled before being removed
        hash<string, bool> disable_map;
    }

    #! sets a dynamic request handler according to the arguments given
    setHandler(string name, hash<HttpHandlerConfigInfo> info) {
        # paths are passed without the leading "/", so they have to be like this in the treemap
        if (info.path =~ /^\//) {
            info.path = info.path.substr(1);
        }
        # for backwards-compatibility, isregex = True if not set
        if (!exists info.isregex) {
            info.isregex = True;
        }

        DynamicHandlerInfo dhi(name, info);

        {
            dhl.writeLock();
            on_exit dhl.writeUnlock();

            if (handlers{name}) {
                throw "SETHANDLER-ERROR", sprintf("dynamic HTTP request handler %y already exists (dynamic handlers: %y)", name, keys handlers);
            }

            handlers{name} = dhi;
        }

        if (!info.isregex && info.path) {
            treeMap.put(info.path, dhi);
        }
    }

    #! remove dynamic handler
    /** @throw REMOVEHANDLER-ERROR if the given dynamic handler does not exist
    */
    removeHandler(string name, *bool force_immediate) {
        Counter c;
        {
            # grab exclusive lock
            dhl.writeLock();
            on_exit dhl.writeUnlock();

            # if no such handler exists, throw an exception
            if (!handlers{name}) {
                throw "REMOVEHANDLER-ERROR", sprintf("dynamic request handler %y does not exist", name);
            }

            # remove the handler from the list
            DynamicHandlerInfo dhi = remove handlers{name};

            # remove handler from treemap if applicable
            if (!dhi.isregex && exists dhi.path)
                treeMap.take(dhi.path);

            # take a copy of a reference to the Counter
            c = dhi.counter;

            # stop handler if it is a dedicated socket handler
            dhi.stop();

            # issue #4173: remove disabled entry, if any
            remove disable_map{name};
        }

        # wait for the call counter to reach zero
        if (!force_immediate) {
            c.waitForZero();
        }
    }

    #! Disable dynamic handler
    /** @throw DISABLEHANDLER-ERROR if the given dynamic handler does not exist
    */
    disableHandler(string name) {
        # grab exclusive lock
        dhl.writeLock();
        on_exit dhl.writeUnlock();

        # if no such handler exists, throw an exception
        if (!handlers{name}) {
            throw "DISABLEHANDLER-ERROR", sprintf("dynamic request handler %y does not exist", name);
        }

        disable_map{name} = True;
    }

    *DynamicHandlerInfo findHandler(hash<auto> hdr, reference<int> score, reference<DynamicHandlerHelper> dhh, *reference<string> root_path) {
        dhl.readLock();
        on_exit dhl.readUnlock();

        *DynamicHandlerInfo h = HttpHandlerList::findHandler(hdr, \score, False, \root_path);
        if (!h || disable_map{h.name}) {
            return;
        }

        dhh = new DynamicHandlerHelper(h.counter);
        return h;
    }
}

class HttpServerCallbackAppender inherits LoggerAppenderWithLayout {
    private {
        code logfunc;
    }

    constructor(code logfunc) : LoggerAppenderWithLayout("HttpServer", new LoggerLayoutPattern("%d T%t [%p]: %m")) {
        self.logfunc = logfunc;
        open();
    }

    processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_LOG:
                call_function(logfunc, params);
                break;
        }
    }
}
}
