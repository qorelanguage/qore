# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file SqlUtil.qm Qore user module for working with SQL data

/*  SqlUtil.qm Copyright (C) 2013 - 2019 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.9

# requires the Util module
%requires Util >= 1.0

# requires the DataProvider module
%requires(reexport) DataProvider >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module SqlUtil {
    version = "1.6";
    desc = "user module for working with SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

# version history is included below in the docs

/** @mainpage SqlUtil Module

    @tableofcontents

    @section sqlutilintro Introduction to the SqlUtil Module

    The %SqlUtil module provides a high level database-independent API for working with database objects and SQL.

    To use this module, use \c "%requires SqlUtil" in your code.

    All the public symbols in the module are defined in the SqlUtil namespace

    Major sections of this documentation:
    - @subpage sql_operations "SQL Operations": working with database data (finding, updating, inserting, deleting, merging data, etc)
    - @subpage schema_management "Schema Management": working schema definitions (creating, modifying, aligning tables, functions, types, triggers, etc)
    - @subpage dba_management "DBA Management": special database administrator tools

    The %SqlUtil module provides generic functionality and a framework for SQL operations and schema management, and in order
    to use the %SqlUtil module with a particular database, a driver-specific module has to be available as well.

    Currently the following driver-specific modules are available:
    - <a href="../../FreetdsSqlUtil/html/index.html">FreetdsSqlUtil</a>: for working with MS SQL Server and Sybase databases through the <a href="https://github.com/qorelanguage/module-sybase">freetds DBI driver</a>
    - <a href="../../MysqlSqlUtil/html/index.html">MysqlSqlUtil</a>: for working with MySQL databases
    - <a href="../../OracleSqlUtil/html/index.html">OracleSqlUtil</a>: for working with Oracle databases
    - <a href="../../PgsqlSqlUtil/html/index.html">PgsqlSqlUtil</a>: for working with PostgreSQL databases

    The underlying driver-specific module is automatically loaded and used when required; the classes provided in
    the %SqlUtil module provide a generic API that uses the driver-specific implementations for the underlying driver-specific
    implementation.

    @section sqlutil_overview Overview of Functionality

    SqlUtil provides API support for the following:
    - @ref sql_operations
      - @ref retrieving_data
      - @ref inserting_data
      - @ref updating_data
      - @ref deleting_data
      - @ref sql_upsert
    - @ref schema_management
      - @ref creating_new_objects
      - @ref retrieving_objects
      - @ref listing_objects
      - @ref interdependent_tables
      - @ref aligning_schemas
      - @ref table_management
    - @ref dba_management
      - @ref dba_indexes
      - @ref dba_statistics
      - @ref dba_space_management

    @section sqlutil_relnotes Release Notes for the SqlUtil Module

    @subsection sqlutilv1_6 SqlUtil v1.6
    - added support for the DataProvider module
      (<a href="https://github.com/qorelanguage/qore/issues/3545">issue 3545</a>)

    @subsection sqlutilv1_5_2 SqlUtil v1.5.2
    - implemented the @ref SqlUtil::AbstractDatabase::getPhysicalSize() functionality
      (<a href="https://github.com/qorelanguage/qore/issues/3385">issue 3385</a>)

    @subsection sqlutilv1_5_1 SqlUtil v1.5.1
    - fixed a bug that could lead to a deadlock when DML methods on the
      @ref SqlUtil::AbstractTable "AbstractTable" class are used with a datasource pool with connection contention
      (<a href="https://github.com/qorelanguage/qore/issues/3352">issue 3352</a>)

    @subsection sqlutilv1_5 SqlUtil v1.5
    - implemented the @ref SqlUtil::AbstractTable::getStatementNoExec() "AbstractTable::getStatementNoExec()" method (<a href="https://github.com/qorelanguage/qore/issues/2773">issue 2773</a>)
    - added support for serializing and deserializing @ref SqlUtil::AbstractTable "AbstractTable" objects (<a href="https://github.com/qorelanguage/qore/issues/2663">issue 2663</a>)
    - updated the module to use the @ref Qore::SQL::AbstractSQLStatement "AbstractSQLStatement" class instead of the @ref Qore::SQL::SQLStatement "SQLStatement" (<a href="https://github.com/qorelanguage/qore/issues/2326">issue 2326</a>)
    - deprecated @ref SqlUtil::AbstractTable::getRowIterator() "AbstractTable::getRowIterator()" for @ref SqlUtil::AbstractTable::getStatement() "AbstractTable::getStatement()" (<a href="https://github.com/qorelanguage/qore/issues/2326">issue 2326</a>)

    @subsection sqlutilv1_4_4 SqlUtil v1.4.4
    - implemented the @ref SqlUtil::AbstractTable::getRowIteratorNoExec() "AbstractTable::getRowIteratorNoExec()" method (<a href="https://github.com/qorelanguage/qore/issues/2773">issue 2773</a>)

    @subsection sqlutilv1_4_3 SqlUtil v1.4.3
    - implemented support for an optional error-handling method in SQL callbacks to allow SqlUtil to recover from error scenarios in schema creation/alignment (<a href="https://github.com/qorelanguage/qore/issues/2643">issue 2643</a>)

    @subsection sqlutilv1_4_2 SqlUtil v1.4.2
    - implemented support for literal values in column operators taking column arguments with @ref SqlUtil::cop_value() "cop_value()" (<a href="https://github.com/qorelanguage/qore/issues/2555">issue 2555</a>)

    @subsection sqlutilv1_4_1 SqlUtil v1.4.1
    - implemented support for user custom column operators (<a href="https://github.com/qorelanguage/qore/issues/2314">issue 2314</a>)

    @subsection sqlutilv1_4 SqlUtil v1.4
    - fixed a bug in update and upsert statement generation when the given data does not have enough columns to use the unique index found, an error message is generated that contains all the columns names instead of just the column names required by the index (<a href="https://github.com/qorelanguage/qore/issues/1013">issue 1013</a>)
    - implemented @ref cop_trunc_date() operator (<a href="https://github.com/qorelanguage/qore/issues/2032">issue 2032</a>)
    - updated to support complex types (<a href="https://github.com/qorelanguage/qore/issues/1724">issue 1724</a>)
    - implemented analytic/window functions: new functions [<a href="https://github.com/qorelanguage/qore/issues/2203">issue 2202</a>]
    - implemented analytic/window functions: cop_over full support including ORDER BY [<a href="https://github.com/qorelanguage/qore/issues/2203">issue 2203</a>]

    @subsection sqlutilv1_3_4 SqlUtil v1.3.4
    - fixed a bug in with column aliases that are reserved words (<a href="https://github.com/qorelanguage/qore/issues/2163">issue 2163</a>)

    @subsection sqlutilv1_3_3 SqlUtil v1.3.3
    - fixed a bug in the \c offset query hash argument in SQL operation methods (<a href="https://github.com/qorelanguage/qore/issues/1880">issue 1880</a>)
    - implemented the @ref select_option_alias "alias" select option to fix a bug that prohibited only columns from the main query to be selected when joins are used (<a href="https://github.com/qorelanguage/qore/issues/1909">issue 1909</a>)

    @subsection sqlutilv1_3_2 SqlUtil v1.3.2
    - fixed schema alignment skips column with name "driver" (<a href="https://github.com/qorelanguage/qore/issues/1684">issue 1684</a>)
    - fixed sqlutil schema management: functional indexes are rejected without () in name (<a href="https://github.com/qorelanguage/qore/issues/1610">issue 1610</a>)

    @subsection sqlutilv1_3_1 SqlUtil v1.3.1
    - implemented the \a force option (i.e. cascade) for dropping code objects (<a href="https://github.com/qorelanguage/qore/issues/1314">issue 1314</a>)
    - fixed the ignored character_semantics column option in schema alignmed (<a href="https://github.com/qorelanguage/qore/issues/1379">issue 1379</a>)
    - implemented the @ref SqlUtil::cop_length() column function (<a href="https://github.com/qorelanguage/qore/issues/1395">issue 1395</a>)

    @subsection sqlutilv1_3 SqlUtil v1.3
    - implemented insert option support (see @ref SqlUtil::AbstractTable::InsertOptions "AbstractTable::InsertOptions") with the \c "returning" clause in supported drivers
    - implemented support for late table resolution in joins to support executing SQL from serialized parameters
    - improved error messages for common errors such as join errors
    - implemented support for DBA actions (see @ref dba_management)
    - implemented support for driver-dependent pseudocolumns
    - implemented per-column support for the \c "desc" keyword in orderby expressions
    - implemented support for \c "or" logic in @ref where_clauses
    - implemented AbstractTable::getBulkUpsertClosure() to better support bulk SQL merge operations
    - implemented @ref SqlUtil::wop_or() to allow for generating complex SQL strings with \a "or" and \a "and" expressions
    - implemented the @ref SqlUtil::cop_cast() operator for converting [column] value into another datatype
    - implemented the @ref SqlUtil::cop_sum() aggregate operator for returning sum of column values
    - implemented update operators @ref SqlUtil::uop_plus(), @ref SqlUtil::uop_minus(), @ref SqlUtil::uop_multiply(), @ref SqlUtil::uop_divide()
    - implemented support for numeric column arguments for the @ref select_option_orderby "orderby" and @ref select_option_groupby "groupby" options
    - implemented the @ref SqlUtil::cop_coalesce() column operator functions for the \c "COALESCE" operator returning the first non-NULL value in a list of columns (<a href="https://github.com/qorelanguage/qore/issues/671">issue 671</a>)
    - column aliases (defined with @ref SqlUtil::cop_as()) can now be used in the @ref where_clauses "where hash argument" and in join criteria
    - removed all APIs that handle implicit transactions; APIs must commit transactions explicitly (<a href="https://github.com/qorelanguage/qore/issues/533">issue 533</a>)
    - @ref sql_cop_funcs "column operator functions" can be used in @ref where_clauses "where hashes" (<a href="https://github.com/qorelanguage/qore/issues/529">issue 529</a>)
    - implemented @ref SqlUtil::AbstractTable::bindEmptyStringsAsNull() (<a href="https://github.com/qorelanguage/qore/issues/776">issue 776</a>)
    - implemented the \c "omit_update" @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" for asymmetrical upserts (updates only update a subset of the columns inserted) (<a href="https://github.com/qorelanguage/qore/issues/791">issue 791</a>)
    - implemented the @ref SqlUtil::AbstractTable::UpsertUpdateOnly upsert option (<a href="https://github.com/qorelanguage/qore/issues/793">issue 793</a>)
    - implemented @ref SqlUtil::cop_substr() and @ref SqlUtil::uop_substr() operators (<a href="https://github.com/qorelanguage/qore/issues/801">issue 801</a>)
    - implemented @ref SqlUtil::op_substr() where operator (<a href="https://github.com/qorelanguage/qore/issues/883">issue 883</a>)
    - fixed a bug with queries using a \a desc argument with the @ref select_option_orderby "orderby" query option with multiple sort columns; the \c "desc" string was added only to the last column but should have been added to all columns
    - fixed a bug where foreign key constraints with supporting indexes were not tracked and therefore schema alignment on DBs that automatically create indexes for foreign key constraints would fail
    - fixed a bug where driver-specific objects were not included when dropping a schema
    - fixed a bug in subquery handling where bind-by-value arguments from the subquery were lost
    - fixed a bug in the partition by/over operator where column names as given in the query argument hash were not properly recognized
    - fixed a bug in schema alignment; when aligning a schema and an index supporting a PK constraint is introduced in the new schema, the alignment would fail when a constraint is attempted to be disabled that doesn't exist
    - fixed a bug generating select statements for tables accessed through a synonym when used with join clauses; previously inconsistent schema prefixes could be used which could cause errors parsing the SQL statements generated
    - fixed a bug where the @ref SqlUtil::AbstractTable "AbstractTable" lock was held while executing SQL to determine the upsert strategy to use with @ref SqlUtil::AbstractTable::UpsertAuto "UpsertAuto" (<a href="https://github.com/qorelanguage/qore/issues/408">issue 409</a>)
    - fixed a bug where complex bind values as hashes (such as used by the pgsql and oracle drivers) were rejected by SqlUtil (<a href="https://github.com/qorelanguage/qore/issues/494">issue 494</a>) when updating
    - fixed a bug where wildcard columns in join tables were not working (<a href="https://github.com/qorelanguage/qore/issues/499">issue 499</a>)
    - fixed a bug in @ref SqlUtil::op_in() where invalid SQL was generated with an argument of 0 (<a href="https://github.com/qorelanguage/qore/issues/500">issue 500</a>)
    - fixed a bug in @ref SqlUtil::cop_value() where an exception was thrown with an argument of 0 (<a href="https://github.com/qorelanguage/qore/issues/511">issue 511</a>)
    - fixed @ref SqlUtil::cop_count() operator to allow other operators as its argument (<a href="https://github.com/qorelanguage/qore/issues/517">issue 517</a>)
    - fixed bugs in @ref SqlUtil::cop_seq() and @ref SqlUtil::cop_seq_currval() (<a href="https://github.com/qorelanguage/qore/issues/624">issue 624</a>)
    - fixed a bug in @ref SqlUtil::join_inner() where the \a cond argument was ignored (<a href="https://github.com/qorelanguage/qore/issues/645">issue 645</a>)
    - fixed @ref SqlUtil::uop_lower() and @ref SqlUtil::uop_upper() operators to allow nesting (<a href="https://github.com/qorelanguage/qore/issues/657">issue 657</a>)
    - fixed a bug where SqlUtil was generating invalid SQL for some DBs where a wilcard was used with explicit column names (<a href="https://github.com/qorelanguage/qore/issues/708">issue 708</a>)
    - fixed a bug where updating an index without any source constraints caused an invalid exception to be raised (<a href="https://github.com/qorelanguage/qore/issues/768">issue 768</a>)
    - fixed a bug in @ref SqlUtil::AbstractTable::update() "AbstractTable::update()" with sequence operators (<a href="https://github.com/qorelanguage/qore/issues/942">issue 942</a>)

    @subsection sqlutilv1_2 SqlUtil v1.2
    - added insert operator support; for example, for inserting with values from sequences
    - added new upsert constant maps: @ref SqlUtil::AbstractTable::UpsertStrategyMap "UpsertStrategyMap" and @ref SqlUtil::AbstractTable::UpsertStrategyDescriptionMap "UpsertStrategyDescriptionMap"
    - added static SqlUtil::AbstractSqlUtilBase::getDatasourceDesc() method
    - added new AbstractTable::insertFromSelect*() variants taking Table arguments
    - added SqlUtil::AbstractTable::checkExistence() method
    - added support for the \c forupdate @ref select_option_hash "select option"
    - fixed a bug in schema management where excessively verbose column aliases were used that caused errors when automatically updating columns with existing rows and new default values and non-null contraints with PostgreSQL databases
    - fixed a bug where select and row iterator operations could fail with certain select hash arguments without a \c "columns" entry but where column names were otherwise required

    @subsection sqlutilv1_1 SqlUtil v1.1
    - implemented new upsert strategy @ref SqlUtil::AbstractTable::UpsertInsertOnly
    - adding a default value to a column with a not null constraint and existing data populates existing null columns with the new default value automatically in schema alignment
    - fixed an infinitely recursive call in SqlUtil::AbstractTable::del()
    - fixed bugs generating "create table" and "align table" SQL with DBs where unique indexes automatically create unique constraints (ex: MySQL)

    @subsection sqlutilv1_0 SqlUtil v1.0
    - initial release of the SqlUtil modules for schema management and SQL operations
*/
/** @page sql_operations SQL Operations

    @tableofcontents

    @section sql_operations_intro Introduction to SQL Operations

    The @ref SqlUtil::AbstractTable "AbstractTable" class provides methods for SQL operations. Instances of this class are returned from most of the API calls working with tables. You need to use a helper class @ref SqlUtil::Table "Table" if you need to create table object in your own.

    @ref SqlUtil::AbstractTable "AbstractTable" uses knowledge about the internal structure of database tables to create and execute SQL on the database.

    SQL strings are constructed programmatically for the following reasons:
    - to present an abstract, database-independent interface to the programmer
    - to allow for database-specific optimizations to be used without requiring programming expertise for the specific database being used
    - to minimize dynamic SQL and therefore use the database server's SQL statement cache more efficiently (if applicable)
    - to prevent SQL injection attacks

    Also for the above reasons, values are bound by value in all possible cases rather than inserted into SQL strings directly.

    @section retrieving_data Retrieving Data from the Database

    There are many methods in the @ref SqlUtil::AbstractTable "AbstractTable" class for retrieving data from the database; here is an overview:
    - @ref SqlUtil::AbstractTable::find(auto): finds a row corresponding to the given single value of the primary key; if not present @ref nothing is returned
    - @ref SqlUtil::AbstractTable::find(list): finds all rows corresponding to the given list of values of the primary key; if none are present @ref nothing is returned
    - @ref SqlUtil::AbstractTable::find(hash): find a row corresponding to the given hash of column name/value pairs, which must at least reference all columns of the table's primary key; if no row matches, @ref nothing is returned
    - @ref SqlUtil::AbstractTable::findSingle(): finds the first (of possibly many) rows that match the @ref where_clauses "where clause hash argument" or returns @ref nothing if no row matches
    - @ref SqlUtil::AbstractTable::findAll(): returns all rows that match the @ref where_clauses "where clause hash argument" or returns @ref nothing if no row matches
    - @ref SqlUtil::AbstractTable::getStatement(): returns an @ref Qore::SQL::AbstractSQLStatement "AbstractSQLStatement" object iterating rows that match the @ref select_option_hash "select option hash" argument
    - @ref SqlUtil::AbstractTable::getSelectSql(): returns an SQL string and bind arguments for the @ref select_option_hash "select option hash" argument
    - @ref SqlUtil::AbstractTable::select(): returns a hash keyed by column name of lists (row values) corresponding to the @ref select_option_hash "select option hash" argument
    - @ref SqlUtil::AbstractTable::selectRow(): return a hash repersenting a single row corresponding to the @ref select_option_hash "select option hash" argument; if the query returns more than one row an exception will be raised
    - @ref SqlUtil::AbstractTable::selectRows(): returns lists of row values corresponding to the @ref select_option_hash "select option hash" argument

    @subsection find_single_row Retrieving a Single Row

    @par From the Primary Key
    To retrieve a single row based on a single primary key value, use @ref SqlUtil::AbstractTable::find(auto):
    @code{.py}
*hash<auto> row = table.find(id);
    @endcode
    If no primary key value matches the given argument, then @ref nothing is returned. A %Qore SQL statement like the following is generated from the above:
    @code{.py}
*hash<auto> row = ds.selectRow("select * from schema.table where id = %v", id);
    @endcode
    \n
    To retrieve a single row based on a complex primary key value, or a single primary key value and extra criteria, use @ref SqlUtil::AbstractTable::find(hash):
    @code{.py}
*hash<auto> row = table.find(("account_type": type, "name": name));
    @endcode
    If no row value matches the given argument hash, then @ref nothing is returned. A %Qore SQL statement like the following is generated from the above:
    @code{.py}
*hash<auto> row = ds.selectRow("select * from schema.table where account_type = %v and name = %v", type, name);
    @endcode

    @par At Most One Matching Row From the Table
    To retrieve at most one matching row from the table, use @ref SqlUtil::AbstractTable::findSingle():
    @code{.py}
*hash<auto> row = table.findSingle(("permission_type": op_between("US", "UX")));
    @endcode
    This method can be used to efficiently check the table if at least one record matches the given \c where criteria; even if more rows match,
    only a single row is returned.  If no rows match, then @ref nothing is returned. A %Qore SQL statement like the following is generated from the above:
    @code{.py}
*hash<auto> row = ds.selectRow("select * from schema.table where permission_type between %v and %v limit %v", "US", "UX", 1);
    @endcode

    @note handling the \c "limit" option depends on the underlying database; see @ref sql_paging for more information

    @subsection find_multiple_rows Retrieving Multiple Rows

    @par From the Primary Key
    To retrieve multiple rows from a list of single primary key values, use @ref SqlUtil::AbstractTable::find(list)
    @code{.py}
*list rows = table.find(list);
    @endcode
    All rows matching the single primary key values in the argument list are returned; if no rows match, @ref nothing is returned.

    @par From Simple Where Criteria
    To find all rows matching simple where criteria, use @ref SqlUtil::AbstractTable::findAll():
    @code{.py}
*list rows = table.findAll(("id": op_gt(100), "created": op_gt(2013-03-01)));
    @endcode
    See @ref where_clauses for a description of the hash argument; if no rows match, @ref nothing is returned.

    @par From Complex Select Criteria
    To select a hash keyed by column name of lists (row values) based on complex select criteria, use @ref SqlUtil::AbstractTable::select():
    @code{.py}
hash<auto> sh = (
    "columns": ("id", "name", "q.*"),
    "where": ("type": "user"),
    "limit": 100,
    "offset": 200,
    "join": join_inner(queues, "q"),
);
*hash h = table.select(sh);
    @endcode
    See @ref select_option_hash for a description of the hash argument; if no rows match, then a hash with column
    names assigned to empty lists is returned.\n\n
    To select a list of row hashes based on complex select criteria, use @ref SqlUtil::AbstractTable::selectRows():
    @code{.py}
*list rows = table.selectRows(sh);
    @endcode
    If no rows match, then @ref nothing is returned.

    @subsection get_row_iterator Acquiring a Row Iterator for Query Results
    @par From Complex Select Criteria
    To get an iterator for the row values corresponding to a select statement, use @ref SqlUtil::AbstractTable::getStatement():
    @code{.py}
Table t(ds, "table_name");
AbstractSQLStatement i = table.getStatement(sh);
on_exit table.commit();
map printf("row: %y\n", $1), i;
    @endcode
    See @ref select_option_hash for a description of the hash argument; if no argument is passed to the method,
    then an iterator for all rows in the table is returned.

    @subsection get_rows_in_batches Retrieving Multiple Rows in Batches
    @par From Complex Select Criteria
    Multiple rows can be retrieved from a single call to an @ref Qore::SQL::AbstractSQLStatement object as returned by @ref SqlUtil::AbstractTable::getStatement():
    @code{.py}
Table t(ds, "table_name");
AbstractSQLStatement i = table.getStatement(sh);
on_exit table.commit();
while (True) {
    list l = i.fetchRows(1000);
    if (!l)
        break;
    printf("rows read: %d\n", l.size());
}
    @endcode
    See @ref select_option_hash for a description of the hash argument; if no argument is passed to the method,
    then an iterator for all rows in the table is returned.

    @subsection column_spec Specifying Columns in Query Output
    @par From Complex Select Criteria
    @ref SqlUtil::AbstractTable "AbstractTable" methods taking a @ref select_option_hash "select option hash argument" support specifying output columns including column operators by assigning a column / column operator list to the @ref select_option_columns "columns" key.
    @code{.py}
*list rows = table.selectRows(("columns": ("id", "name", "started", cop_as("warnings", "warning_count"), cop_as("errors", "error_count")), "where": ("type": "user")));
    @endcode
    @see @ref select_option_columns "select option columns" for details about the \c "columns" option of the @ref select_option_hash "select option hash"

    @subsection select_option_hash Complex Select Criteria

    Selecting data is performed by passing a select option hash argument to a suitable method that will build and execute a DB-specific SQL command based on this value; the following methods take a select option hash argument:
    - @ref SqlUtil::AbstractTable::getStatement()
    - @ref SqlUtil::AbstractTable::getSelectSql()
    - @ref SqlUtil::AbstractTable::insertFromSelect()
    - @ref SqlUtil::AbstractTable::insertFromSelectCommit()
    - @ref SqlUtil::AbstractTable::select()
    - @ref SqlUtil::AbstractTable::selectRow()
    - @ref SqlUtil::AbstractTable::selectRows()
    - @ref SqlUtil::AbstractTable::upsertFromSelect()
    - @ref SqlUtil::AbstractTable::upsertFromSelectCommit()

    SQL strings for select statements are constructed programmatically based on a select option hash<auto> described below.

    @par Select Option Hash Example:
    @code{.py}
hash soh = (
    "columns": ("id", "name", "q.*"),
    "where": ("type": "user"),
    "limit": 100,
    "offset": 200,
    "join": join_inner(queues, "q"),
);
    @endcode

    The select option hash argument has the following keys; all of which are optional:
    - @ref select_option_alias "alias": an optional string providing a table alias for the main table
    - @ref select_option_comment "comment": an optional string with with comment used in select statement
    - @ref select_option_hint "hint": an optional string with with hint used in select statement (platform dependent)
    - @ref select_option_columns "columns": describes the output columns and any output column operations; if not present, then all columns are returned directly in the output
    - @ref select_option_where "where": (@ref hash_type "hash") describes how any \c "where" clause will be built; if not present, then there is no \c where clause
    - @ref select_option_orderby "orderby": (@ref list_type "list of strings") describes the ordering of the results; if not present (and no other output ordering is required, such as implied by the @ref select_option_offset "offset" option), then results are returned in the order returned by the database server
    - @ref select_option_desc "desc": (@ref bool_type "bool") specifies descending order for results; if not present or not @ref True "True" and results are ordered, then the results are returned in ascending order
    - @ref select_option_limit "limit": (@ref int_type "int") specifies the maximum number of results to be returned; if not present, then all results are returned
    - @ref select_option_offset "offset": (@ref int_type "int") specifies the starting offset of the first record to be returned (starting with 0)
    - @ref select_option_join "join": (@ref hash_type "hash") specifies any SQL join operations to return results from multiple tables
    - @ref select_option_groupby "groupby": (@ref list_type "list of strings") specifies grouping for aggregate column functions
    - @ref select_option_having "having": (@ref hash_type "hash") specifies filtering for results with aggregate column functions
    - @ref select_option_superquery "superquery": (@ref hash_type "hash") specifies that the rest of the argument belong to a subquery and the hash arguments under this key will select from the subquery
    - @ref select_option_forupdate "forupdate": (@ref bool_type "bool") adds a \c "for update" clause to a select query

    @subsubsection select_option_alias Select Option "alias"
    This option provides a table alias for the main table when @ref select_option_join "join" options are also used.

    <b>Alias Example:</b>
    @code{.py}
hash<auto> sh = (
    "columns": ("t1.*", "t2.customer_name"),
    "join": join_inner(table2, "t2", ("id": "altid"))),
    "alias": "t1",
);
*list rows = table.selectRows(sh);
    @endcode

    @subsubsection select_option_comment Select Option "comment"
    The comment does not have any impact to data returned from the statement but it can help with statement finding and optimizations.

    <b>Comment Example:</b>
    @code{.py}
table.selectRows(("comment": "foo bar"));
    @endcode
    will produce select statement like this:
    @code{.py}
select /* foo bar *<!--%%-->/ ...
    @endcode
    @warning Oracle: using different comments in the same SQL can lead to new optimizer statement hard parsing.

    @subsubsection select_option_hint Select Option "hint"
    In database query operations, various SQL implementations use hints as additions to the SQL standard that instruct the database engine on how to execute the query. For example, a hint may tell the engine to use as little memory as possible (even if the query will run slowly), or to use or not to use an index (even if the query optimizer would decide otherwise).

    <b>Hint Example:</b>
    @code{.py}
table.selectRows(("hint": "full(t1)"));
    @endcode
    will produce select statement like this:
    @code{.py}
select /*+ full(a) *<!--%%-->/ ...
    @endcode
    The string is taken as-is and it's up to the caller to handle correct aliases in join functions etc.
    @note Hints are platform dependent. Curently only Oracle and some versions of PostgreSQL hints are supported in Sqlutil module.
    @warning Use hints only when you know what you are doing.

    @subsubsection select_option_columns Select Option "columns"
    <b>Columns Example:</b>
    @code{.py}
list columns = (
    "id", "name", "started",
    cop_as("warnings", "warning_count"),
    cop_as("errors", "error_count"),
);
*list rows = table.selectRows(("columns": columns, "where": ("type": "user")));
    @endcode
    By default, all columns are returned from a query; to limit the columns returned, or to perform column operations on the columns returned, use the \c "columns" option of the @ref select_option_hash "select option hash". \n\n
    This option takes a list, each element of the list can be one of the following.\n\n
    <b>A Simple String Giving a Column Name</b>\n
    ex: \c "name"
    @code{.py}
*list rows = table.selectRows(("columns": ("id", "name", "started")));
    @endcode \n
    <b>A String in Dot Notation</b>\n
    This format is for use with @ref select_option_join "joins"; ex: \c "q.name"
    @code{.py}
hash<auto> sh = (
    "columns": ("t1.id", "t2.customer_name"),
    "join": join_inner(table2, "t2", ("id": "altid"))),
    "alias": "t1",
);
*list rows = table.selectRows(sh);
    @endcode \n
    <b>A Column Operation Specified by a Column Operator Function</b>\n
    ex: <tt>cop_as("column_name", "column_alias")</tt> \n
    See @ref sql_cop_funcs "column operator function" for more information on column operator functions
    @code{.py}
list columns = (
    "id",
    cop_as("warnings", "warning_count"),
    cop_as("errors", "error_count"),
);
*list rows = table.selectRows(("columns": columns));
    @endcode
    For @ref sql_cop_funcs "column operator functions" taking a column name, either a string name or a name in dot notation is acceptable\n\n
    <b>The Value \c "*", Meaning All Columns</b>\n
    ex: \c "*"
    @code{.py}
*list rows = table.selectRows(("columns": "*"));
    @endcode
    This is the default if no \c "columns" key is included in the @ref select_option_hash "select option hash" \n\n
    <b>An \c "*" in Dot Notation</b>\n
    ex: \c "q.*"
    @code{.py}
hash<auto> sh = (
    "columns": ("table.id", "t2.*"),
    "join": join_inner(table2, "t2", ("id": "altid")),
);
*list rows = table.selectRows(sh);
    @endcode

    @subsubsection select_option_where Select Option "where"
    <b>Where Example:</b>
    @code{.py}
*list rows = table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    The hash value assigned to this key describes how the \c "where" clause in the query is built.  Because the \c "where" clause logic is common to many SQL methods, this topic is covered in a separate section.  See @ref where_clauses for a detailed description of the value of this key.

    @subsubsection select_option_orderby Select Option "orderby"
    <b>Orderby Example:</b>
    @code{.py}
hash<auto> sh = (
    "where": (
        "account_type": "CUSTOMER",
    ),
    "orderby": "created_date",
);
*list rows = table.selectRows(sh);
    @endcode
    This option is a list of the following values:
    - a simple string giving a column name; ex: \c "name"
    - a simple string with a column name preceded by a \c "-" sign; ex: \c "-name", meaning that that column should be sorted in descending order
    - a string giving a table or table alias and a column name in dot notation (for use with @ref select_option_join "joins"); ex: \c "q.name"
    - a positive integer giving the column number for the ordering
    @note
    - By using the @ref select_option_offset "offset option" the results will be automatically ordered according to the primary key of the table

    @subsubsection select_option_desc Select Option "desc"
    <b>Desc Example:</b>
    @code{.py}
hash<auto> sh = (
    "where": (
        "account_type": "CUSTOMER",
    ),
    "orderby": "created_date",
    "desc": True,
);
*list rows = table.selectRows(sh);
    @endcode
    If the value of this key is @ref True "True" and results are ordered (either due to the @ref select_option_orderby "orderby option" or due to implicit ordering by the primary key due to the use of the @ref select_option_offset "offset option"), then results will be sorted in descending order.\n\n
    Otherwise, ordered results are returned in ascending order by default.

    @note per-column descending options can be given by prepending a \c "-" character to the column name in the @ref select_option_orderby "orderby option list"

    @subsubsection select_option_limit Select Option "limit"
    <b>Limit Example:</b>
    @code{.py}
hash<auto> sh = (
    "where": ("type": "user"),
    "limit": 100,
    "offset": 200
);
*list rows = table.selectRows(sh);
    @endcode
    This option will limit the number of rows returned.
    @note
    - This option is required if the @ref select_option_offset "offset option" is non-zero
    - If this option is present and an @ref select_option_orderby "orderby option" is also present, then at least a subset of the @ref select_option_orderby "orderby" columns must correspond to a unique key of the table or an exception is raised

    @subsubsection select_option_offset Select Option "offset"
    <b>Offset Example:</b>
    @code{.py}
hash<auto> sh = (
    "where": ("type": "user"),
    "limit": 100,
    "offset": 200
);
*list rows = table.selectRows(sh);
    @endcode
    This option specifies the row number offset for the rows returned where the first row is at offset zero.
    @note
    - If this option is present, then either an @ref select_option_orderby "orderby option" must be present of which at least a subset of the @ref select_option_orderby "orderby" columns must correspond to a unique key of the table, or, if no @ref select_option_orderby "orderby option" is used, then the table must have a primary key which is used for the ordering instead.
    - Additionally, this option requires the presence of the @ref select_option_limit "limit option", or an exception will be thrown.
    @see @ref sql_paging

    @subsubsection select_option_join Select Option "join"
    <b>Join Example:</b>
    @code{.py}
hash<auto> sh = (
    "columns": (
        "name", "version", "id",
        cop_as("st.value", "source"),
        cop_as("st.value", "offset"),
    ),
    "join": join_left(function_instance_tags, "st", NOTHING, ("st.tag": "_source"))
            + join_left(function_instance_tags, "lt", NOTHING, ("st.tag": "_offset")),
);
*list rows = table.selectRows(sh);
    @endcode
    To join multiple tables in a single query, use the \c "join" option.  The \c "join" hash key should be assigned to a join description hash as returned by one of the @ref sql_jop_funcs or combined join description hash created by concatenating such values (see an example of this above).
    @note the join columns do not need to be specified in the case that a foreign key in one table exists to the primary key of the other table; in this case this information is assumed for the join automatically

    @see @ref joins for more examples

    @subsubsection select_option_groupby Select Option "groupby"
    <b>Groupby Example:</b>
    @code{.py}
hash<auto> sh = (
    "columns": (
        cop_as(cop_max("service_type"), "type"),
        cop_count(),
    ),
    "groupby": "service_type",
);
*list rows = table.selectRows(sh);
    @endcode
    The \c "groupby" option allows for aggregate SQL column operator functions to be used (ex: @ref cop_max(), cop_min()) in select statements.
    The \c "groupby" hash key should be assigned to a list of column specifiers or a single column specifier.  Column specifiers for the \c "groupby"
    key are strings giving column names, optionally in dot notation or positive column numbers.

    @subsubsection select_option_having Select Option "having"
    <b>Having Example:</b>
    @code{.py}
hash<auto> sh = (
    "columns": (
        cop_as(cop_max("service_type"), "type"),
        cop_count(),
    ),
    "groupby": "service_type",
    "having": (
        "service_type": (COP_COUNT, op_ge(100)),
    ),
);
*list rows = table.selectRows(sh);
    @endcode
    The \c "having" option allows for query results with aggregate SQL column operator functions to be filtered by user-defined criteria.
    The \c "having" hash key should be assigned to a hash where each key is a column specifier (optionally in dot notation) and the values are lists with two elements; the first element must be a @ref sql_cops "column operator code", and the second element is a column operator description normally provided by using a @ref sql_cop_funcs "column operator function" as in the above example.

    @subsubsection select_option_superquery Select Option "superquery"
    <b>Superquery Example:</b>
    @code{.py}
hash<auto> sh = (
    "columns": (
        "serviceid", "service_methodid",
        cop_as(cop_over(cop_max("service_methodid"), "serviceid"), "max_methodid"),
    ),
    "superquery": (
        "columns": ("serviceid", "service_methodid"),
        "where": ("max_methodid": op_ceq("service_methodid")),
    ),
);
*list rows = table.selectRows(sh);
    @endcode
    The \c "superquery" option allows for the rest of the query arguments to define a subquery where as the hash arguments assigned to the \c "superquery" key define the select made from the subquery.  In the example above, the \c "OVER" sql windowing function is used and then rows matching the \c "max_methodid)" result value are selected.\n\n
    The above example results in an SQL command equivalent to the following:
    @code{.py}
*list rows = table.vselectRows("select serviceid,service_methodid from (select serviceid,service_methodid,max(service_methodid) over (partition by serviceid) as max_methodid from schema.service_methods) subquery where max_methodid = service_methodid");
    @endcode
    @note that MySQL does not support SQL windowing functions so the above example would fail on MySQL.

    @subsubsection select_option_forupdate Select Option "forupdate"
    <b>For Update Example:</b>
    @code{.py}
on_success ds.commit();
on_error ds.rollback();

hash<auto> sh = (
    "columns": ("serviceid", "service_methodid"),
    "forupdate": True,
)
*list rows = table.selectRows(sh);
    @endcode
    \n The \c "forupdate" option allows for the rows selected to be locked for updating; to release the locks, call commit() or rollback() on the underlying datasource object.
  The above example results in an SQL commit equivalent to the following:
    @code{.py}
*list rows = table.vselectRows("select serviceid,service_methodid from schema.service_methods for update");
    @endcode

    @subsection sql_paging Select With Paging

    There is support for paging query results in the following methods:
    - @ref SqlUtil::AbstractTable::getStatement()
    - @ref SqlUtil::AbstractTable::getSelectSql()
    - @ref SqlUtil::AbstractTable::select()
    - @ref SqlUtil::AbstractTable::selectRows()

    @note the above list also applies to the corresponding @ref SqlUtil::AbstractTable methods

    Each of these methods takes a @ref select_option_hash "select option hash argument" that allows the \c "limit" and \c "offset" options to be specified to specify the data window for the results.

    If the \c "offset" options is used, then an \c "orderby" option is required which must match some unique constraint or unique index on the table to guarantee the order of results, unless the table has a primary key, in which case the primary key will be used by default if no \c "orderby" option is supplied.

    @par Example:
    Select 100 rows starting at row 200 (the table's primary key will be used for the \c "orderby" option by default): \n
    @code{.py}
*list rows = table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    As an illustration of the different SQL that is generated for different database types; for the above query, here is the SQL generated for Oracle:
    @code{.py}
ds.vselectRows("select * from (select /*+ first_rows(100) *<!--%%-->/ a.*, rownum rnum from (select * from schema.table where type = %v order by type) a where rownum <= %v) where rnum > %v", ("user", 300, 200));
    @endcode
    And for PostgreSQL:
    @code{.py}
ds.vselectRows("select * from public.table where type = %v order by type limit %v offset %v", ("user", 100, 200));
    @endcode

    @subsection check_matching_rows Check For At Least One Matching Row

    Use the @ref SqlUtil::AbstractTable::findSingle() method to find at least one matching row:
    @code{.py}
*hash h = table.findSingle(("account_type": "CUSTOMER"));
if (h)
    printf("found 1 customer row: %y\n", l[0]);
    @endcode

    Also it's possible to use the \c "limit" option to make an efficient check for at least one matching row as in the following example (which is functionally equivalent to the previous example):
    @code{.py}
*hash h = table.selectRow(("where": ("account_type": "CUSTOMER"), "limit": 1));
if (h)
    printf("found 1 customer row: %y\n", l[0]);
    @endcode

    @section inserting_data Inserting Data into the Database

    The following methods can be used to insert data into the database:
    - @ref SqlUtil::AbstractTable::insert(): inserts a single row into a table without committing the transaction
    - @ref SqlUtil::AbstractTable::insertCommit(): inserts a single row into a table and commits the transaction
    - @ref SqlUtil::AbstractTable::insertFromSelect(): inserts data in a table based on a select statement created from the @ref select_option_hash "select option hash" argument and without committing the transaction
    - @ref SqlUtil::AbstractTable::insertFromSelectCommit(): inserts data in a table based on a select statement created from the @ref select_option_hash "select option hash" argument and commits the transaction

    @see @ref sql_upsert for information about upserting or merging data

    @subsection inserting_data_explicitly Inserting Data Explicitly

    @par Example:
    @code{.py}
table.insert(("id": id, "name": name, "created": now_us()));
    @endcode

    Data can be explicitly inserted into the database with immediate values with @ref SqlUtil::AbstractTable::insert() and @ref SqlUtil::AbstractTable::insertCommit() as in the above example.

    Additionally, instead of giving a literal value to be inserted, @ref sql_iop_funcs can be used to insert values based on SQL operations used directly in the insert statement.

    @subsection inserting_data_from_select Inserting Data From a Select Statement

    @par Example:
    @code{.py}
int rows = table.insertFromSelect(("id", "name", "created"), source_table, (("columns": ("cid", "fullname", "created"), "where": ("type": "CUSTOMER"))));
    @endcode

    Data can be inserted into the database based on the results of a select statement with @ref SqlUtil::AbstractTable::insertFromSelect() and @ref SqlUtil::AbstractTable::insertFromSelectCommit() as in the above example.

    The example above would generate a %Qore SQL command like the following:
    @code{.py}
return ds.vexec("insert into schema.table (id,name,created) select cid,fullname,created from schema.source_table where type = %v", ("CUSTOMER"));
    @endcode

    The return value of these methods is the number of rows inserted.  See @ref select_option_hash "select option hash" for more information about how to form the select criteria in these methods.

    @subsection inserting_data_from_iterator Inserting Data from an Iterator Source

    To insert data from an iterator source (such as an @ref Qore::SQL::SQLStatement object), call @ref SqlUtil::AbstractTable::insertFromIterator() or @ref SqlUtil::AbstractTable::insertFromIteratorCommit() as in the following example:

    @par Example:
    @code{.py}
# get the rows to be inserted
list l = get_table_rows();
# insert the data and commit after every 5000 rows
table.insertFromIterator(l.iterator(), ("commit_block": 5000));
    @endcode

    The iterator given to the @ref SqlUtil::AbstractTable::insertFromIterator() or @ref SqlUtil::AbstractTable::insertFromIteratorCommit() methods can be any iterator whose @ref Qore::AbstractIterator::getValue() "getValue()" method returns a @ref hash_type "hash".

    @note the @ref SqlUtil::AbstractTable::InsertFromIteratorOptions "insert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @section updating_data Updating Data

    The following methods can be used to update data:
    - @ref SqlUtil::AbstractTable::update(): updates a single row and does not commit the transaction
    - @ref SqlUtil::AbstractTable::updateCommit(): updates a single row and commits the transaction

    @par Example:
    @code{.py}
int rows_updated = t.update(("permission_type": uop_append("-migrated", uop_lower())));
    @endcode

    The example above generates a %Qore SQL command like the following on Oracle and PostgreSQL for example:
    @code{.py}
return ds.vexec("update schema.table set permission_type = lower(permission_type) || '-migrated');
    @endcode
    And the following on MySQL:
    @code{.py}
return ds.vexec("update schema.table set permission_type = concat(lower(permission_type), '-migrated'));
    @endcode

    @section deleting_data Deleting Data

    The following methods can be used to dekete data:
    - @ref SqlUtil::AbstractTable::del(): updates the table based on a @ref where_clauses "where clause" and does not commit the transaction
    - @ref SqlUtil::AbstractTable::delCommit(): updates the table based on a @ref where_clauses "where clause" and commits the transaction
    - @ref SqlUtil::AbstractTable::truncate(): truncates the table and does not commit the transaction
    - @ref SqlUtil::AbstractTable::truncateCommit(): truncates the table and commits the transaction releasing the transaction lock on the underlying datasource object

    @par Example:
    @code{.py}
int dcnt = table.del(("record_type": "OLD-CUSTOMER"));
    @endcode

    The above example would generate a %Qore SQL command like the following:
    @code{.py}
return ds.vexec("delete from schema.table where record_type = %v", ("OLD-CUSTOMER"));
    @endcode

    The @ref SqlUtil::AbstractTable::del() and @ref SqlUtil::AbstractTable::delCommit() methods can be used to delete data from the database.

    See @ref where_clauses for information about specifying the criteria for the rows to be deleted.

    @section joins Joining Tables

    Joining tables is made by providing a join specification to the @ref select_option_join "join select option" in
    a @ref select_option_hash "select option hash" as in the following example:
    @code{.py}
*list rows = table.selectRows(("columns": ("table.id", "t2.customer_name"), "join": join_inner(table2, "t2", ("id": "altid"))));
    @endcode
    In the above example, \a table is joined with \a table2 on <tt>table.id = table2.altid</tt>.

    Joins on multiple tables are performed by combining the results of @ref sql_jop_funcs "join functions" with the @ref plus_operator "+ operator"
    as follows:
    @code{.py}
*list rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid")) + join_inner(table3, "t3")));
    @endcode
    In the above example, \a table is joined with \a table2 on <tt>table.id = table2.altid</tt> and with \a table3 on an
    automatically detected primary key to foreign key relationship between the two tables.

    Joins are by default made with the primary table; to join with another join table, then give the alias for the table as the first
    argument to the @ref sql_jop_funcs "join function" as in the following example:
    @code{.py}
*list rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid")) + join_inner("t2", table3, "t3")));
    @endcode
    In the above example, \a table is joined with \a table2 on <tt>table.id = table2.altid</tt> and \a table2 (aliased as \c t2) is joined
    with \a table3 (aliased as \c t3) on an automatically detected primary key to foreign key relationship between the two tables.

    @see @ref select_option_join "join select option"

    @section where_clauses Where Clauses

    Several methods accept a hash of conditions to build a \c "where" clause to restrict the rows that are operated on or returned; for example:
    - @ref SqlUtil::AbstractTable::del()
    - @ref SqlUtil::AbstractTable::delCommit()
    - @ref SqlUtil::AbstractTable::findAll()
    - @ref SqlUtil::AbstractTable::findSingle()
    - @ref SqlUtil::AbstractTable::getStatement()
    - @ref SqlUtil::AbstractTable::getSelectSql()
    - @ref SqlUtil::AbstractTable::insertFromSelect()
    - @ref SqlUtil::AbstractTable::insertFromSelectCommit()
    - @ref SqlUtil::AbstractTable::select()
    - @ref SqlUtil::AbstractTable::selectRow()
    - @ref SqlUtil::AbstractTable::selectRows()
    - @ref SqlUtil::AbstractTable::update()
    - @ref SqlUtil::AbstractTable::updateCommit()
    - @ref SqlUtil::AbstractTable::upsertFromSelect()
    - @ref SqlUtil::AbstractTable::upsertFromSelectCommit()

    @note the above list also applies to the corresponding @ref SqlUtil::AbstractTable methods

    The where clause or condition hash is made of keys signifying the column names, and either a direct value meaning that the column value has to match exactly, or SQL operators can be given by using the appropriate operator function as the key value.  Each member of the where hash translates to an expression that is combined with \c "AND" in the SQL query; to combine expressions with \c "OR", there are two options:
    - use the @ref SqlUtil::wop_or() function to combine where expressions with the \c "or" operator
    - use a list of @ref select_option_hash "select option hashes", which will combine each @ref select_option_hash "select option hash" with \c "OR" as in @ref where_list "this example".

    The where condition hash has the following format:
    - each key gives a column name or a table/alias with column name in dot notation
    - the values are either direct values, meaning that the equality operator (\c "=") is used, or a @ref sql_op_funcs "SQL operator function" for operators in the where clause

    @note To reference a column more than once in a where clause, prefix the column specification with a unique number and a colon as in the following example: @code{.py} hash w = ("0:created": op_ge(mindate), "1:created": op_lt(maxdate)); @endcode

    See @ref sql_op_funcs for a list of operator functions.

    @par Where Hash Example:
    @code{.py}
hash w = (
    "name": "Smith",
    "account_type": op_like("%CUSTOMER%"),
    "id": op_ge(500),
);
    @endcode \n
    The preceding example results in a where clause equivalent to: \c "name = 'Smith' and type like '%CUSTOMER%' and id >= 500", except
    that bind by value is used, so, if used in a context like the following:
    @code{.py}
Table t(ds, "table");
*hash<auto> qh = t.select(("where": w));
    @endcode \n
    the complete query would look instead as follows:
    @code{.py}
ds.vselect("select * from table where name = %v and account_type like %v and id >= %v", ("Smith", "%CUSTOMER%", 500));
    @endcode

    @anchor where_list
    @par Where List Example:
    @code{.py}
hash w1 = (
    "name": "Smith",
    "account_type": op_like("%CUSTOMER%"),
    "id": op_ge(500),
);
hash w2 = (
    "name": "Jones",
    "account_type": op_like("%VENDOR%"),
    "id": op_ge(2500),
);
Table t(ds, "table");
*hash<auto> qh = t.select(("where": (w1, w2)));
    @endcode \n
    the complete query would look instead as follows:
    @code{.py}
ds.vselect("select * from table where (name = %v and account_type like %v and id >= %v) or (name = %v and account_type like %v and id >= %v)", ("Smith", "%CUSTOMER%", 500, "Jones", "%VENDOR%", 2500));
    @endcode

    @par Code Examples:
    Find a single row in the table where the \c "permission_type" column is a value between \c "US" and \c "UX":\n
    @code{.py}
*hash<auto> row = table.findSingle(("permission_type": op_between("US", "UX")));
    @endcode
    resulting in an internal SQL command that looks as follows (depending on the database):
    @code{.py}
*hash<auto> row = ds.vselectRow("select * from table where permission_type between %v and %v limit %v", ("US", "UX", 1));
    @endcode \n
    Delete all rows in the table where the \c "name" column is like \c "%Smith%":\n
    @code{.py}
int row_count = table.del(("name": op_like("%Smith%")));
    @endcode
    resulting in an internal SQL command that looks as follows:
    @code{.py}
ds.vexec("delete from table where name like %v", ("%Smith%"));
    @endcode \n
    Find all rows where \c "id" is greater than \c 100 and \c "created" is after \c 2013-03-01:\n
    @code{.py}
*list rows = table.findAll(("id": op_gt(100), "created": op_gt(2013-03-01)));
    @endcode
    resulting in an internal SQL command that looks as follows:
    @code{.py}
ds.vexec("select * from table where id > %v and created > %v", (100, 2013-03-01));
    @endcode \n

    @section sql_upsert Upserting or Merging Data

    This module offers a high-level api for "upserting" or merging data from one table into another table through the following methods:
    - @ref SqlUtil::AbstractTable::upsert()
    - @ref SqlUtil::AbstractTable::upsertCommit()
    - @ref SqlUtil::AbstractTable::getUpsertClosure()
    - @ref SqlUtil::AbstractTable::getUpsertClosureWithValidation()
    - @ref SqlUtil::AbstractTable::upsertFromIterator()
    - @ref SqlUtil::AbstractTable::upsertFromIteratorCommit()
    - @ref SqlUtil::AbstractTable::upsertFromSelect()
    - @ref SqlUtil::AbstractTable::upsertFromSelectCommit()

    @subsection sql_upsert_single Upsert a Single Row

    @par Example:
    @code{.py}
table.upsert(("id": id, "name": name, "account_type": account_type));
    @endcode

    To upsert or merge a single row in the database, call @ref SqlUtil::AbstractTable::upsert() or @ref SqlUtil::AbstractTable::upsertCommit() with the
    single row to be upserted or merged as a hash as in the preceding example.

    @subsection sql_upsert_many Upserting Many Rows Using An Upsert Closure

    To upsert or merge many rows by using an upsert closure, call @ref SqlUtil::AbstractTable::getUpsertClosure() or @ref SqlUtil::AbstractTable::getUpsertClosureWithValidation() and provide an example row as an argument to acquire a closure that will be executed on the rest of the rows as in the following example.

    @par Simple Example:
    @code{.py}
# get the rows to be inserted
list l = get_table_rows();

if (l) {
    code upsert = table.getUpsertClosure(l[0]);

    on_success ds.commit();
    on_error ds.rollback();

    # loop through the reference data rows
    map upsert($1), l;
}
    @endcode

    @par Complex Example With Callbacks:
    @code{.py}
# set the upsert strategy depending on the use case
int upsert_strategy = verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

# hash summarizing changes
hash<auto> sh;

# get the rows to be inserted
list l = get_table_rows();

if (l) {
    # get the upsert closure to use based on the first row to be inserted
    code upsert = table.getUpsertClosure(l[0], upsert_strategy);

    on_success ds.commit();
    on_error ds.rollback();

    # loop through the reference data rows
    foreach hash<auto> h in (l) {
        int code = upsert(h);
        if (code == AbstractTable::UR_Unchanged)
            continue;

        string change = AbstractTable::UpsertResultMap{code};
        ++sh{change};

        if (!verbose) {
            printf(".");
            flush();
        }
        else if (verbose > 1)
            printf("*** reference data %s: %y: %s\n", table.getName(), h, change);
    }

    # show table summary
    if (sh)
        printf("*** reference data %s: %s\n", table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), sh.pairIterator())));
    else
        printf("*** reference data %s: OK\n", table.getName());
}
    @endcode

    @subsection sql_upsert_from_iterator Upserting Many Rows from an Iterator Source

    To upsert or merge many rows from an iterator source (such as an @ref Qore::SQL::SQLStatement object), call @ref SqlUtil::AbstractTable::upsertFromIterator() or @ref SqlUtil::AbstractTable::upsertFromIteratorCommit() as in the following example:

    @par Simple Example:
    @code{.py}
# get the rows to be inserted
list l = get_table_rows();
table.upsertFromIterator(l.iterator());
    @endcode

    @par Complex Example With Callbacks:
    @code{.py}
# set the upsert strategy depending on the use case
int upsert_strategy = verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

# get the rows to be inserted
list l = get_table_rows();

code callback = sub (string table_name, hash<auto> row, int result) {
    if (result == AbstractTable::UR_Unchanged)
        return;
    string change = AbstractTable::UpsertResultMap{result};
    if (verbose)
        printf("*** reference data %s: %y: %s\n", table_name, row, change);
};

hash<auto> sh = table.upsertFromIterator(l.iterator(), upsert_strategy, False, ("info_callback": callback, "commit_block": 5000));
if (sh)
    printf("*** reference data %s: %s\n", table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), sh.pairIterator())));
else
    printf("*** reference data %s: OK\n", table.getName());
    @endcode

    The iterator given to the @ref SqlUtil::AbstractTable::upsertFromIterator() or @ref SqlUtil::AbstractTable::upsertFromIteratorCommit() methods can be any iterator whose @ref Qore::AbstractIterator::getValue() "getValue()" method returns a @ref hash_type "hash".

    @note the @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @subsection sql_upsert_from_select Upserting Many Rows from a Select Statement

    To upsert or merge many rows from a select statement, use @ref SqlUtil::AbstractTable::upsertFromSelect() or @ref SqlUtil::AbstractTable::upsertFromSelectCommit() as in the following example:

    @par Simple Example:
    @code{.py}
table.upsertFromSelect(table2, ("where": ("account_type": "CUSTOMER")));
    @endcode

    @par Complex Example With Callbacks:
    @code{.py}
# set the upsert strategy depending on the use case
int upsert_strategy = verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

code callback = sub (string table_name, hash<auto> row, int result) {
    if (result == AbstractTable::UR_Unchanged)
        return;
    string change = AbstractTable::UpsertResultMap{result};
    if (verbose)
        printf("*** reference data %s: %y: %s\n", table_name, row, change);
};

hash<auto> sh = table.upsertFromSelect(table2, ("where": ("account_type": "CUSTOMER")), upsert_strategy, False, ("info_callback": callback, "commit_block": 5000));
if (sh)
    printf("*** reference data %s: %s\n", table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), sh.pairIterator())));
else
    printf("*** reference data %s: OK\n", table.getName());
    @endcode

    The source table does not have to be in the same database or even of the same database type (ie you can upsert to and from any database type supported by SqlUtil).

    @note the @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @subsection sql_upsert_with_delete Upserting Many Rows and Deleting Unwanted Rows

    Call any of the batch upsert methods with @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others set to @ref True "True" to perform a batch upsert / merge operation on a table, and then scan the table and delete any unwanted rows.  If there are no rows to be deleted, these calls have very similar performance to the batch upsert method calls without any deletions, however, if there are rows to be deleted, then the entire source table must be iterated to compare each row to valid data to delete the rows that do not belong.  Therefore for large tables this can be an expensive operation.

    The only difference in the following examples and the preceding ones is  any that @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref True "True" in these examples. any
 any
    @par Simple Example: any
    @code{.py}
# get the rows to be inserted
list l = get_table_rows();
table.upsertFromSelect(table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertAuto, ("delete_others": True, "commit_block": 5000));
    @endcode

    @par Complex Example With Callbacks:
    @code{.py}
# set the upsert strategy depending on the use case
int upsert_strategy = verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

# get the rows to be inserted
list l = get_table_rows();

code callback = sub (string table_name, hash<auto> row, int result) {
    if (result == AbstractTable::UR_Unchanged)
        return;
    string change = AbstractTable::UpsertResultMap{result};
    if (verbose)
        printf("*** reference data %s: %y: %s\n", table_name, row, change);
};

hash<auto> sh = table.upsertFromSelect(table2, ("where": ("account_type": "CUSTOMER")), upsert_strategy, ("delete_others": True, "info_callback": callback, "commit_block": 5000));
if (sh)
    printf("*** reference data %s: %s\n", table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), sh.pairIterator())));
else
    printf("*** reference data %s: OK\n", table.getName());
    @endcode

    @note the @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @subsection sql_upsert_strategies Upsert Strategies
    The approach used is based on one of the following strategies (see @ref upsert_options):
    - @ref SqlUtil::AbstractTable::UpsertAuto "AbstractTable::UpsertAuto": if the target table is empty, then @ref SqlUtil::AbstractTable::UpsertInsertFirst is used, otherwise @ref SqlUtil::AbstractTable::UpsertUpdateFirst is used; note that if a driver-specific optimized version of the upsert operation is implemented, this strategy will normally result in the best performance
    - @ref SqlUtil::AbstractTable::UpsertInsertFirst "AbstractTable::UpsertInsertFirst": first an insert will be attempted, if it fails due to a duplicate key, then an update will be made; this strategy should be used if more inserts will be made than updates
    - @ref SqlUtil::AbstractTable::UpsertUpdateFirst "AbstractTable::UpsertUpdateFirst": first an update will be attempted, if it fails due to missing data, then an insert is performed; this strategy should be used if more updates will be made then inserts
    - @ref SqlUtil::AbstractTable::UpsertSelectFirst "AbstractTable::UpsertSelectFirst": first a select is made on the unique key, if the data to be updated is equal, nothing is done and @ref upsert_results "upsert result" @ref SqlUtil::AbstractTable::UR_Unchanged is returned
    - @ref SqlUtil::AbstractTable::UpsertInsertOnly "AbstractTable::UpsertInsertOnly": insert if the row doesn't exist, otherwise do nothing and @ref upsert_results "upsert result" @ref SqlUtil::AbstractTable::UR_Unchanged is returned
    - @ref SqlUtil::AbstractTable::UpsertUpdateOnly "AbstractTable::UpsertUpdateOnly": update if the row exists, otherwise do nothing and @ref upsert_results "upsert result" @ref SqlUtil::AbstractTable::UR_Unchanged is returned

    @note @ref SqlUtil::AbstractTable::UpsertSelectFirst "AbstractTable::UpsertSelectFirst" is the only upsert strategy that can return @ref SqlUtil::AbstractTable::UR_Updated; the @ref SqlUtil::AbstractTable::UpsertSelectFirst "AbstractTable::UpsertSelectFirst" strategy should be used when verbose reporting is required, particularly if it's necessary to report the actual number of changed rows.
*/
/** @page schema_management Schema Management

    @tableofcontents

    @section schema_management_intro Introduction to Schema Management

    Most schema management is performed by using the @ref SqlUtil::Database "Database" class (which is a wrapper for the @ref SqlUtil::AbstractDatabase "AbstractDatabase" class).

    The most complex object is the @ref SqlUtil::AbstractTable "AbstarctTable", which has its own @ref table_management "section".

    One of the primary goals of schema management in %SqlUtil is to facilitate automatic schema management from a database-independent schema
    description. The idea is that a schema can be described in a generic way and then %SqlUtil can use the generic schema description to align
    the database with the description.  Aligning in %SqlUtil is performed as follows:
    - if the object does not exist, then it is created
    - if the object exists, but does not match the description, it is either:
      - dropped and recreated, or
      - modified in place
    - if the object exists and matches, then nothing is done

    Unfortuntely, it's not currently possible to describe all database objects in a generic way (and it probably never will be); in particular,
    functions, triggers, and other objects based on procedural code or database-specific functionality have to be defined in their
    database-specific formats.

    The following is a table describing the alignment support for various objects supported by %SqlUtil; for database-specific objects, see the
    database-specific %SqlUtil module:
    - <a href="../../MysqlSqlUtil/html/index.html">MysqlSqlUtil</a>
    - <a href="../../OracleSqlUtil/html/index.html">OracleSqlUtil</a>
    - <a href="../../PgsqlSqlUtil/html/index.html">PgsqlSqlUtil</a>

    |!Database Object|!Alignment Type
    |@ref SqlUtil::AbstractColumn "Columns"|aligned in place
    |@ref SqlUtil::AbstractConstraint "Constraints"|dropped and recreated
    |@ref SqlUtil::AbstractFunction "Functions" and @ref SqlUtil::AbstractFunction "Procedures"|dropped and recreated
    |@ref SqlUtil::AbstractIndex "Indexes"|dropped and recreated
    |@ref SqlUtil::AbstractSequence "Sequences"|dropped and recreated
    |@ref SqlUtil::AbstractTrigger "Triggers"|dropped and recreated
    |@ref SqlUtil::AbstractTable "AbstractTables"|aligned in place

    @note
    - For objects that are dropped and recreated, renaming the object is generally supported if the underlying database server supports
    renaming.
    - Schemas (and other objects) can also be dropped based on a generic description (or descriptions derived from the database); see
    @ref SqlUtil::AbstractDatabase::getDropSchemaSql()

    @section creating_new_objects Creating New Objects

    New objects are generally creating using appropriate methods from the @ref SqlUtil::Database "Database" class, such as the following:
    - @ref SqlUtil::AbstractDatabase::makeFunction() "AbstractDatabase::makeFunction()"
    - @ref SqlUtil::AbstractDatabase::makeProcedure() "AbstractDatabase::makeProcedure()"
    - @ref SqlUtil::AbstractDatabase::makeSequence() "AbstractDatabase::makeSequence()"
    - @ref SqlUtil::AbstractDatabase::makeTable() "AbstractDatabase::makeTable()"

    Tables can also be created by instantiating a @ref SqlUtil::Table "Table" object (see @ref SqlUtil::AbstractTable::constructor()).

    Each database driver may provide additional objects (such as types or materialized views, etc); see driver-specific documentation for more
    information.

    @section retrieving_objects Retrieving Objects from the Database

    Existing objects can be retrieved from the database using appropriate methods from the @ref SqlUtil::Database "Database" class,
    such as the following:
    - @ref SqlUtil::AbstractDatabase::getFunction() "AbstractDatabase::getFunction()"
    - @ref SqlUtil::AbstractDatabase::getProcedure() "AbstractDatabase::getProcedure()"
    - @ref SqlUtil::AbstractDatabase::getSequence() "AbstractDatabase::getSequence()"
    - @ref SqlUtil::AbstractDatabase::getTable() "AbstractDatabase::getTable()"

    Each database driver may provide additional objects (such as types or materialized views, etc); see driver-specific documentation for more
    information.

    @section listing_objects Listing Objects

    Listing database objects can be performed using appropriate methods from the @ref SqlUtil::Database "Database" class, such as the following:
    - @ref SqlUtil::AbstractDatabase::listFunctions() "AbstractDatabase::listFunctions()"
    - @ref SqlUtil::AbstractDatabase::listProcedures() "AbstractDatabase::listProcedures()"
    - @ref SqlUtil::AbstractDatabase::listSequences() "AbstractDatabase::listSequences()"
    - @ref SqlUtil::AbstractDatabase::listTables() "AbstractDatabase::listTables()"
    - @ref SqlUtil::AbstractDatabase::listViews() "AbstractDatabase::listViews()"

    Alternatively, iterators for lists of objects can be acquired with the following methods:
    - @ref SqlUtil::AbstractDatabase::functionIterator() "AbstractDatabase::functionIterator()"
    - @ref SqlUtil::AbstractDatabase::procedureIterator() "AbstractDatabase::procedureIterator()"
    - @ref SqlUtil::AbstractDatabase::sequenceIterator() "AbstractDatabase::sequenceIterator()"
    - @ref SqlUtil::AbstractDatabase::tableIterator() "AbstractDatabase::tableIterator()"
    - @ref SqlUtil::AbstractDatabase::viewIterator() "AbstractDatabase::viewIterator()"

    @section interdependent_tables Working With Interdependent Tables

    The @ref SqlUtil::Tables class manages a group of tables and the foreign key dependencies between the tables.
    This class is useful when managing an entire schema, particularly in the context of manual changes to
    a schema, such as a schema upgrade or downgrade for complex scenarios that are beyond the capabilities of
    the automatic schema and table alignment code.

    Below you can find some examples of what the @ref SqlUtil::Tables "Tables" class can do.

    @par Cache All Tables from a Schema
    To load all tables in a particular schema into an object of class @ref SqlUtil::Tables "Tables":
    @code{.py}
Tables tables(ds);
    @endcode

    @par Drop All Foreign Constraints to a Table
    The following is an example of how all foreign constraints to a particular table can be dropped:
    @code{.py}
*list l = tables.getDropAllForeignConstraintsOnTableSql("table_name", ("sql_callback_executed": True));
{
    on_success ds.commit();
    on_error ds.rollback();
    map ds.execRaw($1), l;
}
    @endcode
    This can be useful when performing a schema change and a table will be dropped, for example.

    @note by setting the @ref sql_callback_executed "sql_callback_executed option" to @ref True "True", the affected constraints and linked unique constraints are also updated in the cached table objects, see @ref sql_callback_executed for more information

    @par Drop a Constraint If It Exists
    The following code provides an example of how to unconditionally drop a constraint from a table and update the internal links between unique constraints and foreign constraints (if a foreign constraint is dropped):
    @code{.py}
*string sql = tables.getDropConstraintIfExistsSql("table_name", "fk_table_name_other_table", ("sql_callback_executed": True));
if (sql) {
    on_success ds.commit();
    on_error ds.rollback();
    ds.execRaw(sql);
}
    @endcode

    @note by setting the @ref sql_callback_executed "sql_callback_executed option" to @ref True "True", the affected constraints and linked unique constraints are also updated in the cached table objects, see @ref sql_callback_executed for more information

    @par Rename a Table
    The following code gives an example of renaming a table and updating all foreign constraint and unique key links in impacted tables if the source table exists and the target name does not exist:
    @code{.py}
*string sql = tables.getRenameTableIfExistsSql("old_table_name", "new_table_name", ("sql_callback_executed": True));
if (sql) {
    on_success ds.commit();
    on_error ds.rollback();
    ds.execRaw(sql);
}
    @endcode

    @note by setting the @ref sql_callback_executed "sql_callback_executed option" to @ref True "True", the affected constraints and linked unique constraints are also updated in the cached table objects, see @ref sql_callback_executed for more information

    @section aligning_schemas Aligning Schemas With a Template

    A schema template can be created any way required (ie by hand, or by retrieving the description from another database), but typically they will be created from a @ref schema_desc_hash "schema description hash".

    The following code provides an example of creating a schema template and using it to align the schema in the database with the template using callbacks:
    @code{.py}
int change_count;
code info_callback = sub (string str, int ac, string type, string name, *string table, *string new_name, *string info) {
    if (ac != AbstractDatabase::AC_NotFound && ac != AbstractDatabase::AC_Unchanged)
        ++change_count;
    if (verbose)
        printf("*** %s\n", str);
    else {
        print(AbstractDatabase::ActionLetterMap{ac});
        flush();
    }
};

code sql_callback = sub (string str) {
    if (verbose > 1)
        printf("%s\n", str);
    ds.execRaw(str);
};

hash callback_opts = ("info_callback": info_callback, "sql_callback": sql_callback, "sql_callback_executed": True);

Database db(ds);
Tables table_cache();
db.getAlignSql(schema_template, callback_opts, table_cache);
    @endcode

    @subsection schema_desc_hash Schema Description Hash

    The schema description hash has the following structure:
    - \c tables: a hash of @ref table_desc_hash "table description hashes" keyed by table name; each entry describes a table
    - \c sequences: a hash of sequence description hashes keyed by sequence name; each entry describes a sequence
    - \c functions: a hash of function description hashes keyed by function name; each entry describes a function
    - \c procedures: a hash of procedure description hashes keyed by procedure name; each entry describes a procedure
    - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the schema description hash before processing; this way a schema description hash can contain all the information required for the schema including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys

    Each database driver may provide additional objects (such as types or materialized views, packages, etc); see
    driver-specific documentation for more information.

    The following is an example of a schema description hash:
    @code{.py}
const Options = (
    "driver": (
        "oracle": (
            "compute_statistics": True,
            "character_semantics": True,
        ),
    ),
    );

const T_Customers = (
    "columns": (
        "id": (
            "qore_type": Type::Number,
            "size": 14,
            "notnull": True,
            # this column is normally populated from a sequence by a trigger, but mysql
            # enforces not null constraints before "before insert" triggers are fired, so
            # we can't use our emulated sequences on mysql with a not null constraint on this
            # column, also since this column is a part of the primary key for this table,
            # we can't leave it nullable, so we use auto_increment
            "driver": ("mysql": ("native_type": "bigint", "unsigned": True, "auto_increment": True, "size": NOTHING)),
        ),
        "family_name": (
            "qore_type": Type::String,
            "size": 120,
            "notnull": True,
        ),
        "first_names": (
            "qore_type": Type::String,
            "size": 240,
            "notnull": True,
        ),
        "created": (
            "qore_type": Type::Date,
            "notnull": True,
            # this column is populated by a trigger, but mysql enforces not null
            # constraints before "before insert" triggers are fired, so for mysql only
            # this column must be nullable
            "driver": ("mysql": ("notnull": False)),
        ),
        "modified": (
            "qore_type": Type::Date,
        ),
    ),
    "primary_key": ("name": "pk_customers", "columns": "id"),
    "indexes": (
        "sk_customers_name": ("columns": "family_name"),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_customers()": "returns trigger language plpgsql as function$ begin if (tg_op = 'INSERT') then if new.created is null then select current_timestamp into new.created;
    end if; end if; if new.modified is null then select current_timestamp into new.modified; end if; return new; end; function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_customers": "BEFORE INSERT OR UPDATE ON customers REFERENCING NEW AS NEW OLD AS OLD FOR EACH ROW begin if inserting then if :new.id is null then select seq_customers.nextval into :new.id from dual; end if; if :new.created is null then :new.created := sysdate; end if; end if; if :new.modified is null or :new.modified = :old.modified then :new.modified := sysdate; end if; end;",
            ),
            "pgsql": (
                "trig_customers": "before insert or update on customers for each row execute procedure trig_customers()",
            ),
            "mysql": (
                "trig_customers_insert": "before insert on customers for each row begin if new.created is null then set new.created = now(); end if; if new.modified is null then set new.modified = now(); end if; end",
                "trig_customers_update": "before update on customers for each row begin if new.modified is null or new.modified = old.modified then set new.modified = now(); end if; end",
            ),
        ),
    ),
);

const SequenceList = (
    "seq_customers": {},
    );

const Sequences = (
    "driver": (
        "oracle": SequenceList,
        "pgsql": SequenceList,
    ),
    );

const Tables = (
    "customers": T_Customers,
    );

const Schema = (
    "sequences": Sequences,
    "tables": Tables,
    );
    @endcode

    @section table_management Table Management

    The main class to be used for table management is @ref SqlUtil::Table "Table" (which is a wrapper for @ref SqlUtil::AbstractTable "AbstractTable").  This class can be used both for building a table from scratch or for retrieving the structure of a table from the database.

    Real table related work is done in @ref SqlUtil::AbstractTable "AbstractTable". AbstractTable is also instance returned from most of API calls used.

    @subsection creating_new_tables Creating New Tables

    Tables can be created manually, by creating a @ref SqlUtil::Table "Table object" and then populating the table with columns, indexes, etc, and then calling @ref SqlUtil::AbstractTable::create() for example.
    The following methods can be used for adding new attributes to a table:
    - @ref SqlUtil::AbstractTable::addColumn()
    - @ref SqlUtil::AbstractTable::addPrimaryKey()
    - @ref SqlUtil::AbstractTable::addUniqueConstraint()
    - @ref SqlUtil::AbstractTable::addIndex()
    - @ref SqlUtil::AbstractTable::addForeignConstraint()
    - @ref SqlUtil::AbstractTable::addCheckConstraint()
    - @ref SqlUtil::AbstractTable::addTrigger()

    Note that if the table is known to be in the database already (for example, if the original table info was read from the database), then calling one of the above methods will also effect the change in the database immediately.

    Alternatively, the following methods can be used to retrieve the SQL that can be executed for the particular database driver that the @ref SqlUtil::Table object is based on:
    - @ref SqlUtil::AbstractTable::getAddColumnSql()
    - @ref SqlUtil::AbstractTable::getAddPrimaryKeySql()
    - @ref SqlUtil::AbstractTable::getAddUniqueConstraintSql()
    - @ref SqlUtil::AbstractTable::getAddIndexSql()
    - @ref SqlUtil::AbstractTable::getAddForeignConstraintSql()
    - @ref SqlUtil::AbstractTable::getAddCheckConstraintSql()
    - @ref SqlUtil::AbstractTable::getAddTriggerSql()

    Otherwise a table can be built from a @ref table_desc_hash "table description hash" with one of the following methods:
    - @ref SqlUtil::AbstractTable::constructor()
    - @ref SqlUtil::AbstractTable::setupTable()

    Table description hashes are also used when aligning tables to a template, which can be used to automate schema upgrades; see @ref SqlUtil::AbstractTable::getAlignSql(), @ref SqlUtil::AbstractDatabase::getAlignSql(), and @ref table_desc_hash "table description hash" for more information.

    @subsection retrieving_table_info Retrieving Table Information

    The following methods retrieve table information from the database:
    - @ref SqlUtil::AbstractTable::cache() "Table::cache()": this method reads in the entire table configuration immediately
    - @ref SqlUtil::AbstractTable::describe() "Table::describe()": this method returns an object of class @ref SqlUtil::Columns describing the table's columns
    - @ref SqlUtil::AbstractTable::getPrimaryKey() "Table::getPrimaryKey()": this method returns an object of class @ref SqlUtil::AbstractPrimaryKey describing the table's primary key if it has one
    - @ref SqlUtil::AbstractTable::getIndexes() "Table::getIndexes()": this method returns an object of class @ref SqlUtil::Indexes describing the table's indexes
    - @ref SqlUtil::AbstractTable::getForeignConstraints() "Table::getForeignConstraints()": this method returns an object of class @ref SqlUtil::ForeignConstraints describing the table's foreign constraints
    - @ref SqlUtil::AbstractTable::getConstraints() "Table::getConstraints()": this method returns an object of class @ref SqlUtil::Constraints describing the table's non-foreign constraints
    - @ref SqlUtil::AbstractTable::getTriggers() "Table::getTriggers()": this method returns an object of class @ref SqlUtil::Triggers describing the table's triggers

    The @ref SqlUtil::AbstractTable::cache() method can be used to retrieve all table information from the database immediately as in the following example:
    @code{.py}
Table table(ds, "table_name");
table.cache();
string sql = table.getCreateSqlString();
    @endcode

    Use the following code to test if a table exists:
    @code{.py}
Table table(ds, "table_name");
if (table.checkExistence())
    printf("table exists\n");
    @endcode

    Or the following:
    @code{.py}
Database db(ds);
*AbstractTable table = db.getTable("table_name");
    @endcode

    @subsection aligning_tables Aligning Tables With a Template

    Template tables can be created any way required (ie by hand, or by retrieving the description from another database), but typically they will be created from a @ref table_desc_hash "table description hash".

    The following code provides an example of creating a template table and using it to align a table in the database with the template using callbacks:
    @code{.py}
int change_count;
code info_callback = sub (string str, int ac, string type, string name, *string table, *string new_name, *string info) {
    if (ac != AbstractDatabase::AC_NotFound && ac != AbstractDatabase::AC_Unchanged)
        ++change_count;
    if (verbose)
        printf("*** %s\n", str);
    else {
        print(AbstractDatabase::ActionLetterMap{ac});
        flush();
    }
};

code sql_callback = sub (string str) {
    if (verbose > 1)
        printf("%s\n", str);
    ds.execRaw(str);
};

hash callback_opts = ("info_callback": info_callback, "sql_callback": sql_callback, "sql_callback_executed": True);

Table template_table(ds, table_desc_hash, "table_name");
Table db_table(ds, "table_name");
db_table.getAlignSql(template_table, callback_opts);
    @endcode

    @subsection table_desc_hash Table Description Hash

    Table description hashes have the following structure:
    - \c columns: (required) a hash of column information keyed by column name; the values are @ref column_desc_hash "column description hashes"
    - \c primary_key: (optional) a @ref pk_desc_hash "primary key description hash" describing the primary key for the table
    - \c indexes: (optional) a hash of index information keyed by index name; the values are @ref index_desc_hash "index description hashes"
    - \c triggers: (optional) a hash of trigger information keyed by trigger name; the values are the trigger source code; since triggers are driver-dependent, a driver-independent table description would include trigger hashes under the \c drivers key and the driver key name under that; see below for an example
    - \c foreign_constraints: (optional) a hash of foreign constraint information keyed by constraint name; the values are @ref fk_desc_hash "foreign constraint hashes"
    - \c unique_constraints: (optional) a hash of unique constraint information keyed by constraint name; the values are @ref uk_desc_hash "unique constraint hashes"
    - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the table description hash before processing; this way a table description hash can contain all the information required for the table including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys, see below for an example

    Here is an example of a table description hash:
    @code{.py}
hash table_desc = (
    "columns": (
        "domain": (
            "qore_type": Type::String,
            "size": 240,
            "notnull": True,
        ),
        "keyname": (
            "qore_type": Type::String,
            "size": 240,
            "notnull": True,
        ),
        "value": (
            "qore_type": Type::String,
            "size": 4000,
        ),
        "created": (
            "qore_type": Type::Date,
            "notnull": True,
            "driver": (
                "oracle": (
                    "native_type": "date",
                ),
            ),
        ),
        "modified": (
            "qore_type": Type::Date,
            "driver": (
                "oracle": (
                    "native_type": "date",
                ),
            ),
        ),
    ),
    "primary_key": ("name": "pk_system_properties", "columns": ("domain", "keyname")),
    "indexes": (
        "sk_system_properties_domain": ("columns": "domain"),
        "driver": (
            "oracle": (
                "pk_system_properties": ("columns": ("domain", "keyname"), "unique": True),
            ),
        ),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_system_properties()": "returns trigger language plpgsql as function$ begin if (tg_op = 'INSERT') then if new.created is null then select current_timestamp into new.created; end if; end if; if new.modified is null then select current_timestamp into new.modified; end if; return new; end; function$",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_system_properties": "BEFORE INSERT OR UPDATE ON SYSTEM_PROPERTIES REFERENCING NEW AS NEW OLD AS OLD FOR EACH ROW begin if inserting then if :new.created is null then :new.created := sysdate; end if; end if; if :new.modified is null or :new.modified = :old.modified then :new.modified := sysdate; end if; end;",
            ),
            "pgsql": (
                    "trig_system_properties": "before insert or update on system_properties for each row execute procedure trig_system_properties()",
            ),
            "mysql": (
            ),
        ),
    ),
);
    @endcode

    @note
    - some databases will automatically create indexes for you when you create primary keys and unique constraints; some do not (ex: oracle).  In the above example, an index is created explicitly for the primary key constraint for oracle only.
    - the above example includes an additional driver-specific key for the \c "pgsql" driver: \c "functions" which is used by the PgsqlSqlUtil module to create trigger functions used by the table's trigger.

    @subsection column_desc_hash Column Description Hash

    Column description hashes have the following structure:
    - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion
    - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
    - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
    - \c scale: for numeric data types, this value gives the scale
    - \c default_value: the default value for the column
    - \c default_value_native: a boolean flag to say if a \c default_value should be validated against table column type (False) or used as it is (True) to allow to use DBMS native functions or features. Defaults to False. It is strongly recommended to use \c default_value_native for \c default_value in \c driver specific sub-hash to avoid non-portable schema hashes
    - \c comment: an optional comment for the column
    - \c notnull: if the column should have a "not null" constraint on it; if missing the default value is @ref False "False"
    - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the column description hash before processing; this way a column description hash can contain all the information required for the column including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys, see below for an example

    Note that the above structure is an extension of the fields in @ref SqlUtil::AbstractTable::ColumnDescOptions, adding \c notnull and \c driver keys for additional information to create the column in the table.

    Here is an example of a column description hash:
    @code{.py}
hash date_col_desc = (
    "qore_type": Type::Date,
    "notnull": True,
    "driver": (
        "oracle": (
            "native_type": "date",
        ),
    ),
);
    @endcode

    The above hash<auto> describes a column that will be have \c TIMESTAMP type on most databases, but \c DATE on Oracle.

    @subsection pk_desc_hash Primary Key Description Hash

    The primary key description hash has the following keys:
    - \c name: (required) the name of the primary key
    - \c columns: (required) a single column name or a list of column names making up the primary key

    Here is an example of a primary key description hash:
    @code{.py}
hash pk_desc = (
    "name": "pk_queue",
    "columns": "queueid",
);
    @endcode

    @subsection fk_desc_hash Foreign Constraint Description Hash

    The foreign constraint description hash has the following keys:
    - \c columns: (required) a single column name or a list of column names in the current table making up the foreign constraint
    - \c table: (required) a string giving the name of the table the foreign constraint is on
    - \c target_columns: (optional) this key is only necessary if the columns in the foreign table have different names than in the current table; if so, it must be assigned to a single column name or a list of column names in the foreign table; if this key is present then the same number of columns must appear in each key

    The following is an example of a foreign key description hash:
    @code{.py}
hash fk_desc = (
    "columns": "queueid",
    "tables": "queues",
);
    @endcode

    @subsection uk_desc_hash Unique Constraint Description Hash

    The unique constraint description hash has the following key:
    - \c columns: (required) a single column name or a list of column names in the current table making up the unique constraint

    The following is an example of a unique constraint description hash:
    @code{.py}
hash uk_desc = (
    "columns": ("type", "name"),
);
    @endcode

    @subsection index_desc_hash Index Description Hash

    Index description hashes have the following structure:
    - \c columns: (required) a single column or a list of column names making up the index
    - \c unique: a boolean value indicating if the index is unique or not, if missing, then the index is assumed to e not unique

    The following is an example of an index description hash:
    @code{.py}
hash<auto> ix_desc = (
    "columns": ("type", "name"),
    "unique": True,
);
    @endcode

    @section callbacks Callbacks

    Most of the SqlUtil methods that return SQL strings also accept an option hash where callbacks an be set.  Callbacks can be used
    to display detailed information about long-running operations, such as schema or data alignment for complex schemas or large
    data sets, or as a generic framework for executing and logging SQL operations.

    @subsection error_callback SQL Error Callback

    the \c "error_callback" @ref closure "closure" or @ref call_reference "call reference" is called with information about the current SQL
    operation if an error occurs in the @ref sql_callback "sql callback" and can be specified as in the following example:
    @code{.py}
code error_callback = sub (int ac, string type, string name, *string table, *string new_name, *string info, string sql, hash<ExceptionInfo> ex) {
    if (ac == AC_Create && type == "materialized_view" && ex.alterr == "ORA-01031") {
        # try to drop any table create to back the materialized view; ignoring ORA-00942 table or view does not exist errors
        ds.exec("begin execute immediate 'drop table %s'; exception when others then if sqlcode != 942 then raise; end if; end;", name);
    }
};
    @endcode

    @subsection info_callback SQL Info CallBack Closure or Call Ceference

    The \c "info_callback" @ref closure "closure" or @ref call_reference "call reference" is called with information about the current SQL
    operation and can be specified as in the following example:
    @code{.py}
int change_count;
code info_callback = sub (string str, int ac, string type, string name, *string table, *string new_name, *string info) {
    if (ac != AbstractDatabase::AC_NotFound && ac != AbstractDatabase::AC_Unchanged)
        ++change_count;
    if (verbose)
        printf("*** %s\n", str);
    else {
        print(AbstractDatabase::ActionLetterMap{ac});
        flush();
    }
};

hash callback_opts = ("info_callback": info_callback);
db.getAlignSql(schema, callback_opts);
    @endcode

    @subsection sql_callback SQL Raw/DDL CallBack Closure or Call Ceference

    The \c "sql_callback" @ref closure "closure" or @ref call_reference "call reference" is called with an SQL string suitable for raw execution for each SQL command that is returned
    or generated for a particular operation and can be specified as in the following example:
    @code{.py}
code sql_callback = sub (string str) {
    ds.execRaw(str);
    if (verbose > 1)
        printf("%s\n", str);
};

hash callback_opts = ("sql_callback": sql_callback, "sql_callback_executed": True);
db.getAlignSql(schema, callback_opts);
    @endcode

    @note this callback is used for DDL execution and does not use bound arguments; for SQL data operations, the @ref sqlarg_callback is used instead

    @subsection sql_callback_executed SQL CallBack Executed Flag

    If the \c "sql_callback_executed" flag is set to @ref True "True" then the called method knows that the changes are made in the database and the internal representation of the affected object(s) is also updated accordingly.  Here is an example:
    @code{.py}
code sql_callback = sub (string str) {
    if (verbose > 1)
        printf("%s\n", str);
    ds.execRaw(str);
};

hash callback_opts = ("sql_callback": sql_callback, "sql_callback_executed": True);
db.getAlignSql(schema, callback_opts);
    @endcode

    @subsection sqlarg_callback SQL Operation Callback Closure or Call Reference

    The \c "sqlarg_callback" @ref closure "closure" or @ref call_reference "call reference" is called with an SQL string and arguments for each SQL command that is executed
    during SQL data operations and can be specified as in the following example:
    @code{.py}
code sqlarg_callback = sub (string str, *list<auto> args) {
    if (verbose > 1)
        printf("SQL: %s\nargs: %y", str, args);
};

table.insertFromIterator(i, sqlarg_callback);
    @endcode

    @note this callback is used for data operations and is called with bound arguments; for DLL operations, see @ref sql_callback

    @subsection upsert_info_callback Upsert Info Callback

    The \c "info_callback" upsert option key can be assigned to a @ref closure "closure" or @ref call_reference "call reference" that
    is called whenever an row result is available; this callback takes the following arguments:
    - @ref string_type "string" table_name: the name of the table
    - @ref hash_type "hash" row: the row affected
    - @ref int_type "int" result: the upsert result code (see @ref upsert_results) for possible values

    Here is an example of an upsert callback:
    @code{.py}
code upsert_callback = sub (string table_name, hash<auto> row, int result) {
    # verbosity threshold
    int t = 0;
    if (result != AbstractTable::UR_Unchanged)
        ++change_count;
    else
        t = 1;

    if (opt.verbose > t) {
        if (dot_count) {
            print("\n");
            dot_count = 0;
        }
        printf("%s reference data %s: %y: %s\n", t ? "+++" : "***", table_name, row, AbstractTable::UpsertResultMap{result});
    }
    else {
        ++dot_count;
        print(AbstractTable::UpsertResultLetterMap{result});
        flush();
    }
};

hash<auto> sh = table.upsertFromIterator(i, upsert_strategy, False, ("info_callback": upsert_callback));
    @endcode

    @subsection insert_info_callback Insert Info Callback

    This option is identical to @ref upsert_info_callback, except the \a result argument is always @ref SqlUtil::AbstractTable::UR_Inserted.
*/
/** @page dba_management DBA Management

    @tableofcontents

    @section dba_management_intro Introduction to DB Administration

    This part of SqlUtil contain some additional tools to handle subset of database administration.
    Common application developer usually does not need to handle anything described in this section on his own.

    @warning Database administration is complex task and it requires knowledge in various areas of IT. Always ask your DBA if and when you can use these tools.

    DBA tools are part of the AbstractDatabase (or Database) classes. Methods described below are wrappers around database specific commands.

    @section dba_indexes Index Management

    - @ref SqlUtil::AbstractDatabase::rebuildIndex()

    Index rebuilding is quite controversial task and it is highly variable for each database server. And even worse - it's varying between database server versions too. Modern database servers usually do not need to rebuild indexes in regular operations, but there can be situations when it's required still. Like: testing DB features, index corruption as a result of HW failure, storage parameters changing etc.

    The easiest criteria which can be quickly and easily given to you is it not to rebuild or coalesce any index unless you have a specific, proven reason for doing so.

    rebuildIndex() methods always takes a index name or an SqlUtil::AbstractIndex instance as first argument. The second argument is an optional hash with rebuild index options. These options are specific for each database server.
    See driver-specific modules for more info.

    @code{.py}
new Database(ds).rebuildIndex("ix_foo_bar");
    @endcode

    @subsection dba_indexes_oracle Oracle Options

    Oracle backend implementation uses \c ALTER \c INDEX \c REBUILD statement internally.

    |!Option|!Type|!Description
    |\c parallel|Boolean|Use parallel keyword in the statement if it's set to True
    |\c logging|Boolean|Use \c logging keyword in the statement if it's set to True. By default \c nologging keyword is used.
    |\c statistics|Boolean|Use \c compute \c statistics keyword in the stetement if it's set to True
    |\c tablespace|String|Rebuild index in given tablespace
    |\c cond_rebuild|Boolean|Rebuild index only when it meets \c INDEX_STATS criteria
    |\c cond_maxheight|Integer|maximum index height before rebuilding index
    |\c cond_maxleafpct|Integer|maximum percentage of deleted leaf nodes before rebuilding index

    @subsection dba_indexes_pgsql PostgreSQL Options

    PostgreSQL uses \c REINDEX \c INDEX statement internally.

    There are no special options for PostgreSQL.

    @subsection dba_indexes_mysql MySQL Options

    MySQL does not offer any command to rebuild an index. Exception \c MYSQL-REBUILD-INDEX-ERROR is thrown if is the rebuildIndex method called for MySQL.

    Use reclaimSpace method for MySQL.

    @section dba_statistics Database Statistics

    - @ref SqlUtil::AbstractDatabase::computeStatistics()

    Database statistics are critical metadata used by SQL optimizers to build as good execution plans as possible.
    Some DB environments refresh statistics on regular basis, some not. All is usually highly configured by DBA.

    The optional argument holds options for statistics. These options are specific for each database server.
    See driver-specific modules for more info.

    @subsection dba_statistics_oracle Oracle Options

    Oracle uses \c DBMS_STATS package internally. With \c GATHER_SCHEMA_STATS or \c GATHER_TABLE_STATS depending on options set below.

    Statistics are calculated in currently logged user's schema.

    Please consult Oracle documentation for exact option meanings.

    |!Option|!Type|!Description
    |\c tables|list of strings|If it's set, the table by table statistics are computed with \c GATHER_TABLE_STATS. Otherwise the full schema with \c GATHER_SCHEMA_STATS is used.
    |\c estimate_percent|Integer|A percent as integer given. \c DBMS_STATS.AUTO_SAMPLE_SIZE is used as a default
    |\c block_sample|Boolean|Whether use random block sampling
    |\c method_opt|String|an optional size clause. By default "for all columns size auto" is used.
    |\c degree|Integer|a degree of parallelism. Default is NULL.
    |\c granularity|String|granularity of statistics to collect. Default is "ALL"
    |\c cascade|Boolean|True = gather statistics on indexes as well, False = do not make statistics for indexes. By default "dbms_stats.auto_cascade" is used.
    |\c stattab|String|user statistics table identifier describing where to save the current statistics
    |\c statid|String|identifier to associate with these statistics within \c stattab
    |\c options|String|further specification of which objects to gather statistics. By default "gather auto"
    |\c statown|String|schema containing \c stattab (if different than \c ownname)

    <b>Example:</b>
    Compute statistics for enumerated tables only.
    @code{.py}
hash<auto> opts = (
    "tables": ("workflows", "workflow_instance"),
);
db.computeStatistics(opts);
    @endcode

    @subsection dba_statistics_pgsql PostgreSQL Options

    PostgreSQL uses \c ANALYZE \c TABLE internally.

    |!Option|!Type|!Description
    |\c tables|list of strings|If it's set, the table by table statistics are computed. Otherwise all tables in the user DB are used.

    @subsection dba_statistics_mysql MySQL Options

    MySQL uses \c ANALYZE \c TABLE internally.

    Please consult MySQL documentation for exact option meanings.

    |!Option|!Type|!Description
    |\c tables|list of strings|If it's set, the table by table statistics are computed. Otherwise all tables in the user DB are used.
    |\c no-binlog|Boolean|If True, the "no_write_to_binlog" is used. If False (default), the "local" keyword is used.

    @section dba_space_management Space Management

    - @ref SqlUtil::AbstractDatabase::reclaimSpace()

    Space reclaiming can be done if there was a huge deletion from some tables. As usual causes are DB-dependent.

    The optional argument holds options for space management. These options are specific for each database server.
    See driver-specific modules for more info.

    @subsection dba_space_management_oracle Oracle Options

    Oracle uses \c ALTER \c TABLE \c SHRINK \c SPACE \c CASCADE statement internally. So it requires enabled row movement.

    Please consult Oracle documentation for more information.

    |!Option|!Type|!Description
    |\c tables|list of strings|If it's set, the table by table statistics are computed. Otherwise all tables in the user DB are used.

    @subsection dba_space_management_pgsql PostgreSQL Options

    PostgreSQL uses \c VACUUM internally.

    Please consult PostgreSQL documentation for exact option meanings.

    |!Option|!Type|!Description
    |\c tables|list of strings|If it's set, the table by table statistics are computed. Otherwise all tables in the user DB are used.
    |\c full|Boolean|True if \c full keyword should be used
    |\c analyze|Boolean|True if \c analyze keyword should be used

    @subsection dba_space_management_mysql MySQL Options

    MySQL uses \c OPTIMIZE \c TABLE internally.

    Please consult MySQL documentation for exact option meanings.

    |!Option|!Type|!Description
    |\c tables|list of strings|If it's set, the table by table statistics are computed. Otherwise all tables in the user DB are used.
    |\c no-binlog|Boolean|If True, the "no_write_to_binlog" is used. If False (default), the "local" keyword is used.
*/

#! the SqlUtil namespace contains all the objects in the SqlUtil module
public namespace SqlUtil {
    #! generic column description hash in schema descriptions
    public hashdecl GenericColumnInfo {
        #! a qore type string that will be converted to a native DB type with some default conversion
        string qore_type;
        #! the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
        string native_type;
        #! for data types requiring a size component, the size; for numeric columns this represents the precision for example
        softint size;
        #! for numeric data types, this value gives the scale
        softint scale;
        #! the default value for the column
        auto default_value;
        #! a boolean flag to say if a \c default_value should be validated against table column type (False) or used as it is (True) to allow to use DBMS native functions or features. Defaults to False. It is strongly recommended to use \c default_value_native for \c default_value in \c driver specific sub-hash to avoid non-portable schema hashes
        bool default_value_native = False;
        #! an optional comment for the column
        *string comment;
        #! if the column should have a "not null" constraint on it; if missing the default value is @ref False "False"
        bool notnull = False;
        #! this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the column description hash before processing; this way a column description hash can contain all the information required for the column including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys
        hash<string, hash> driver;
        #! @ref True "True" for DBs that support an auto-increment column
        *bool auto_increment;
    }

    #! SQL operator info hash as returned by all @ref sql_op_funcs "operator functions"
    public hashdecl OperatorInfo {
        string op;   #!< the operator string code
        auto arg;     #!< optional argument
    }

    #! column operator info hash as returned by all @ref sql_cop_funcs "column operator functions"
    public hashdecl ColumnOperatorInfo {
        string cop;  #!< the column operator string code
        auto column;  #!< column sopecifier, may be a string or a complex hash
        auto arg;     #!< optional argument
    }

    #! insert operator info hash as returned by all @ref sql_iop_funcs() "insert operator functions"
    public hashdecl InsertOperatorInfo {
        string _iop;  #!< the insert operator string code
        any arg;      #!< optional argument
    }

    #! update operator info hash as returned by all @ref sql_uop_funcs() "update operator functions"
    public hashdecl UpdateOperatorInfo {
        string uop;  #!< the update operator string code
        auto arg;     #!< optional argument
        *hash nest;  #!< option nested operation hash
    }

    #! join operator info hash as returned by all @ref sql_jop_funcs "join operator functions"
    public hashdecl JoinOperatorInfo {
        string jop;           #!< the join operator string code
        auto table;            #!< the table to join with (either an @ref SqlUtil::AbstractTable "AbstractTable" object or a string table name)
        *string alias;        #!< optional alias for \a table in the query
        *hash jcols;          #!< the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument
        *hash cond;           #!< additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        *string ta;           #!< optional table name or alias of the other table to join with when not joining with the primary table
        *hash<auto> opt;            #!< optional join options (for example, to specify a partition for the join if supported)
    }

    #! column data type options
    public hashdecl SqlUtilDataTypeOptionInfo {
        #! optional format string for converting strings to dates for date / timestamp columns
        *string date_format;

        #! the timezone when converting dates from external data to the DB's date
        *TimeZone data_timezone;

        #! the timezone to use when sending date/time values to the DB
        *TimeZone db_timezone;

        #! optional format string for converting strings to numeric / decimal / number columns
        *string number_format;

        #! optional flag to overrude any nullable attribute and require data for the column
        *softbool mandatory;

        #! optional additional limit to the maximum length of the data
        /** only takes effect if the value is smaller than the column's maximum length
        */
        *softint maxlen;
    }

    #! A hash describing SQL and arguments for an SQL DML command
    /** @since %SqlUtil 1.6
    */
    public hashdecl SqlCommandInfo {
        #! the SQL string for the update
        string sql;

        #! the arguments for the string
        list<auto> args;
    }

    /** @defgroup DBFeaturesConstants DB Features Constants
        These constants can be used as a lookup values in AbstractDatabase::features() method.
    */
    #@{
    #! Features constants

    #! Feature: functions
    public const DB_FUNCTIONS = "functions";
    #! Feature: materialized views / snapshots
    public const DB_MVIEWS = "materialized views";
    #! Feature: packages
    public const DB_PACKAGES = "packages";
    #! Feature: procedures
    public const DB_PROCEDURES = "procedures";
    #! Feature: sequences
    public const DB_SEQUENCES = "sequences";
    #! Feature: tables
    public const DB_TABLES = "tables";
    #! Feature: named types
    public const DB_TYPES = "named types";
    #! Feature: views
    public const DB_VIEWS = "views";
    #! Feature: synonyms
    public const DB_SYNONYMS = "synonyms";
    #@}

    /* @defgroup SqlTypeConstants SQL Type Constants
        These constants can be used for the \c "qore_type" values when creating columns to specify additional SQL column types
    */
    #@{
    #! specifies a \c VARCHAR column (equivalent to @ref Qore::Type::String)
    public const VARCHAR = "string";

    #! specifies a numeric column (equivalent to @ref Qore::Type::Number)
    public const NUMERIC = "number";

    #! specifies a \c CHAR column
    public const CHAR = "char";

    #! specifies a large variable-length binary column (ie \c BLOB or \c BYTEA, etc)
    public const BLOB = "blob";

    #! specifies a large variable-length character column (ie \c CLOB or \c TEXT, etc)
    public const CLOB = "clob";
    #@}

    /** @defgroup ColumnSizeOptions Column Size Options
        These constants represent the possible values for column size options
     */
    #@{
    #! the data type does not take a size parameter
    public const SZ_NONE = 0;

    #! the data type takes a mandatory size parameter
    public const SZ_MAND = 1;

    #! the data type takes an optional size parameter
    public const SZ_OPT = 2;

    #! the data type is numeric so takes an optional precision and scale
    public const SZ_NUM = 3;
    #@}

    /** @defgroup sql_cops SQL Column Operators
        These are the operators that can be used in the \c "columns" argument for select statements
     */
    #@{
    #! to rename a column on output
    /** @see cop_as()
    */
    public const COP_AS = "as";

    #! to convert column value into another datatype
    /** @see cop_cast()
    */
    public const COP_CAST = "cast";

    #! to prepend a string to a column on output
    /** @see cop_prepend()
    */
    public const COP_PREPEND = "prepend";

    #! to append a string to a column on output
    /** @see cop_append()
    */
    public const COP_APPEND = "append";

    #! to append a constant value (SQL Literal) to use as an output column value
    /** @see cop_value()
    */
    public const COP_VALUE = "value";

    #! to return column value in upper case
    /** @see cop_upper()
    */
    public const COP_UPPER = "upper";

    #! to return column value in lower case
    /** @see cop_lower()
    */
    public const COP_LOWER = "lower";

    #! to return distinct values
    /** @see cop_distinct
    */
    public const COP_DISTINCT = "distinct";

    #! to return the minimum value
    /** @see cop_min
    */
    public const COP_MIN = "min";

    #! to return the maximum value
    /** @see cop_max
    */
    public const COP_MAX = "max";

    #! to return the average value
    /** @see cop_avg
    */
    public const COP_AVG = "avg";

    #! to return the sum value
    /** @see cop_sum
    */
    public const COP_SUM = "sum";

    #! to return the row count
    /** @see cop_count
    */
    public const COP_COUNT = "count";

    #! the SQL \c "over" clause
    /** @see cop_over()
    */
    public const COP_OVER = "over";

    #! the SQL \c "minus" operator
    /** @see cop_minus()
    */
    public const COP_MINUS = "minus";

    #! the SQL \c "plus" operator
    /** @see cop_plus()
    */
    public const COP_PLUS = "plus";

    #! the SQL \c "divide" operator
    /** @see cop_divide()
    */
    public const COP_DIVIDE = "divide";

    #! the SQL \c "multiply" operator
    /** @see cop_multiply()
    */
    public const COP_MULTIPLY = "multiply";

    #! to return a date value with year information only
    /** @see cop_year()
    */
    public const COP_YEAR = "year";

    #! to return a date value with year to month information
    /** @see cop_year_month()
    */
    public const COP_YEAR_MONTH = "year_month";

    #! to return a date value with year to day information
    /** @see cop_year_day()
    */
    public const COP_YEAR_DAY = "year_day";

    #! to return a date value with year to hour information
    /** @see cop_year_hour()
    */
    public const COP_YEAR_HOUR = "year_hour";

    #! to return the next value of a sequence
    /** @see cop_seq()
    */
    public const COP_SEQ = "seq";

    #! to return the last value of a sequence issued in the same session
    /** @see cop_seq_currval()
    */
    public const COP_SEQ_CURRVAL = "seq_currval";

    #! to return the first non-null argument in the list
    /** @see cop_coalesce()
    */
    public const COP_COALESCE = "coalesce";

    #! to extract a substring from a column
    /** @see cop_substr()
    */
    public const COP_SUBSTR = "substr";

    #! to get the length of a text field
    /** @see cop_length()

        @since %SqlUtil 1.3.1
    */
    public const COP_LENGTH = "length";

    #! to return the date with truncated value
    /** @see cop_trunc_date()

        See also @ref sql_cop_trunc_date_enum

        @since %SqlUtil 1.4.0
     */
    public const COP_TRUNC_DATE = "truncate_date";

    #! Analytic (window) function: CUME_DIST
    /** @see cop_cume_dist()

        @since %SqlUtil 1.4.0
    */
    public const COP_CUME_DIST = "cume_dist";

    #! Analytic (window) function: DENSE_RANK
    /** @see cop_dense_rank()

        @since %SqlUtil 1.4.0
    */
    public const COP_DENSE_RANK = "dense_rank";

    #! Analytic (window) function: FIRST_VALUE
    /** @see cop_first_value()

        @since %SqlUtil 1.4.0
    */
    public const COP_FIRST_VALUE = "first_value";

    #! Analytic (window) function: LAST_VALUE
    /** @see cop_last_value()

        @since %SqlUtil 1.4.0
    */
    public const COP_LAST_VALUE = "last_value";

    #! Analytic (window) function: NTILE
    /** @see cop_ntile()

        @since %SqlUtil 1.4.0
    */
    public const COP_NTILE = "ntile";

    #! Analytic (window) function: PERCENT_RANK
    /** @see cop_percent_rank()

        @since %SqlUtil 1.4.0
    */
    public const COP_PERCENT_RANK = "percent_rank";

    #! Analytic (window) function: RANK
    /** @see cop_rank()

        @since %SqlUtil 1.4.0
    */
    public const COP_RANK = "rank";

    #! Analytic (window) function: ROW_NUMBER
    /** @see cop_row_number()

        @since %SqlUtil 1.4.0
    */
    public const COP_ROW_NUMBER = "row_number";

    #! a hash of default column operator descriptions
    public const DefaultCopMap = (
        COP_AS: (
            "arg": Type::String,
            "withalias": True,
            "code": string sub (string cve, string arg, reference psch) {
                # issue #2163: make sure the unquoted alias is inserted in the map
                if (arg =~ /^".*"$/)
                    psch{arg.substr(1, -1)} = cve;
                else
                    psch{arg} = cve;
                return sprintf("%s as %s", cve, arg);
            },
        ),
        COP_PREPEND: (
            "arg": Type::String,
            "sqlvalue": True,
            "code": string sub (string cve, string arg) {
                return sprintf("%s || %s", arg, cve);
            },
        ),
        COP_APPEND: (
            "arg": Type::String,
            "sqlvalue": True,
            "code": string sub (string cve, string arg) {
                return sprintf("%s || %s", cve, arg);
            },
        ),
        COP_VALUE: (
            "sqlvalue": True,
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return arg;
            },
        ),
        COP_UPPER: (
            "code": string sub (string cve, auto arg) {
                return sprintf("upper(%s)", cve);
            },
        ),
        COP_LOWER: (
            "code": string sub (string cve, auto arg) {
                return sprintf("lower(%s)", cve);
            },
        ),
        COP_DISTINCT: (
            "code": string sub (string cve, auto arg) {
                return sprintf("distinct %s", cve);
            },
        ),
        COP_MIN: (
            "code": string sub (string cve, auto arg) {
                return sprintf("min(%s)", cve);
            },
            "group": True,
        ),
        COP_MAX: (
            "code": string sub (string cve, auto arg) {
                return sprintf("max(%s)", cve);
            },
            "group": True,
        ),
        COP_AVG: (
            "code": string sub (string cve, auto arg) {
                return sprintf("avg(%s)", cve);
            },
            "group": True,
        ),
        COP_SUM: (
            "code": string sub (string cve, auto arg) {
                return sprintf("sum(%s)", cve);
            },
            "group": True,
        ),
        COP_COUNT: (
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return sprintf("count(%s)", cve ? cve : "*");
            },
        ),
        COP_MINUS: (
            "argcolumn": True,
            "code": string sub (string arg1, string arg2) {
                return sprintf("%s - %s", arg1, arg2);
            },
        ),
        COP_PLUS: (
            "argcolumn": True,
            "code": string sub (string arg1, string arg2) {
                return sprintf("%s + %s", arg1, arg2);
            },
        ),
        COP_DIVIDE: (
            "argcolumn": True,
            "code": string sub (string arg1, string arg2) {
                return sprintf("%s / %s", arg1, arg2);
            },
        ),
        COP_MULTIPLY: (
            "argcolumn": True,
            "code": string sub (string arg1, string arg2) {
                return sprintf("%s * %s", arg1, arg2);
            },
        ),
        COP_SEQ: (
            "nocolumn": True,
            "code": string sub (*string cve, hash<auto> arg) {
                throw "SEQUENCE-ERROR", sprintf("cannot select sequence %y because this database does not support sequences", arg.seq);
            }
        ),
        COP_SEQ_CURRVAL: (
            "nocolumn": True,
            "code": string sub (*string cve, hash<auto> arg) {
                throw "SEQUENCE-ERROR", sprintf("cannot select the current value of sequence %y because this database does not support sequences", arg.seq);
            }
        ),
        COP_COALESCE: (
            "columnargs": True,
            "code": string sub (*string cve, hash<auto> arg) {
                return sprintf("coalesce(%s)", (foldl $1 + "," + $2, arg.args));
            }
        ),
        COP_SUBSTR: (
            "code": string sub (string cve, list<auto> args) {
                if (!exists args[1])
                    return sprintf("substring(%s from %d)", cve, args[0]);
                return sprintf("substring(%s from %d for %d)", cve, args[0], args[1]);
            },
        ),
        COP_LENGTH: (
            "code": string sub (string cve, auto arg) {
                return sprintf("length(%s)", cve);
            },
        ),
        COP_OVER: (
            "columnargs" : True,
            "columnargs_ignore_nothings" : True,
            "code": string sub (*string cve, hash<auto> args)
            {
                *string partitionby = args.args[0];
                *string orderby = args.args[1];
                if (!exists partitionby && exists orderby) {
                    throw "COP-OVER-ERROR", "Argument 'partitionby' must be given in case of usage of 'orderby'";
                }
                string sql = cve + " over (";
                if (exists partitionby)
                    sql += sprintf("partition by %s", partitionby); # TODO/FIXME: sql injection!
                if (exists orderby)
                    sql += sprintf(" order by %s", orderby); # TODO/FIXME: sql injection!
                sql += ")";
                return sql;
            },
        ),
        COP_CUME_DIST: (
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return "cume_dist()";
            },
        ),
        COP_DENSE_RANK: (
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return "dense_rank()";
            },
        ),
        COP_FIRST_VALUE: (
            "code": string sub (string cve) {
                return sprintf("first_value(%s)", cve);
            },
        ),
        COP_LAST_VALUE: (
            "code": string sub (string cve) {
                return sprintf("last_value(%s)", cve);
            },
        ),
        COP_NTILE: (
            "sqlvalue": True,
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return sprintf("ntile(%d)", arg);
            },
        ),
        COP_PERCENT_RANK: (
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return "percent_rank()";
            },
        ),
        COP_RANK: (
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return "rank()";
            },
        ),
        COP_ROW_NUMBER: (
            "nocolumn": True,
            "code": string sub (*string cve, auto arg) {
                return "row_number()";
            },
        ),
        );
    #@}

    /** @defgroup sql_cop_funcs SQL Column Operator Functions
        These are functions that can be used in the \c "columns" argument for select statements:
        - @ref cop_append(): append a string to the output of a column
        - @ref cop_as(): rename columns
        - @ref cop_avg(): return the averge value for the given column when grouping
        - @ref cop_cast(): convert column value into another datatype
        - @ref cop_coalesce(): returns the first non-NULL value in the given columns
        - @ref cop_distinct(): add \c DISTINCT to the column name
        - @ref cop_length(): return the length of the given text column
        - @ref cop_lower(): return a column in lower case
        - @ref cop_max(): return the maximum value for the given column when grouping
        - @ref cop_min(): return the minimum value for the given column when grouping
        - @ref cop_over(): return a hash for the \c "over" operator for windowing functions
        - @ref cop_prepend(): prepend a string to the output of a column
        - @ref cop_seq(): increments the sequence and returns the next value
        - @ref cop_seq_currval(): returns the current value of the given sequence without changing the sequence
        - @ref cop_substr(): returns a substring of a text column
        - @ref cop_sum(): return the sum of all values for the given column when grouping
        - @ref cop_upper(): return a column in upper case
        - @ref cop_value(): return a constant value (SQL literal) in a column
        - @ref cop_year(): return the year of the given date column
        - @ref cop_year_day(): return the year to day value of the given date column
        - @ref cop_year_hour(): return the year to hour value of the given date column
        - @ref cop_year_month(): return the year and month value of the given date column
        - @ref cop_trunc_date(): return truncated date regarding the mask
        - @ref cop_cume_dist(): analytic/window function
        - @ref cop_dense_rank(): analytic/window function
        - @ref cop_first_value(): analytic/window function
        - @ref cop_last_value(): analytic/window function
        - @ref cop_ntile(): analytic/window function
        - @ref cop_percent_rank(): analytic/window function
        - @ref cop_rank(): analytic/window function
        - @ref cop_row_number(): analytic/window function

        Column operator functions can be nested as in the following example:
        @par Example:
        @code{.py}
*list<auto> rows = t.selectRows(("columns": cop_as(cop_lower("permission_type"), "perm"), "where": ("permission_type": "USER"), "limit": 100, "offset": 200));
        @endcode
     */
    #@{
    #! returns a @ref ColumnOperatorInfo hash
    /** @param cop the column operator (one of @ref sql_cops)
        @param column the column name
        @param arg the argument to the operator

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        @note Normally this function is not called directly, but rather by the other column operator functions
    */
    public hash<ColumnOperatorInfo> sub make_cop(string cop, auto column, auto arg) {
        switch (column.typeCode()) {
            case NT_HASH:
            case NT_STRING: return new hash<ColumnOperatorInfo>(("cop": cop, "column": column, "arg": arg));
            default: throw "MAKE-COLUMN-OPERATOR-ERROR", sprintf("invalid column value passed to make_cop(); got type %y, expecting \"string\" or \"hash\"", column.type());
        }
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "as" operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_as("errors", "error_count")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins) or any other column "cop_..." function
        @param arg the new name of the output column

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        @see SqlUtil::cop_value for SQL literals handling
    */
    public hash<ColumnOperatorInfo> sub cop_as(auto column, string arg) {
        return make_cop(COP_AS, column, arg);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "cast" operator with the given argument(s)
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_cast("id", "string")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins) or any other column "cop_..." function
        @param arg the new datatype to cast the column value(s) to
        @param arg1 optional, type dependent, specification (e.g. size or precision)
        @param arg2 optional, type dependent, specification (e.g. scale)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        @see SqlUtil::cop_value for SQL literals handling
    */
    public hash<ColumnOperatorInfo> sub cop_cast(auto column, string arg, auto arg1, auto arg2) {
        return make_cop(COP_CAST, column, (arg, arg1, arg2));
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "prepend" operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_prepend("name", "migrated-")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)
        @param arg the text to prepend to the row values in the output column

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_prepend(auto column, string arg) {
        return make_cop(COP_PREPEND, column, arg);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "append" operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_append("name", "-migrated")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)
        @param arg the text to append (ie concatenate) to the row values in the output column

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_append(auto column, string arg) {
        return make_cop(COP_APPEND, column, arg);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "value" (literal) operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_value(100)), "where": ("type": "user")));
        @endcode

        @param arg the value to be returned in the column

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        SQL literals can be useful in some cases - as dummy values for select
        statements where there is exact columns required, unions, expected values
        for \c arc.insertFromIterator(src.getStatement(sh))
        "insert as select", etc.

        The term literal refers to a fixed data value. For example, 123, 'foobar' etc.

        Mapping of Qore values to literals:

        |!Qore Type|!SQL Type|!Qore Example|!SQL interpretation
        |Integer|NUMBER as it is|\c 123|\c 123
        |Float|NUMBER as it is|\c 12.3|\c 12.3
        |Numeric|NUMBER as it is|\c 1.2n|\c 1.2
        |Date|String representation of the date using DB native implementation like TO_TIMESTAMP for Oracle.|\c now()|\c to_timestamp('20150421104825000000', 'YYYYMMDDHH24MISSFF6')
        |Bool|Internal representation of the bool value using DB native implementation|\c True|\c 1
        |String|Standard and escaped string literal. No additional literal methods like Oracle's <tt>nq{foobar}</tt> are supported now|\c "foo bar"|\c 'foo bar'
        |\c NULL|Direct null literal|\c NULL|\c null
        |\c NOTHING|Direct null literal|\c NOTHING|\c null

        @note Passing an existing SQL function name as a value to the cop_value() function
              does not result in function call. The string value is escaped as it is.
              Example: sysdate becomes 'sysdate'. See example below.

        The most useful SqlUtil::cop_value() usage is with cooperation of SqlUtil::cop_as() which allows
        human readable column name aliases.

        @warning Using SqlUtil::cop_value() without SqlUtil::cop_as() can result in errors
                 depending on the DB backend. For example Oracle's use of <tt>cop_value(1), cop_value(True)</tt>
                 ends with <tt>ORA-00918: column ambiguously defined</tt>
                 because both values are interpreted as 1 in the resulting SQL.

    <b>Example</b>
    @code{.py}
%new-style
%requires SqlUtil

DatasourcePool ds("oracle:pvanek_omq/omq@xbox(al32utf8)");
Database db(ds);
Table t(ds, "dual");

hash<auto> sh = (
    "columns" : (
        cop_as(cop_value(1), "as_int"),
        cop_as(cop_value(1.2), "as_float"),
        cop_as(cop_value(3.2n), "as_numeric"),
        cop_as(cop_value(now()), "as_date"),
        cop_as(cop_value("foo bar"), "as_string"),
        cop_as(cop_value("sysdate"), "as_function_call"),
        cop_as(cop_value(True), "as_bool"),
        cop_as(cop_value(NULL), "as_null"),
        cop_as(cop_value(NOTHING), "as_nothing"),
    ),
);
string sql;
on_exit { printf("sql: %s\n", sql); }
printf("%N\n", t.selectRow(sh, \sql));

# results in:
hash: (9 members)
  as_int : 1
  as_float : 1.2
  as_numeric : 3.2
  as_date : 2015-04-21 10:56:57.000000 Tue +02:00 (CEST)
  as_string : "foo bar"
  as_function_call : "sysdate"
  as_bool : 1
  as_null : <NULL>
  as_nothing : <NULL>
sql: select 1 as as_int,1.2 as as_float,3.2 as as_numeric,to_timestamp('20150421105657000000', 'YYYYMMDDHH24MISSFF6') as as_date,'foo bar' as as_string,'sysdate' as as_function_call,1 as as_bool,null as as_null,null as as_nothing from pvanek_omq.workflows fetch next %v rows only
    @endcode
    */
    public hash<ColumnOperatorInfo> sub cop_value(auto arg) {
        return make_cop(COP_VALUE, "", arg);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "upper" operator with the given argument; returns a column value in upper case
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_upper("name")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_upper(auto column) {
        return make_cop(COP_UPPER, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "lower" operator with the given argument; returns a column value in lower case
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_lower("name")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_lower(auto column) {
        return make_cop(COP_LOWER, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "distinct" operator with the given argument; returns distinct column values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_distinct("name")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_distinct(auto column) {
        return make_cop(COP_DISTINCT, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "min" operator; returns minimum column values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": (cop_min("id")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_min(auto column) {
        return make_cop(COP_MIN, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "max" operator; returns maximum column values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": (cop_max("id")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_max(auto column) {
        return make_cop(COP_MAX, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "avg" operator; returns average column values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": (cop_avg("quantity")), "where": ("order_type": "wholesale")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_avg(auto column) {
        return make_cop(COP_AVG, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "sum" operator; returns the total sum of a numeric column.
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": (cop_sum("quantity")), "where": ("order_type": "wholesale")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_sum(auto column) {
        return make_cop(COP_SUM, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "count" operator; returns row counts
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("account_type", cop_count()), "where": ("type": "user"), "groupby": "account_type"));
        @endcode

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_count(auto column = "") {
        return make_cop(COP_COUNT, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "over" clause
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("account_type", cop_count(), cop_as(cop_over(cop_max("qty"), "account_id"), "max_qty_per_account")), "where": ("type": "user"), "groupby": "account_type"));
        @endcode

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_over(auto column, *string partitionby, *string orderby) {
        list<auto> args = (partitionby, orderby, );
        return make_cop(COP_OVER, column, ("args" : args));
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "-" operator with the given arguments
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_minus("complete_count", "error_count")), "where": ("type": "user")));
        @endcode

        @param column1 the column specification for the first argument (string name or dot notation for use in joins)
        @param column2 the column specification for the second argument (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_minus(auto column1, auto column2) {
        return make_cop(COP_MINUS, column1, column2);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "+" operator with the given arguments
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_plus("complete_count", "error_count")), "where": ("type": "user")));
        @endcode

        @param column1 the column specification for the first argument (string name or dot notation for use in joins)
        @param column2 the column specification for the second argument (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_plus(auto column1, auto column2) {
        return make_cop(COP_PLUS, column1, column2);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "/" operator with the given arguments
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_divide("complete_count", "error_count")), "where": ("type": "user")));
        @endcode

        @param column1 the column specification for the first argument (string name or dot notation for use in joins)
        @param column2 the column specification for the second argument (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_divide(auto column1, auto column2) {
        return make_cop(COP_DIVIDE, column1, column2);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "*" operator with the given arguments
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_multiply("complete_count", "error_count")), "where": ("type": "user")));
        @endcode

        @param column1 the column specification for the first argument (string name or dot notation for use in joins)
        @param column2 the column specification for the second argument (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_multiply(auto column1, auto column2) {
        return make_cop(COP_MULTIPLY, column1, column2);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "year" operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_year("error_time")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_year(auto column) {
        return make_cop(COP_YEAR, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "year_month" operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_year_month("error_time")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_year_month(auto column) {
        return make_cop(COP_YEAR_MONTH, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "year_day" operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_year_day("error_time")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_year_day(auto column) {
        return make_cop(COP_YEAR_DAY, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "year_hour" operator with the given argument
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_year_hour("error_time")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_year_hour(auto column) {
        return make_cop(COP_YEAR_HOUR, column);
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "seq" operator with the given argument giving the sequence name whose value should be returned
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_seq("xid", "xis")), "where": ("type": "user")));
        @endcode

        @param seq the name of the sequence whose value should be returned
        @param as an optional column name that should be returned for the sequence value (so that @ref SqlUtil::cop_as() need not be used)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_seq(string seq, *string as) {
        return make_cop(COP_SEQ, "", ("seq": seq, "as": as));
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "seq_currval" operator with the given argument giving the sequence name whose current value should be returned
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", "name", cop_seq("xid", "xid_val"), cop_seq_currval("xid", "xid_current")), "where": ("type": "user")));
        @endcode

        @param seq the name of the sequence whose current value should be returned
        @param as an optional column name that should be returned for the sequence value (so that @ref SqlUtil::cop_as() need not be used)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_seq_currval(string seq, *string as) {
        return make_cop(COP_SEQ_CURRVAL, "", ("seq": seq, "as": as));
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "coalesce" operator with the given column arguments; the first non-NULL column value will be returned
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("first_name", "last_name", cop_colesce("first_name", "last_name")), "where": ("type": "user")));
        @endcode

        @param col1 the name or column operator hash for the first value
        @param col2 the name or column operator hash for the second value, additional values should follow this argument

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        @throw COALESCE-ERROR the arguments must be either string column designators or column operator hashes
    */
    public hash<ColumnOperatorInfo> sub cop_coalesce(auto col1, auto col2) {
        code check = sub (auto c) {
            if (c.typeCode() != NT_STRING && c.typeCode() != NT_HASH)
                throw "COALESCE-ERROR", sprintf("cop_coalesce() accepts string column designators or column operator hashes as arguments; got: %y", c);
        };
        # ensure at least two arguments
        check(col1);
        check(col2);
        # validate any remaining args
        map check($1), argv;

        list<auto> args = (col1, col2) + (argv ?? ());
        return make_cop(COP_COALESCE, "", ("args": args));
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "substr" operator with the given arguments; returns a substring of a column value
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_substr("name", 1, 1)), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)
        @param start position where the substring starts
        @param count length of the substring in characters

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash<ColumnOperatorInfo> sub cop_substr(auto column, int start, *int count) {
        return make_cop(COP_SUBSTR, column, (start, count));
    }

    #! returns a @ref ColumnOperatorInfo hash for the \c "len" operator with the given argument; returns the length of the given text field
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": ("id", cop_length("product_code")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a @ref ColumnOperatorInfo hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.3.1
    */
    public hash<ColumnOperatorInfo> sub cop_length(auto column) {
        return make_cop(COP_LENGTH, column);
    }

    #! Truncates a date column or value regarding the given mask. The resulting value remains Qore::date (no conversion to eg. string)
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("columns": cop_trunc_date("mydate", DF_MINUTE));
# input: 2017-02-01 14:22:37
# output 2017-02-01 14:22:00
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)
        @param mask the string with one of specified values rederenced in @ref sql_cop_trunc_date_enum

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_trunc_date(auto column, string mask) {
        if (!inlist(mask, DT_ALL_VALUES)) {
            throw "COP-TRUNC-DATE-ERROR", sprintf("Not allowed format argument: %n: allowed: %n", mask, DT_ALL_VALUES);
        }
        return make_cop(COP_TRUNC_DATE, column, mask);
    }


    #! Analytic/window function: relative rank of the current row
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_cume_dist(), "row_type", "id"), "cume_dist"),
    );

# rendered SQL statement
# select cume_dist() over (partition by row_type order by id) as "cume_dist" test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @return relative rank of the current row: (number of rows preceding or peer with current row) / (total rows)

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_cume_dist() {
        return make_cop(COP_CUME_DIST, "");
    }

    #! Analytic/window function: rank of the current row without gaps
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_dense_rank(), "row_type", "id"), "dense_rank"),
    );

# rendered SQL statement
select dense_rank() over (partition by row_type order by id) as "dense_rank" from test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @return rank of the current row without gaps; this function counts peer groups

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_dense_rank() {
        return make_cop(COP_DENSE_RANK, "");
    }

    #! Analytic/window function: value evaluated at the row that is the first row of the window frame
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_first_value("row_value"), "row_type", "id"), "first_value"),
    );

# rendered SQL statement
select first_value(row_value) over (partition by row_type order by id) as "first_value" from test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @return returns value evaluated at the row that is the first row of the window frame

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_first_value(any column) {
        return make_cop(COP_FIRST_VALUE, column);
    }

    #! Analytic/window function: value evaluated at the row that is the last row of the window frame
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_last_value("row_value"), "row_type", "id"), "last_value"),
    );

# rendered SQL statement
select last_value(row_value) over (partition by row_type order by id) as "last_value" from test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @return returns value evaluated at the row that is the last row of the window frame

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_last_value(any column) {
        return make_cop(COP_LAST_VALUE, column);
    }

    #! Analytic/window function: integer ranging from 1 to the argument value, dividing the partition as equally as possible
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_ntile(10), "row_type", "id"), "ntile"),
    );

# rendered SQL statement
select ntile(10) over (partition by row_type order by id) as "ntile" from test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @param value an integer value used as count of sp;it buckets

        @return integer ranging from 1 to the argument value, dividing the partition as equally as possible

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_ntile(int value) {
        return make_cop(COP_NTILE, "", value);
    }

    #! Analytic/window function: relative rank of the current row
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_percent_rank(), "row_type", "id"), "percent_rank"),
    );

# rendered SQL statement
select percent_rank() over (partition by row_type order by id) as "percent_rank" from test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @return relative rank of the current row: (rank - 1) / (total rows - 1)

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_percent_rank() {
        return make_cop(COP_PERCENT_RANK, "");
    }

    #! Analytic/window function: rank of the current row with gaps
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_rank(), "row_type", "id"), "rank"),
    );

# rendered SQL statement
select rank() over (partition by row_type order by id) as "rank" from test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @return rank of the current row with gaps; same as row_number of its first peer

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_rank() {
        return make_cop(COP_RANK, "");
    }

    #! Analytic/window function: number of the current row within its partition, counting from 1
    /** @par Example:
        @code{.py}
# with table structure (Schema module syntax)
const T_TestAnalyticFunctions = (
    "columns" : (
        "id" : c_number(),
        "row_type" : c_varchar(10),
        "row_value" : c_number(),
    ),
);

# select hash
hash<auto> sh = (
        "columns" : cop_as(cop_over(cop_row_number(), "row_type", "id"), "row_number"),
    );

# rendered SQL statement
select row_number() over (partition by row_type order by id) as "row_number" from test_analytic_functions;
        @endcode

        Analytic/window function. Must be used with @ref cop_over() with \c partitionby and \c orderby arguments

        @note MySQL DB family: This analytic function is available only in MariaDB 10.2 and later only.

        @return number of the current row within its partition, counting from 1

        @since %SqlUtil 1.4.0
    */
    public hash<ColumnOperatorInfo> sub cop_row_number() {
        return make_cop(COP_ROW_NUMBER, "");
    }

    #@}

    /** @defgroup sql_cop_trunc_date_enum cop_trunc_date formats
        These are formatting constant which can be used in @ref cop_trunc_date() formatting argument.

        Input date used in the table below: 20.4.2017 14:27:34

        |!Constant|!Meaning|!Example
        |@ref DT_YEAR|Truncate date up to year|1.1.2017 00:00:00
        |@ref DT_MONTH|Truncate date up to month|1.4.2017 00:00:00
        |@ref DT_DAY|Truncate date up to day|20.4.2017 00:00:00
        |@ref DT_HOUR|Truncate date up to hour|20.4.2017 14:00:00
        |@ref DT_MINUTE|Truncate date up to minute|20.4.2017 14:27:00
        |@ref DT_SECOND|Truncate date up to second|20.4.2017 14:27:34

        @note Oracle: using \c DT_SECOND for \c DATE type does not make sense as the \c DATE resolution
              is up to seconds out of the box. On the other side \c TINESTAMP is truncated up to seconds
              with this operator.

     */
    #@{
    #! Format unit: year
    public const DT_YEAR = "Y";

    #! Format unit: month
    public const DT_MONTH = "M";

    #! Format unit: day
    public const DT_DAY = "D";

    #! Format unit: hour
    public const DT_HOUR = "H";

    #! Format unit: minute
    public const DT_MINUTE = "m";

    #! Format unit: hour
    public const DT_SECOND = "S";

    # let's simulate and enum here'
    const DT_ALL_VALUES = ( DT_YEAR, DT_MONTH, DT_DAY, DT_HOUR, DT_MINUTE, DT_SECOND );
    #@}

    /** @defgroup sql_uops SQL Update Operators
        These are the operators that can be used in update statements to process column values automatically
     */
    #@{
    #! a hash of valid update operators
    public const DefaultUopMap = (
        COP_PREPEND: True,
        COP_APPEND: True,
        COP_UPPER: True,
        COP_LOWER: True,
        COP_MINUS: (
            "sqlvalue": True,
            "code": string sub (string cve, auto arg) {
                return sprintf("%s - %s", cve, arg);
            },
        ),
        COP_PLUS: (
            "sqlvalue": True,
            "code": string sub (string cve, auto arg) {
                return sprintf("%s + %s", cve, arg);
            },
        ),
        COP_DIVIDE: (
            "sqlvalue": True,
            "code": string sub (string cve, auto arg) {
                return sprintf("%s / %s", cve, arg);
            },
        ),
        COP_MULTIPLY: (
            "sqlvalue": True,
            "code": string sub (string cve, auto arg) {
                return sprintf("%s * %s", cve, arg);
            },
        ),
        COP_SUBSTR: True,
        COP_SEQ: (
            "nocolumn": True,
            "code": string sub (*string cve, string arg) {
                throw "SEQUENCE-ERROR", sprintf("cannot select sequence %y because this database does not support sequences", arg);
            }
        ),
        COP_SEQ_CURRVAL: (
            "nocolumn": True,
            "code": string sub (*string cve, string arg) {
                throw "SEQUENCE-ERROR", sprintf("cannot select the current value of sequence %y because this database does not support sequences", arg);
            }
        ),
        COP_COALESCE: (
            "columnargs": True,
            "code": string sub (*string cve, softlist<auto> args) {
                return sprintf("coalesce(%s)", (foldl $1 + "," + $2, args));
            }
        ),
        );
    #@}

    /** @defgroup sql_uop_funcs SQL Update Operator Functions
        These are functions that can be used as the values of update keys in select statements:
        - @ref uop_prepend(): prepend a string to the output of a column
        - @ref uop_append(): append a string to the output of a column
        - @ref uop_upper(): return a column in upper case
        - @ref uop_lower(): return a column in lower case
        - @ref uop_substr(): extract a substring from a column
        - @ref uop_plus(): add a numeric value to a column
        - @ref uop_minus(): subtract a numeric value from a column
        - @ref uop_multiply(): multiply a column by a numeric value
        - @ref uop_divide(): divide a column by a numeric value
        - @ref uop_seq(): returns the value of the given sequence
        - @ref uop_seq_currval(): returns the last value issued in the current session for the given sequence

        Update operator functions can be nested as in the following example:
        @par Example:
        @code{.py}
int rows_updated = t.update(("permission_type": uop_append("-migrated", uop_lower())));
        @endcode
     */
    #@{
    #! returns an @ref UpdateOperatorInfo hash
    /** @param uop the update operator (one of @ref sql_uops)
        @param arg the argument to the operator
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements

        @note Normally this function is not called directly, but rather by the other update operator functions
    */
    public hash<UpdateOperatorInfo> sub make_uop(string uop, auto arg, *hash<UpdateOperatorInfo> nest) {
        return new hash<UpdateOperatorInfo>(("uop": uop, "arg": arg, "nest": nest));
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "prepend" operator with the given argument
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("permission_type": uop_prepend("migrated-", uop_lower())));
        @endcode

        @param arg the text to prepend to the row values in the output column
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_prepend(string arg, *hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_PREPEND, arg, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "append" or concatenate operator with the given argument
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("permission_type": uop_append("-migrated", uop_lower())));
        @endcode

        @param arg the text to prepend to the row values in the output column
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_append(string arg, *hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_APPEND, arg, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "upper" operator with the given argument; returns a column value in upper case
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("permission_type": uop_upper()));
        @endcode

        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_upper(*hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_UPPER, NOTHING, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "lower" operator with the given argument; returns a column value in lower case
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("permission_type": uop_lower()));
        @endcode

        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_lower(*hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_LOWER, NOTHING, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "substr" operator with the given arguments; returns a substring of a column value
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("first_name": uop_substr(1, 1)));
        @endcode

        @param start position where the substring starts
        @param count length of the substring in characters
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_substr(int start, *int count, *hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_SUBSTR, (start, count), nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "+" operator with the given arguments
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("counter": uop_plus(1)));
        @endcode

        @param arg numeric value to add to the column
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_plus(auto arg, *hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_PLUS, arg, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "-" operator with the given arguments
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("counter": uop_minus(1)));
        @endcode

        @param arg numeric value to subtract from the column
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_minus(auto arg, *hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_MINUS, arg, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "*" operator with the given arguments
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("counter": uop_multiply(2)));
        @endcode

        @param arg numeric value to multiply the column by
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_multiply(auto arg, *hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_MULTIPLY, arg, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "/" operator with the given arguments
    /** @par Example:
        @code{.py}
int rows_updated = t.update(("counter": uop_divide(2)));
        @endcode

        @param arg numeric value to divide the column by
        @param nest any nested operation to the operator

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_divide(auto arg, *hash<UpdateOperatorInfo> nest) {
        return make_uop(COP_DIVIDE, arg, nest);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "seq" operator with the given argument giving the sequence name whose value should be returned
    /** @par Example:
        @code{.py}
*list<auto> rows = t.update(("id": uop_seq("xid")), ("type": "user"));
        @endcode

        @param seq the name of the sequence whose value should be returned

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_seq(string seq) {
        return make_uop(COP_SEQ, seq);
    }

    #! returns an @ref UpdateOperatorInfo hash for the \c "seq" operator with the given argument giving the sequence name whose current value should be returned
    /** @par Example:
        @code{.py}
*list<auto> rows = t.update(("id": uop_seq("xid")), ("type": "user"));
        @endcode

        @param seq the name of the sequence whose current value should be returned

        @return an @ref UpdateOperatorInfo hash corresponding to the arguments for use in update statements
    */
    public hash<UpdateOperatorInfo> sub uop_seq_currval(string seq) {
        return make_uop(COP_SEQ_CURRVAL, seq);
    }
    #@}

    /** @defgroup sql_jops SQL Join Operators
        These are the operators that can be used in the @ref select_option_join "join" argument in a @ref select_option_hash "select option hash"

        @note these operators are normally not used directly, but rather are used by the @ref sql_jop_funcs
    */
    #@{
    #! for standard inner joins
    /** @see join_inner()
    */
    public const JOP_INNER = "inner";

    #! for left outer joins
    /** @see join_left()
    */
    public const JOP_LEFT = "left";

    #! for right outer joins
    /** @see join_right()
    */
    public const JOP_RIGHT = "right";

    #! a hash of valid join operators
    public const JopMap = (
        JOP_INNER: "inner",
        JOP_LEFT: "left outer",
        JOP_RIGHT: "right outer",
        );
    #@}

    /** @defgroup sql_jop_funcs SQL Join Operator Functions
        These are functions that can be used in the @ref select_option_join "join" argument in a @ref select_option_hash "select option hash":
        - join_inner(): specifies an inner join
        - join_left(): specifies a left outer join
        - join_right(): specifies a right outer join

        @note for join functions, explicit join columns do not need to be specified in the case that a foreign key in one table exists to the primary key of the other table; in this case this information is assumed for the join automatically
     */
    #@{
    #! returns hash keyed with the table name assigned to a @ref JoinOperatorInfo hash
    /**
        @note this function is normally not used directly, but rather is called by the other @ref sql_jop_funcs
    */
    public hash<string, hash<JoinOperatorInfo>> sub make_jop(string jop, AbstractTable table, *string alias, *hash jcols, *hash cond, *string ta, *hash<auto> opt) {
        string hk = alias ? alias : table.getSqlName();
        return new hash<string, hash<JoinOperatorInfo>>((hk: cast<hash<JoinOperatorInfo>>(("jop": jop, "table": table, "jcols": jcols, "cond": cond, "alias": alias, "ta": ta, "opt": opt))));
    }

    #! returns a hash keyed with the table name assigned to a @ref JoinOperatorInfo hash
    /** This version is used for deferred table resolution at join time

        @note this function is normally not used directly, but rather is called by the other @ref sql_jop_funcs
    */
    public hash<string, hash<JoinOperatorInfo>> sub make_jop(string jop, string table_name, *string alias, *hash jcols, *hash cond, *string ta, *hash<auto> opt) {
        string hk = alias ? alias : table_name;
        return new hash<string, hash<JoinOperatorInfo>>((hk:  cast<hash<JoinOperatorInfo>>(("jop": jop, "table": table_name, "jcols": jcols, "cond": cond, "alias": alias, "ta": ta, "opt": opt))));
    }

    #! returns a hash for standard inner joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid"))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2)));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_inner(AbstractTable table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_INNER, table, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for standard inner joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid"))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2)));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_inner(Table table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_INNER, table.getTable(), alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for standard inner joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid"))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2)));
        @endcode

        @param table_name the table to join with; table will be subject to deferred resolution
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_inner(string table_name, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_INNER, table_name, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for standard inner joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid")) + join_inner("t2", table3)));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2)));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.3
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_inner(string ta, AbstractTable table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_INNER, table, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for standard inner joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid")) + join_inner("t2", table3)));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2)));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_inner(string ta, Table table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_INNER, table.getTable(), alias, jcols, cond, ta, opt);
    }

    #! returns a hash for standard inner joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2, "t2", ("id": "altid")) + join_inner("t2", table3)));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_inner(table2)));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table_name the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.3
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_inner_alias(string ta, string table_name, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_INNER, table_name, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for left outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_left(AbstractTable table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_LEFT, table, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for left outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_left(Table table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_LEFT, table.getTable(), alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for left outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table_name the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.3
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_left(string table_name, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_LEFT, table_name, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for left outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_left("t2", table3, "t3")));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_left("t2", table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_left(string ta, AbstractTable table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_LEFT, table, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for left outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_left("t2", table3, "t3")));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_left("t2", table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_left(string ta, Table table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_LEFT, table.getTable(), alias, jcols, cond, ta, opt);
    }

    #! returns a hash for left outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_left("t2", table3, "t3")));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_left(table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_left("t2", table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table_name the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.3
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_left_alias(string ta, string table_name, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_LEFT, table_name, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for right outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_right(AbstractTable table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_RIGHT, table, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for right outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_right(Table table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_RIGHT, table.getTable(), alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for right outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table_name the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.3
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_right(string table_name, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_RIGHT, table_name, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for right outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_right("t2", table3, "t3")));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_right("t2", table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_right(string ta, AbstractTable table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_RIGHT, table, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for right outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_right("t2", table3, "t3")));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_right("t2", table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_right(string ta, Table table, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_RIGHT, table.getTable(), alias, jcols, cond, ta, opt);
    }

    #! returns a hash for right outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_right("t2", table3, "t3")));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code{.py}
*list<auto> rows = table.selectRows(("join": join_right(table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_right("t2", table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table_name the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"

        @since %SqlUtil 1.3
    */
    public hash<string, hash<JoinOperatorInfo>> sub join_right_alias(string ta, string table_name, *string alias, *hash jcols, *hash cond, *hash<auto> opt) {
        return make_jop(JOP_RIGHT, table_name, alias, jcols, cond, ta, opt);
    }
    #@}

    /** @defgroup sql_ops SQL Operators
        These are the operators that can be used in where clauses; see @ref where_clauses for more information
     */
    #@{
    #! the SQL "like" operator for use in @ref where_clauses
    /** @see op_like()
    */
    public const OP_LIKE = "like";

    #! the SQL less than (<) operator for use in @ref where_clauses
    /** @see op_lt()
    */
    public const OP_LT = "<";

    #! the SQL less than or equals (<=) operator for use in @ref where_clauses
    /** @see op_le()
    */
    public const OP_LE = "<=";

    #! the SQL greater than operator (>) for use in @ref where_clauses
    /** @see op_gt()
    */
    public const OP_GT = ">";

    #! the SQL greater than or equals operator (>=) for use in @ref where_clauses
    /** @see op_ge()
    */
    public const OP_GE = ">=";

    #! the SQL not equals operator (!= or <>) for use in @ref where_clauses
    /** @see op_ne()
    */
    public const OP_NE = "!=";

    #! the SQL equals operator (=) for use in @ref where_clauses
    /** @see op_eq()
    */
    public const OP_EQ = "=";

    #! the SQL less than (<) operator for use in @ref where_clauses when comparing two columns
    /** @see op_clt()
    */
    public const OP_CLT = "C<";

    #! the SQL less than or equals (<=) operator for use in @ref where_clauses
    /** @see op_cle()
    */
    public const OP_CLE = "C<=";

    #! the SQL greater than operator (>) for use in @ref where_clauses
    /** @see op_cgt()
    */
    public const OP_CGT = "C>";

    #! the SQL greater than or equals operator (>=) for use in @ref where_clauses
    /** @see op_cge()
    */
    public const OP_CGE = "C>=";

    #! the SQL not equals operator (!= or <>) for use in @ref where_clauses
    /** @see op_cne()
    */
    public const OP_CNE = "C!=";

    #! the SQL equals operator (=) for use in @ref where_clauses
    /** @see op_ceq()
    */
    public const OP_CEQ = "C=";

    #! the SQL \c "between" operator for use in @ref where_clauses
    /** @see op_between()
    */
    public const OP_BETWEEN = "between";

    #! the SQL \c "in" operator for use in @ref where_clauses
    /** @see op_in()
    */
    public const OP_IN = "in";

    #! the SQL \c "not" operator for use in @ref where_clauses
    /** @see op_not()
    */
    public const OP_NOT = "not";

    #! the SQL \c "substr" operator for use in @ref where_clauses
    /** @see op_substr()
    */
    public const OP_SUBSTR = "substr";

    #! to combine SQL expressions with \c "or" for use in @ref where_clauses
    public const OP_OR = "or";

    #! a hash of valid operators for use in @ref where_clauses
    public const DefaultOpMap = (
        OP_LIKE: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                args += arg;
                return sprintf("%s like %v", cn);
            },
        ),
        OP_LT: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                args += arg;
                return sprintf("%s < %v", cn);
            },
        ),
        OP_LE: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                args += arg;
                return sprintf("%s <= %v", cn);
            },
        ),
        OP_GT: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                args += arg;
                return sprintf("%s > %v", cn);
            },
        ),
        OP_GE: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                args += arg;
                return sprintf("%s >= %v", cn);
            },
        ),
        OP_NE: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                if (arg === NULL || !exists arg)
                    return sprintf("%s is not null", cn);
                args += arg;
                return sprintf("(%s != %v or %s is null)", cn, cn);
            },
        ),
        OP_EQ: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                if (arg === NULL || !exists arg)
                    return sprintf("%s is null", cn);
                args += arg;
                return sprintf("%s = %v", cn);
            },
        ),
        OP_BETWEEN: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                args += arg[0];
                args += arg[1];
                return sprintf("%s between %v and %v", cn);
            },
        ),
        OP_IN: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                *string ins = (foldl $1 + "," + $2, (map t.getSqlValue($1), arg));
                return exists ins ? sprintf("%s in (%s)", cn, ins) : "1 != 1";
            },
        ),
        OP_NOT: (
            "recursive": True,
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                return sprintf("not (%s)", cn);
            },
        ),
        OP_CLT: (
            "argcolumn": True,
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                return sprintf("%s < %s", cn, arg);
            },
        ),
        OP_CLE: (
            "argcolumn": True,
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                return sprintf("%s <= %s", cn, arg);
            },
        ),
        OP_CGT: (
            "argcolumn": True,
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                return sprintf("%s > %s", cn, arg);
            },
        ),
        OP_CGE: (
            "argcolumn": True,
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                return sprintf("%s >= %s", cn, arg);
            },
        ),
        OP_CNE: (
            "argcolumn": True,
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                return sprintf("%s != %s", cn, arg);
            },
        ),
        OP_CEQ: (
            "argcolumn": True,
            "code": string sub (object t, string cn, string arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                return sprintf("%s = %s", cn, arg);
            },
        ),
        OP_SUBSTR: (
            "code": string sub (object t, string cn, auto arg, reference<list<auto>> args, *hash<auto> jch,
                bool join = False, *hash<auto> ch, *hash<auto> psch) {
                args += arg[0]; # start
                if (!exists arg[1]) {
                    args += arg[2]; # text
                    return sprintf("substring(%s from %v) = %v", cn);
                }
                args += arg[1]; # count
                args += arg[2]; # text
                return sprintf("substring(%s from %v for %v) = %v", cn);
            },
        ),
        OP_OR: (
            "code": string sub (object t, string cn, list<auto> arg, reference<list<auto>> args, *hash<auto> jch, bool join = False,
                *hash<auto> ch, *hash<auto> psch) {
                return t.getOrClause(arg, \args, jch, join, ch, psch);
            },
        ),
        );
    #@}

    /** @defgroup sql_op_funcs SQL Operator Functions
        These are the operators that can be used in where clauses; see @ref where_clauses for more information:
        - op_between(): for the \c "between" operator
        - op_in(): for the \c "in" operator
        - op_like(): for the \c "like" operator
        - op_substr(): for the \c "substr" operator
        - op_ge(): for the \c ">=" operator when comparing column values to immediate values
        - op_gt(): for the \c ">" operator when comparing column values to immediate values
        - op_le(): for the \c "<=" operator when comparing column values to immediate values
        - op_lt(): for the \c "<" operator when comparing column values to immediate values
        - op_ne(): for the \c "!=" or \c "<>" operator when comparing column values to immediate values
        - op_eq(): for the \c "=" operator when comparing column values to immediate values
        - op_not(): for negating other operators
        - op_cge(): for the \c ">=" operator when comparing the values of two columns
        - op_cgt(): for the \c ">" operator when comparing the values of two columns
        - op_cle(): for the \c "<=" operator when comparing the values of two columns
        - op_clt(): for the \c "<" operator when comparingthe values of two columns
        - op_cne(): for the \c "!=" or \c "<>" operator when comparing the values of two columns
        - op_ceq(): for the \c "=" operator when comparing the values of two columns
        - wop_or(): for combining SQL expressions with \c "or"
     */
    #@{
    #! returns an @ref OperatorInfo hash
    public hash<OperatorInfo> sub make_op(string op, auto arg) {
        return new hash<OperatorInfo>(("op": op, "arg": arg));
    }

    #! returns an @ref OperatorInfo hash for the \c "like" operator with the given argument for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_like("%smith%"))));
        @endcode

        @param str the argument for the operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"
    */
    public hash<OperatorInfo> sub op_like(string str) {
        return make_op(OP_LIKE, str);
    }

    #! returns an @ref OperatorInfo hash for the \c "<" operator with the given argument for use in @ref where_clauses "where clauses" when comparing column values to immediate values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_lt("Zebra"))));
        @endcode

        @param arg the argument for the operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_clt() for a function to be used when comparing two column values
    */
    public hash<OperatorInfo> sub op_lt(auto arg) {
        return make_op(OP_LT, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "<=" operator with the given argument for use in @ref where_clauses "where clauses" when comparing column values to immediate values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_le("Zebra"))));
        @endcode

        @param arg the argument for the operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_cle() for a function to be used when comparing two column values
    */
    public hash<OperatorInfo> sub op_le(auto arg) {
        return make_op(OP_LE, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c ">" operator with the given argument for use in @ref where_clauses "where clauses" when comparing column values to immediate values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_gt("Apple"))));
        @endcode

        @param arg the argument for the operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_cgt() for a function to be used when comparing two column values
    */
    public hash<OperatorInfo> sub op_gt(auto arg) {
        return make_op(OP_GT, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c ">=" operator with the given argument for use in @ref where_clauses "where clauses" when comparing column values to immediate values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_ge("Apple"))));
        @endcode

        @param arg the argument for the operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_cge() for a function to be used when comparing two column values
    */
    public hash<OperatorInfo> sub op_ge(auto arg) {
        return make_op(OP_GE, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "!=" or \c "<>" operator with the given argument for use in @ref where_clauses "where clauses" when comparing column values to immediate values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_ne("Smith"))));
        @endcode

        @param arg the argument for the operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_cne() for a function to be used when comparing two column values

        This operator also handles Qore::NULL as SQL NULL values expanding them into <tt>IS NOT NULL</tt> clause.
    */
    public hash<OperatorInfo> sub op_ne(auto arg) {
        return make_op(OP_NE, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "=" operator with the given argument for use in @ref where_clauses "where clauses" when comparing column values to immediate values
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_eq("Smith"))));
        @endcode

        @param arg the argument for the operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_ceq() for a function to be used when comparing two column values

        This operator also handles Qore::NULL as SQL NULL values expanding them into <tt>IS NULL</tt> clause.
    */
    public hash<OperatorInfo> sub op_eq(auto arg) {
        return make_op(OP_EQ, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "between" operator with the given arguments, neither of which can be @ref null or @ref nothing; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_between("US", "UX"))));
        @endcode

        @param l the lower bound for the \c "between" operator
        @param r the upper bound for the \c "between" operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @throw BETWEEN-ERROR one or both of the required arguments are @ref null or @ref nothing
     */
    public hash<OperatorInfo> sub op_between(auto l, auto r) {
        if (!exists l || l === NULL)
            throw "BETWEEN-ERROR", sprintf("the first argument is %y; both arguments to op_between() must be values that can be used with the BETWEEN operator (ie not NULL or NOTHING)", l);
        if (!exists r || r === NULL)
            throw "BETWEEN-ERROR", sprintf("the second argument is %y; both arguments to op_between() must be values that can be used with the BETWEEN operator (ie not NULL or NOTHING)", r);
        return make_op(OP_BETWEEN, (l, r));
    }

    #! returns an @ref OperatorInfo hash for the \c "in" operator with all arguments passed to the function; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_in(200, 300, 500, 9))));
        @endcode

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @note The argument list size may be constrained depending on the database server / driver used; passing a large number of arguments to this function may be a sign of an improper application or query design; consider using a join with a temporary table instead of passing a large number of arguments to this function
    */
    public hash<OperatorInfo> sub op_in() {
        return make_op(OP_IN, argv);
    }

    #! returns an @ref OperatorInfo hash for the \c "in" operator with the given argument list as the first argument; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_in(idlist))));
        @endcode

        @param args a list of values for the \c "in" operator

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @note The argument list size may be constrained depending on the database server / driver used; passing a large number of arguments to this function may be a sign of an improper application or query design; consider using a join with a temporary table instead of passing a large number of arguments to this function
    */
    public hash<OperatorInfo> sub op_in(list<auto> args) {
        return make_op(OP_IN, args);
    }

    #! returns an @ref OperatorInfo hash for the \c "not" operator; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": opt_not(op_in(200, 300, 500, 9))))_;
        @endcode

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"
    */
    public hash<OperatorInfo> sub op_not(hash arg) {
        return make_op(OP_NOT, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "<" operator with the given argument for use in @ref where_clauses "where clauses" when comparing the values of two columns
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_clt("other_name"))));
        @endcode

        @param arg the name of the column to compare against

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_lt() for a function to be used when comparing a column against an immediate value
    */
    public hash<OperatorInfo> sub op_clt(string arg) {
        return make_op(OP_CLT, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "<=" operator with the given argument for use in @ref where_clauses "where clauses" when comparing the values of two columns
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_cle("other_name"))));
        @endcode

        @param arg the name of the column to compare against

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_le() for a function to be used when comparing a column against an immediate value
    */
    public hash<OperatorInfo> sub op_cle(string arg) {
        return make_op(OP_CLE, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c ">" operator with the given argument for use in @ref where_clauses "where clauses" when comparing the values of two columns
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_cgt("other_name"))));
        @endcode

        @param arg the name of the column to compare against

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_gt() for a function to be used when comparing a column against an immediate value
    */
    public hash<OperatorInfo> sub op_cgt(string arg) {
        return make_op(OP_CGT, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c ">=" operator with the given argument for use in @ref where_clauses "where clauses" when comparing the values of two columns
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_cge("other_name"))));
        @endcode

        @param arg the name of the column to compare against

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_ge() for a function to be used when comparing a column against an immediate value
    */
    public hash<OperatorInfo> sub op_cge(string arg) {
        return make_op(OP_CGE, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "!=" or \c "<>" operator with the given argument for use in @ref where_clauses "where clauses" when comparing the values of two columns
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_cne("other_name"))));
        @endcode

        @param arg the name of the column to compare against

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_ne() for a function to be used when comparing a column against an immediate value
    */
    public hash<OperatorInfo> sub op_cne(string arg) {
        return make_op(OP_CNE, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "=" operator with the given argument for use in @ref where_clauses "where clauses" when comparing the values of two columns
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_ceq("other_name"))));
        @endcode

        @param arg the name of the column to compare against

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"

        @see op_eq() for a function to be used when comparing a column against an immediate value
    */
    public hash<OperatorInfo> sub op_ceq(string arg) {
        return make_op(OP_CEQ, arg);
    }

    #! returns an @ref OperatorInfo hash for the \c "substr" operator with the given arguments; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_substr(1, 6, "Martin"))));
        @endcode

        @param start position where the substring starts
        @param count length of the substring in characters
        @param text what substring should match

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"
     */
    public hash<OperatorInfo> sub op_substr(int start, *int count, string text) {
        return make_op(OP_SUBSTR, (start, count, text));
    }

    #! returns an @ref OperatorInfo hash for the \c "substr" operator with the given arguments; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("hex": op_substr(5, "BEEF"))));
        @endcode

        @param start position where the substring starts
        @param text what substring should match

        @return an @ref OperatorInfo hash for use in @ref where_clauses "where clauses"
     */
    public hash<OperatorInfo> sub op_substr(int start, string text) {
        return make_op(OP_SUBSTR, (start, NOTHING, text));
    }

    #! returns an @ref OperatorInfo hash with a fake \c "_OR_" column name; the list of arguments to the function is combined such that each hash in the list generates SQL expressions combined with \a "and" logic, and each of those clauses is combined with \a "or" logic; this is for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code{.py}
*list<auto> rows = table.selectRows(("where": ("name": op_ceq("other_name")) + wop_or(("type": "C", "validation_flag": op_ne(NULL)), ("expiration_date": op_ge(date)))));
        @endcode
        Generates:
        @verbatim
select * from schema.table where name = other_name and ((type = %v and validation flag is not null) or (expiration_date >= %v))
        @endverbatim

        @param h1 the first hash of expressions to combine with \c "or" logic
        @param h2 the second hash of expressions to combine with \c "or" logic
        @param ... remaining expressions to combine with \c "or" logic

        @return a hash with an @ref OperatorInfo hash value keyed by a fake column name (\c "_OR_" with a numeric prefix for uniqueness) for use in a where operation description hash for use in @ref where_clauses "where clauses"

        @note a random prefix is used so that multiple uses of the function can be used to generate a single @ref where_clauses "where clause hash"
    */
    public hash<string, hash<OperatorInfo>> sub wop_or(hash h1, hash h2) {
        softlist l = h1;
        l += h2;
        if (argv)
            l += argv;
        return new hash<string, hash<OperatorInfo>>((sprintf("%d:_OR_", rand() % 10000000): make_op(OP_OR, l)));
    }
    #@}

    /** @defgroup sql_iops SQL Insert Operators
        These are operators that can be used for special value functions as the values of inserted columns.

        @note these operators are normally not used directly, but rather are used by the @ref sql_iop_funcs
    */
    #@{
    #! for using the value of a sequence
    /** @see iop_seq()
    */
    public const IOP_SEQ = "seq";

    #! for using the last value of a sequence issued in the current session
    /** @see iop_seq_currval()
    */
    public const IOP_SEQ_CURRVAL = "seq_currval";

    #! a hash of default insert operator descriptions (currently empty, all operators are driver-dependent)
    public const DefaultIopMap = {};
    #@}

    /** @defgroup sql_iop_funcs SQL Insert Operator Functions
        These are functions that can be used to give special values in insert queries
        - @ref iop_seq(): insert the value of a sequence into the column
    */
    #@{
    #! returns an @ref InsertOperatorInfo hash
    /** @param iop the value operator (one of @ref sql_iops)
        @param arg the argument to the operator

        @return an @ref InsertOperatorInfo hash corresponding to the arguments for use as values in insert queries

        @note Normally this function is not called directly, but rather by the other insert operator functions
    */
    public hash<InsertOperatorInfo> sub make_iop(string iop, auto arg) {
        return new hash<InsertOperatorInfo>(("_iop": iop, "arg": arg));
    }

    #! returns an @ref InsertOperatorInfo hash for retrieving the value of the given sequence in insert queries
    /** @par Example:
        @code{.py}
table.insert(("id": id, "ref": iop_seq("xid")));
        @endcode

        @param arg the name of the sequence whose value should be inserted into the column

        @return an @ref InsertOperatorInfo hash corresponding to the arguments for use in insert queries
    */
    public hash<InsertOperatorInfo> sub iop_seq(string arg) {
        return make_iop(IOP_SEQ, arg);
    }

    #! returns an @ref InsertOperatorInfo hash for retrieving the current value of the given sequence in insert queries
    /** @par Example:
        @code{.py}
table.insert(("id": id, "ref": iop_seq("xid"), "ref2": iop_seq_currval("xid")));
        @endcode

        @param arg the name of the sequence whose current value should be inserted into the column

        @return an @ref InsertOperatorInfo hash corresponding to the arguments for use in insert queries
    */
    public hash<InsertOperatorInfo> sub iop_seq_currval(string arg) {
        return make_iop(IOP_SEQ_CURRVAL, arg);
    }
    #@}

    #! known drivers
    public const SqlUtilDrivers = (
        "oracle",
        "pgsql",
        "mysql",
        "freetds",
        "sybase",
    );

    # private variable to store the closure used to deserialize datasources (if any)
    our code ds_get;

    # private variable to store the closure used to serialize datasources (if any)
    our code ds_do;

    #! registers a closure or call reference taking a string type and string datasource configuration that will return an AbstractDatasource
    public sub sqlutil_register_ds_deserializer(*code new_ds_get) {
        ds_get = new_ds_get;
    }

    #! registers a closure or call reference taking a string type and string datasource configuration that will return an AbstractDatasource
    public sub sqlutil_register_ds_serializer(*code new_ds_do) {
        ds_do = new_ds_do;
    }

    # private function used to deserialize datasources
    AbstractDatasource sub sqlutil_get_ds(string type, string config) {
        if (ds_get) {
            return ds_get(type, config);
        }

        switch (type) {
            case "DatasourcePool":
                return new DatasourcePool(config);
            case "Datasource":
                return new Datasource(config);
            default:
                throw "DATASOURCE-DESERIALIZATION-ERROR", sprintf("cannot deserialize datasource of unknown type %y with config %y", type, config);
        }
    }

    # private function used to serialize datasources
    hash<auto> sub sqlutil_ds(AbstractDatasource ds) {
        if (ds_do) {
            return ds_do(ds);
        }

        return {
            "ds_type": ds.className(),
            "ds": ds.getConfigString(),
        };
    }

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractHashContainer inherits Serializable {
        public {}

        private {
            #! the data to be contained
            *hash h;
        }

        #! creates the object with the hash argument passed
        constructor(*hash nh) {
            h = nh;
        }

        #! creates a copy of the object
        constructor(AbstractHashContainer old) {
            h = old.h;
        }

        #! creates a "deep copy" of the object
        copy(AbstractHashContainer old) {
            map h.$1 = old.h.$1.copy(), old.h.keyIterator();
        }

        #! returns the value of the given key in the contained hash if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        auto memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        #! purges the contained data
        /** @par Example:
            @code{.py}
c.clear();
            @endcode

        */
        clear() {
            delete h;
        }

        #! removes the given key from the contained hash and returns the value
        abstract auto take(string k);

        #! renames the given key; maintains the key order
        renameKey(string old_name, string new_name) {
            h = map {$1.key == old_name ? new_name : $1.key: $1.value}, h.pairIterator();
        }

        #! returns the hash contained by this object
        *hash<auto> getHash() {
            return h;
        }

        #! returns @ref True "True" if the hash argument has the same keys (in any order), @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = c.matchKeys(h);
            @endcode

            @param h1 the hash to compare

            @return @ref True "True" if the hash argument has the same keys (in any order), @ref False "False" if not
        */
        bool matchKeys(hash h1) {
            if (h.size() != h1.size())
                return False;

            foreach string k in (h.keyIterator()) {
                if (!h1.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref True "True" if the list<auto> argument has the same list of key strings as the keys in the object (in any order), @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = c.matchKeys(l);
            @endcode

            @param l the hash to compare

            @return @ref True "True" if the list<auto> argument has the same list of key strings as the keys in the object (in any order), @ref False "False" if not
        */
        bool matchKeys(list<auto> l) {
            if (h.size() != l.size())
                return False;

            foreach string k in (l) {
                if (!h.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref True "True" if the container argument has the same keys (in any order), @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = c.matchKeys(c1);
            @endcode

            @param c the container to compare

            @return @ref True "True" if the container argument has the same keys (in any order), @ref False "False" if not
        */
        bool matchKeys(AbstractHashContainer c) {
            return matchKeys(c.h);
        }

        #! returns @ref True "True" if the hash argument has at least the same keys (in any order, can have more keys), @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = c.partialMatchKeys(h);
            @endcode

            @param h1 the hash to compare

            @return @ref True "True" if the hash argument has at least the same keys (in any order, can have more keys), @ref False "False" if not
        */
        bool partialMatchKeys(hash h1) {
            if (h.size() > h1.size())
                return False;

            foreach string k in (h.keyIterator()) {
                if (!h1.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref True "True" if the list<auto> argument has at least the same keys (in any order, can have more keys), @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = c.partialMatchKeys(l);
            @endcode

            @param l the list of strings to compare

            @return @ref True "True" if the list<auto> argument has at least the same keys (in any order, can have more keys), @ref False "False" if not
        */
        bool partialMatchKeys(list<auto> l) {
            if (h.size() > l.size())
                return False;

            # make a hash of the list for quick searching
            hash<string, bool> h1 = map {$1: True}, l;

            foreach string k in (keys h) {
                if (!h1{k})
                    return False;
            }

            return True;
        }

        #! returns @ref True "True" if the container argument has at least the same keys (in any order, can have more keys), @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = c.partialMatchKeys(c1);
            @endcode

            @param c the container to compare

            @return @ref True "True" if the container argument has at least the same keys (in any order, can have more keys), @ref False "False" if not
        */
        bool partialMatchKeys(AbstractHashContainer c) {
            return partialMatchKeys(c.h);
        }

        #! Returns @ref False "False" if the contained hash has no keys, @ref True "True" if it does
        /** @par Example:
            @code{.py}
bool b = h.val();
            @endcode

            The opposite of empty()

            @return @ref False "False" if the contained hash has no keys, @ref True "True" if it does
        */
        bool val() {
            return h.val();
        }

        #! Returns a list of key names of the contained hash
        /** @par Example:
            @code{.py}
list<string> l = h.keys();
            @endcode

            @return a list of key names of the contained hash
        */
        list<string> keys() {
            return h.keys();
        }

        #! Returns a list of values of the contained hash
        /** @par Example:
            @code{.py}
list<auto> l = h.values();
            @endcode

            @return a list of values of the contained hash
        */
        list<auto> values() {
            return h.values();
        }

        #! Returns a @ref Qore::HashIterator "HashIterator" object for the contained hash
        /** @par Example:
            @code{.py}
map printf("+ %y\n", $1.value), h.iterator();
            @endcode

            @return a @ref Qore::HashIterator "HashIterator" object for the contained hash
        */
        Qore::AbstractIterator iterator() {
            return h.iterator();
        }

        #! Returns a @ref Qore::HashKeyIterator "HashKeyIterator" object for the contained hash
        /** @par Example:
            @code{.py}
map printf("+ %s\n", $1), h.keyIterator();
            @endcode

            @return a @ref Qore::HashKeyIterator "HashKeyIterator" object for the contained hash
        */
        Qore::AbstractIterator keyIterator() {
            return h.keyIterator();
        }

        #! Returns a @ref Qore::HashPairIterator "HashPairIterator" object for the contained hash
        /** @par Example:
            @code{.py}
map printf("+ %s: %y\n", $1.key, $1.value), h.pairIterator();
            @endcode

            @return a @ref Qore::HashPairIterator "HashPairIterator" object for the contained hash
        */
        Qore::AbstractIterator pairIterator() {
            return h.pairIterator();
        }

        #! returns @ref True "True" if the container is empty, @ref False "False" if not
        bool empty() {
            return h.empty();
        }

        #! Returns the number of keys in the contained hash
        /** @par Example:
            @code{.py}
int num = h.size();
            @endcode

            @return the number of keys in the contained hash
        */
        int size() {
            return h.size();
        }

        #! Returns @ref True "True" if the key exists in the contained hash (may or may not be assigned a value), @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = h.hasKey(key);
            @endcode

            @param k the key name to check

            @return @ref True "True" if the key exists in the contained hash (may or may not be assigned a value), @ref False "False" if not
        */
        bool hasKey(string k) {
            return h.hasKey(k);
        }

        #! Returns @ref True "True" if the key exists in the contained hash and is assigned a value, @ref False "False" if not
        /** @par Example:
            @code{.py}
bool b = h.hasKeyValue(key);
            @endcode

            @param k the key name to check

            @return @ref True "True" if the key exists in the contained hash and is assigned a value, @ref False "False" if not
        */
        bool hasKeyValue(string k) {
            return h.hasKeyValue(k);
        }

        #! Returns the first key name in the contained hash or @ref nothing if the contained hash has no keys
        /** @par Example:
            @code{.py}
*string n = h.firstKey();
            @endcode

            @return the first key name in the contained hash or @ref nothing if the contained hash has no keys

            @see lastKey()
        */
        *string firstKey() {
            return h.firstKey();
        }

        #! Returns the last key name in the contained hash or @ref nothing if the contained hash has no keys
        /** @par Example:
            @code{.py}
*string n = h.lastKey();
            @endcode

            @return the last key name in the contained hash or @ref nothing if the contained hash has no keys

            @see firstKey()
        */
        *string lastKey() {
            return h.lastKey();
        }

        #! must return the name of the contained element
        abstract string getElementName();
    }

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractListContainer inherits Serializable {
        public {}

        private {
            softlist l;
        }

        #! creates the object with the list<auto> argument passed
        constructor(softlist nl) {
            l = nl;
        }

        #! returns the value of the given element in the contained list if it exists, otherwise throws an \c ELEMENT-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.get(2);
            @endcode

            @param i the index of the element to access

            @return the value of the given index in the contained list if it exists

            @throw ELEMENT-ERROR the given element does not exist in the contained list
        */
        abstract auto get(softint i);

        #! adds the given value to the list
        add(auto val) {
            l += val;
        }

        #! removes the given element from the contained list and returns the value
        auto take(int i) {
            checkIndex(i);
            return extract l, i, 1;
        }

        #! returns the list contained by this object
        list<auto> getList() {
            return l;
        }

        #! Returns @ref False "False" if the contained list is empty, @ref True "True" if not
        /** @par Example:
            @code{.py}
bool b = l.val();
            @endcode

            The opposite of empty()

            @return @ref False "False" if the contained list is empty, @ref True "True" if not
        */
        bool val() {
            return l.val();
        }

        #! Returns a @ref Qore::ListIterator "ListIterator" object for the contained list
        /** @par Example:
            @code{.py}
map printf("+ %s: %y\n", $1), h.iterator();
            @endcode

            @return a @ref Qore::HashIterator "HashIterator" object for the contained hash
        */
        Qore::ListIterator iterator() {
            return l.iterator();
        }

        #! returns @ref True "True" if the container is empty, @ref False "False" if not
        bool empty() {
            return l.empty();
        }

        #! Returns the number of elements in the contained list
        /** @par Example:
            @code{.py}
int num = l.size();
            @endcode

            @return the number of elements in the contained list
        */
        int size() {
            return l.size();
        }

        #! must return the name of the contained element
        abstract string getElementName();

        private checkIndex(int i) {
            if (i < 0 || i >= l.size())
                throw "ELEMENT-ERROR", sprintf("cannot access %s element %d; total elements: %d", getElementName(), i, l.size());
        }
    }

    #! the table container class stores a collection of tables in a schema
    public class Tables inherits AbstractHashContainer {
        #! creates an empty object
        constructor() {
        }

        #! creates and populates the object from a hash<auto> description
        constructor(AbstractDatasource ds, hash tables, *hash<auto> opt) {
            populate(ds, tables, opt);
        }

        #! creates and populates the object from tables in the database
        constructor(AbstractDatasource ds) {
            populate(ds);
        }

        #! adds the given value to the hash with the given key name
        add(string k, Table val) {
            h{k} = val.getTable();
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractTable val) {
            h{k} = val;
        }

        #! adds the given value to the hash with the given key name
        add(Table val) {
            h{val.getName()} = val.getTable();
        }

        #! adds the given value to the hash with the given key name
        add(AbstractTable val) {
            h{val.getName()} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractTable take(string k) {
            return remove h{k};
        }

        #! populates the object from a hash<auto> description
        populate(AbstractDatasource ds, hash tables, *hash<auto> opt) {
            delete h;
            AbstractDatabase::checkDriverOptions(\tables, ds.getDriverName());
            foreach string name in (tables.keyIterator()) {
                if (h.hasKey(name))
                    continue;
                if (tables{name}.typeCode() != NT_HASH) {
                    throw "ALIGN-TABLE-ERROR",
                            sprintf("table '%s' schema definition has to be hash, but it's %s",
                                    name, tables{name}.type());
                }
                hash th = tables{name} - "rename";
                # create table template
                Table t(ds, th, name, opt + ("table_cache": self));
                # store in table_cache
                h{name} = t.getTable();
            }
        }

        #! populates the object from tables in the database
        populate(AbstractDatasource ds) {
            delete h;
            Database db(ds);
            foreach string name in (db.tableIterator()) {
                if (h{name}) {
                    h{name}.cache();
                    continue;
                }
                Table t(ds, name);
                t.cache(("table_cache": self));
                h{name} = t.getTable();
            }
        }

        #! returns a list of SQL strings that can be used to drop all the foreign constraints on a particular table
        /** @par Example:
            @code{.py}
*list<auto> l = tables.getDropAllForeignConstraintsOnTableSql(name);
            @endcode

            Make sure that all relevant tables are cached before calling this method; if the table is not cached, then @ref nothing is returned

            @param name the name of the table to find all the foreigjn constraints for
            @param opt a hash of options for the SQL strings; see @ref AbstractDatabase::DropSchemaOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to drop all the foreign constraints on a particular table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list<auto> getDropAllForeignConstraintsOnTableSql(string name, *hash<auto> opt) {
            if (!h{name})
                return;

            AbstractTable t = h{name};

            list l = ();
            foreach AbstractUniqueConstraint uk in (t.getUniqueConstraintIterator()) {
                foreach hash<auto> sch in (uk.getSourceConstraintIterator()) {
                    l += AbstractDatabase::doCallback(opt, sch.fk.getDropSql(sch.table), AbstractDatabase::AC_Drop, "foreign constraint", sch.fk.getName(), sch.table);
                    string tn = sch.table;
                    tn =~ s/.*\.//;
                    if (opt.sql_callback_executed && h{tn})
                        h{tn}.removeForeignConstraint(sch.fk.getName());
                }
            }

            return l;
        }

        #! returns the AbstractTable object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code{.py}
AbstractTable t = tables.table_name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        AbstractTable memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        #! returns \c "table" since this object stores AbstractTable objects
        string getElementName() {
            return "table";
        }

        #! gets a table from the database or from the cache if already cached; if the table does not exist, then @ref nothing is returned
        *AbstractTable getIfExists(AbstractDatasource ds, string name) {
            if (h{name})
                return h{name};

            Table t(ds, name);
            if (!t.checkExistence())
                return;
            t.cache(("table_cache": self));
            return h{name} = t.getTable();
        }

        #! gets a table from the database or from the cache if already cached
        AbstractTable get(AbstractDatasource ds, string name) {
            if (h{name})
                return h{name};

            Table t(ds, name);
            t.cache(("table_cache": self));
            return h{name} = t.getTable();
        }

        #! returns an SQL string that can be used to rename the given table if it exists and the target does not exist, otherwise returns @ref nothing
        /** @par Example:
            @code{.py}
*string sql = tables.getRenameTableIfExistsSql(old_name, new_name);
            @endcode

            If the @ref sql_callback_executed "sql_callback_executed option key" is @ref True "True", this
            method also takes care of renaming internal foreign constraint references and source constraint references
            from unique keys for the renamed table (see @ref sql_callback_executed for more information).

            @param old_name the current name of the table
            @param new_name the new name of the table
            @param opts optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return an SQL string that can be used to rename the given table if it exists and the target does not exist, otherwise returns @ref nothing
         */
        *string getRenameTableIfExistsSql(string old_name, string new_name, *hash<auto> opts) {
            if (!h{old_name} || h{new_name})
                return;

            AbstractTable t = h{old_name};
            string oldsn = t.getSqlName();
            *string sql = t.getRenameSql(new_name, opts);
            if (opts.sql_callback_executed)
                tableRenamedIntern(old_name, new_name, oldsn);

            return sql;
        }

        #! updates table names and internal references for renamed tables
        /** @par Example:
            @code{.py}
tables.tableRenamed(old, newv);
            @endcode

            @param old_name the current name of the table
            @param new_name the new name of the table
            @param old_sql_name the old full SQL name of the table (ie the value returned by @ref SqlUtil::AbstractTable::getSqlName())

            @return @ref True "True" if the table was renamed internally, @ref False "False" if not
        */
        bool tableRenamed(string old_name, string new_name, string old_sql_name) {
            if (!h{old_name} || h{new_name})
                return False;
            tableRenamedIntern(old_name, new_name, old_sql_name);
            return True;
        }

        private tableRenamedIntern(string old_name, string new_name, string oldsn) {
            renameKey(old_name, new_name);
            AbstractTable t = h{new_name};

            # search through all unique keys and rename foreign keys in source tables
            foreach AbstractUniqueConstraint uk in (t.getUniqueConstraintIterator()) {
                foreach hash<auto> sch in (uk.getSourceConstraintIterator()) {
                    sch.fk.target.table = t.getName();
                }
            }

            if (!t.getForeignConstraints().empty()) {
                string newsn = t.getSqlName();

                # search through all foreign constraints and try to rename source constraints
                foreach AbstractForeignConstraint fk in (t.getForeignConstraints().iterator()) {
                    if (h{fk.target.table}) {
                        AbstractTable tt = h{fk.target.table};
                        foreach AbstractUniqueConstraint uk in (tt.getUniqueConstraintIterator())
                            uk.renameSourceConstraintTable(oldsn, newsn);
                    }
                }
            }
        }

        #! returns an SQL string that can be used to drop an existing constraint on a table, if the table is not already cached or the constraint does not exist, then @ref nothing is returned
        /** @par Example:
            @code{.py}
*string sql = tables.getDropConstraintIfExistsSql("table", "pk_table");
            @endcode

            If the @ref sql_callback_executed "sql_callback_executed option key" is @ref True "True" and
            if the constraint to be dropped is a foreign constraint, then if any unique constraint is linked
            to this foreign constraint, the link is removed (see @ref sql_callback_executed for more information).

            @param tname the name of the table
            @param cname the name of the constraint to drop if it exists
            @param opts optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return an SQL string that can be used to drop an existing constraint on a table, if the table is not already cached or the constraint does not exist, then @ref nothing is returned
        */
        *string getDropConstraintIfExistsSql(string tname, string cname, *hash<auto> opts) {
            if (!h{tname})
                return;

            AbstractTable t = h{tname};
            AbstractConstraint c;
            *string sql = t.getDropConstraintIfExistsSql(cname, opts, \c);
            if (!sql)
                return;
            if (opts.sql_callback_executed && c instanceof AbstractForeignConstraint) {
                AbstractForeignConstraint fk = c;
                if (h{fk.target.table}) {
                    AbstractTable tt = h{fk.target.table};
                    list cols = fk.target.columns.keys();
                    foreach AbstractUniqueConstraint uk in (tt.getUniqueConstraintIterator())
                        uk.removeSourceConstraint(t.getSqlName(), cols);
                }
            }
            return sql;
        }

        list<auto> getCreateList() {
            # foreign dependency hash: table -> hash: source table (ie table with foreign constraint on key)
            hash tdh;
            # source dependency hash: table -> list: foreign table (key has foreign constraint on value)
            hash sdh;
            getDependencies(\tdh, \sdh);

            hash th = h;

            #printf("TDH: %N\nSDH: %N\nNT: %y", tdh, sdh, nt);exit(1);

            # make a list of tables in dependency order
            list l = ();
            while (True) {
                bool found = False;
                foreach AbstractTable t in (th.iterator()) {
                    if (!sdh{t.getName()}) {
                        l += t;
                        found = True;
                        remove th{t.getName()};
                        map remove sdh.$1{t.getName()}, tdh{t.getName()}.keyIterator();
                        remove tdh{t.getName()};
                    }
                }
                if (!found)
                    break;
            }

            return l;
        }

        Qore::AbstractIterator createIterator() {
            return getCreateList().iterator();
        }

        #! returns a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        /** @par Example:
            @code{.py}
list l = tables.getDropList();
map $1.drop(), l;
            @endcode

            @return a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        */
        list<auto> getDropList() {
            if (!h)
                return ();

            # foreign dependency hash: table -> hash: source table (ie table with foreign constraint on key)
            hash tdh;
            # source dependency hash: table -> list: foreign table (key has foreign constraint on value)
            hash sdh;
            # table hash
            hash th = h;
            getDependencies(\tdh, \sdh, \th);

            #printf("TDH: %N\nSDH: %N\nNT: %y", tdh, sdh, nt);exit(1);

            # make a list of tables in dependency order
            list l = ();
            while (True) {
                bool found = False;
                foreach AbstractTable t in (th.iterator()) {
                    if (!tdh{t.getName()}) {
                        if (t.checkExistence())
                            l += t;
                        found = True;
                        remove th{t.getName()};
                        map remove tdh.$1{t.getName()}, sdh{t.getName()}.keyIterator();
                        remove sdh{t.getName()};
                    }
                }
                if (!found)
                    break;
            }

            return l;
        }

        #! returns an iterator for a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        /** @par Example:
            @code{.py}
map $1.drop(), tables.getDropIterator();
            @endcode

            @return an iterator for a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        */
        Qore::AbstractIterator dropIterator() {
            return getDropList().iterator();
        }

        private getDependencies(reference<hash> tdh, reference<hash> sdh, *reference<hash> th) {
            # list of tables not in DB
            list nt = ();
            foreach AbstractTable t in (h.iterator()) {
                if (th && !t.checkExistence()) {
                    nt += t.getName();
                    continue;
                }
                foreach AbstractForeignConstraint fk in (t.getForeignConstraints().iterator()) {
                    # skip constraints on the same table
                    if (fk.target.table == t.getName())
                        continue;
                    # make dependency map entries
                    sdh{t.getName()}{fk.target.table} = True;
                    tdh{fk.target.table}{t.getName()} = True;
                }
            }

            # process tables not in DB
            foreach string name in (nt) {
                remove th{name};
                map remove tdh.$1{name}, sdh{name}.keyIterator();
                remove sdh{name};
            }
        }
    }

    #! column container class that throws an exception if an unknown column is accessed
    public class Columns inherits AbstractHashContainer {
        #! creates the object from the argument
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! creates a copy of the object
        constructor(Columns old) : AbstractHashContainer(old) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractColumn val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractColumn take(string k) {
            return remove h{k};
        }

        #! returns the AbstractColumn object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code{.py}
AbstractColumn c = cols.id;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        AbstractColumn memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        #! returns a subset of the current columns according to the list<auto> argument
        Columns subset(softlist l) {
            hash nh = h{l};
            if (nh.size() != l.size())
                throw "SUBSET-ERROR", sprintf("subset requested: %y is not possible, can only provide: %y", l, nh.keys());
            return new Columns(nh);
        }

        #! returns \c "column" since this object stores column objects
        string getElementName() {
            return "column";
        }

        #! returns @ref True "True" if the argument has the same columns in the same order as the current object, @ref False "False" if not
        bool equal(Columns cols) {
            AbstractIterator i = cols.iterator();
            foreach AbstractColumn c in (iterator()) {
                if (!i.next())
                    return False;
                if (!c.equal(i.getValue()))
                    return False;
            }
            return True;
        }

        #! returns an iterator for column SQL names
        AbstractIterator getSqlColumnNameIterator() {
            return new ListIterator((map $1.value.ddl_name ?? $1.key, h.pairIterator()));
        }
    }

    #! the base class for named objects
    public class AbstractDdlObject inherits Serializable {
        public {
            #! the name of the object
            string name;

            #! the name of the object for DDL (in case it's a reserved word)
            string ddl_name;
        }

        #! empty constructor for subclasses
        private constructor() {
        }

        #! creates the object from the name
        constructor(string name) {
            self.name = name;
            ddl_name = getDdlName(name);
        }

        #! returns the column name with quoting in case the column name is a reserved word
        /** the name returned here will be used when executing DDL
        */
        abstract string getDdlName(string name);
    }

    #! the base class for column information
    public class AbstractColumn inherits AbstractDdlObject {
        public {
            #! the native type name of the column
            string native_type;

            #! the equivalent qore type name of the column if known
            *string qore_type;

            #! the size of the column
            int size;

            #! @ref True "True" if the column can hold a NULL value, @ref False "False" if not
            bool nullable;

            #! default value for column
            *string def_val;

            #! comment on the column
            *string comment;
        }

        #! empty constructor for subclasses
        private constructor() {
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string c)
            : AbstractDdlObject(n) {
            native_type = nt;
            qore_type = qt;
            size = sz;
            nullable = nul;
            def_val = dv;
            comment = c;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the colunn to a table or when creating the table)
        string getNativeTypeString() {
            string sql = native_type;
            if (size)
                sql += sprintf("(%d)", size);
            return sql;
        }

        #! returns an sql string that can be used to add the column to a table
        string getCreateSql(AbstractTable t) {
            string sql = sprintf("%s %s", ddl_name, getNativeTypeString());
            if (exists def_val)
                sql += " default " + def_val + "";
            if (!nullable)
                sql += " not null";
            return sql;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code{.py}
list l = col.getAddColumnSql(t);
            @endcode

            @param t the AbstractTable object to modify

            @return a list of sql strings that can be used to add the column to an existing table
         */
        abstract list<auto> getAddColumnSql(AbstractTable t);

        #! returns a string that can be used to drop the column from the table
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop column %s", table_name, ddl_name);
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code{.py}
list l = col.getModifySql(t, newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param c the new column definition
            @param opt column modification options (if supported by the underlying driver)

            @return a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
         */
        list<auto> getModifySql(AbstractTable t, AbstractColumn c, *hash<auto> opt) {
            list l = getModifySqlImpl(t, c, opt);

            # update existing rows with the new default column value if:
            /* - a default value is being assigned and there was no default value before
               - a not null constraint is being added whereas there was none before
               - the table is not empty
            */
            if (def_val != c.def_val
                && (exists c.def_val && c.def_val != NULL)
                && (!exists def_val || def_val == NULL)
                && !c.nullable && nullable && !t.emptyData()) {
                string sql = sprintf("update %s set %s = %s where %s is null", t.getSqlName(), ddl_name, c.def_val, ddl_name);
                # insert in the front of the list
                unshift l, sql;
            }

            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code{.py}
string str = col.getRenameSql(t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        abstract string getRenameSql(AbstractTable t, string new_name);

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equal(AbstractColumn c) {
            if (self.className() != c.className() || name != c.name || native_type != c.native_type || size != c.size || nullable != c.nullable || def_val != c.def_val || comment != c.comment) {
                #printf("L: %N\nXXXXXXXXXXXXXXX\nR: %N\n\n", self, c);
                return False;
            }

            return equalImpl(c);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private abstract bool equalImpl(AbstractColumn c);

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code{.py}
list l = col.getModifySql(t, newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param c the new column definition
            @param opt column modification options (if supported by the underlying driver)

            @return a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
         */
        private abstract list<auto> getModifySqlImpl(AbstractTable t, AbstractColumn c, *hash<auto> opt);
    }

    #! the base class to use to extend AbstractColumn to implement numeric columns
    public class NumericColumnInfo inherits Serializable {
        public {
            #! the scale for numeric columns
            int scale;
        }

        constructor(softint n_scale = 0) {
            scale = n_scale;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the column to a table or when creating the table)
        string getNativeTypeString(string native_type, int precision) {
            string sql = native_type;
            if (precision) {
                sql += sprintf("(%d", precision);
                if (scale)
                    sql += sprintf(",%d", scale);
                sql += ")";
            }
            return sql;
        }
   }

    #! index container class that throws an exception if an unknown index is accessed
    public class Indexes inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractIndex val) {
            h{k} = val;
        }

        #! find an index with columns equal to the index passed
        *AbstractIndex findEqual(AbstractIndex ix) {
            foreach AbstractIndex ix2 in (h.iterator()) {
                if (ix2.equalExceptName(ix))
                    return ix2;
            }
        }

        #! removes the given key from the contained hash and returns the value
        AbstractIndex take(string k) {
            return remove h{k};
        }

        #! tries to remove the given key from the contained hash and returns the value if it exists
        *AbstractIndex tryTake(string k) {
            return remove h{k};
        }

        #! returns the AbstractIndex object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code{.py}
AbstractIndex ix = indexes.pk_jobs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        AbstractIndex memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "index";
        }
    }

    #! the abstract base class for index information
    public class AbstractIndex inherits Serializable {
        public {
            #! the name of the index
            string name;

            #! @ref True "True" if the index is a unique index, @ref False "False" if not
            bool unique;

            #! an object of class Columns representing the columns in the index
            Columns columns;
        }

        private {
            #! the AbstractColumnSupportingConstraint that this index supports, if any
            *AbstractColumnSupportingConstraint constraint;
        }

        #! creates the object from the name, a unique flag, and a hash of column information
        constructor(string n, bool u, hash c) {
            name = n;
            unique = u;
            columns = new Columns(c);
        }

        #! returns the index name
        string getName() {
            return name;
        }

        #! returns @ref True "True" if the constraint references the named column
        bool hasColumn(string cname) {
            return columns.hasKey(cname);
        }

        #! returns a string that can be used to create the index in the database
        abstract string getCreateSql(string table_name, *hash<auto> opt);

        #! returns a string that can be used to drop the index from the database
        string getDropSql(string table_name) {
            return sprintf("drop index %s", name);
        }

        #! returns @ref True "True" if the argument is equal to the current index, @ref False "False" if not
        bool equal(AbstractIndex ix) {
            if (ix.className() != self.className())
                return False;

            if (name != ix.name || unique != ix.unique || (columns.keys() != ix.columns.keys()))
                return False;

            return equalImpl(ix);
        }

        #! returns @ref True "True" if the argument is equal to the current index with the exception of the name, @ref False "False" if not
        bool equalExceptName(AbstractIndex ix) {
            if (ix.className() != self.className())
                return False;

            if (unique != ix.unique || (columns.keys() != ix.columns.keys()))
                return False;

            return equalImpl(ix);
        }

        #! returns @ref True "True" if the argument is equal to the current index, @ref False "False" if not
        abstract bool equalImpl(AbstractIndex ix);

        #! returns a string that can be used to rename the index in the database
        abstract string getRenameSql(string table_name, string new_name);

        #! tags the index with a column supporting constraint (unique or fk constraint, etc) that the index supports
        setSupportingConstraint(AbstractColumnSupportingConstraint c) {
            constraint = c;
        }

        #! clears the supporting constraint
        setSupportingConstraint() {
            remove constraint;
        }

        #! returns the supporting constraint, if any
        *AbstractColumnSupportingConstraint getSupportingConstraint() {
            return constraint;
        }

        #! returns a list of strings to drop and recreate the current index; if there are dependent constraints, the list contains commands to disable the constraints before dropping the index and also contains commands to re-enable the contraints after re-creating the index
        list<auto> getRecreateSql(AbstractDatasource ds, string table_name, *hash<auto> opt) {
            list l = ();
            list enl;
            # get drop SQL and disable any dependent constraints plus a list of strings to re-enable the constraints
            if (constraint) {
                hash drh = constraint.getDisableReenableSql(ds, table_name, opt);
                l += drh.disable;
                enl = drh.enable;
            }

            ## drop current index
            l += getDropSql(table_name);

            # add new index to table
            l += getCreateSql(table_name, opt);

            # re-enable any constraints disabled when dropping the index
            if (enl)
                l += enl;

            return l;
        }
    }

    #! constraint container class that throws an exception if an unknown constraint is accessed
    public class Constraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractConstraint val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractConstraint take(string k) {
            return remove h{k};
        }

        #! finds a unique constraint with the same columns as the unique constraint passed
        *AbstractUniqueConstraint findEqualUniqueConstraint(AbstractUniqueConstraint uk) {
            foreach AbstractConstraint c in (h.iterator()) {
                if (!(c instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uk2 = c;
                if (uk2.matchKeys(uk))
                    return uk2;
            }
        }

        #! returns the AbstractConstraint object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code{.py}
AbstractConstraint ix = constraints.uk_jobs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        AbstractConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "constraint";
        }
    }

    #! abstract base class for constraints
    public class AbstractConstraint inherits Serializable {
        public {}

        private {
            #! the name of the constraint
            string name;
        }

        #! creates the object and sets its name
        constructor(string n) {
            name = n;
        }

        #! returns the constraint name
        string getName() {
            return name;
        }

        #! renames the constraint
        rename(string n) {
            name = n;
        }

        #! returns a string that can be used to create the constraint in the database
        abstract string getCreateSql(string table_name, *hash<auto> opt);

        #! returns a string that can be used to drop the constraint from the database
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop constraint %s", table_name, name);
        }

        #! returns a list of SQL strings that can be used to rename the constraint in the database
        abstract list<auto> getRenameSql(string table_name, string new_name);

        #! returns a string that can be used to temporarily disable the constraint from the database; if disabling constraints is not supported, then the constraint will be dropped
        string getDisableSql(string table_name) {
            return getDropSql(table_name);
        }

        #! returns a string that can be used to enable the constraint in the database; if disabling constraints is not supported, then the constraint will be dropped
        string getEnableSql(string table_name, *hash<auto> opt) {
            return getCreateSql(table_name, opt);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equal(AbstractConstraint c) {
            if (c.className() != self.className() || name != c.name)
                return False;

            return equalImpl(c);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private abstract bool equalImpl(AbstractConstraint c);

        #! returns @ref True "True" if the object supports an index property and is set, @ref False "False" if not
        abstract bool setIndexBase(string ix);

        #! clears any index base for the constraint
        abstract clearIndex();

        #! returns @ref True "True" if the constraint references the named column
        bool hasColumn(string cname) {
            return False;
        }
    }

    #! abstract class for check constraints
    public class AbstractCheckConstraint inherits AbstractConstraint {
        public {
            #! the source of the check clause
            string src;
        }

        #! creates the object and sets its name and the check clause source
        constructor(string n, string n_src) : AbstractConstraint(n) {
            name = n;
            src = n_src;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractConstraint c) {
            return src != cast<AbstractCheckConstraint>(c).src ? False : True;
        }

        #! returns @ref True "True" if the object supports an index property and is set, @ref False "False" if not
        bool setIndexBase(string ix) {
            return False;
        }

        #! clears any index base for the constraint
        clearIndex() {
        }
    }

    #! the API for a constraint with columns
    public class AbstractColumnSupportingConstraint inherits AbstractConstraint, Columns {
        private {
            #! a hash of ForeignConstraintSources, keyed by table name, the value is a hash of foreign constraints keyed by constraint name
            *hash sourceConstraints;

            #! the index supporting the constraint
            *string index;
        }

        #! creates the object from the name and a hash of column information
        constructor(string n, *hash c, *string n_index) : AbstractConstraint(n), Columns(c) {
            index = n_index;
        }

        #! creates the object from the name and a Columns object
        constructor(string n, Columns c, *string n_index) : AbstractConstraint(n), Columns(c) {
            index = n_index;
        }

        #! returns an iterator through all known source foreign constraints on the current table
        /** each element is a hash with the following keys:
            - \c fk: the AbstractForeignConstraint object
            - \c table: the table name
        */
        Qore::AbstractIterator getSourceConstraintIterator() {
            list l = ();
            if (sourceConstraints) {
                HashIterator i(sourceConstraints);
                while (i.next())
                    map l += ("fk": $1, "table": i.getKey()), i.getValue().iterator();
            }

            return l.iterator();
        }

        #! returns lists of SQL strings to disable this constraint plus any dependent constraints and another list of SQL strings to reenable the same constraints; used when updating indexes that depend on constraints
        hash<auto> getDisableReenableSql(AbstractDatasource ds, string table_name, *hash<auto> opts) {
            hash<auto> ch = (
                "disable": (),
                "enable": (),
                );

            HashIterator i(sourceConstraints);
            while (i.next()) {
                # make sure table actually exists before disabling constraints
                string key = i.getKey();
                Table t(ds, key);
                if (!t.checkExistence())
                    continue;
                foreach AbstractForeignConstraint fk in (i.getValue().iterator()) {
                    ch.disable += fk.getDisableSql(key);
                    unshift ch.enable, fk.getEnableSql(key, opts);
                }
            }

            ch.disable += getDisableSql(table_name);
            unshift ch.enable, getEnableSql(table_name, opts);

            return ch;
        }

        #! find an index that matches the constraint and marks both objects as related
        findMatchingIndex(*Indexes indexes) {
            if (index) {
                if (indexes.hasKey(index))
                    indexes{index}.setSupportingConstraint(self);
                return;
            }

            # see if the primary key corresponds to a unique index with the same name & columns
            if (indexes.hasKey(name)) {
                AbstractIndex ix = indexes{name};
                if (ix.columns.matchKeys(h) && setIndexBase(ix.name))
                    ix.setSupportingConstraint(self);
            }
            else {
                # search for an index with matching columns
                foreach AbstractIndex ix in (indexes.iterator()) {
                    if (ix.columns.matchKeys(h)) {
                        if (setIndexBase(ix.name))
                            ix.setSupportingConstraint(self);
                        break;
                    }
                }
            }
        }

        #! adds a foreign constraint source to the unique constraint
        /** @par Example:
            @code{.py}
uk.addSourceConstraint(table_name, constraint_name);
            @endcode

            @param tname the name of the source table
            @param fk the source constraint

            @throw SOURCE-CONSTRAINT-ERROR a different source constraint with the given name already exists
        */
        addSourceConstraint(string tname, AbstractForeignConstraint fk) {
            if (sourceConstraints{tname}{fk.getName()})
                throw "SOURCE-CONSTRAINT-ERROR", sprintf("unique constraint %y: already has a source constraint from table %y from foreign constraint %y", name, tname, fk.getName());
            sourceConstraints{tname}{fk.getName()} = fk;
            #printf("added source constraint to %y: %s.%s\n", name, tname, fk.getName());
        }

        #! removes a source constraint
        removeSourceConstraint(string tname, list cols) {
            if (matchKeys(cols))
                remove sourceConstraints{tname};
        }

        #! renames a table in a source constraint
        renameSourceConstraintTable(string old_name, string new_name) {
            if (sourceConstraints{old_name})
                sourceConstraints{new_name} = remove sourceConstraints{old_name};
        }

        #! returns @ref True "True" if the constraint references the named column
        bool hasColumn(string cname) {
            return h.hasKey(cname);
        }

        #! returns the name of the associated index, if any
        *string getIndex() {
            return index;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractConstraint c) {
            return (self.keys() != cast<AbstractColumnSupportingConstraint>(c).keys()) ? False : True;
        }

        #! returns @ref True "True" if the object supports an index property and is set, @ref False "False" if not
        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        #! returns a string that can be used to create the constraint in the database
        abstract string getCreateSql(string table_name, *hash<auto> opts);
    }

    #! represents a unique column constraint
    public class AbstractUniqueConstraint inherits AbstractColumnSupportingConstraint {
        #! creates the object from the name an a hash of column information
        constructor(string n, *hash c, *string n_index) : AbstractColumnSupportingConstraint(n, c, n_index) {
        }
    }

    #! represents a primary key
    public class AbstractPrimaryKey inherits AbstractUniqueConstraint {
        constructor() : AbstractUniqueConstraint("") {
        }

        constructor(string n, *hash c) : AbstractUniqueConstraint(n, c) {
        }
    }

    #! foreign constraint container class that throws an exception if an unknown constraint is accessed
    public class ForeignConstraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractForeignConstraint val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractForeignConstraint take(string k) {
            return remove h{k};
        }

        #! find an index with columns equal to the index passed
        *AbstractForeignConstraint findEqual(AbstractForeignConstraint fk) {
            foreach AbstractForeignConstraint fk2 in (h.iterator()) {
                if (fk2.matchKeys(fk) && fk2.target.table == fk.target.table && fk2.target.columns.matchKeys(fk.target.columns))
                    return fk2;
            }
        }

        #! returns the AbstractForeignConstraint object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code{.py}
AbstractForeignConstraint ix = fcs.fk_jobs_job_defs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        AbstractForeignConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        #! returns either a hash of AbstractColumn information or @ref nothing if no foreign constraint can be found that matches the arguments
        *hash findConstraintOn(string table, softlist cols) {
            foreach AbstractForeignConstraint fk in (h.iterator()) {
                if (fk.target.table == table && fk.target.columns.matchKeys(cols))
                    return fk.getHash();
            }
        }

        #! returns \c "foreign constraint" for the type of object encapsulated
        string getElementName() {
            return "foreign constraint";
        }
    }

    #! a class describing a foreign constraint target
    public class ForeignConstraintTarget inherits Serializable {
        public {
            #! the name of the target table
            string table;

            #! columns in the target table
            Columns columns;
        }

        #! creates the object and sets the target table name and the target columns
        constructor(string t, Columns c) {
            table = t;
            columns = c;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equal(ForeignConstraintTarget targ) {
            return table != targ.table || (columns.keys() != targ.columns.keys()) ? False : True;
        }
    }

    #! the base class for foreign key constraint information
    public class AbstractForeignConstraint inherits AbstractColumnSupportingConstraint {
        public {
            #! a ForeignConstraintTarget object to describe the target table and columns
            ForeignConstraintTarget target;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractColumnSupportingConstraint(n, c) {
            target = t;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractConstraint con) {
            AbstractForeignConstraint c = cast<AbstractForeignConstraint>(con);
            return (h.keys() != c.h.keys())
                || !target.equal(c.target)
                ? False : True;
        }
    }

    #! base class for sequences
    public class AbstractSequence inherits Serializable {
        public {
            #! the name of the sequence
            string name;

            #! the starting number
            number start;

            #! the increment
            number increment;

            #! the ending number
            *number max;
        }

        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_max) {
            name = n_name;
            start = n_start;
            increment = n_increment;
            max = n_max;
            if (!increment)
                throw "SEQUENCE-ERROR", sprintf("sequence %y: increment cannot be zero", name);
            if (max) {
                if (increment > 0 && max < start)
                    throw "SEQUENCE-ERROR", sprintf("ascending sequence %y increment %d: max value %d is less than the starting value: %d", name, increment, max, start);
                if (increment < 0 && max > start)
                    throw "SEQUENCE-ERROR", sprintf("descending sequence %y increment %d: max value %d is less than the starting value: %d", name, increment, max, start);
            }
        }

        #! returns a string that can be used to create the sequence in the database
        abstract string getCreateSql(*hash<auto> opt);

        #! returns a string that can be used to drop the sequence from the database
        /** @param opt drop options (if supported by the driver and object); in this generic base class method, this argument is ignored
         */
        string getDropSql(*hash<auto> opt) {
            return sprintf("drop sequence %s", name);
        }

        #! returns a list of strings that can be used to rename the sequence in the database
        /** @param new_name the new name of the object
            @param opt drop options (if supported by the driver and object)
         */
        abstract softlist<auto> getRenameSql(string new_name, *hash<auto> opt);
    }

    #! base class for views
    public class AbstractView inherits Serializable {
        public {
            # ! potential object schema
            *string schema;

            #! the name of the sequence
            string name;

            #! the source code
            string src;

            #! Flag showing if is the view updatable with DML commands.
            bool updatable;
        }

        #! creates the object from the arguments
        constructor(string n_name, string n_src) {
            name = n_name;
            src = n_src;
        }

        #! returns a string that can be used to create the view in the database
        abstract string getCreateSql(*hash<auto> opt);

        #! returns a string that can be used to drop the view from the database
        /** @param opt drop options (if supported by the driver and object); in this generic base class method, this argument is ignored
         */
        string getDropSql(*hash<auto> opt) {
            return sprintf("drop view %s", name);
        }

        #! returns a list with command(s) that can be used to rename the view in the database
        /** @param new_name the new name of the object
            @param opt drop options (if supported by the driver and object)
         */
        abstract softlist<auto> getRenameSql(string new_name, *hash<auto> opt);
    }

    #! base class for function or objects with code
    public class AbstractFunctionBase inherits Serializable {
        public {
            #! the name of the object
            string name;

            #! the type of object
            string type;

            #! the source of the object
            string src;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) {
            name = n;
            type = n_type;
            src = n_src;
        }

        #! returns the type of object
        string getType() {
            return type;
        }

        #! returns a string that can be used to drop the function from the database
        /** @param opt drop options (if supported by the driver and object); in this generic base class method, this argument is ignored
         */
        string getDropSql(*hash<auto> opt) {
            return sprintf("drop %s %s", type, name);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equal(AbstractFunctionBase t) {
            if (self.className() != t.className() || name != t.name || type != t.type) {
                return False;
            }

            string src1 = getNormalizedSource(src);
            src1 =~ s/\n/ /g;
            string src2 = getNormalizedSource(t.src);
            src2 =~ s/\n/ /g;

            if (src1 != src2) {
                # XXX DEBUG
                #printf("%s\nXXXXXXXXXXXXXXX\n%s\n", src1, src2);
                return False;
            }
            #printf("%s\nXXXXXX EQUAL XXXXXX\n%s\n", src1, src2);

            return equalImpl(t);
        }

        #! returns normalized source for comparisons
        string getNormalizedSource(string src) {
            # replace newlines with spaces
            src =~ s/\n/ /g;
            return src;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private abstract bool equalImpl(AbstractFunctionBase t);
    }

    #! base class for functions
    public class AbstractFunction inherits AbstractFunctionBase {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : AbstractFunctionBase(n, n_type, n_src) {
        }

        #! returns a list of SQL strings that can be used to create the function in the database
        abstract list<auto> getCreateSql(*hash<auto> opt);

        #! returns a list of strings that can be used to rename the function in the database
        /** @param new_name the new name of the object
            @param opt drop options (if supported by the driver and object)
         */
        abstract softlist<auto> getRenameSql(string new_name, *hash<auto> opt);

        #! sets the new name of the object
        setName(string new_name) {
            name = new_name;
        }
    }

    #! function container class that throws an exception if an unknown function is accessed
    public class Functions inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractFunction val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractFunction take(string k) {
            return remove h{k};
        }

        #! returns the AbstractFunction object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code{.py}
AbstractFunction f = funcs.func1;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        AbstractFunction memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "function";
        }
    }

    #! the base class for triggers
    public class AbstractTrigger inherits AbstractFunctionBase {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractFunctionBase(n, "trigger", n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        abstract list<auto> getCreateSql(string table_name, *hash<auto> opt);

        #! returns a string that can be used to rename the trigger in the database
        abstract softlist<auto> getRenameSql(string table_name, string new_name);

        #! returns a string that can be used to drop the trigger in the database
        abstract list<auto> getDropSql(string table_name);
    }

    #! trigger container class that throws an exception if an unknown trigger is accessed
    public class Triggers inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractTrigger val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractTrigger take(string k) {
            return remove h{k};
        }

        #! returns the AbstractTrigger object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code{.py}
AbstractTrigger trig = trigs.job_trig;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        AbstractTrigger memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "trigger";
        }
    }
}
