# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Mime.qm Mime module definition

/*  Mime.qm Copyright (C) 2012 - 2024 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 2.0

%requires Util

# assume local var scope, do not use "$" for vars, members, and method calls
%new-style

module Mime {
    version = "1.6";
    desc = "Mime module providing MIME-related definitions";
    author = "David Nichols";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Mime Module

    @tableofcontents

    @section mimeintro Introduction to the Mime Module

    The %Mime module provides definitions and functions related to MIME processing.  MIME concepts are used in HTTP
    and SMTP communications, among others.

    To use this module, use \c "%requires Mime" in your code.  See the SmtpClient and the HttpServer modules for
    examples of %Qore code using this module.

    All the public symbols in the module are defined in the Mime namespace

    The main definitions and functions are:
    - @ref MimeTypeDefinitions "MimeTypeDefinitions": constant for common MIME types
    - @ref Mime::MimeTypes "MimeTypes": a map of common file name extensions to the default MIME type
    - @ref MimeEncodingFunctions "MimeEncodingFunctions": functions for encoding MIME data
    - @ref MimeDecodingFunctions "MimeDecodingFunctions": functions for decoding MIME data
    - @ref MultiPartConstants "MultiPartConstants": constants for the MultiPartMessage classes
    - @ref Mime::MultiPartAlternativeMessage "MultiPartAlternativeMessage": a class for handling multipart/alternative
      messages
    - @ref Mime::MultiPartFormDataMessage "MultiPartFormDataMessage": a class for handling multipart/form-data
      messages
    - @ref Mime::MultiPartMessage "MultiPartMessage": the base class for MultiPartMessage classes
      - @ref Mime::MultiPartMessage::parseBody() "MultiPartMessage::parseBody()": this static function can be used to
        parse a multipart message body (including parts with subparts if the \a decode argument is @ref True "True");
        this static method can be used for both HTTP multipart messages or text multipart messages (for example as
        sent in an email/SMTP message)
    - @ref Mime::MultiPartMixedMessage "MultiPartMixedMessage": a class for handling multipart/mixed messages
    - @ref Mime::MultiPartRelatedMessage "MultiPartRelatedMessage": a class for handling multipart/related messages

    based on:
    - http://tools.ietf.org/html/rfc1521: quoted printable & base 64 transfer encodings
    - http://tools.ietf.org/html/rfc2045: mime headers, content types, etc
    - http://tools.ietf.org/html/rfc2047: "Q" and "B" encoded words (implemented by the Mime module)

    @par Example:
    @code{.py}
#!/usr/bin/env qore

%requires Mime

string str = "This is a test: æéìœü";
printf("%y: quoted printable: %y\n", mime_decode_quoted_printable(mime_encode_quoted_printable(str)),
    mime_encode_quoted_printable(str));
printf("%y: base64: %y\n", mime_decode_base64_to_string(mime_encode_base64(str)), mime_encode_base64(str));
printf("%y: header word q: %y\n", mime_decode_header(mime_encode_header_word_q(str)), mime_encode_header_word_q(str));
printf("%y: header word b: %y\n", mime_decode_header(mime_encode_header_word_b(str)), mime_encode_header_word_b(str));
    @endcode \n
    The output of the above example looks like:
    @verbatim
"This is a test: æéìœü": quoted printable: "This is a test: =C3=A6=C3=A9=C3=AC=C5=93=C3=BC"
"This is a test: æéìœü": base64: "VGhpcyBpcyBhIHRlc3Q6IMOmw6nDrMWTw7w="
"This is a test: æéìœü": header word q: "=?UTF-8?Q?This_is_a_test:_=C3=A6=C3=A9=C3=AC=C5=93=C3=BC?="
"This is a test: æéìœü": header word b: "=?UTF-8?B?VGhpcyBpcyBhIHRlc3Q6IMOmw6nDrMWTw7w=?="
    @endverbatim

    @section mimereleasenotes Release Notes

    @subsection mime_1_6 v1.6
    - added the @ref Mime::is_mime_text() "is_mime_text()" and @ref Mime::is_filename_text() "is_filename_text()" functions

    @subsection mime_1_5 v1.5
    - added a constant for SVG types

    @subsection mime_1_4_4 v1.4.4
    - various fixes from downstream to Mime data handling
      (<a href="https://github.com/qorelanguage/qore/issues/4352">issue 4352</a>)

    @subsection mime_1_4_3 v1.4.3
    - fixed bugs parsing binary data in multipart messages
      (<a href="https://github.com/qorelanguage/qore/issues/4223">issue 4223</a>)

    @subsection mime_1_4_2 v1.4.2
    - fixed bugs parsing binary data in multipart messages
      (<a href="https://github.com/qorelanguage/qore/issues/2936">issue 2936</a>)

    @subsection mime_1_4_1 v1.4.1
    - allow the default type for unknown extensions to be overridden in
      @ref Mime::get_mime_type_from_ext() "get_mime_type_from_ext()"
      (<a href="https://github.com/qorelanguage/qore/issues/3260">issue 3260</a>)
    - fixed a bug in @ref Mime::mime_parse_form_urlencoded_string() "mime_parse_form_urlencoded_string()" where
      repeated elements would be overwritten by subsequent keys with the same name
      (<a href="https://github.com/qorelanguage/qore/issues/2761">issue 2761</a>)

    @subsection mime_1_4 v1.4
    - added complex type support
    - added the following constants:
      - @ref Mime::MimeTypeMultipartFormData "MimeTypeMultipartFormData"
      - @ref Mime::MimeTypeMultipartRelated "MimeTypeMultipartRelated"
      - @ref Mime::MimeTypeMultipartMixed "MimeTypeMultipartMixed"
    - added the following methods:
      - @ref Mime::MultiPartMessage::getBoundary() "MultiPartMessage::getBoundary()"
      - @ref Mime::MultiPartMessage::serializeBody() "MultiPartMessage::serializeBody()"
      - @ref Mime::MultiPartMessage::size() "MultiPartMessage::size()"
    - fixed a bug parsing multipart messages where unnecessary characters were searched
      (<a href="https://github.com/qorelanguage/qore/issues/2099">issue 2099</a>)

    @subsection mime_1_3_4_1 v1.3.4.1
    - added support for generating and parsing MIME multipart form encoded data

    @subsection mime_1_3_4 v1.3.4
    - added dependency on the Util module
    - replaced Mime::MultiPartMessage::getRandomString() with Util::get_random_string()
    - converted to new-style

    @subsection mime_1_3_3 v1.3.3
    - added Mime::MimeTypeOctetStream constant

    @subsection mime_1_3_2 v1.3.2
    - added mime type for WSDL files (\c "application/wsdl+xml")
    - added mappings for xls and xlst extensions to Mime::MimeTypes

    @subsection mime_1_3_1 v1.3.1
    - added Mime::get_mime_type_from_ext()
    - minor corrections
    - added constants for css and js files + more extension -> mime type mappings

    @subsection mime_1_3 v1.3
    - made get Mime::MultiPartMessage::getMsgAndHeaders() abstract as originally intended
    - added Mime::MultiPartMessage::parseBody() static method

    @subsection mime_1_2_1 v1.2.1
    - fixed q-encoding mail headers (always encode '_' chars otherwise they will be decoded as spaces)

    @subsection mime_1_2 v1.2
    - added MIME decoding functions

    @subsection mime_1_1 v1.1
    - added initial Mime::MultiPartMessage classes

    @subsection mime_1_0 v1.0
    - pulled MIME implementation out of other code and made a user module to aggregate MIME definitions and functions
*/

#! public Mime namespace defines constants and functions relevant to MIME
public namespace Mime {
    #! message and part info hash
    /**
    */
    public hashdecl MessageInfo {
        #! message or part headers
        hash hdr;
        #! the data for the message or part
        data body;
        #! parts of the message or subparts of the part
        list<hash<MessageInfo>> part();
    }

    #! message part hash
    public hashdecl MessagePartInfo {
        #! part body data
        data data;
        #! part header hash
        hash hdr;
    }

    #! parsed form-data message part info
    public hashdecl FormDataMessageInfo {
        #! the name of the part
        string name;
        #! the optional filename for the part
        *string filename;
        #! message or part headers
        hash hdr;
        #! the data for the message or part
        data body;
    }

    /** @defgroup MimeTypeDefinitions MIME Type Definitions
        These are constants for common MIME types
     */
    #/@{
    #! MIME type for unknown file types
    public const MimeTypeUnknown = MimeTypeOctetStream;

    #! MIME type for unknown file types
    public const MimeTypeOctetStream = "application/octet-stream";

    #! MIME type for text
    public const MimeTypeText = "text/plain";

    #! MIME type for HTML
    public const MimeTypeHtml = "text/html";

    #! MIME type for csv files (http://tools.ietf.org/html/rfc4180)
    public const MimeTypeCsv = "text/csv";

    #! MIME type for jpeg images
    public const MimeTypeJpeg = "image/jpeg";

    #! MIME type for png images
    public const MimeTypePng = "image/png";

    #! Mime type for SOAP XML messages (XML MIME type reference: http://tools.ietf.org/html/rfc3023)
    public const MimeTypeSoapXml = "application/soap+xml";

    #! Mime type for yaml data files
    public const MimeTypeYaml = "text/x-yaml";

    #! Mime type for plain (human-readable) xml files
    public const MimeTypeXml = "text/xml";

    #! Mime type for more complicated (not human-readable) xml files
    public const MimeTypeXmlApp = "application/xml";

    #! Mime type for JSON
    public const MimeTypeJson = "application/json";

    #! Mime type for JSON-RPC
    public const MimeTypeJsonRpc = MimeTypeJson;

    #! Mime type for XML-RPC
    public const MimeTypeXmlRpc = MimeTypeXml;

    #! Mime type for YAML-RPC
    public const MimeTypeYamlRpc = "application/x-yaml";

    #! Mime type for Javascript
    public const MimeTypeJavascript = "application/javascript";

    #! Mime type for css
    public const MimeTypeCss = "text/css";

    #! Mime type for multipart form URL encoding
    public const MimeTypeFormUrlEncoded = "application/x-www-form-urlencoded";

    #! Mime type for multipart form data
    public const MimeTypeMultipartFormData = "multipart/form-data";

    #! Mime type for multipart related
    public const MimeTypeMultipartRelated = "multipart/related";

    #! Mime type for multipart mixed
    public const MimeTypeMultipartMixed = "multipart/mixed";

    #! Mime type for SVG files
    public const MimeTypeSvg = "image/svg+xml";

    #! Mime type for Qore sources
    public const MimeTypeQore = "text/x-qore";

    #! Mime type for Java sources
    public const MimeTypeJavaSource = "text/x-java-source";

    #! Mime type for Java class files
    public const MimeTypeJava = "application/java";

    #! Mime type for Java jar files
    public const MimeTypeJar = "application/java-archive";

    #! Mime type for Python sources
    public const MimeTypePython = "text/x-python-source";

    #! Mime type for Python compiled code
    public const MimeTypePythonCode = "application/x-python-code";

    #! Mime type for PHP sources
    public const MimeTypePhp = "application/x-httpd-php";

    #! A map of default mime types per file extension; the hash keys are file extensions in lower-case without the dot (ex: \c "txt")
    /** @showinitializer
     */
    public const MimeTypes = {
        "7z": "application/x-7z-compressed",
        "ai": "application/postscript",
        "aif": "audio/x-aiff",
        "aifc": "audio/x-aiff",
        "aiff": "audio/x-aiff",
        "asc": MimeTypeText,
        "atom": "application/atom+xml",
        "au": "audio/basic",
        "avi": "video/x-msvideo",
        "bcpio": "application/x-bcpio",
        "bin": MimeTypeUnknown,
        "bmp": "image/bmp",
        "bz2": "application/x-bzip",
        "cc": MimeTypeText,
        "cdf": "application/x-netcdf",
        "cgm": "image/cgm",
        "class": MimeTypeJava,
        "cpio": "application/x-cpio",
        "cpp": MimeTypeText,
        "cpt": "application/mac-compactpro",
        "csh": "application/x-csh",
        "css": MimeTypeCss,
        "csv": MimeTypeCsv,
        "dcr": "application/x-director",
        "dif": "video/x-dv",
        "dir": "application/x-director",
        "djv": "image/vnd.djvu",
        "djvu": "image/vnd.djvu",
        "dll": MimeTypeUnknown,
        "dmg": MimeTypeUnknown,
        "dms": MimeTypeUnknown,
        "doc": "application/msword",
        "dtd": "application/xml-dtd",
        "dv": "video/x-dv",
        "dvi": "application/x-dvi",
        "dxr": "application/x-director",
        "eps": "application/postscript",
        "etx": "text/x-setext",
        "exe": MimeTypeUnknown,
        "ez": "application/andrew-inset",
        "gif": "image/gif",
        "gram": "application/srgs",
        "grxml": "application/srgs+xml",
        "gtar": "application/x-gtar",
        "gz": "application/x-gzip",
        "h": MimeTypeText,
        "hdf": "application/x-hdf",
        "hh": MimeTypeText,
        "hpp": MimeTypeText,
        "hqx": "application/mac-binhex40",
        "htm": MimeTypeHtml,
        "html": MimeTypeHtml,
        "ice": "x-conference/x-cooltalk",
        "ico": "image/x-icon",
        "ics": "text/calendar",
        "ief": "image/ief",
        "ifb": "text/calendar",
        "iges": "model/iges",
        "igs": "model/iges",
        "jar": MimeTypeJar,
        "java": MimeTypeJavaSource,
        "jnlp": "application/x-java-jnlp-file",
        "jp2": "image/jp2",
        "jpe": MimeTypeJpeg,
        "jpeg": MimeTypeJpeg,
        "jpg": MimeTypeJpeg,
        "js": MimeTypeJavascript,
        "json": MimeTypeJson,
        "kar": "audio/midi",
        "latex": "application/x-latex",
        "lha": MimeTypeUnknown,
        "lzh": MimeTypeUnknown,
        "m3u": "audio/x-mpegurl",
        "m4a": "audio/mp4a-latm",
        "m4b": "audio/mp4a-latm",
        "m4p": "audio/mp4a-latm",
        "m4u": "video/vnd.mpegurl",
        "m4v": "video/x-m4v",
        "mac": "image/x-macpaint",
        "man": "application/x-troff-man",
        "mathml": "application/mathml+xml",
        "me": "application/x-troff-me",
        "mesh": "model/mesh",
        "mid": "audio/midi",
        "midi": "audio/midi",
        "mif": "application/vnd.mif",
        "mov": "video/quicktime",
        "movie": "video/x-sgi-movie",
        "mp2": "audio/mpeg",
        "mp3": "audio/mpeg",
        "mp4": "video/mp4",
        "mpe": "video/mpeg",
        "mpeg": "video/mpeg",
        "mpg": "video/mpeg",
        "mpga": "audio/mpeg",
        "ms": "application/x-troff-ms",
        "msh": "model/mesh",
        "mxu": "video/vnd.mpegurl",
        "nc": "application/x-netcdf",
        "oda": "application/oda",
        "ogg": "application/ogg",
        "pbm": "image/x-portable-bitmap",
        "pct": "image/pict",
        "pdb": "chemical/x-pdb",
        "pdf": "application/pdf",
        "pgm": "image/x-portable-graymap",
        "pgn": "application/x-chess-pgn",
        "php": MimeTypePhp,
        "pic": "image/pict",
        "pict": "image/pict",
        "png": MimeTypePng,
        "pnm": "image/x-portable-anymap",
        "pnt": "image/x-macpaint",
        "pntg": "image/x-macpaint",
        "ppm": "image/x-portable-pixmap",
        "ppt": "application/vnd.ms-powerpoint",
        "ps": "application/postscript",
        "py": MimeTypePython,
        "pyc": MimeTypePythonCode,

        # Qore script
        "q": MimeTypeQore,

        # Qore class include file
        "qc": MimeTypeQore,

        # Qorus function definition file
        "qfd": MimeTypeQore,

        # Qorus class definition file
        "qclass": MimeTypeQore,

        # Qorus constant definition file
        "qconst": MimeTypeQore,

        # Qorus job definition
        "qjob": MimeTypeQore,

        # Qore include file
        "ql": MimeTypeQore,

        # Qore user module source
        "qm": MimeTypeQore,

        # Qorus service definition
        "qsd": MimeTypeQore,

        # Qorus workflow definition
        "qwf": MimeTypeQore,

        "qt": "video/quicktime",
        "qti": "image/x-quicktime",
        "qtif": "image/x-quicktime",
        "ra": "audio/x-pn-realaudio",
        "ram": "audio/x-pn-realaudio",
        "ras": "image/x-cmu-raster",
        "rdf": "application/rdf+xml",
        "rgb": "image/x-rgb",
        "rm": "application/vnd.rn-realmedia",
        "roff": "application/x-troff",
        "rtf": "text/rtf",
        "rtx": "text/richtext",
        "sgm": "text/sgml",
        "sgml": "text/sgml",
        "sh": "application/x-sh",
        "shar": "application/x-shar",
        "silo": "model/mesh",
        "sit": "application/x-stuffit",
        "skd": "application/x-koan",
        "skm": "application/x-koan",
        "skp": "application/x-koan",
        "skt": "application/x-koan",
        "smi": "application/smil",
        "smil": "application/smil",
        "snd": "audio/basic",
        "so": MimeTypeUnknown,
        "spl": "application/x-futuresplash",
        "src": "application/x-wais-source",
        "sv4cpio": "application/x-sv4cpio",
        "sv4crc": "application/x-sv4crc",
        "svg": MimeTypeSvg,
        "swf": "application/x-shockwave-flash",
        "t": "application/x-troff",
        "tar": "application/x-tar",
        "tar.bz2": "application/x-bzip-compressed-tar",
        "tar.gz": "application/x-tar-gz",
        "tbz": "application/x-bzip-compressed-tar",
        "tcl": "application/x-tcl",
        "tex": "application/x-tex",
        "texi": "application/x-texinfo",
        "texinfo": "application/x-texinfo",
        "text": MimeTypeText,
        "tgz": "application/x-tar-gz",
        "tif": "image/tiff",
        "tiff": "image/tiff",
        "tr": "application/x-troff",
        "tsv": "text/tab-separated-values",
        "txt": MimeTypeText,
        "ustar": "application/x-ustar",
        "vcd": "application/x-cdlink",
        "vrml": "model/vrml",
        "vxml": "application/voicexml+xml",
        "wav": "audio/x-wav",
        "wbmp": "image/vnd.wap.wbmp",
        "wbmxl": "application/vnd.wap.wbxml",
        "wml": "text/vnd.wap.wml",
        "wmlc": "application/vnd.wap.wmlc",
        "wmls": "text/vnd.wap.wmlscript",
        "wmlsc": "application/vnd.wap.wmlscriptc",
        "wrl": "model/vrml",
        "wsdl": "application/wsdl+xml",
        "xbm": "image/x-xbitmap",
        "xht": "application/xhtml+xml",
        "xhtml": "application/xhtml+xml",
        "xls": "application/vnd.ms-excel",
        "xml": MimeTypeXml,
        "xpm": "image/x-xpixmap",
        "xsd": MimeTypeXml,
        "xsl": "application/xml",
        "xslt": "application/xslt+xml",
        "xul": "application/vnd.mozilla.xul+xml",
        "xwd": "image/x-xwindowdump",
        "xyz": "chemical/x-xyz",
        "yaml": MimeTypeYaml,
        "zip": "application/zip",
    };

    #! hash of non-alphanumeric characters that can be used unencoded in URL encoded format
    /** @note the plus character can also appear unencoded in a URL string, but because many
        decoders interpret it as a space (which is it in the query part of a URL string), it's
        not in this list

        @see <a href="https://tools.ietf.org/html/rfc1738">RFC 2738 2.2</a>
    */
    public const UrlEncodedChars = {
        "\$": True,
        "-": True,
        "_": True,
        ".": True,
        "!": True,
        "*": True,
        "'": True,
        "(": True,
        ")": True,
        ",": True
    };
    #/@}

    /** @defgroup MimeContentTransferEncodingConstants MIME Content Transfer Encoding Constants
     */
    #/@{
    #! default Content-Transfer-Encoding if none is present; implies lines < 1000 chars (= no encoding)
    public const ContentTransEnc7Bit = "7bit";

    #! implies lines < 1000 chars (= no encoding)
    public const ContentTransEnc8Bit = "8bit";

    #! binary transfer encoding; implies no maximum line length (= no encoding)
    public const ContentTransEncBinary = "binary";

    #! base-64 Content-Transfer-Encoding
    public const ContentTransEncBase64 = "base64";

    #! quoted-printable Content-Transfer-Encoding
    public const ContentTransEncQuotedPrintable = "quoted-printable";

    #! maximum line length for base64 encoding
    /** <a href="http://tools.ietf.org/html/rfc2045#section-6.8">RFC 2045 section 6.8</a>
     */
    public const MimeBase64LineLen = 76;

    #! maximum line length for quoted-printable encoding
    /** <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>
     */
    public const MimeQuotedPrintableLineLen = 76;
    #/@}

    /** @defgroup MimeEncodingFunctions MIME Encoding Functions
     */
    #/@{
    #! returns a string in "BASE64" encoding according to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>
    /** @param str the string to encode
        @param len the maximum line length

        @note this function is basically just a wrapper for the standard %Qore function make_base64_string()
     */
    public string sub mime_encode_base64(data str, int len = MimeBase64LineLen) {
        return make_base64_string(str, len);
    }

    #! returns a string in "quoted-printable" (or "QP") encoding
    /** According to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>

        @param str the string to encode
        @param hdr use rules for a MIME header (<a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>)
    */
    public string sub mime_encode_quoted_printable(string str, bool hdr = False, *string encoding) {
        string rv;
        int lp = 0;

        for (int i = 0; i < str.size(); ++i) {
            int c = get_byte(str, i);

            # check if we're processing a UNIX '\n' line break
            if (c == 10) {
                # we MUST encode this as a CRLF sequence (we assume it's a UNIX line break)
                rv += "\r\n";
                lp = 0;
                continue;
            }

            # check if we're processing a CRLF line break
            if (c == 13 && get_byte(str, i + 1) == 10) {
                rv += "\r\n";
                lp = 0;
                ++i;
                continue;
            }

            # new string to append
            string nc;
            # if we are encoding a header and we have a space, transform to "_"
            if (hdr && c == 32) {
                nc = "_";
                # check if the high bit is set or if it's an ASCII control character or '=', or we are encoding a
                # header and the char is not '?' and '_', encode
            } else if ((c & 0x80) || c < 32 || c == 61 || (!hdr && c == 46) || (hdr && (c == 63 || c == 95
                || c == 137))) {
                nc = sprintf("=%02x", c).upr();
            } else {
                nc = chr(c);
            }

            # used for body and parts
            if (!hdr && (nc.size() + lp) >= (MimeQuotedPrintableLineLen - 1)) {
                # insert soft line break
                rv += "=\r\n";
                lp = 0;
            } else if (hdr && (nc.size() + lp) >= (MimeQuotedPrintableLineLen - 2)) {
                # we MUST break up lines longer than 76 characters (the line length includes the '?=' but not the CRLF
                # for every line break we put separate encoding blocks
                # used for headers
                # example (notice space after first line, it will break the headers without it)
                # =?UTF-8?Q?F=C3=BCJon_Doe_Austria_<jondoe.verylongemailblablbalbablbalblbabla@gmail.?=
                #  =?UTF-8?Q?com><jondoe.verylongemailblablbalbablbalblbabla@gmail.com>

                # insert soft line break
                rv += sprintf("?=\r\n =?%s?Q?", encoding);
                lp = 0;
            }

            rv += nc;
            lp += nc.size();
        }
        return rv;
    }

    #! encodes data according to the given encoding
    /** @param mime_data the data to encode
        @param enc the encoding to use; see @ref MimeContentTransferEncodingConstants for possible values (case is ignored)

        @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
     */
    public data sub mime_encode_transfer_data(data mime_data, string enc) {
        enc = enc.lwr();
        switch (enc) {
            case ContentTransEnc7Bit:
            case ContentTransEnc8Bit:
            case ContentTransEncBinary:
                return mime_data;

            case ContentTransEncBase64:
                return mime_encode_base64(mime_data, MimeBase64LineLen);

            case ContentTransEncQuotedPrintable:
                return mime_encode_quoted_printable(mime_data);
        }

        throw "MIME-TRANSFER-ENCODING-ERROR", sprintf("Content-Transfer-Encoding: %y is unknown", enc);
    }

    #! returns a string in "B" ("BASE64") encoding for MIME header string words
    /** According to <a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>
    */
    public string sub mime_encode_header_word_b(string str) {
        return sprintf("=?%s?B?%s?=", get_encoding(str), make_base64_string(str, MimeBase64LineLen));
    }

    #! returns a string in "Q" ("quoted-printable") encoding for MIME header string words
    /** According to <a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>
    */
    public string sub mime_encode_header_word_q(string str) {
        return sprintf("=?%s?Q?%s?=", get_encoding(str), mime_encode_quoted_printable(str, True));
    }
    #/@}

    /** @defgroup MimeDecodingFunctions MIME Decoding Functions
     */
    #/@{
    #! returns a binary value from a string in "BASE64" encoding
    /** According to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>

        @param str the string to decode

        @note this function is basically just a wrapper for the standard %Qore function parse_base64_string()
     */
    public binary sub mime_decode_base64(data str) {
        return parse_base64_string(str.typeCode() == NT_STRING ? str : str.toString());
    }

    #! returns a string value from a string in "BASE64" encoding
    /** According to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>

        @param str the string to decode
        @param encoding the character encoding to use for the string returned (if not present the default encoding is used)

        @note this function is basically just a wrapper for the standard %Qore function parse_base64_string_to_string()
     */
    public string sub mime_decode_base64_to_string(data str, *string encoding) {
        return parse_base64_string_to_string(str, encoding);
    }

    #! returns a string parsed from "quoted-printable" (or "QP") encoding
    /** According to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>

        @param str the string to decode
        @param encoding the character encoding to use for the string returned (if not present the default encoding is used)

        @throw QUOTED-PRINTABLE-DECODE-ERROR an error occurred decoding the quoted-printable string
     */
    public string sub mime_decode_quoted_printable(string str, *string encoding, *bool is_body) {
        str = force_encoding(str, "us-ascii");

        if (encoding.empty())
            encoding = get_default_encoding();

        string rv;
        int lp = 0;

        # recombine broken lines
        str = replace(str, "=\r\n", "");

%ifdef Unix
        # substitute all \r\n occurrences with \n
        str = replace(str, "\r\n", "\n");
%endif

        # substitute all "_" occurrences with " "
        if (!is_body) {
            str = replace(str, "_", " ");
        }

        int i = 0;
        while (True) {
            i = str.find("=", i);
            if (i == -1)
                break;

            string hex = toupper(extract str, i + 1, 2);
            # according to RFC 2045 sec 6.7 rule (1): we have to use upper-case characters
            if (hex !~ /[0-9A-Z][0-9A-Z]/)
                throw "QUOTED-PRINTABLE-DECODE-ERROR", sprintf("invalid hex byte code found: %y", hex);
            # replace the code with the given character
            splice str, i, 1, chr(int(hex, 16), "us-ascii");
            ++i;
        }

        return force_encoding(str, encoding);
    }

    #! decodes data according to the given encoding
    /** @param mime_data the data to decode
        @param enc the decoding to use; see @ref MimeContentTransferEncodingConstants for possible values (case is
        ignored)
        @param ct the content-type of the data; if there is a \c "charset=xxx" component and the data is decoded to a
        string, then it will be returned in the given character encoding

        @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
     */
    public data sub mime_decode_transfer_data(data mime_data, string enc, *string ct, *bool is_body) {
        enc = enc.lwr();
        switch (enc) {
            case ContentTransEnc7Bit:
            case ContentTransEnc8Bit:
            case ContentTransEncBinary:
                break;

            case ContentTransEncBase64: {
                mime_data = (mime_data.typeCode() == NT_STRING)
                    ? mime_decode_base64(mime_data)
                    : mime_decode_base64(binary_to_string(mime_data, enc));
                break;
            }

            case ContentTransEncQuotedPrintable: {
                mime_data = mime_decode_quoted_printable(
                    mime_data.typeCode() == NT_STRING ? mime_data : mime_data.toString(enc), enc, is_body
                );
                break;
            }

            default:
                throw "MIME-TRANSFER-ENCODING-ERROR", sprintf("Content-Transfer-Encoding: %y is unknown", enc);
        }

        if (mime_data.typeCode() == NT_STRING) {
            # see if there is a character encoding specification in the content-type
            *string senc = (ct =~ x/charset="?([^"]+)"?/)[0];
            if (exists senc)
                mime_data = force_encoding(mime_data, senc);
        }

        return mime_data;
    }

    #! decodes a header string
    /** If any part of the string is encoded with "B" ("BASE64") or "Q" ("quoted-printable") encodings
        according to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>, then those
        parts are decoded and the decoded string is returned

        @param hdr the header value string to decode
        @return the decoded value of the header
     */
    public string sub mime_decode_header(string hdr) {
        int count = 0;
        while (True) {
            (*string enc, *string he, *string hw) = (hdr =~ x/=\?([^?]+)\?(Q|B)\?([^?]+)\?=/i);
            if (!enc.val() || !he.val() || !hw.val()) {
                break;
            }
            string dv = he.upr() == "Q" ? mime_decode_quoted_printable(hw, enc) : mime_decode_base64_to_string(hw, enc);
            # remove space in front of multiline headers
            string os = (!count)
                ? sprintf("=?%s?%s?%s?=", enc, he, hw)
                : sprintf(" =?%s?%s?%s?=", enc, he, hw);
            hdr = replace(hdr, os, dv);
            ++count;
        }
        return hdr;
    }
    #/@}

    /** @defgroup MimeMiscFunctions Misc MIME Functions
     */
    #/@{
    #! Returns @ref True if the given MIME type is known to provide text content, @ref False if not
    /** @param mime The MIME type to test

        @return @ref True if the given MIME type is known to provide text content, @ref False if not

        @since Mime 1.6
    */
    public bool sub is_mime_text(string mime) {
        if (mime == MimeTypeFormUrlEncoded) {
            return True;
        }
        return (mime =~ /(text\/|(x-|\/|-|\+)?(xml|yaml|json|tex|latex|postscript|sh|csh|bash|zsh|tcl|shar|srgs))/);
    }

    #! Returns @ref True if the given filename / path is known to provide text content, @ref False if not
    /** @param path The filename or path to test

        @return @ref True if the given filename / path is known to provide text content, @ref False if not

        @since Mime 1.6
    */
    public bool sub is_filename_text(string path) {
        return is_mime_text(get_mime_type_from_ext(path));
    }

    #! returns the mime type for the given filename from the extension or the default type if the extension is not present or unknown
    public string sub get_mime_type_from_ext(string path, string def_type = MimeTypeUnknown) {
        *string ext = (path =~ x/\.([a-z0-9]+)$/i)[0];
        return (ext && (ext = MimeTypes{ext.lwr()})) ? ext : def_type;
    }

    #! returns a single string in MIME URL encoded format
    /** reserved characters are replaced with percent encoding, characters outside the ASCII character set cause an exception to be thrown

        @param val the input value

        @return the output string in MIME URL encoded format

        @throw INVALID-VALUE the value given cannot be converted to a string
        @throw INVALID-CHARACTER an invalid character has been found

        @see <a href="https://tools.ietf.org/html/rfc1738">RFC 2738 2.2</a>

        @note spaces are not replaced with \c '+' signs but rather encoded as \c %20 because \c '+' signs are often encoded and decoded improperly in URLs, and \c %20 is unambiguous

        @since %Mime 1.3.4.1
     */
    public string sub mime_get_urlencoded_string(auto val) {
        if (!val.strp())
            throw "INVALID-VALUE", sprintf("type %y cannot be converted to a string (value: %y)", val.type(), val);
        string str = val.toString();

        string rv = "";

        for (int i = 0; i < str.size(); ++i) {
            string c = str[i];
            int code = c.getUnicode();
            if (code > 127)
                throw "INVALID-CHARACTER", sprintf("cannot generate a URL encoded string with non-ASCII character %y (unicode point %d)", c, code);
            if ((code >= 48 && code <= 57) || (code >= 65 && code <= 90) || (code >= 97 && code <= 122) || UrlEncodedChars{c}) {
                rv += c;
                continue;
            }
            rv += sprintf("%%%02X", code);
        }

        return rv;
    }

    #! returns a string in MIME multipart form URL encoded format (for use with \c "Content-Type: application/x-www-form-urlencoded" data)
    /** Parameters will be separated by \c "&" characters.
        All key values must be strings or convertible to strings or a URLENCODED-TYPE-ERROR exception is thrown

        @param h the hash to use to generate the string

        @return a string in \c application/x-www-form-urlencoded format

        @throw URLENCODED-TYPE-ERROR hash value cannot be converted to a string
        @throw INVALID-CHARACTER an invalid character has been found

        @see <a href="https://tools.ietf.org/html/rfc1738">RFC 2738 2.2</a>

        @since %Mime 1.3.4.1
     */
    public string sub mime_get_form_urlencoded_string(hash<auto> h) {
        string str;
        foreach hash<auto> kh in (h.pairIterator()) {
            if (str)
                str += "&";
            on_error rethrow $1.err, sprintf("%s (while URL encoding key %y, value %y)", $1.desc, kh.key, kh.value);
            str += mime_get_urlencoded_string(kh.key) + "=" + mime_get_urlencoded_string(kh.value);
        }

        return str;
    }

    #! decodes the given string from URL encoded format
    /**
        @param str the URL encoded string to decode

        @return the decoded string

        @see <a href="https://tools.ietf.org/html/rfc1738">RFC 2738 2.2</a>

        @since %Mime 1.3.4.1
     */
    public string sub mime_decode_urlencoded_string(string str) {
        while (True) {
            int i = str.find("%");
            if (i == -1)
                break;

            string source = str.substr(i, 3);

            # gets the value of a hex digit in decimal
            code get_digit = int sub (string d) {
                int c = ord(d.upr());
                if (c >= 48 && c <= 57)
                    return c - 48;
                return c - 55;
            };

            # get hex code
            string code = source.substr(1);
            int v = get_digit(code[0]) * 16 + get_digit(code[1]);
            code = chr(v);
            str = replace(str, source, code);
        }

        return str;
    }

    #! returns a hash corresponding to the string in MIME multipart form URL encoded format (for use with \c "Content-Type: application/x-www-form-urlencoded" data)
    /** @param str the string to parse

        @return the hash corresponding to the string, where values are always of type *string unlessa key is repeated,
        in which case the key's value will be a list of all elements provided

        @throw URLENCODED-PARSE-ERROR cannot parse the given string

        @see <a href="https://tools.ietf.org/html/rfc1738">RFC 2738 2.2</a>

        @since %Mime 1.3.4.1
     */
    public hash<auto> sub mime_parse_form_urlencoded_string(string str) {
        hash<auto> rv = {};
        foreach string ustr in (str.split("&")) {
            (*string key, *string value) = (ustr =~ x/([^=]+)=(.*)$/);
            if (!exists key)
                throw "URLENCODED-PARSE-ERROR", sprintf("urlencoded parameter element not in key=value format: %y", ustr);
            key = mime_decode_urlencoded_string(key);
            value = value === "" ? NOTHING : mime_decode_urlencoded_string(value);
            if (!exists rv{key}) {
                rv{key} = value;
            } else if (rv{key}.typeCode() != NT_LIST) {
                rv{key} = (rv{key}, value);
            } else {
                rv{key} += value;
            }
        }

        return rv;
    }
    #/@}

    /** @defgroup MultiPartConstants MultiPartMessage Constants
     */
    #/@{
    #! for form data (http://tools.ietf.org/html/rfc1867, http://tools.ietf.org/html/rfc2388)
    public const MPT_FORM_DATA   = "form-data";

    #! for sending files with different "Content-Type" headers (http://tools.ietf.org/html/rfc2046#section-5.1.3)
    public const MPT_MIXED       = "mixed";

    #! for email/MIME messages with headers (http://tools.ietf.org/html/rfc2046)
    public const MPT_MESSAGE     = "message";

    #! for sending multiple text messages (http://tools.ietf.org/html/rfc2046#section-5.1.5)
    public const MPT_DIGEST      = "digest";

    #! for sending multiple "alternatives" of the same content (http://tools.ietf.org/html/rfc2046#section-5.1.4)
    public const MPT_ALTERNATIVE = "alternative";

    #! for sending multiple components of an aggregated whole (http://tools.ietf.org/html/rfc2387)
    public const MPT_RELATED     = "related";

    #! to attach a digital signature to a message (http://tools.ietf.org/html/rfc1847#section-2.1)
    public const MPT_SIGNED      = "signed";

    #! for sending encrypted messages (http://tools.ietf.org/html/rfc1847#section-2.2)
    public const MPT_ENCRYPTED   = "encrypted";

    #! for sending noncontiguous byte ranges of a single message (http://tools.ietf.org/html/rfc2616)
    public const MPT_BYTERANGES  = "byteranges";
    #/@}

    #! MultiPartMessage class implementation
    public class MultiPartMessage {
        const MP_DEFAULT_MSG = "This is a MIME multipart message";

        #! @cond nodoc
        private {
            #! the type of multi-part message: see @ref MultiPartConstants for possible values
            string mptype;

            #! the boundary to use between parts
            string boundary;

            #! the content type for the message as a whole
            string ct;

            #! list of the parts of the message
            list<hash<MessagePartInfo>> l();

            #! a hash of the headers of the message
            hash hdr;

            #! constants for parsing MIME multipart messages
            const ASCII_CR = 13;
            const ASCII_LF = 10;
        }
        #! @endcond

        #! creates the object
        /** @param mptype the type of multi-part message: see @ref MultiPartConstants for possible values
            @param boundary the boundary to use between parts
         */
        constructor(string mptype, string boundary = MultiPartMessage::getBoundary()) {
            self.mptype = mptype;
            self.boundary = boundary;
            ct = sprintf("multipart/%s; boundary=%s", mptype, boundary);
        }

        #! serializes the message with the Content-Type header first and returns a binary object ready to send over a socket
        binary serialize() {
            hash<MessageInfo> h = getMsgAndHeaders();
            binary rv = MultiPartMessage::serializeHeaders(h.hdr);
            rv += h.body;
            return rv;
        }

        #! serializes the message body only and returns a binary object ready to send over a socket
        /** @since %Mime 1.4
        */
        binary serializeBody() {
            return getMsgAndHeaders().body;
        }

        #! returns the number of parts in the message
        /** @return the number of parts in the message

            @since %Mime 1.4
        */
        int size() {
            return l.size();
        }

        #! returns the message boundary string used
        /** @return the message boundary string used

            @since %Mime 1.4
        */
        string getBoundary() {
            return boundary;
        }

        #! serializes a header hash to a binary object
        /** @param hdr the hash to serialize

            @return the binary object representing the hash with each header separated by \c "\r\n"
         */
        static binary serializeHeaders(hash hdr) {
            binary b;
            map b += sprintf("%s: %s\r\n", $1.key, $1.value), hdr.pairIterator();
            b += "\r\n";
            return b;
        }

        #! returns a string embedded with the current timestamp designed to be used as MultiPart boundary string
        static string getBoundary() {
            return "------Qore-MIME-Boundary" + now_us().format("YYYYMMDDHHmmSS.usZ") + "------";
        }

        #! returns a string of random characters
        /** @param len the length of the string to return

            @since %Mime 1.3.4 implemented by Util::get_random_string()
         */
        static string getRandomString(int len) {
            return get_random_string(len, 3);
        }

        #! returns a hash representing a parsed multipart message body from a boundary string and body arguments
        /** Also parses long headers as per <a href="http://tools.ietf.org/html/rfc2822#section-2.2.3">RFC 2822 section 2.2.3</a>

            @par Example:
            For example, given the following code:
            @code{.py}
string body = "This is a message with multiple parts in MIME format.\r
--frontier\r
Content-Type: text/plain\r
\r
This is the body of the message.\r
--frontier\r
Content-Type: text/html\r
Content-Transfer-Encoding: base64\r
\r
PGh0bWw+CiAgPGhlYWQ+CiAgPC9oZWFkPgogIDxib2R5PgogICAgPHA+VGhpcyBpcyB0aGUg\rMultiPartFormDataMessage
Ym9keSBvZiB0aGUgbWVzc2FnZS48L3A+CiAgPC9ib2R5Pgo8L2h0bWw+Cg=\r
--frontier--\r
";
    printf("%N\n", MultiPartMessage::parseBody("frontier", body, True));
            @endcode \n
            The above code will output the following:
            @verbatim
hash: (2 members)
  body : "This is a message with multiple parts in MIME format."
  part : list: (2 elements)
    [0]=hash: (2 members)
      hdr : hash: (1 member)
        content-type : "text/plain"
      body : "This is the body of the message."
    [1]=hash: (2 members)
      hdr : hash: (2 members)
        content-type : "text/html"
        content-transfer-encoding : "base64"
      body : "<html>
  <head>
  </head>
  <body>
    <p>This is the body of the message.</p>
  </body>
</html>
"
            @endverbatim

            @param boundary the boundary string
            @param body the message body to parse; parsing only works if the line termination characters are \c "\r\n"
            @param decode decode the parts (in this case a part may itself have parts recursively)

            @return a hash representing a parsed multipart message body with the following keys:
            - \c body: any non-part message body left after parsing the parts; will be an empty string if the entiore
              body is made up of the parts
            - \c part: a list of the parts; each list element is a hash representing a part of the message with the following keys:
              - \c hdr: a hash of part headers, where each header value is converted to lower case and used as a hash key
              - \c body: the body of the part as a string; this can only be a binary object if the \a decode argument is @ref True "True", the part's content-encoding is base64 and the part's content type does not contain the word \c "text"
              - \c [part]: if the \a decode parameter is @ref True "True" then any content-encoding for parts is decoded automatically; also parts that have parts themselves are processed recursively if this argument is set

            @throw MULTIPART-PARSEBODY-ERROR no boundary found in body; no closing boundary; malformatted part or part header, etc

            @note multipart message parsing only works if the line termination characters are \c "\r\n"; make sure and convert the end of line characters before passing to this method if necessary
         */
        static hash<MessageInfo> parseBody(string boundary, data body, bool decode = True) {
            # issue #2936: convert body to binary for binary searches / byte offsets
            if (body.typeCode() == NT_STRING) {
                body = binary(body);
            }
            # find beginning
            int i = body.find("--" + boundary + "\r\n");
            if (i == -1)
                throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot find boundary %y in body", boundary);

            # see if the boundary is at the beginning of the body, in which case it is not preceded by "\r\n"
            # otherwise it should be
            # start offset
            int so = 4;
            if (i >= 2 && body[i - 2] == ASCII_CR && body[i - 1] == ASCII_LF) {
                so = 6;
                i -= 2;
            }

            binary mbin = body.substr(i + boundary.size() + so);
            #printf("boundary:\n%s\nMBIN (i: %d size: %d):\n%s\n", boundary, i, mbin.size(), mbin.toString());

            # find end
            int j = mbin.rfind("\r\n--" + boundary + "--");
            if (j == -1)
                throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot find closing boundary %y in body", "--" + boundary
                    + "--");

            # remove multipart string from body
            splice body, i, j + boundary.size() * 2 + 8 + so;

            #printf("BODY (i: %d, j: %d): %s\n", i, j, body.toString());

            # remove final boundary and any excess text from the multipart string
            splice mbin, j;

            # part list
            list<hash<MessageInfo>> plist();

            # process parts
            list<binary> l = mbin.split("\r\n--" + boundary + "\r\n");
            foreach data pstr in (l) {
                i = pstr.find("\r\n\r\n");
                if (i == -1)
                    throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot parse MIME part %d/%d; could not find content "
                        "boundary", $# + 1, l.size());

                # get header string
                string phdr = pstr.substr(0, i).toString();
                # parse header
                hash h;
                list<string> pl = phdr.split("\r\n");
                for (int k = 0; k < pl.size(); ++k) {
                    string phl = pl[k];
                    (*string hdr, *string val) = (phl =~ x/([^:]+):\s*(.*)$/);
                    if (!hdr) {
                        throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot parse MIME part %d/%d header line: %y",
                            $# + 1, l.size(), phl);
                    }

                    # see if the following line is a long header field as defined in RFC 2822 section 2.2.3:
                    # http://tools.ietf.org/html/rfc2822#section-2.2.3
                    while (pl[k + 1] =~ /^[ \t]/)
                        val += " " + trim(pl[++k]);

                    # make sure header keys are returned in lower case
                    hdr = hdr.lwr();
                    h{hdr} = val;
                }

                # remove header from content
                splice pstr, 0, i + 4;

                list<hash<MessageInfo>> part();

                # decode the part if necessary
                if (decode) {
                    # part content type (default = no encoding)
                    string pct = Mime::ContentTransEnc7Bit;
                    # part content transfer encoding (default: no encoding)
                    string pcte = ContentTransEncBinary;

                    # process part headers
                    foreach hash hh in (h.pairIterator()) {
                        if (hh.key == "content-transfer-encoding")
                            pcte = hh.value.lwr();
                        else if (hh.key == "content-type")
                            pct = hh.value;
                    }

                    # decode the part's body
                    pstr = mime_decode_transfer_data(pstr, pcte, pct, True);
                    if (pstr.typeCode() == NT_BINARY && pct =~ /text/)
                        pstr = binary_to_string(pstr);

                    # see if the part has parts itself
                    if (pct =~ /multipart\//i) {
                        *string part_boundary = (pct =~ x/[Bb]oundary="?([^"]+)"?/)[0];
                        if (!exists part_boundary)
                            throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot parse part %d Content-Type: %y; could "
                                "not find message boundary", $#, pct);

                        hash<MessageInfo> ph = MultiPartMessage::parseBody(part_boundary, pstr, True);
                        pstr = ph.body;
                        part = ph.part;
                    }
                }

                hash<MessageInfo> pi((
                    "hdr": h,
                    "body": pstr,
                ));

                if (part)
                    pi.part = part;

                plist += pi;
            }

            return <MessageInfo>{
                "body": binary_to_string(body),
                "part": plist,
            };
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c body: a binary object of serialized message parts
         */
        abstract hash<MessageInfo> getMsgAndHeaders();

        #! @cond nodoc
        # don't reimplement this method; fix/enhance it in the module
        final private hash<MessageInfo> getMsgAndHeadersIntern(*string content_type, bool conlen = True) {
            if (!exists content_type)
                content_type = ct;

            if (l.empty())
                throw "HTTP-MULTIPART-ERROR", "the message has no parts";

            binary msg = binary(MP_DEFAULT_MSG);
            foreach hash<MessagePartInfo> m in (l) {
                binary bd = binary(m.data);
                msg += "\r\n--" + boundary + "\r\n";
                msg += MultiPartMessage::serializeHeaders(m.hdr + (conlen ? ("Content-Length": bd.size()) : NOTHING));
                msg += bd;
            }
            msg += "\r\n--" + boundary + "--";

            return new hash<MessageInfo>((
                "hdr": hdr + ("Content-Type": content_type),
                "body": msg,
                ));
        }

        # don't reimplement this method; fix/enhance it in the module
        private splicePartIntern(data mime_data, hash<auto> hdr) {
            splice l, 0, 0, MultiPartMessage::getPart(mime_data, hdr);
        }

        # don't reimplement this method; fix/enhance it in the module
        private addPartIntern(data mime_data, hash<auto> hdr) {
            l += MultiPartMessage::getPart(mime_data, hdr);
        }

        private static hash<MessagePartInfo> getPart(data mime_data, hash<auto> hdr) {
            if (exists hdr."Content-Length")
                throw "HTTP-MULTIPART-ERROR", "illegal part header 'Content-Length': the Content-Length header will be generated automatically according to the size of each part";

            switch (mime_data.typeCode()) {
                case NT_STRING: {
                    *string ct;
                    if (hdr."content-type") {
                        ct = hdr."Content-Type" = remove hdr."content-type";
                    }
                    else
                        ct = hdr."Content-Type";
                    # NOTE we do not check if the charset matches the actual encoding here
                    # we just add the charset= text if it's not already present
                    if (ct !~ /charset=/) {
                        if (!ct.empty())
                            ct += "; ";
                        ct += sprintf("charset=%s", get_encoding(mime_data));
                        hdr."Content-Type" = ct;
                    }
                    if (!exists hdr."Content-Transfer-Encoding")
                        hdr."Content-Transfer-Encoding" = "8bit";
                    break;
                }
                case NT_BINARY: {
                    if (!exists hdr."Content-Transfer-Encoding")
                        hdr."Content-Transfer-Encoding" = "binary";
                }
            }
            return new hash<MessagePartInfo>((
                "data": mime_data,
                "hdr": hdr,
            ));
        }
        #! @endcond
    }

    #! implements the MultiPartRelatedMessage class, a specialization of MultiPartMessage
    public class MultiPartRelatedMessage inherits MultiPartMessage {
        #! @cond nodoc
        private {
            # the starting part ID
            string startid;
        }
        #! @endcond

        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_RELATED, boundary) {
        }

        #! adds a message part to the start of the list
        /** @param mime_data the data for the part
            @param id the multipart/related ID for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-RELATED-ERROR if the id parameter is empty, this exception is thrown
         */
        splicePart(data mime_data, string id, string content_type, *hash<auto> hdr) {
            if (id.empty()) {
                throw "MULTIPART-RELATED-ERROR", "missing second argument giving the Content-ID identifying the "
                    "part; this header is required for each part as this is how the parts are related to the main "
                    "message";
            }

            startid = id;
            splicePartIntern(mime_data, hdr + {
                "Content-ID": id,
                "Content-Type": content_type,
            });
        }

        #! adds a message part to the end of the list
        /** @param mime_data the data for the part
            @param id the multipart/related ID for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-RELATED-ERROR if the id parameter is empty, this exception is thrown
         */
        addPart(data mime_data, string id, string content_type, *hash hdr) {
            if (id.empty()) {
                throw "MULTIPART-RELATED-ERROR", "missing second argument giving the Content-ID identifying the "
                    "part; this header is required for each part as this is how the parts are related to the main "
                    "message";
            }

            if (!exists startid) {
                startid = id;
            }

            addPartIntern(mime_data, hdr + {
                "Content-ID": id,
                "Content-Type": content_type,
            });
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c body: a binary object of serialized message parts
         */
        hash<MessageInfo> getMsgAndHeaders() {
            return getMsgAndHeadersIntern(ct + "; start=" + startid);
        }
    }

    #! implements the MultiPartMixedMessage class, a specialization of MultiPartMessage
    public class MultiPartMixedMessage inherits MultiPartMessage {
        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_MIXED, boundary) {
            #hdr = {};
            hdr = {
                "MIME-Version": "1.0",
            };
        }

        #! adds a message part to the start of the list; the data muyst already be encoded and any Content-Transfer-Encoding header must already be present in hdr
        /** @param mime_data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::spliceEncodePart()
            - MultiPartMixedMessage::addEncodePart()
         */
        splicePart(data mime_data, string content_type = MimeTypeText, string disp = "inline", *hash<auto> hdr) {
            if (content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            splicePartIntern(mime_data, hdr + {
                "Content-Type": content_type,
                "Content-Disposition": disp,
            });
        }

        #! adds a message part to the end of the list; the data muyst already be encoded and any Content-Transfer-Encoding header must already be present in hdr
        /** @param mime_data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::spliceEncodePart()
            - MultiPartMixedMessage::addEncodePart()
         */
        addPart(data mime_data, string content_type = MimeTypeText, string disp = "inline", *hash<auto> hdr) {
            if (content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            addPartIntern(mime_data, hdr + {"Content-Type": content_type, "Content-Disposition": disp});
        }

        #! adds a message part to the start of the list; encodes the data according to the transfer encoding argument passed
        /** @param mime_data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::addEncodePart()
         */
        spliceEncodePart(data mime_data, string enc, string content_type = MimeTypeText, string disp = "inline", *hash<auto> hdr) {
            if (content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            if (mime_data.typeCode() == NT_STRING && content_type !~ /charset=/ && disp == "inline")
                content_type += sprintf("; charset=%s", get_encoding(mime_data));
            splicePartIntern(mime_encode_transfer_data(mime_data, enc), hdr
                + {"Content-Type": content_type, "Content-Disposition": disp, "Content-Transfer-Encoding": enc});
        }

        #! adds a message part to the end of the list; encodes the data according to the transfer encoding argument passed
        /** @param mime_data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::spliceEncodePart()
         */
         addEncodePart(data mime_data, string enc, string content_type = MimeTypeText, string disp = "inline", *hash<auto> hdr) {
            if (content_type.empty()) {
                throw "PART-ERROR", "empty content type argument passed";
            }

            if (mime_data.typeCode() == NT_STRING && content_type !~ /charset=/ && disp == "inline") {
                content_type += sprintf("; charset=%s", get_encoding(mime_data));
            } else if (content_type !~ /charset=/ && disp == "attachment"
                && exists hdr."Content-Disposition") {
                content_type += sprintf('; name=%y', hdr."Content-Disposition");
                disp = sprintf('%s; filename=%y', disp, hdr."Content-Disposition");
            }

            addPartIntern(mime_encode_transfer_data(mime_data, enc), hdr + {
                 "Content-Type": content_type,
                 "Content-Disposition": disp,
                 "Content-Transfer-Encoding": enc,
            });
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c body: a binary object of serialized message parts
         */
        hash<MessageInfo> getMsgAndHeaders() {
            return getMsgAndHeadersIntern(NOTHING, False);
        }
    }

    #! implements the MultiPartAlternativeMessage class, a specialization of MultiPartMessage
    public class MultiPartAlternativeMessage inherits MultiPartMessage {
        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_ALTERNATIVE, boundary) {
            hdr = hash();
        }

        #! adds a message part to the start of the list
        /** The data must already be encoded and any Content-Transfer-Encoding header must already be present in hdr

            @param mime_data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartAlternativeMessage::addPart()
            - MultiPartAlternativeMessage::spliceEncodePart()
            - MultiPartAlternativeMessage::addEncodePart()
         */
        splicePart(data mime_data, string content_type = MimeTypeText, string disp = "inline", *hash<auto> hdr) {
            if (content_type.empty()) {
                throw "PART-ERROR", "empty content type argument passed";
            }

            splicePartIntern(mime_data, hdr + {
                "Content-Type": content_type,
                "Content-Disposition": disp,
            });
        }

        #! adds a message part to the end of the list; the data muyst already be encoded and any Content-Transfer-Encoding header must already be present in hdr
        /** @param mime_data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartAlternativeMessage::splicePart()
            - MultiPartAlternativeMessage::spliceEncodePart()
            - MultiPartAlternativeMessage::addEncodePart()
         */
        addPart(data mime_data, string content_type = MimeTypeText, string disp = "inline", *hash<auto> hdr) {
            if (content_type.empty()) {
                throw "PART-ERROR", "empty content type argument passed";
            }

            addPartIntern(mime_data, hdr + {
                "Content-Type": content_type,
                "Content-Disposition": disp,
            });
        }

        #! adds a message part to the start of the list; encodes the data according to the transfer encoding argument passed
        /** @param mime_data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartAlternativeMessage::splicePart()
            - MultiPartAlternativeMessage::addPart()
            - MultiPartAlternativeMessage::addEncodePart()
         */
        spliceEncodePart(data mime_data, string enc, string content_type = MimeTypeText, string disp = "inline",
                *hash<auto> hdr) {
            if (content_type.empty()) {
                throw "PART-ERROR", "empty content type argument passed";
            }

            if (mime_data.typeCode() == NT_STRING && content_type !~ /charset=/ && disp == "inline") {
                content_type += sprintf("; charset=%s", get_encoding(mime_data));
            }
            splicePartIntern(mime_encode_transfer_data(mime_data, enc), hdr + {
                "Content-Type": content_type,
                "Content-Disposition": disp,
                "Content-Transfer-Encoding": enc,
            });
        }

        #! adds a message part to the end of the list; encodes the data according to the transfer encoding argument passed
        /** @param mime_data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartAlternativeMessage::addPart()
            - MultiPartAlternativeMessage::splicePart()
            - MultiPartAlternativeMessage::spliceEncodePart()
         */
        addEncodePart(data mime_data, string enc, string content_type = MimeTypeText, string disp = "inline",
                *hash<auto> hdr) {
            if (content_type.empty()) {
                throw "PART-ERROR", "empty content type argument passed";
            }

            if (mime_data.typeCode() == NT_STRING && content_type !~ /charset=/ && disp == "inline") {
                content_type += sprintf("; charset=%s", get_encoding(mime_data));
            }

            addPartIntern(mime_encode_transfer_data(mime_data, enc), hdr + {
                "Content-Type": content_type,
                "Content-Transfer-Encoding": enc,
            });
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c body: a binary object of serialized message parts
         */
        hash<MessageInfo> getMsgAndHeaders() {
            return getMsgAndHeadersIntern(NOTHING, False);
        }
    }

    #! implements the MultiPartFormDataMessage class, a specialization of MultiPartMessage
    /** @since %Mime 1.4
    */
    public class MultiPartFormDataMessage inherits MultiPartMessage {
        private {
            #! hash of part names to ensure uniqueness
            hash parts;
        }

        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_FORM_DATA, boundary) {
        }

        #! adds a message part to the start of the list
        /** @param mime_data the data for the part
            @param name the unique name for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-FORMDATA-ERROR the name parameter is empty or conflicts with an existing part name
         */
        splicePart(data mime_data, string name, *hash hdr) {
            checkPartName(name);
            splicePartIntern(mime_data, getPartHeader(name, NOTHING, NOTHING, hdr));
        }

        #! adds a message part to the start of the list
        /** @param mime_data the data for the part
            @param name the unique name for the part
            @param filename the filename for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-FORMDATA-ERROR the name parameter is empty or conflicts with an existing part name; empty filename or content_type arguments
         */
        splicePart(data mime_data, string name, string filename, string content_type, *hash hdr) {
            checkPartName(name);
            splicePartIntern(mime_data, getPartHeader(name, filename, content_type, hdr));
        }

        #! adds a message part to the start of the list
        /** @param h the information for this part

            @throw MULTIPART-FORMDATA-ERROR the name parameter is empty or conflicts with an existing part name; empty filename or content_type arguments
         */
        splicePart(hash<FormDataMessageInfo> h) {
            checkPartName(h.name);
            splicePartIntern(h.body, getPartHeader(h.name, h.filename, h.hdr."Content-Type" ?? h.hdr."content-type", h.hdr - ("Content-Type", "content-type")));
        }

        #! adds a message part to the end of the list
        /** @param mime_data the data for the part
            @param name the unique name for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-FORMDATA-ERROR the name parameter is empty or conflicts with an existing part name
         */
        addPart(data mime_data, string name, *hash hdr) {
            checkPartName(name);
            addPartIntern(mime_data, getPartHeader(name, NOTHING, NOTHING, hdr));
        }

        #! adds a message part to the end of the list
        /** @param mime_data the data for the part
            @param name the unique name for the part
            @param filename the filename for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-FORMDATA-ERROR the name parameter is empty or conflicts with an existing part name; empty filename or content_type arguments
         */
        addPart(data mime_data, string name, string filename, string content_type, *hash hdr) {
            checkPartName(name);
            addPartIntern(mime_data, getPartHeader(name, filename, content_type, hdr));
        }

        #! adds a message part to the end of the list
        /** @param h the information for this part

            @throw MULTIPART-FORMDATA-ERROR the name parameter is empty or conflicts with an existing part name; empty filename or content_type arguments
         */
        addPart(hash<FormDataMessageInfo> h) {
            checkPartName(h.name);
            addPartIntern(h.body, getPartHeader(h.name, h.filename, h.hdr."Content-Type" ?? h.hdr."content-type", h.hdr - ("Content-Type", "content-type")));
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c body: a binary object of serialized message parts
         */
        hash<MessageInfo> getMsgAndHeaders() {
            return getMsgAndHeadersIntern(NOTHING, False);
        }

        #! parses a multipart/form-data encoded message and returns a hash of its ContentTransEnc7Bit
        /** @param content the message \c Content-Type string which must contain the message boundary string
            @param body the message body to parse

            @return a hash of @ref FormDataMessageInfo hashes keyed by part name

            @throws MULTIPART-FORMDATA-MESSAGE-ERROR cannot find message boundary string; invalid form-data part data

            @since %Mime 1.4
        */
        static hash<string, hash<FormDataMessageInfo>> parseMessage(string content, string body) {
            *string boundary = (content =~ x/[Bb]oundary="?([^"]+)"?/)[0];
            if (!exists boundary)
                throw "MULTIPART-FORMDATA-MESSAGE-ERROR", sprintf("cannot parse form-data Content-Type: %y; could "
                    "not find message boundary", content);

            hash<MessageInfo> mh = MultiPartMessage::parseBody(boundary, body);

            hash<string, hash<FormDataMessageInfo>> rv();

            foreach hash<MessageInfo> h in (mh.part) {
                # parse Content-Disposition header
                *string cd = h.hdr."content-disposition" ?? h.hdr."Content-Disposition";
                if (!cd.val())
                    throw "MULTIPART-FORMDATA-MESSAGE-ERROR", sprintf("the Content-Disposion part header is missing "
                        "in part %d/%d", $# + 1, mh.part.size());
                *string name = (cd =~ x/name="([^"]+)"/)[0];
                if (!name.val())
                    throw "MULTIPART-FORMDATA-MESSAGE-ERROR", sprintf("the Content-Disposion part header is missing "
                        "the part name in part %d/%d", $# + 1, mh.part.size());
                *string filename = (cd =~ x/filename="([^"]+)"/)[0];
                rv{name} = new hash<FormDataMessageInfo>((
                    "name": name,
                    "filename": filename,
                    "hdr": h.hdr,
                    "body": h.body,
                ));
            }

            return rv;
        }

        #! creates a multipart/form-data message from a hash of @ref FormDataMessageInfo hashes keyed by part name
        /** @param parts a hash of @ref FormDataMessageInfo hashes keyed by part name

            @return the message object corresponding to the arguments
        */
        static MultiPartFormDataMessage makeMessage(hash<string, hash<FormDataMessageInfo>> parts) {
            MultiPartFormDataMessage msg();
            map msg.addPart($1), parts.iterator();
            return msg;
        }

        #! creates a multipart/form-data message body from a hash of @ref FormDataMessageInfo hashes keyed by part name
        /** @param parts a hash of @ref FormDataMessageInfo hashes keyed by part name

            @return the serialized message body corresponding to the arguments
        */
        static binary makeMessageBody(hash<string, hash<FormDataMessageInfo>> parts) {
            return MultiPartFormDataMessage::makeMessage(parts).serialize();
        }

        #! check for unique part names and adds the part to the unique name hash
        private checkPartName(string name) {
            if (name.empty())
                throw "MULTIPART-FORMDATA-ERROR", "missing second argument giving the name of the part";
            if (parts{name})
                throw "MULTIPART-FORMDATA-ERROR", sprintf("part %y given twice", name);
            parts{name} = True;
        }

        #! builds the header for the part
        private hash getPartHeader(string name, *string filename, *string content_type, *hash<auto> hdr) {
            # make Content-Disposition part header
            string cd = sprintf("%s; name=%y", MPT_FORM_DATA, name);
            if (filename.val()) {
                if (!content_type) {
                    throw "MULTIPART-FORMDATA-ERROR", sprintf("the content_type argument is required when a filename "
                        "(%y) is given", filename);
                }
                cd += sprintf("; filename=%y", filename);
            }
            if (content_type) {
                hdr."Content-Type" = content_type;
            }
            hdr."Content-Disposition" = cd;
            return hdr;
        }
    }
}
