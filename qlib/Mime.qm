# -*- mode: qore; indent-tabs-mode: nil -*-
# @file Mime.qm Mime module definition

/*  Mime.qm Copyright (C) 2012 - 2014 David Nichols

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.10

%requires Util

module Mime {
    version = "1.3.4";
    desc = "Mime module providing MIME-related definitions";
    author = "David Nichols";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Mime Module

    @tableofcontents

    @section mimeintro Introduction to the Mime Module

    The %Mime module provides definitions and functions related to MIME processing.  MIME concepts are used in HTTP and SMTP communications, among others.

    To use this module, use \c "%requires Mime" in your code.  See the SmtpClient and the HttpServer modules for examples of %Qore code using this module.
    
    All the public symbols in the module are defined in the Mime namespace

    The main definitions and functions are:
    - @ref MimeTypeDefinitions "MimeTypeDefinitions": constant for common MIME types
    - @ref Mime::MimeTypes "MimeTypes": a map of common file name extensions to the default MIME type
    - @ref MimeEncodingFunctions "MimeEncodingFunctions": functions for encoding MIME data
    - @ref MimeDecodingFunctions "MimeDecodingFunctions": functions for decoding MIME data
    - @ref MultiPartConstants "MultiPartConstants": constants for the MultiPartMessage classes
    - @ref Mime::MultiPartMessage "MultiPartMessage": the base class for MultiPartMessage classes
      - @ref Mime::MultiPartMessage::parseBody() "MultiPartMessage::parseBody()": use this static function to parse multipart message bodies (including parts that themselves have parts if the \a decode argument is @ref Qore::True "True"); this static method can be used for both HTTP multipart messages or text multipart messages (for example as sent in an email/SMTP message)
    - @ref Mime::MultiPartRelatedMessage "MultiPartRelatedMessage": a class for handling multipart/related messages

    based on:
    - http://tools.ietf.org/html/rfc1521: quoted printable & base 64 transfer encodings
    - http://tools.ietf.org/html/rfc2045: mime headers, content types, etc
    - http://tools.ietf.org/html/rfc2047: "Q" and "B" encoded words (implemented by the Mime module)

    @par Example:
    @code
#!/usr/bin/env qore

%requires Mime

my string $str = "This is a test: æéìœü";
printf("%y: quoted printable: %y\n", mime_decode_quoted_printable(mime_encode_quoted_printable($str)), mime_encode_quoted_printable($str));
printf("%y: base64: %y\n", mime_decode_base64_to_string(mime_encode_base64($str)), mime_encode_base64($str));
printf("%y: header word q: %y\n", mime_decode_header(mime_encode_header_word_q($str)), mime_encode_header_word_q($str));
printf("%y: header word b: %y\n", mime_decode_header(mime_encode_header_word_b($str)), mime_encode_header_word_b($str));
    @endcode \n
    The output of the above example looks like:
    @verbatim
"This is a test: æéìœü": quoted printable: "This is a test: =C3=A6=C3=A9=C3=AC=C5=93=C3=BC"
"This is a test: æéìœü": base64: "VGhpcyBpcyBhIHRlc3Q6IMOmw6nDrMWTw7w="
"This is a test: æéìœü": header word q: "=?UTF-8?Q?This_is_a_test:_=C3=A6=C3=A9=C3=AC=C5=93=C3=BC?="
"This is a test: æéìœü": header word b: "=?UTF-8?B?VGhpcyBpcyBhIHRlc3Q6IMOmw6nDrMWTw7w=?="
    @endverbatim

    @section mimereleasenotes Release Notes

    @subsection mime_1_3_4 v1.3.4
    - added dependency on the Util module
    - replaced Mime::MultiPartMessage::getRandomString() with Util::get_random_string()

    @subsection mime_1_3_3 v1.3.3
    - added Mime::MimeTypeOctetStream constant

    @subsection mime_1_3_2 v1.3.2
    - added mime type for WSDL files (\c "application/wsdl+xml")
    - added mappings for xls and xlst extensions to Mime::MimeTypes

    @subsection mime_1_3_1 v1.3.1
    - added Mime::get_mime_type_from_ext()
    - minor corrections
    - added constants for css and js files + more extension -> mime type mappings
    
    @subsection mime_1_3 v1.3
    - made get Mime::MultiPartMessage::getMsgAndHeaders() abstract as originally intended
    - added Mime::MultiPartMessage::parseBody() static method

    @subsection mime_1_2_1 v1.2.1
    - fixed q-encoding mail headers (always encode '_' chars otherwise they will be decoded as spaces)

    @subsection mime_1_2 v1.2
    - added MIME decoding functions

    @subsection mime_1_1 v1.1
    - added initial Mime::MultiPartMessage classes

    @subsection mime_1_0 v1.0
    - pulled MIME implementation out of other code and made a user module to aggregate MIME definitions and functions
*/

#! public Mime namespace defines constants and functions relevant to MIME
public namespace Mime {
    /** @defgroup MimeTypeDefinitions MIME Type Definitions
	These are constants for common MIME types
     */
    #@{
    public const MimeTypeUnknown = MimeTypeOctetStream;

    #! MIME type for unknown file types
    public const MimeTypeOctetStream = "application/octet-stream";

    #! MIME type for text
    public const MimeTypeText = "text/plain";

    #! MIME type for HTML
    public const MimeTypeHtml = "text/html";

    #! MIME type for csv files (http://tools.ietf.org/html/rfc4180)
    public const MimeTypeCsv = "text/csv";

    #! MIME type for jpeg images
    public const MimeTypeJpeg = "image/jpeg";

    #! MIME type for png images
    public const MimeTypePng = "image/png";

    #! Mime type for SOAP XML messages (XML MIME type reference: http://tools.ietf.org/html/rfc3023)
    public const MimeTypeSoapXml = "application/soap+xml";

    #! Mime type for yaml data files
    public const MimeTypeYaml = "text/x-yaml";

    #! Mime type for plain (human-readable) xml files
    public const MimeTypeXml = "text/xml";

    #! Mime type for more complicated (not human-readable) xml files
    public const MimeTypeXmlApp = "application/xml";

    #! Mime type for JSON
    public const MimeTypeJson = "application/json";

    #! Mime type for JSON-RPC
    public const MimeTypeJsonRpc = MimeTypeJson;

    #! Mime type for XML-RPC
    public const MimeTypeXmlRpc = MimeTypeXml;

    #! Mime type for YAML-RPC
    public const MimeTypeYamlRpc = "application/x-yaml";

    #! Mime type for Javascript
    public const MimeTypeJavascript = "application/javascript";

    #! Mime type for css
    public const MimeTypeCss = "text/css";

    #! A map of default mime types per file extension; the hash keys are file extensions in lower-case without the dot (ex: \c "txt")
    /** @showinitializer
     */
    public const MimeTypes = (
	"7z": "application/x-7z-compressed",
	"ai": "application/postscript",
	"aif": "audio/x-aiff",
	"aifc": "audio/x-aiff",
	"aiff": "audio/x-aiff",
	"asc": MimeTypeText,
	"atom": "application/atom+xml",
	"au": "audio/basic",
	"avi": "video/x-msvideo",
	"bcpio": "application/x-bcpio",
	"bin": MimeTypeUnknown,
	"bmp": "image/bmp",
	"bz2": "application/x-bzip",
	"cc": MimeTypeText,
	"cdf": "application/x-netcdf",
	"cgm": "image/cgm",
	"class": MimeTypeUnknown,
	"cpio": "application/x-cpio",
	"cpp": MimeTypeText,
	"cpt": "application/mac-compactpro",
	"csh": "application/x-csh",
	"css": MimeTypeCss,
	"csv": MimeTypeCsv,
	"dcr": "application/x-director",
	"dif": "video/x-dv",
	"dir": "application/x-director",
	"djv": "image/vnd.djvu",
	"djvu": "image/vnd.djvu",
	"dll": MimeTypeUnknown,
	"dmg": MimeTypeUnknown,
	"dms": MimeTypeUnknown,
	"doc": "application/msword",
	"dtd": "application/xml-dtd",
	"dv": "video/x-dv",
	"dvi": "application/x-dvi",
	"dxr": "application/x-director",
	"eps": "application/postscript",
	"etx": "text/x-setext",
	"exe": MimeTypeUnknown,
	"ez": "application/andrew-inset",
	"gif": "image/gif",
	"gram": "application/srgs",
	"grxml": "application/srgs+xml",
	"gtar": "application/x-gtar",
	"gz": "application/x-gzip",
	"h": MimeTypeText,
	"hdf": "application/x-hdf",
	"hh": MimeTypeText,
	"hpp": MimeTypeText,
	"hqx": "application/mac-binhex40",
	"htm": MimeTypeHtml,
	"html": MimeTypeHtml,
	"ice": "x-conference/x-cooltalk",
	"ico": "image/x-icon",
	"ics": "text/calendar",
	"ief": "image/ief",
	"ifb": "text/calendar",
	"iges": "model/iges",
	"igs": "model/iges",
	"jar": "application/java-archive",
	"java": MimeTypeText,
	"jnlp": "application/x-java-jnlp-file",
	"jp2": "image/jp2",
	"jpe": MimeTypeJpeg,
	"jpeg": MimeTypeJpeg,
	"jpg": MimeTypeJpeg,
	"js": MimeTypeJavascript,
	"kar": "audio/midi",
	"latex": "application/x-latex",
	"lha": MimeTypeUnknown,
	"lzh": MimeTypeUnknown,
	"m3u": "audio/x-mpegurl",
	"m4a": "audio/mp4a-latm",
	"m4b": "audio/mp4a-latm",
	"m4p": "audio/mp4a-latm",
	"m4u": "video/vnd.mpegurl",
	"m4v": "video/x-m4v",
	"mac": "image/x-macpaint",
	"man": "application/x-troff-man",
	"mathml": "application/mathml+xml",
	"me": "application/x-troff-me",
	"mesh": "model/mesh",
	"mid": "audio/midi",
	"midi": "audio/midi",
	"mif": "application/vnd.mif",
	"mov": "video/quicktime",
	"movie": "video/x-sgi-movie",
	"mp2": "audio/mpeg",
	"mp3": "audio/mpeg",
	"mp4": "video/mp4",
	"mpe": "video/mpeg",
	"mpeg": "video/mpeg",
	"mpg": "video/mpeg",
	"mpga": "audio/mpeg",
	"ms": "application/x-troff-ms",
	"msh": "model/mesh",
	"mxu": "video/vnd.mpegurl",
	"nc": "application/x-netcdf",
	"oda": "application/oda",
	"ogg": "application/ogg",
	"pbm": "image/x-portable-bitmap",
	"pct": "image/pict",
	"pdb": "chemical/x-pdb",
	"pdf": "application/pdf",
	"pgm": "image/x-portable-graymap",
	"pgn": "application/x-chess-pgn",
	"pic": "image/pict",
	"pict": "image/pict",
	"png": MimeTypePng,
	"pnm": "image/x-portable-anymap",
	"pnt": "image/x-macpaint",
	"pntg": "image/x-macpaint",
	"ppm": "image/x-portable-pixmap",
	"ppt": "application/vnd.ms-powerpoint",
	"ps": "application/postscript",

	# Qore script
	"q": MimeTypeText,

	# Qore class include file
	"qc": MimeTypeText,

        # Qorus function definition file
        "qfd": MimeTypeText,

        # Qorus class definition file
        "qclass": MimeTypeText,

        # Qorus constant definition file
        "qconst": MimeTypeText,

        # Qorus job definition
        "qjob": MimeTypeText,

	# Qore include file
	"ql": MimeTypeText,

	# Qore user module source
	"qm": MimeTypeText,

        # Qorus service definition
        "qsd": MimeTypeText,

        # Qorus workflow definition
        "qwf": MimeTypeText,

	"qt": "video/quicktime",
	"qti": "image/x-quicktime",
	"qtif": "image/x-quicktime",
	"ra": "audio/x-pn-realaudio",
	"ram": "audio/x-pn-realaudio",
	"ras": "image/x-cmu-raster",
	"rdf": "application/rdf+xml",
	"rgb": "image/x-rgb",
	"rm": "application/vnd.rn-realmedia",
	"roff": "application/x-troff",
	"rtf": "text/rtf",
	"rtx": "text/richtext",
	"sgm": "text/sgml",
	"sgml": "text/sgml",
	"sh": "application/x-sh",
	"shar": "application/x-shar",
	"silo": "model/mesh",
	"sit": "application/x-stuffit",
	"skd": "application/x-koan",
	"skm": "application/x-koan",
	"skp": "application/x-koan",
	"skt": "application/x-koan",
	"smi": "application/smil",
	"smil": "application/smil",
	"snd": "audio/basic",
	"so": MimeTypeUnknown,
	"spl": "application/x-futuresplash",
	"src": "application/x-wais-source",
	"sv4cpio": "application/x-sv4cpio",
	"sv4crc": "application/x-sv4crc",
	"svg": "image/svg+xml",
	"swf": "application/x-shockwave-flash",
	"t": "application/x-troff",
	"tar": "application/x-tar",
	"tar.bz2": "application/x-bzip-compressed-tar",
	"tar.gz": "application/x-tar-gz",	
	"tbz": "application/x-bzip-compressed-tar",
	"tcl": "application/x-tcl",
	"tex": "application/x-tex",
	"texi": "application/x-texinfo",
	"texinfo": "application/x-texinfo",
	"text": MimeTypeText,
	"tgz": "application/x-tar-gz",	
	"tif": "image/tiff",
	"tiff": "image/tiff",
	"tr": "application/x-troff",
	"tsv": "text/tab-separated-values",
	"txt": MimeTypeText,
	"ustar": "application/x-ustar",
	"vcd": "application/x-cdlink",
	"vrml": "model/vrml",
	"vxml": "application/voicexml+xml",
	"wav": "audio/x-wav",
	"wbmp": "image/vnd.wap.wbmp",
	"wbmxl": "application/vnd.wap.wbxml",
	"wml": "text/vnd.wap.wml",
	"wmlc": "application/vnd.wap.wmlc",
	"wmls": "text/vnd.wap.wmlscript",
	"wmlsc": "application/vnd.wap.wmlscriptc",
	"wrl": "model/vrml",
        "wsdl": "application/wsdl+xml",
	"xbm": "image/x-xbitmap",
	"xht": "application/xhtml+xml",
	"xhtml": "application/xhtml+xml",
	"xls": "application/vnd.ms-excel",
	"xml": MimeTypeXml,
	"xpm": "image/x-xpixmap",
        "xsd": MimeTypeXml,
	"xsl": "application/xml",
	"xslt": "application/xslt+xml",
	"xul": "application/vnd.mozilla.xul+xml",
	"xwd": "image/x-xwindowdump",
	"xyz": "chemical/x-xyz",
	"yaml": MimeTypeYaml,
	"zip": "application/zip",
	);
    #@}

    /** @defgroup MimeContentTransferEncodingConstants MIME Content Transfer Encoding Constants
     */
    #@{
    #! default Content-Transfer-Encoding if none is present; implies lines < 1000 chars (= no encoding)
    public const ContentTransEnc7Bit = "7bit";

    #! implies lines < 1000 chars (= no encoding)
    public const ContentTransEnc8Bit = "8bit";

    #! binary transfer encoding; implies no maximum line length (= no encoding)
    public const ContentTransEncBinary = "binary";

    #! base-64 Content-Transfer-Encoding
    public const ContentTransEncBase64 = "base64";

    #! quoted-printable Content-Transfer-Encoding
    public const ContentTransEncQuotedPrintable = "quoted-printable";

    #! maximum line length for base64 encoding
    /** <a href="http://tools.ietf.org/html/rfc2045#section-6.8">RFC 2045 section 6.8</a>
     */
    public const MimeBase64LineLen = 76;

    #! maximum line length for quoted-printable encoding
    /** <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>
     */
    public const MimeQuotedPrintableLineLen = 76;
    #@}

    /** @defgroup MimeEncodingFunctions MIME Encoding Functions
     */
    #@{ 
    #! returns a string in "BASE64" encoding according to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>
    /** @param str the string to encode
	@param len the maximum line length

	@note this function is basically just a wrapper for the standard %Qore function makeBase64String()
     */
    public string sub mime_encode_base64(data $str, int $len = MimeBase64LineLen) {
	return makeBase64String($str, $len);
    }

    #! returns a string in "quoted-printable" (or "QP") encoding according to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>
    /** @param str the string to encode
	@param hdr use rules for a MIME header (<a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>)
     */
    public string sub mime_encode_quoted_printable(string $str, bool $hdr = False) {
	my string $rv;
	my int $lp = 0;

	for (my int $i = 0; $i < $str.size(); ++$i) {
	    my int $c = get_byte($str, $i);

	    # check if we're processing a UNIX '\n' line break
	    if ($c == 10) {
		# we MUST encode this as a CRLF sequence (we assume it's a UNIX line break)
		$rv += "\r\n";
		$lp = 0;
		continue;
	    }

	    # check if we're processing a CRLF line break
	    if ($c == 13 && get_byte($str, $i + 1) == 10) {
		$rv += "\r\n";
		$lp = 0;
		++$i;
		continue;
	    }

	    # new string to append
	    my string $nc;
	    # if we are encoding a header and we have a space, transform to "_"
	    if ($hdr && $c == 32)
		$nc = "_";
	    # check if the high bit is set or if it's an ASCII control character or '=', or we are encoding a header and the char is not '?' and '_', encode
	    else if (($c & 0x80) || $c < 32 || $c == 61 || ($hdr && ($c == 63 || $c == 95 || $c == 137)))
		$nc = sprintf("=%02x", $c).upr();
	    else
		$nc = chr($c);

	    # we MUST break up lines longer than 76 characters (the line length includes the '=' but not the CRLF
	    if (($nc.size() + $lp) >= (MimeQuotedPrintableLineLen - 1)) {
		# insert soft line break
		$rv += "=\r\n";
		$lp = 0;
	    }

	    $rv += $nc;
	    $lp += $nc.size();
	}
	return $rv;
    }

    #! encodes data according to the given encoding
    /** @param data the data to encode
        @param enc the encoding to use; see @ref MimeContentTransferEncodingConstants for possible values (case is ignored)

        @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
     */
    public data sub mime_encode_transfer_data(data $data, string $enc) {
        $enc = $enc.lwr();
        switch ($enc) {
            case ContentTransEnc7Bit:
            case ContentTransEnc8Bit:
            case ContentTransEncBinary:
                return $data;

            case ContentTransEncBase64:
                return mime_encode_base64($data, MimeBase64LineLen);

            case ContentTransEncQuotedPrintable:
                return mime_encode_quoted_printable($data);
        }

        throw "MIME-TRANSFER-ENCODING-ERROR", sprintf("Content-Transfer-Encoding: %y is unknown", $enc);
    }

    #! returns a string in "B" ("BASE64") encoding for MIME header string words according to <a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>
    public string sub mime_encode_header_word_b(string $str) {
	return sprintf("=?%s?B?%s?=", get_encoding($str), makeBase64String($str, MimeBase64LineLen));
    }

    #! returns a string in "Q" ("quoted-printable") encoding for MIME header string words according to <a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>
    public string sub mime_encode_header_word_q(string $str) {
	return sprintf("=?%s?Q?%s?=", get_encoding($str), mime_encode_quoted_printable($str, True));
    }
    #@}

    /** @defgroup MimeDecodingFunctions MIME Decoding Functions
     */
    #@{ 
    #! returns a binary value from a string in "BASE64" encoding according to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>
    /** @param str the string to decode

	@note this function is basically just a wrapper for the standard %Qore function parseBase64String()
     */
    public binary sub mime_decode_base64(data $str) {
	return parseBase64String($str);
    }

    #! returns a string value from a string in "BASE64" encoding according to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>
    /** @param str the string to decode
        @param encoding the character encoding to use for the string returned (if not present the default encoding is used)

	@note this function is basically just a wrapper for the standard %Qore function parseBase64StringtoString()
     */
    public string sub mime_decode_base64_to_string(data $str, *string $encoding) {
	return parseBase64StringToString($str, $encoding);
    }

    #! returns a string parsed from "quoted-printable" (or "QP") encoding according to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>
    /** @param str the string to decode
        @param encoding the character encoding to use for the string returned (if not present the default encoding is used)

        @throw QUOTED-PRINTABLE-DECODE-ERROR an error occurred decoding the quoted-printable string
     */
    public string sub mime_decode_quoted_printable(string $str, *string $encoding) {
        $str = force_encoding($str, "us-ascii");

        if ($encoding.empty())
            $encoding = get_default_encoding();

	my string $rv;
	my int $lp = 0;

        # recombine broken lines
        $str = replace($str, "=\r\n", "");

%ifdef Unix
        # substitute all \r\n occurrences with \n
        $str = replace($str, "\r\n", "\n");
%endif

        # substitute all "_" occurrences with " "
        $str = replace($str, "_", " ");

        my int $i = 0;
        while (True) {
            $i = $str.find("=", $i);
            if ($i == -1)
                break;

            my string $hex = extract $str, $i + 1, 2;
            # according to RFC 2045 sec 6.7 rule (1): we have to use upper-case characters
            if ($hex !~ /[0-9A-Z][0-9A-Z]/)
                throw "QUOTED-PRINTABLE-DECODE-ERROR", sprintf("invalid hex byte code found: %y", $hex);
            # replace the code with the given character
            splice $str, $i, 1, chr(int($hex, 16), "us-ascii");
            ++$i;
        }

        return force_encoding($str, $encoding);
    }

    #! decodes data according to the given encoding
    /** @param data the data to decode
        @param enc the decoding to use; see @ref MimeContentTransferEncodingConstants for possible values (case is ignored)
        @param ct the content-type of the data; if there is a \c "charset=xxx" component and the data is decoded to a string, then it will be returned in the given character encoding

        @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
     */
    public data sub mime_decode_transfer_data(data $data, string $enc, *string $ct) {
        $enc = $enc.lwr();
        switch ($enc) {
            case ContentTransEnc7Bit:
            case ContentTransEnc8Bit:
            case ContentTransEncBinary:
                break;

            case ContentTransEncBase64: {
                $data = mime_decode_base64($data);
                break;
            }

            case ContentTransEncQuotedPrintable: {
                $data = mime_decode_quoted_printable($data);
                break;
            }

            default:
                throw "MIME-TRANSFER-ENCODING-ERROR", sprintf("Content-Transfer-Encoding: %y is unknown", $enc);
        }

        if ($data.typeCode() == NT_STRING) {
            # see if there is a character encoding specification in the content-type
            my *string $senc = ($ct =~ x/charset="?([^"]+)"?/)[0];
            if (exists $senc)
                $data = force_encoding($data, $senc);
        }

        return $data;
    }

    #! decodes a header string; if any part of the string is encoded with "B" ("BASE64") or "Q" ("quoted-printable") encodings according to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>, then those parts are decoded and the decoded string is returned
    /** @param hdr the header value string to decode
        @return the decoded value of the header
     */
    public string sub mime_decode_header(string $hdr) {
        while (True) {
            my (*string $enc, *string $he, *string $hw) = ($hdr =~ x/=\?([^?]+)\?(Q|B)\?(.+)\?=/i);
            if (!$enc.val() || !$he.val() || !$hw.val())
                break;
            my string $dv = $he.upr() == "Q" ? mime_decode_quoted_printable($hw, $enc) : mime_decode_base64_to_string($hw, $enc);
            my string $os = sprintf("=?%s?%s?%s?=", $enc, $he, $hw);
            $hdr = replace($hdr, $os, $dv);
        }
        return $hdr;
    }
    #@}

    /** @defgroup MimeMiscFunctions Misc MIME Functions
     */
    #@{
    #! returns the mime type for the given filename from the extension or @ref MimeTypeUnknown if the extension is not present or unknown
    public string sub get_mime_type_from_ext(string $path) {
        my *string $ext = ($path =~ x/\.([a-z0-9]+)$/i)[0];
        return ($ext && ($ext = MimeTypes{$ext.lwr()})) ? $ext : MimeTypeUnknown;
    }
    #@}

    /** @defgroup MultiPartConstants MultiPartMessage Constants
     */
    #@{
    #! for form data (http://tools.ietf.org/html/rfc1867, http://tools.ietf.org/html/rfc2388)
    public const MPT_FORM_DATA   = "form-data";

    #! for sending files with different "Content-Type" headers (http://tools.ietf.org/html/rfc2046#section-5.1.3)
    public const MPT_MIXED       = "mixed";

    #! for email/MIME messages with headers (http://tools.ietf.org/html/rfc2046)
    public const MPT_MESSAGE     = "message";

    #! for sending multiple text messages (http://tools.ietf.org/html/rfc2046#section-5.1.5)
    public const MPT_DIGEST      = "digest";

    #! for sending multiple "alternatives" of the same content (http://tools.ietf.org/html/rfc2046#section-5.1.4)
    public const MPT_ALTERNATIVE = "alternative";

    #! for sending multiple components of an aggregated whole (http://tools.ietf.org/html/rfc2387)
    public const MPT_RELATED     = "related";

    #! to attach a digital signature to a message (http://tools.ietf.org/html/rfc1847#section-2.1)
    public const MPT_SIGNED      = "signed";

    #! for sending encrypted messages (http://tools.ietf.org/html/rfc1847#section-2.2)
    public const MPT_ENCRYPTED   = "encrypted";

    #! for sending noncontiguous byte ranges of a single message (http://tools.ietf.org/html/rfc2616)
    public const MPT_BYTERANGES  = "byteranges";
    #@}
        
    #! MultiPartMessage class implementation
    public class MultiPartMessage {
        const MP_DEFAULT_MSG = "This is a MIME multipart message";

        #! @cond nodoc
        private {
            #! the type of multi-part message: see @ref MultiPartConstants for possible values
            string $.mptype;

            #! the boundary to use between parts
            string $.boundary;

            #! the content type for the message as a whole
            string $.ct;

            #! list of the parts of the message
            list $.l = ();

            #! a hash of the headers of the message
            hash $.hdr;
        }
        #! @endcond

        #! creates the object
        /** @param mptype the type of multi-part message: see @ref MultiPartConstants for possible values
            @param boundary the boundary to use between parts
         */
        constructor(string $mptype, string $boundary = MultiPartMessage::getBoundary()) {
            $.mptype = $mptype;
            $.boundary = $boundary;
            $.ct = sprintf("multipart/%s;boundary=%s", $mptype, $boundary);
            $.boundary = "--" + $.boundary;
        }

        #! returns a string embedded with the current timestamp designed to be used as MultiPart boundary string
        static string getBoundary() {
            return "------Qore-MIME-Boundary" + now_us().format("YYYYMMDDHHmmSS.uuuZ") + "------";
        }

        #! returns a string of random characters
        /** @param len the length of the string to return

            @since Mime 1.3.4 implemented by Util::get_random_string()
         */
        static string getRandomString(int $len) {
            return get_random_string($len, 3);
        }

        #! returns a hash representing a parsed multipart message body from a boundary string and body arguments
        /** Also parses long headers as per <a href="http://tools.ietf.org/html/rfc2822#section-2.2.3">RFC 2822 section 2.2.3</a>

            @par Example:
            For example, given the following code:
            @code
my string $body = "This is a message with multiple parts in MIME format.\r
--frontier\r
Content-Type: text/plain\r
\r
This is the body of the message.\r
--frontier\r
Content-Type: text/html\r
Content-Transfer-Encoding: base64\r
\r
PGh0bWw+CiAgPGhlYWQ+CiAgPC9oZWFkPgogIDxib2R5PgogICAgPHA+VGhpcyBpcyB0aGUg\r
Ym9keSBvZiB0aGUgbWVzc2FnZS48L3A+CiAgPC9ib2R5Pgo8L2h0bWw+Cg=\r
--frontier--\r
";
    printf("%N\n", MultiPartMessage::parseBody("frontier", $body, True));
            @endcode \n
            The above code will output the following:
            @verbatim
hash: (2 members)
  body : "This is a message with multiple parts in MIME format."
  part : list: (2 elements)
    [0]=hash: (2 members)
      hdr : hash: (1 member)
        content-type : "text/plain"
      body : "This is the body of the message."
    [1]=hash: (2 members)
      hdr : hash: (2 members)
        content-type : "text/html"
        content-transfer-encoding : "base64"
      body : "<html>
  <head>
  </head>
  <body>
    <p>This is the body of the message.</p>
  </body>
</html>
"
            @endverbatim

            @param boundary the boundary string
            @param body the message body to parse; parsing only works if the line termination characters are \c "\r\n"
            @param decode decode the parts (in this case a part may itself have parts recursively)

            @return a hash representing a parsed multipart message body with the following keys:
            - \c body: any non-part message body left after parsing the parts; will be an empty string if the entiore body is made up of the parts
            - \c part: a list of the parts; each list element is a hash representing a part of the message with the following keys:
              - \c hdr: a hash of part headers, where each header value is converted to lower case and used as a hash key
              - \c body: the body of the part as a string or binary object; this can only be a binary object if the \a decode argumnent is @ref Qore::True "True", the part's content-encoding is base64 and the part's content type does not contain the word \c "text"
              - \c [part]: if the \a decode parameter is @ref Qore::True "True" then any content-encoding for parts is decoded automatically; also parts that have parts themselves are processed recursively if this argument is set

            @throw MULTIPART-PARSEBODY-ERROR no boundary found in body; no closing boundary; malformatted part or part header, etc

            @note multipart message parsing only works if the line termination characters are \c "\r\n"; make sure and convert the end of line characters before passing to this method if necessary
         */
        static hash parseBody(string $boundary, string $body, bool $decode = True) {
            # find beginning
            my int $i = $body.find("--" + $boundary + "\r\n");
            if ($i == -1)
                throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot find boundary %y in body", $boundary);

            # see if the boundary is at the beginning of the body, in which case it is not preceded by "\r\n"
            # otherwise it should be
            # start offset
            my int $so = 4;
            if ($i >= 2 && $body[$i - 2] == "\r" && $body[$i - 1] == "\n") {
                $so = 6;
                $i -= 2;
            }

            my string $mstr = $body.substr($i + $boundary.size() + $so);
            #printf("MSTR (i: %d): %s\n", $i, $mstr);

            # find end
            my int $j = $mstr.find("\r\n--" + $boundary + "--\r\n");
            if ($j == -1)
                throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot find closing boundary %y in body", $boundary + "--");

            # remove multipart string from body
            splice $body, $i, $j + $boundary.size() * 2 + 8 + $so;
            
            #printf("BODY (i: %d, j: %d): %s\n", $i, $j, $body);
    
            # remove final boundary and any excess text from the multipart string
            splice $mstr, $j;

            # process parts
            my list $l = $mstr.split("\r\n--" + $boundary + "\r\n");
            foreach my data $pstr in ($l) {
                $i = $pstr.find("\r\n\r\n");
                if ($i == -1)
                    throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot parse MIME part %d/%d; could not find content boundary", $# + 1, $l.size());
        
                # get header string
                my string $phdr = $pstr.substr(0, $i);
                # parse header
                my hash $h;
                my list $pl = $phdr.split("\r\n");
                for (my int $k = 0; $k < $pl.size(); ++$k) {
                    my string $phl = $pl[$k];
                    my (*string $hdr, *string $val) = ($phl =~ x/([^:]+):\s*(.*)$/);
                    if (!$hdr || !$val.val())
                        throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot parse MIME part %d/%d header line: %y", $# + 1, $l.size(), $phl);
                    
                    # see if the following line is a long header field as defined in RFC 2822 section 2.2.3: http://tools.ietf.org/html/rfc2822#section-2.2.3
                    while ($pl[$k + 1] =~ /^[ \t]/)
                        $val += " " + trim($pl[++$k]);
                    
                    # make sure header keys are returned in lower case
                    $hdr = $hdr.lwr();
                    $h.$hdr = $val;
                }
                
                # remove header from content
                splice $pstr, 0, $i + 4;

                my list $part = ();

                # decode the part if necessary
                if ($decode) {
		    # part content type (default = no encoding)
		    my string $pct = Mime::ContentTransEnc7Bit;
		    # part content transfer encoding (default: no encoding)
		    my string $pcte = ContentTransEncBinary;

                    # process part headers
                    foreach my hash $hh in ($h.pairIterator()) {
			if ($hh.key == "content-transfer-encoding")
			    $pcte = $hh.value.lwr();
			else if ($hh.key == "content-type")
			    $pct = $hh.value;
                    }

                    # decode the part's body
		    $pstr = mime_decode_transfer_data($pstr, $pcte, $pct);
                    if ($pstr.typeCode() == NT_BINARY && $pct =~ /text/)
                        $pstr = binary_to_string($pstr);

		    # see if the part has parts itself
                    if ($pct =~ /multipart\//i) {
                        my *string $part_boundary = ($pct =~ x/boundary="?([^"]+)"?/)[0];
                        if (!exists $part_boundary)
                            throw "MULTIPART-PARSEBODY-ERROR", sprintf("cannot parse part %d Content-Type: %y; could not find message boundary", $#, $pct);

                        my hash $ph = MultiPartMessage::parseBody($part_boundary, $pstr, True);
                        $pstr = $ph.body;
                        $part = $ph.part;
                    }
                }

                $l[$#] = (
                    "hdr": $h,
                    "body": $pstr,
                    );

                if ($part)
                    $l[$#].part = $part;
            }
            
            return (
                "body": $body,
                "part": $l,
                );
        }

        #! serializes the message and returns a binary object ready to send over a socket
        binary serialize() {
            my hash $h = $.getMsgAndHeaders();
            my binary $rv = MultiPartMessage::serializeHeaders($h.hdr);
            $rv += $h.body;
            return $rv;
        }

        #! serializes a header hash to a binary object
        /** @param hdr the hash to serialize

            @return the binary object representing the hash with each header separated by \c "\r\n"
         */
        static binary serializeHeaders(hash $hdr) {
            my binary $b;
            foreach my string $k in ($hdr.keyIterator())
                $b += sprintf("%s: %s\r\n", $k, $hdr.$k); 
            $b += "\r\n";
            return $b;
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c msg: a binary object of serialized message parts
         */
        abstract hash getMsgAndHeaders();

        #! @cond nodoc

        # don't reimplement this method; fix/enhance it in the module
        final private hash getMsgAndHeadersIntern(*string $content_type, bool $conlen = True) {
            if (!exists $content_type)
                $content_type = $.ct;

            if ($.l.empty())
                throw "HTTP-MULTIPART-ERROR", "the message has no parts";

            my binary $msg = binary(MP_DEFAULT_MSG);
            foreach my hash $m in ($.l) {
                my binary $bd = binary($m.data);
                $msg += "\r\n" + $.boundary + "\r\n";
                $msg += MultiPartMessage::serializeHeaders($m.hdr + ($conlen ? ("Content-Length": $bd.size()) : NOTHING));
                $msg += $bd;
            }
            $msg += "\r\n" + $.boundary + "--";
            
            return (
                "hdr": $.hdr + ("Content-Type": $content_type),
                "body": $msg,
                );
        }

        # don't reimplement this method; fix/enhance it in the module
        private splicePartIntern(data $data, hash $hdr) {
            splice $.l, 0, 0, MultiPartMessage::getPart($data, $hdr);
        }

        # don't reimplement this method; fix/enhance it in the module
        private addPartIntern(data $data, hash $hdr) {
            $.l += MultiPartMessage::getPart($data, $hdr);
        }

        private static hash getPart(data $data, hash $hdr) {
            if (exists $hdr."Content-Length")
                throw "HTTP-MULTIPART-ERROR", "illegal part header 'Content-Length': the Content-Length header will be generated automatically according to the size of each part";

            switch ($data.typeCode()) {
                case NT_STRING: {
                    my string $ct = $hdr."Content-Type";
                    # NOTE we do not check if the charset matches the actual encoding here
                    # we just add the charset= text if it's not already present
                    if ($ct !~ /charset=/) {
                        if (!$ct.empty())
                            $ct += ";";
                        $ct += sprintf("charset=%s", get_encoding($data));
                        $hdr."Content-Type" = $ct;		
                    }
                    if (!exists $hdr."Content-Transfer-Encoding")
                        $hdr."Content-Transfer-Encoding" = "8bit";
                    break;
                }
                case NT_BINARY: {
                    if (!exists $hdr."Content-Transfer-Encoding")
                        $hdr."Content-Transfer-Encoding" = "binary";		
                }
            }
            return (
                "data": $data,
                "hdr": $hdr,
                );
        }
        #! @endcond
    }

    #! implements a MultiPartRelatedMessage class, a specialization of MultiPartMessage
    public class MultiPartRelatedMessage inherits MultiPartMessage {
        #! @cond nodoc
        private {
            # the starting part ID
            string $.startid;
        }
        #! @endcond

        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string $boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_RELATED, $boundary) {
        }

        #! adds a message part to the start of the list
        /** @param data the data for the part
            @param id the multipart/related ID for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-RELATED-ERROR if the id parameter is empty, this exception is thrown
         */
        splicePart(data $data, string $id, string $content_type, *hash $hdr) {
            if ($id.empty())
                throw "MULTIPART-RELATED-ERROR", "missing second argument giving the Content-ID identifying the part; this header is required for each part as this is how the parts are related to the main message";

            $.startid = $id;
            $.splicePartIntern($data, $hdr + ("Content-ID": $id, "Content-Type": $content_type));
        }

        #! adds a message part to the end of the list
        /** @param data the data for the part
            @param id the multipart/related ID for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-RELATED-ERROR if the id parameter is empty, this exception is thrown
         */
        addPart(data $data, string $id, string $content_type, *hash $hdr) {
            if ($id.empty())
                throw "MULTIPART-RELATED-ERROR", "missing second argument giving the Content-ID identifying the part; this header is required for each part as this is how the parts are related to the main message";

            if (!exists $.startid)
                $.startid = $id;

            $.addPartIntern($data, $hdr + ("Content-ID": $id, "Content-Type": $content_type));
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c msg: a binary object of serialized message parts
         */
        hash getMsgAndHeaders() {
            return $.getMsgAndHeadersIntern($.ct + ";start=" + $.startid);
        }
    }

    #! implements a MultiPartMixedMessage class, a specialization of MultiPartMessage
    public class MultiPartMixedMessage inherits MultiPartMessage {
        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string $boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_MIXED, $boundary) {
            $.hdr = (
                "MIME-Version": "1.0",
                );
        }

        #! adds a message part to the start of the list; the data muyst already be encoded and any Content-Transfer-Encoding header must already be present in hdr
        /** @param data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::spliceEncodePart()
            - MultiPartMixedMessage::addEncodePart()
         */
        splicePart(data $data, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            $.splicePartIntern($data, $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp));
        }

        #! adds a message part to the end of the list; the data muyst already be encoded and any Content-Transfer-Encoding header must already be present in hdr
        /** @param data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::spliceEncodePart()
            - MultiPartMixedMessage::addEncodePart()
         */
        addPart(data $data, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            $.addPartIntern($data, $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp));
        }

        #! adds a message part to the start of the list; encodes the data according to the transfer encoding argument passed
        /** @param data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::addEncodePart()
         */
        spliceEncodePart(data $data, string $enc, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            if ($data.typeCode() == NT_STRING && $content_type !~ /charset=/ && $disp == "inline")
                $content_type += sprintf(";charset=%s", get_encoding($data));
            $.splicePartIntern(mime_encode_transfer_data($data, $enc), $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp, "Content-Transfer-Encoding": $enc));
        }

        #! adds a message part to the end of the list; encodes the data according to the transfer encoding argument passed
        /** @param data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::spliceEncodePart()
         */
        addEncodePart(data $data, string $enc, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            if ($data.typeCode() == NT_STRING && $content_type !~ /charset=/ && $disp == "inline")
                $content_type += sprintf(";charset=%s", get_encoding($data));
            $.addPartIntern(mime_encode_transfer_data($data, $enc), $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp, "Content-Transfer-Encoding": $enc));
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c msg: a binary object of serialized message parts
         */
        hash getMsgAndHeaders() {
            return $.getMsgAndHeadersIntern(NOTHING, False);
        }
    }
}
