# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Swagger.qm Swagger: https://swagger.io/, OpenAPI: https://github.com/OAI/OpenAPI-Specification

/*  Swagger.qm Copyright (C) 2017 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%new-style
%enable-all-warnings
%require-types
%strict-args

# make sure we have the required qore version
%requires qore >= 0.8.13

# try importing JSON and YAML modules
%try-module json
%define NoJson
%endtry

%try-module yaml
%define NoYaml
%endtry

%try-module xml
%define NoXml
%endtry

# need mime definitions
%requires(reexport) Mime >= 1.4
# requires the Util module
%requires(reexport) Util >= 1.3
# requires the HttpServerUtil module
%requires(reexport) HttpServerUtil >= 0.3.12
# requires the RestSchemaValidator module
%requires(reexport) RestSchemaValidator >= 1.0

module Swagger {
    version = "0.1";
    desc = "Swagger module providing functionality for Swagger 2.0 schema definitions";
    author = "Ondrej Musil <ondrej.musil@qoretechnologies.com>, David Nichols <david.nichols@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Swagger module

    @tableofcontents

    @section swaggerintro Swagger Module Introduction

    The %Swagger module provides a <a href="https://swagger.io/">Swagger 2.0 REST API validation API</a> to %Qore.

    The primary classes provided by this module:
    - @ref Swagger::SwaggerLoader "SwaggerLoader": provides static methods for loading %Swagger schemas
    - @ref Swagger::SwaggerSchema "SwaggerSchema": the %Swagger schema object for client/server REST API validation and example code and message generation

    This class is most often used in the <a href="../../RestClient/html/index.html">RestClient</a> and <a href="../../RestHandler/html/index.html">RestHandler</a> modules to register a
    <a href="https://swagger.io/">Swagger 2.0</a> schema for
    automatic REST API validation.

    JSON and YAML serialization and deserialization are supported; XML is currently not supported.

    @section swagger_usage Swagger Usage

    @subsection swagger_client Swagger Client-Side Usage

    Use the \a swagger or \a validator options in the \c RestClient::constructor() call to use <a href="https://swagger.io/">Swagger 2.0</a>
    REST schema validation on the client side with the \c RestClient class.

    To override the target URL specified in the <a href="https://swagger.io/">Swagger</a> schema, use the \c "url" option in the
    \c RestClient::constructor() call.

    To override the URI base path specified in the <a href="https://swagger.io/">Swagger</a> schema,
    get the <a href="https://swagger.io/">Swagger</a> schema object by calling
    \c RestClient::getValidator(), and then call @ref RestSchemaValidator::AbstractRestSchemaValidator::setBasePath()     "AbstractRestSchemaValidator::setBasePath()" on the validator object.

    @par Client Example
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

# the RestClient module imports and reexports the Swagger module automatically
%requires RestClient

# create the RestClient options with a Swagger schema
hash opts = (
    "swagger": ENV.SCHEMA_DIR + DirSep + "MySchema.yaml",
);

# there is no need to add the "url" option if the target URL provided by the schema is valid
# (otherwise you can override the target URL provided by the Swagger schema by using the
# "url" option in the RestClient constructor options)
RestClient rc(opts);

# afterwards all REST calls made with the RestClient objects with automatic Swagger 2.0
# schema validation; do not include the Swagger schema's basePath in the URI path in the
# requests
hash h = rc.get("get", "/some_api");
    @endcode

    @par Override Base Path Client Example
    @code{.py}
# create the RestClient options with a Swagger schema
hash opts = (
    "swagger": ENV.SCHEMA_DIR + DirSep + "MySchema.yaml",
);
RestClient rc(opts);
# get the SwaggerSchema validator object
AbstractRestSchemaValidator schema = rc.getValidator();
# override the base path in requests
schema.setBasePath("/new/path");
    @endcode

    @subsection swagger_server Swagger Server-Side Usage

    Enforce <a href="https://swagger.io/">Swagger</a> REST API validation on the server side by passing a @ref Swagger::SwaggerSchema "SwaggerSchema"
    object to the \c RestHandler::constructor() call as in the following example.

    @par Server Example
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

%requires RestHandler
%requires Swagger

SwaggerSchema swagger = SwaggerLoader::fromFile(ENV.SCHEMA_DIR + DirSep + "MySchema.yaml");
RestHandler handler(NOTHING, swagger);
    @endcode

    @section swagger_relnotes Swagger Module Release Notes

    @subsection swagger_1_0 Swagger v1.0

    - initial release of the %Swagger module
*/

#! main namespace for all public %Swagger declarations
public namespace Swagger {
#! Valid integer type formats
public const ValidIntFormats = ("int32", "int64");
#! Valid number type formats
public const ValidNumberFormats = ("double", "float");
#! Valid string type formats
public const ValidStringFormats = ("binary", "byte", "date", "date-time", "password");

#! allowed collection formats
public const CollectionFormats = (
    "csv": True,
    "ssv": True,
    "tsv": True,
    "pipes": True,
);

#! valid parameter collection formats
public const ParameterCollectionFormats = CollectionFormats + (
    "multi": True,
);

#! A hash of valid integer type formats
public const ValidIntFormatsHash = map {$1: True}, ValidIntFormats;
#! A hash of valid number type formats
public const ValidNumberFormatsHash = map {$1: True}, ValidNumberFormats;
#! A hash of valid string type formats
public const ValidStringFormatsHash = map {$1: True}, ValidStringFormats;

#! supported mime types for de/serializing data
public const MimeDataTypes = {
%ifndef NoJson
    MimeTypeJson: (
        "serialize": \make_json(),
        "serialize_verbose": string sub (any val) {return make_json(val, JGF_ADD_FORMATTING);},
        "deserialize": \parse_json(),
        "module": "json",
    ),
%endif
%ifndef NoYaml
    MimeTypeYamlRpc: (
        "serialize": \make_yaml(),
        "serialize_verbose": string sub (any val) {return make_yaml(val, BlockStyle);},
        "deserialize": \parse_yaml(),
        "module": "yaml",
    ),
%endif
    # Content-Type: application/x-www-form-urlencoded
    MimeTypeFormUrlEncoded: (
        "serialize": \mime_get_form_urlencoded_string(),
        "serialize_verbose": \mime_get_form_urlencoded_string(),
        "deserialize": \mime_parse_form_urlencoded_string(),
    ),
    # Content-Type: multipart/form-data (handled manually)
    MimeTypeMultipartFormData: {},
};

#! modules available for data serialization and/or deserialization
public const SerializationModules = map $1.module, MimeDataTypes.iterator(), $1;

#! MIME types for data serialization
public const MimeContentTypes = keys MimeDataTypes;

#! Valid transfer protocol schemes.
public const ValidSchemes = ("http", "https", "ws", "wss");
public const ValidSchemesHash = map {$1: True}, ValidSchemes;

#! Base class for the %Swagger specification objects, wrapping the vendor extensions.
class ObjectBase {
    public {
        #! Allows extensions to the %Swagger Schema.
        /**
            The field name MUST begin with \c x-, for example, \c x-internal-id.
            The value can be \c null, a primitive, an array or an object.
         */
        hash vendorExtensions;
    }

    #! Constructor.
    public constructor() {
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the object
     */
    public constructor(hash oh) {
        initialize(oh);
    }

    #! copy constructor
    constructor(ObjectBase other) {
        vendorExtensions = other.vendorExtensions;
    }

    #! Initialize.
    /**
        @param oh deserialized hash from the source schema description
     */
    public initialize(hash oh) {
        vendorExtensions = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^x-/;
    }
}

#! Base used by @ref OtherParameter, @ref HeaderObject and @ref SchemaObject.
class SchemaBase {
    public {
        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *float maximum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *float minimum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *bool exclusiveMax;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *bool exclusiveMin;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.1.
        *int maxLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.2.
        *int minLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        *string pattern;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.2.
        *int maxItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.3.
        *int minItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.4.
        *bool uniqueItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1.
        /** @note Swagger enums can be of any type, but we only support enums of simple types that can be converted
            to a string for fast lookups in a hash
        */
        hash<string, bool> enum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.1.
        *float multipleOf;
    }

    #! Constructor.
    /** @param objType the type of object
        @param oh deserialized hash from the source schema description
     */
    public constructor(string objType, hash oh) {
        optional_field(objType, oh, "maximum", (NT_FLOAT: True, NT_INT: True), \maximum);
        optional_field(objType, oh, "minimum", (NT_FLOAT: True, NT_INT: True), \minimum);
        optional_field(objType, oh, "exclusiveMaximum", NT_BOOLEAN, \exclusiveMax);
        optional_field(objType, oh, "exclusiveMinimum", NT_BOOLEAN, \exclusiveMin);
        optional_field(objType, oh, "maxLength", NT_INT, \maxLength);
        optional_field(objType, oh, "minLength", NT_INT, \minLength);
        optional_field(objType, oh, "pattern", NT_STRING, \pattern);
        optional_field(objType, oh, "maxItems", NT_INT, \maxItems);
        optional_field(objType, oh, "minItems", NT_INT, \minItems);
        optional_field(objType, oh, "uniqueItems", NT_BOOLEAN, \uniqueItems);
        optional_field(objType, oh, "enum", SwaggerListToSet, \enum);
        optional_field(objType, oh, "multipleOf", (NT_FLOAT: True, NT_INT: True), \multipleOf);
    }

    #! Copy constructor
    constructor(SchemaBase other) {
        self += map {$1: other.$1}, (
            "maximum", "minimum", "exclusiveMax", "exclusiveMin",
            "maxLength", "minLength", "pattern", "maxItems", "minItems",
            "uniqueItems", "enum", "multipleOf"), exists other.$1;
    }

    #! returns an example value for the given type
    private any getExampleValue(string type, *string format) {
        if (enum) {
            any rv = enum.firstKey();
            switch (type) {
                case "integer": rv = rv.toInt(); break;
                case "number": rv = (format && ValidNumberFormatsHash{format} ? rv.toFloat() : rv.toNumber()); break;
                case "boolean": rv = rv.toBool(); break;
                case "string": {
                    switch (format) {
                        case "byte": return parse_base64_string(rv);
                        case "binary": return parse_hex_string(rv);
                        case "date":
                        case "date-time":
                            return date(rv);
                    }
                }
            }
            return rv;
        }
        switch (type) {
            case "string": {
                switch (format) {
                    case "byte":
                    case "binary": return "<deadbeef>";
                    case "date": return now_us().format("YYYY-MM-DD");
                    case "date-time": return now_us().format("YYYY-MM-DDTHH:mm:SS.xx");
                    default:
                        return "value";
                }
            }
            case "integer": {
                if (exists minimum)
                    return exclusiveMin ? minimum + 1 : minimum;
                if (exists maximum)
                    return exclusiveMax ? maximum - 1 : maximum;
                return 1;
            }
            case "number": {
                number rv;
                if (exists minimum)
                    rv = exclusiveMin ? minimum + 0.1 : minimum;
                else if (exists maximum)
                    rv = exclusiveMax ? maximum - 0.1 : maximum;
                else
                    rv = 1.1n;
                if (format && ValidNumberFormatsHash{format})
                    return rv.toFloat();
                return rv;
            }
            case "boolean":
                return True;
            case "null":
                return NOTHING;
        }
    }

    #! validates the value against the schema definition
    private check(bool serialize, bool request, string type, *SchemaObject items, string path, string method, string name, reference value) {
        # accept a single value for an array (= one-element list)
        if (type == "array")
            checkArrayParam(serialize, request, items, path, method, name, \value);
        else
            checkIntern(serialize, request, type, path, method, name, value, \value);
    }

    #! validates string values
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, string v, reference<string> value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        checkStringIntern(path, method, name, value);
    }

    private checkStringIntern(string path, string method, string name, data value) {
        if (exists maxLength && value.size() > maxLength)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y is too long (maxLength: %d, actual: %d)",
                    name, path, method, maxLength, value.size());
        if (exists minLength && value.size() < minLength)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y is too short (minLength: %d, actual: %d)",
                    name, path, method, minLength, value.size());
        if (exists pattern && value.typeCode() == NT_STRING && !value.regex(pattern))
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the parameter string pattern (pattern:%y, value: %y)",
                    name, path, method, pattern, value);
        if (enum && !enum{value})
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %y)",
                    name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, int v, reference<int> value) {
        if (type != "integer")
            throwInvalidType(name, "integer", type);
        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
            else {
                if (value > maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
            else {
                if (value < minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value})
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %d)",
                    name, path, method, keys enum, value);
    }

    # NOTE: "number" also accepts "float"
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, number v, reference<number> value) {
        if (type != "number")
            throwInvalidType(name, "number", type);
        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
            else {
                if (value > maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
            else {
                if (value < minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value})
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %f)",
                    name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, bool v, reference<bool> value) {
        if (type != "boolean")
            throwInvalidType(name, "boolean", type);
    }

    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, nothing v, reference<nothing> value) {
        if (type != "null")
            throw "INVALID-PARAMETER-VALUE", sprintf("Parameter %y for path %y and method %y is null, but the expected type is %y", name, path, method, type);
    }

    #! validates the value against the schema definition
    private checkArrayParam(bool serialize, bool request, SchemaObject items, string path, string method, string name, reference<softlist> value) {
        if (exists maxItems && value.size() > maxItems)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y has too many items (maxItems: %d, actual: %d)",
                    name, path, method, maxItems, value.size());
        if (exists minItems && value.size() < minItems)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y has too few items (minItems: %d, actual: %d)",
                    name, path, method, minItems, value.size());

        # check array element types
        if (!uniqueItems || items.type != "array") {
            # hash for checking uniqueness if uniqueItems is true
            #printf("v: %y self: %N\n", value, self);
            hash h;
            foreach any v in (\value) {
                items.check(serialize, request, path, method, name, \v);
                if (uniqueItems) {
                    if (h{v})
                        throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameter value %y is duplicated in the array", method, path, v);
                    h{v} = True;
                }
            }
        }
        else {
            # perform slow array uniqueness check
            list uniqueItems = ();
            foreach any val in (\value) {
                items.check(serialize, request, path, method, name, \val);
                if (uniqueItems.contains(val))
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("%s %s: Array parameter %y does not have unique items",
                            method, path, name);
                uniqueItems += val;
            }
        }
    }

    #! throws an \c INVALID-PARAMETER-TYPE exception
    static private throwInvalidType(string name, string actual, string expected) {
        throw "INVALID-PARAMETER-TYPE",
            sprintf("Parameter %y has invalid type %y (should be %y)", name, actual, expected);
    }
}

#! Used for loading the %Swagger definitions.
public class SwaggerLoader {
    #! Load %Swagger definition from a string.
    /**
        @param swaggerSpecification <a href="https://swagger.io/">Swagger</a> API specification
        @param json whether the specification is in JSON or YAML format

        @throws JSON-MODULE-MISSING trying to parse a JSON %Swagger specification with JSON module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %Swagger specification with YAML module unavailable
     */
    static SwaggerSchema fromString(string swaggerSpecification, bool json = True) {
        hash val;
        if (json) {
%ifdef NoJson
            throw "JSON-MODULE-MISSING", "Trying to parse a JSON Swagger specification, but the json module is unavailable";
%else
            val = parse_json(swaggerSpecification);
%endif
        }
        else {
%ifdef NoYaml
            throw "YAML-MODULE-MISSING", "Trying to parse a YAML Swagger specification, but the yaml module is unavailable";
%else
            val = parse_yaml(swaggerSpecification);
%endif
        }
        return new SwaggerSchema(val);
    }

    #! Load <a href="https://swagger.io/">Swagger</a> definition from a file.
    /**
        @param filepath path to the <a href="https://swagger.io/">Swagger</a> file

        @throws EMPTY-SCHEMA-FILE %Swagger file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON %Swagger specification with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %Swagger specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML %Swagger specification with the xml module unavailable
     */
    static SwaggerSchema fromFile(string filepath) {
        return new SwaggerSchema(SwaggerLoader::parseSchemaContent(filepath, ReadOnlyFile::readTextFile(filepath)));
    }

    #! Load a schema definition from a file
    /**
        @param filepath path to the schema file
        @param str the file content to parse

        @throws EMPTY-SCHEMA-FILE schema file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON schema with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML schema specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML schema specification with the xml module unavailable
     */
    static hash parseSchemaContent(string filepath, string str) {
        if (!str)
            throw "EMPTY-SCHEMA-FILE", sprintf("%y: file is empty", filepath);

        string ser = "json";
        string filename = basename(filepath);
        if (filename =~ /.*\.json$/i) {
            ser = "json";
        }
        else if (filename =~ /.*\.yaml$/i) {
            ser = "yaml";
        }
        else if (filename =~ /.*\.xml$/i) {
            ser = "xml";
        }
        else {
            DataLineIterator it(str);
            while (it.next()) {
                string line = trim(it.getValue());
                if (line.size()) {
                    if (line =~ /^<\?xml/)
                        ser = "xml";
                    else if (line =~ /^([^{])+:/ || line =~ /^(---|%YAML)/)
                        ser = "yaml";
                    else
                        ser = "json";
                    break;
                }
            }
        }

        hash rv;
        switch (ser) {
            case "json": {
%ifdef NoJson
                throw "JSON-MODULE-MISSING", "Trying to parse a JSON schema, but the json module is unavailable";
%else
                rv = parse_json(str);
                break;
%endif
            }
            case "yaml": {
%ifdef NoYaml
                throw "YAML-MODULE-MISSING", "Trying to parse a YAML schema, but the yaml module is unavailable";
%else
                rv = parse_yaml(str);
                break;
%endif
            }
            case "xml": {
%ifdef NoXml
                throw "XML-MODULE-MISSING", "Trying to parse an XML schema, but the xml module is unavailable";
%else
                rv = parse_xml(str);
                break;
%endif
            }
        }
        return rv;
    }
}

#! This is the root document object for the API specification. It combines what previously was the Resource Listing and API Declaration (version 1.2 and earlier) together into one document.
public class SwaggerSchema inherits ObjectBase, AbstractRestSchemaValidator {
    public {
        #! <a href="https://swagger.io/">Swagger</a> Specification version being used.
        /**
            It can be used by the %Swagger UI and other clients to interpret the
            API listing. The value MUST be \c "2.0".
         */
        string swaggerSpec;

        #! Required. Provides metadata about the API. The metadata can be used by the clients if needed.
        InfoObject info;

        #! Required. The available paths and operations for the API.
        PathsObject paths;

        #! The host (name or IP) serving the API.
        /**
            This MUST be the host only and does not include the scheme nor sub-paths.
            It MAY include a port. If the \c host is not included, the host serving
            the documentation is to be used (including the port).
            The host does not support path templating.
         */
        *string host;

        #! The base path on which the API is served, which is relative to the @ref SwaggerSchema::host "host".
        /**
            If it is not included, the API is served directly under the \c host.
            The value MUST start with a leading slash (/).
            The \c basePath does not support path templating.
         */
        *string basePath;

        #! The transfer protocol of the API.
        /**
            Values MUST be from the list: \c "http", \c "https", \c "ws", \c "wss".
            If the schemes is not included, the default scheme to be used is
            the one used to access the %Swagger definition itself.
         */
        hash<string, bool> schemes;

        #! A set of MIME types (strings) the APIs can consume.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Key values MUST be Mime Types.
         */
        hash<string, bool> consumes;

        #! A set of MIME types (strings) the APIs can produce.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Key values MUST be Mime Types.
         */
        hash<string, bool> produces;

        #! An object to hold data types produced and consumed by operations.
        /**
            A hash of @ref SchemaObject objects. Keys are schema names.
         */
        hash<string, SchemaObject> definitions();

        #! Parameter definitions that can be used across operations. This property does not define global parameters for all operations.
        /**
            A hash of @ref AbstractParameterObject objects. Keys are parameter names.
         */
        hash<string, AbstractParameterObject> parameters();

        #! Response definitions that can be used across operations. This property does not define global responses for all operations.
        /**
            A hash of @ref ResponseObject objects. Keys are response names.
         */
        hash<string, ResponseObject> responses;

        #! Security scheme definitions that can be used across the specification.
        /**
            A hash of @ref SecuritySchemeObject objects. Keys are scheme names.
         */
        hash<string, SecuritySchemeObject> securityDefinitions;

        #! A declaration of which security schemes are applied for the API as a whole.
        /**
            The list of values describes alternative security schemes that can
            be used (that is, there is a logical OR between the security
            requirements). Individual operations can override this definition.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref SwaggerSchema::securityDefinitions "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
         */
        hash<string, softlist<string>> security;

        #! A list of @ref TagObject "tags" used by the specification with additional metadata.
        /**
            The order of the tags can be used to reflect on their order by the
            parsing tools. Not all tags that are used by the @ref OperationObject
            must be declared. The tags that are not declared may be organized
            randomly or based on the tools' logic. Each tag name in the list
            MUST be unique.

            Individual values in this list are of type @ref TagObject "TagObject".
         */
        list<TagObject> tags;

        #! Additional external documentation.
        *ExternalDocumentationObject externalDocs;

        #! SwaggerSchema options
        const SwaggerOptions = (
            "compact_serialization": True,
            "def_path": True,
            "try_import": True,
        );
    }

    private {
        #! if serialized data should be subject to compact serialization (default: @ref Qore::True "True")
        bool compact_serialization;

        #! the default path to use when retrieving external schema references
        *string def_path;

        #! a call reference or closure to be passed a string name for external schema references, must take a string argument (the resource name) and return a string (the resource data)
        *code try_import;
    }

    #! Builds the schema representation from the deserialized schema hash describing the root document object
    /**
        @param oh deserialized hash from the source schema description describing the root document object
        @param opts options as per @ref SwaggerOptions as follows:
        - \c compact_serialization (default @ref Qore::True "True"): optimize the size of serialized data strings
        - \c def_path: the default path to use when retrieving external schema references
        - \c try_import: a call reference or closure to be passed a string name for external schema references, must take a string argument (the resource name) and return a string (the resource data)

        @throws SWAGGER-OPTION-ERROR unsuported options in constructor
        @throws INVALID-SWAGGER-VERSION invalid or missing Swagger schema version
        @throws INVALID-FIELD-FORMAT field has an invalid format
        @throws INVALID-FIELD-TYPE field has an invalid type
        @throws INVALID-FIELD-VALUE field has an invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws SECURITY-ERROR inconsistent security information in schema
     */
    public constructor(hash oh, *hash opts) : ObjectBase(oh) {
        # process options
        compact_serialization = remove opts.compact_serialization ?? True;
        def_path = remove opts.def_path;
        try_import = remove opts.try_import;
        if (opts)
            throw "SWAGGER-OPTION-ERROR", sprintf("unknown options in SwaggerSchema constructor: %y; known options: %y", keys opts, keys SwaggerOptions);

        string objType = "Swagger";
        if (!oh.hasKey("swagger"))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: 'swagger' field is missing", objType);
        if (oh.swagger.typeCode() == NT_STRING)
            swaggerSpec = oh.swagger;
        else if (oh.swagger.typeCode() == NT_FLOAT || oh.swagger.typeCode() == NT_INT)
            swaggerSpec = sprintf("%.1f", oh.swagger);
        else
            throw "INVALID-FIELD-TYPE",
                sprintf("%s Object: 'swagger' field has invalid type %y (should be string or float)", objType, oh.swagger.type());
        if (swaggerSpec != "2.0")
            throw "INVALID-SWAGGER-VERSION", sprintf("invalid schema version %y; expecting \"2.0\"", swaggerSpec);

        {
            hash obj;
            optional_field(objType, oh, "definitions", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid definition datatype: " + item.value.type();
                definitions{item.key} = SchemaObject::newSchemaObject(item.key, item.value, self);
            }

            delete obj;
            optional_field(objType, oh, "parameters", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid parameter datatype: " + item.value.type();
                parameters{item.key} = AbstractParameterObject::newParameter(item.key, item.value, self);
            }

            delete obj;
            optional_field(objType, oh, "responses", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid response datatype: " + item.value.type();
                responses{item.key} = ResponseObject::newResponse(item.key, item.value, self);
            }
        }

        {
            hash infoObj;
            required_field(objType, oh, "info", NT_HASH, \infoObj);
            info = new InfoObject(infoObj);
        }

        {
            hash pathsObj;
            required_field(objType, oh, "paths", NT_HASH, \pathsObj);
            paths = new PathsObject(pathsObj, self);
        }

        optional_field(objType, oh, "host", NT_STRING, \host);
        if (optional_field(objType, oh, "basePath", NT_STRING, \basePath)) {
            if (basePath.size() && basePath[0] != "/")
                throw "INVALID-FIELD-FORMAT", "Swagger Object: basePath does not begin with a slash: " + basePath;
        }

        if (oh.schemes) {
            optional_field(objType, oh, "schemes", SwaggerListToSet, \schemes);
            # check for invalid schemes
            if ((hash h = (schemes - ValidSchemes)))
                throw "INVALID-FIELD-VALUE", sprintf("Swagger Object: invalid transfer protocol scheme%s: %y", h.size() == 1 ? "" : "s", keys h);
        }

        optional_field(objType, oh, "consumes", SwaggerListToSet, \consumes);

        optional_field(objType, oh, "produces", SwaggerListToSet, \produces);

        {
            hash obj;
            optional_field(objType, oh, "securityDefinitions", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid security definition datatype: " + item.value.type();
                securityDefinitions{item.key} = new SecuritySchemeObject(item.value);
            }
        }

        optional_field(objType, oh, "security", SwaggerListToHashOfStrings, \security);

        # verify security consistency
        if (security) {
            hash h = security - securityDefinitions.keys();
            if (h)
                throw "SECURITY-ERROR", sprintf("the following security schemes are not defined: %y", keys h);
        }

        {
            list lobj = ();
            optional_field(objType, oh, "tags", NT_LIST, \lobj);
            foreach any val in (lobj) {
                if (val.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid tag datatype: " + val.type();
                tags += new TagObject(val);
            }
        }

        {
            *hash extDocsObj;
            if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
                externalDocs = new ExternalDocumentationObject(extDocsObj);
        }
    }

    #! resolves a reference to a schema object
    /** @throw INVALID-REFERENCE invalid reference
    */
    SchemaObject resolveSchemaObject(string name, string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return SchemaObject::newSchemaObject(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/definitions\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y", name, refstr);
        string rstr = (refstr =~ x/^#\/definitions\/(.*)$/)[0];
        *SchemaObject ref = definitions{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y", name, refstr);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a parameter items schema object
    /** @throw INVALID-REFERENCE invalid reference
    */
    ParameterItemsSchemaObject resolveParameterItemsSchemaObject(string name, string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ParameterItemsSchemaObject::newSchemaObject(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/definitions\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve parameter items SchemaObject %y reference %y", name, refstr);
        string rstr = (refstr =~ x/^#\/definitions\/(.*)$/)[0];
        *SchemaObject ref = definitions{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve parameter items SchemaObject %y reference %y", name, refstr);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a parameter
    /** @throw INVALID-REFERENCE invalid reference
    */
    AbstractParameterObject resolveParameter(string name, string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return AbstractParameterObject::newParameter(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/parameters\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; expecting \"#/parameters/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/parameters\/(.*)$/)[0];
        *AbstractParameterObject ref = parameters{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; known parameter references: %y", name, refstr, keys parameters);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a response
    /** @throw INVALID-RESPONSE invalid response
    */
    ResponseObject resolveResponse(string name, string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ResponseObject::newResponse(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/responses\//)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; expecting \"#/responses/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/responses\/(.*)$/)[0];
        *ResponseObject res = responses{rstr};
        if (!res)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; known response references: %y", name, refstr, keys responses);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-RESPONSE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return res;
    }

    #! returns the target URL for the schema
    /** @return the target URL for the schema

        @throws MISSING-TARGET-URL no target URL provided for the schema
    */
    private string getTargetUrlImpl() {
        return sprintf("%s://%s%s", schemes ? schemes.firstKey() : "http", host, basePath);
    }

    #! processes a client-side REST request and returns a hash that can be used to make the outgoing client-side HTTP request
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body data
        @param headers any headers to include in the request
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return a @ref RestSchemaValidator::RestRequestClientInfo "RestRequestClientInfo" hash with information about the request

        @throws SERIALIZATION-ERROR unsupported message body MIME type requested or missing serialization module
    */
    private hash<RestSchemaValidator::RestRequestClientInfo> processRequestImpl(string method, string path, any body, *hash headers, *softlist<string> content_types) {
        return processRequestIntern(method, path, body, headers, content_types, compact_serialization);
    }

    #! processes and parses a client request and returns the deserialized message body (if any)
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param http_body the unserialized message body hash
        @param headers a reference to the hash of HTTP headers received; any default header values to be assumed by the server for the request will be added here

        @return a @ref RestSchemaValidator::RestRequestServerInfo hash of request information

        @throw DESERIALIZATION-ERROR the path does not match the basePath or the request body could not be deserialized
    */
    private hash<RestSchemaValidator::RestRequestServerInfo> parseRequestImpl(string method, string path, *data http_body, reference<hash> headers) {
        hash body;
        # deserialize body according to Content-Type
        if (exists http_body) {
            if (headers."content-type" =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h = MultiPartFormDataMessage::parseMessage(headers."content-type", http_body.toString());
                body = map {$1.key: $1.value.body}, h.pairIterator();
            }
            else {
                *code ds = MimeDataTypes.(headers."content-type").deserialize;
                if (!ds)
                    throw "DESERIALIZATION-ERROR", sprintf("%s %s: cannot deserialize message body with Content-Type: %y; supported MIME types: %y; available deserialization modules: %y", method.upr(), path, headers."content-type", MimeContentTypes, SerializationModules);

                any any_body = ds(http_body);
                if (exists any_body) {
                    if (any_body.typeCode() != NT_HASH)
                        throw "DESERIALIZATION-ERROR", sprintf("%s %s: message body serialized to %y; expecting \"hash\"", method.upr(), path, any_body.type());
                    body = any_body;
                }
            }
        }

        hash<UriQueryInfo> h = parse_uri_query(path);
        method = method.lwr();

        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        op.parseRequest(pio, \h, \body, \headers);
        return new hash<RestRequestServerInfo>((
            "path": h.method,
            "query": h.params,
            "body": body,
        ));
    }

    #! processes a REST response with a serialized message body, validates any response data against schema definitions if possible
    /** @param method the HTTP method of the original request
        @param path the URI path of the original request (without query arguments)
        @param code the HTTP response code
        @param response_body the response body data (if any)
        @param headers HTTP headers to include in the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return an HttpResponseInfo hash for the response

        @throw ACCEPT-ERROR the response body could not be serialized because the client does not accept a supported type
        @throw SERIALIZATION-ERROR the response body could not be serialized due to an error

        @note <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>RFC 2616 section 14</a>: If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.  To ensure this happens, if
        an Accept error of this nature occurs in this call, an \c "ACCEPT-ERROR" must be thrown
    */
    private hash<HttpResponseInfo> processResponseImpl(string method, string path, int code, any response_body, *hash headers, *softlist<string> content_types) {
        return processResponseIntern(method, path, code, response_body, headers, content_types, compact_serialization);
    }

    #! parses and validates the response from the server and returns a hash of the processed info
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the original request (without any query arguments)
        @param code the HTTP response code
        @param response_body the HTTP response body data (if any)
        @param hdr as hash of HTTP headers received

        @return a @ref RestSchemaValidator::RestResponseClientInfo hash describing the response

        @throw DESERIALIZATION-ERROR the request body could not be deserialized or had an invalid \c Content-Type
    */
    private hash<RestSchemaValidator::RestResponseClientInfo> parseResponseImpl(string method, string path, int code, *data response_body, hash hdr) {
        # remove basePath if present
        if (basePath.val() && regex(path, "^" + basePath))
            splice path, 0, basePath.length();

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        hash<RestResponseClientInfo> rv((
            "code": code,
            "hdr": hdr,
        ));

        string content = hdr."content-type" ?? hdr."Content-Type";

        # deserialize body according to Content-Type
        if (exists response_body) {
            if (content =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h = MultiPartFormDataMessage::parseMessage(hdr."content-type", response_body.toString());
                rv.body = map {$1.key: $1.value.body}, h.pairIterator();
                content = MimeTypeMultipartFormData;
            }
            else {
                *code ds = MimeDataTypes{content}.deserialize;
                if (!ds)
                    throw "DESERIALIZATION-ERROR", sprintf("%s %s: cannot deserialize message body with Content-Type: %y; supported MIME types: %y; available deserialization modules: %y", method, path, hdr."content-type", MimeContentTypes, SerializationModules);

                rv.body = ds(response_body);
            }
        }

        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, rv.body, \mime_types);

        if (!mime_types{content})
            throw "DESERIALIZATION-ERROR", sprintf("%s %s: content type %y is not accepted by this operation; accepted content types: %y", method.upr(), path, content, mime_types);

        return rv;
    }

    #! returns the base path prefix for all requests in this schema
    /** @return the base path prefix for all requests in this schema
    */
    private string getBasePathImpl() {
        return basePath;
    }

    #! overrides the basePath value
    /** @param basePath the new base path value; use an empty string here to clear the basePath
    */
    private setBasePathImpl(string basePath) {
        self.basePath = basePath;
    }

    #! returns example Qore code for the given request
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the request

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given request message
    */
    private hash<RestQoreExampleCodeInfo> getQoreExampleRequestImpl(string method, string path) {
        # remove basePath if present
        if (basePath.val() && regex(path, "^" + basePath))
            splice path, 0, basePath.length();

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        return op.getQoreExampleRequest(method, path, pio, self);
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the request
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown

        @return a @ref RestSchemaValidator::RestExampleRequestInfo "RestExampleRequestInfo" hash of example message information for the given request
    */
    private hash<RestSchemaValidator::RestExampleRequestInfo> getExampleRequestImpl(string method, string path, *softlist<string> content_types) {
        # remove basePath if present
        if (basePath.val() && regex(path, "^" + basePath))
            splice path, 0, basePath.length();

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        any body;
        hash<RestExampleRequestInfo> rv = op.getExampleRequest(method, path, pio, self, \body);
        if (exists body) {
            # serialize example body
            hash<RestRequestClientInfo> req = processRequestIntern(method, path, body, rv.hdr, content_types, False);
            rv.hdr."Content-Type" = req.content;
            rv.body = req.body;
        }

        return rv;
    }

    #! returns example Qore code for the given response
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given response message
    */
    private hash<RestQoreExampleCodeInfo> getQoreExampleResponseImpl(string method, string path, int code) {
        # remove basePath if present
        if (basePath.val() && regex(path, "^" + basePath))
            splice path, 0, basePath.length();

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        return op.getQoreExampleResponse(method, path, code);
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown

        @return a @ref RestSchemaValidator::RestExampleResponseInfo "RestExampleResponseInfo" hash giving example response message info
    */
    private hash<RestExampleResponseInfo> getExampleResponseImpl(string method, string path, int code, *softlist<string> content_types) {
        # remove basePath if present
        if (basePath.val() && regex(path, "^" + basePath))
            splice path, 0, basePath.length();

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        any body;
        hash<RestExampleResponseInfo> rv = op.getExampleResponse(method, path, code, \body);
        if (exists body) {
            # serialize example body
            hash<HttpResponseInfo> res = processResponseIntern(method, path, code, body, rv.hdr, content_types, False);
            rv += res.("code", "hdr", "body");
        }

        return rv;
    }

    #! retrieves external references
    /** @throw INVALID-REFERENCE invalid reference
    */
    private hash getExternalReference(string refstr) {
        (string ext_ref, *string int_ref) = (refstr =~ x/([^#]+)(?:#\/(.*))/);

        #! get file content
        string content;

        if (try_import)
            content = call_function(try_import, ext_ref);
        else {
            # do environment variable substitution
            map ext_ref = replace(ext_ref, "\$" + $1, ENV.$1), (ext_ref =~ x/\$(\w+)/g);
            # derive target file name if def_path is set and the reference is not an absolute path
            if (def_path && !absolute_path(ext_ref))
                ext_ref = def_path + DirSep + ext_ref;
            content = ReadOnlyFile::readTextFile(ext_ref);
        }

        hash h = SwaggerLoader::parseSchemaContent(ext_ref, content);
        if (int_ref) {
            if (!h.hasKey(int_ref))
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but internal reference %y is not available; known internal references: %y", refstr, ext_ref, content.size(), int_ref, keys h);
            if (h{int_ref}.typeCode() != NT_HASH)
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but internal reference %y is not a hash; got type %y instead", refstr, ext_ref, content.size(), int_ref, h{int_ref}.type());
            return h{int_ref};
        }
        return h;
    }

    #! processes a client-side REST request and returns a hash that can be used to make the outgoing client-side HTTP request
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body data
        @param headers any headers to include in the request
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml
        @param compact_serialization overrides the internal \c compact_serialization flag

        @return a @ref RestSchemaValidator::RestRequestClientInfo "RestRequestClientInfo" hash with information about the request

        @throws SERIALIZATION-ERROR unsupported path, message body MIME type requested, or missing serialization module
    */
    private:internal hash<RestSchemaValidator::RestRequestClientInfo> processRequestIntern(string method, string path, any body, *hash headers, *softlist<string> content_types, bool compact_serialization) {
        hash<string, bool> mime_types;

        # remove basePath if present
        if (basePath.val() && regex(path, "^" + basePath))
            splice path, 0, basePath.length();

        hash<UriQueryInfo> h = parse_uri_query(path);
        method = method.lwr();

        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        op.validateRequest(True, pio, \h, \body, \headers, \mime_types);

        hash<RestRequestClientInfo> rv((
            "uri_path": h.method,
        ));

        # add the basePath to the request
        if (exists basePath) {
            rv.uri_path = basePath + (h.method =~ /^\// ? "" : "/") + h.method;
        }

        # rebuild URI query after processing
        if (h.params) {
            string query_arg_separator = (path =~ x/([;&])/)[0] ?? ";";
            rv.uri_path = make_uri_query(cast<hash<UriQueryInfo>>(h), query_arg_separator);
        }

        if (!body)
            return rv;

        if (!exists content_types)
            content_types = MimeContentTypes;

        foreach string content in (content_types) {
            if (!mime_types{content})
                continue;
            if (content == MimeTypeMultipartFormData) {
                hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>((
                    "name": $1.key,
                    "filename": $1.key,
                    "hdr": ("Content-Type": MimeTypeText),
                    "body": $1.value,
                  ))}, body.pairIterator());

                hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                return rv += (
                    "body": mh.body,
                    "content": mh.hdr."Content-Type",
                );
            }
            if (!MimeDataTypes{content})
                continue;
            return rv += (
                "body": compact_serialization ? MimeDataTypes{content}.serialize(body) : MimeDataTypes{content}.serialize_verbose(body),
                "content": content,
            );
        }
        if (body)
            if (content_types == MimeContentTypes)
                throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; available MIME type(s): %y; available serialization modules: %y", method.upr(), path, mime_types, SerializationModules);
            else
                throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; requested MIME type(s): %y; available MIME types: %y; available serialization modules: %y", method.upr(), path, content_types, mime_types, SerializationModules);
        return rv;
    }

    #! processes a REST response with a serialized message body, validates any response data against schema definitions if possible
    /** @param method the HTTP method of the original request
        @param path the URI path of the original request (without query arguments)
        @param code the HTTP response code
        @param response_body the response body data (if any)
        @param headers HTTP headers to include in the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml
        @param compact_serialization allows the \a compact_serialization property to be overridden

        @return an HttpResponseInfo hash for the response

        @throw ACCEPT-ERROR the response body could not be serialized because the client does not accept a supported type
        @throw SERIALIZATION-ERROR the response body could not be serialized due to an error

        @note <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>RFC 2616 section 14</a>: If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.  To ensure this happens, if
        an Accept error of this nature occurs in this call, an \c "ACCEPT-ERROR" must be thrown
    */
    private:internal hash<HttpResponseInfo> processResponseIntern(string method, string path, int code, any response_body, *hash headers, *softlist<string> content_types, bool compact_serialization) {
        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, response_body, \mime_types);

        hash<HttpResponseInfo> rv((
            "code": code,
            "hdr": headers,
        ));

        if (exists response_body) {
            if (!exists content_types)
                content_types = MimeContentTypes;
            foreach string content in (content_types) {
                if (!mime_types{content})
                    continue;
                if (content == MimeTypeMultipartFormData) {
                    if (response_body.typeCode() != NT_HASH)
                        throw "SERIALIZATION-ERROR", sprintf("response to %s %s: cannot serialize type %y to MIME type %y; expecing \"hash\"", method.upr(), path, response_body.type(), content);
                    hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>((
                        "name": $1.key,
                        "filename": $1.key,
                        "hdr": ("Content-Type": MimeTypeText),
                        "body": $1.value,
                    ))}, response_body.pairIterator());

                    hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                    return rv += (
                        "body": mh.body,
                        "hdr": rv.hdr + ("Content-Type": mh.hdr."Content-Type"),
                    );
                }
                if (!MimeDataTypes{content})
                    continue;
                return rv += (
                    "body": compact_serialization ? MimeDataTypes{content}.serialize(response_body) : MimeDataTypes{content}.serialize_verbose(response_body),
                    "hdr": rv.hdr + ("Content-Type": content),
                );
            }
            if (content_types == MimeContentTypes)
                throw "ACCEPT-ERROR", sprintf("response to %s %s: message body cannot be serialized; available MIME type(s) for this call: %y; available serialization modules: %y", method.upr(), path, mime_types, SerializationModules), ("types": mime_types);
            else
                throw "ACCEPT-ERROR", sprintf("response to %s %s: message body cannot be serialized; requested MIME type(s): %y; available MIME types for this call: %y; available serialization modules: %y", method.upr(), path, content_types, mime_types, SerializationModules), ("types": mime_types);
        }

        return rv;
    }
}

#! The object provides metadata about the API. The metadata can be used by the clients if needed, and can be presented in the %Swagger-UI for convenience.
public class InfoObject inherits ObjectBase {
    public {
        #! Required. The title of the application.
        string title;

        #! A short description of the application. GFM syntax can be used for rich text representation.
        *string desc;

        #! The Terms of Service for the API.
        *string termsOfService;

        #! Required. Provides the version of the application API (not to be confused with the specification version).
        string version;

        #! The contact information for the exposed API.
        *ContactObject contact;

        #! The license information for the exposed API.
        *LicenseObject license;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing metadata about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Info";
        required_field(objType, oh, "title", NT_STRING, \title);
        required_field(objType, oh, "version", NT_STRING, \version);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(objType, oh, "termsOfService", NT_STRING, \termsOfService);

        *hash contactObj;
        if (optional_field(objType, oh, "contact", NT_HASH, \contactObj))
            contact = new ContactObject(contactObj);

        *hash licenseObj;
        if (optional_field(objType, oh, "license", NT_HASH, \licenseObj))
            license = new LicenseObject(licenseObj);
    }
}

#! Contact information for the exposed API.
public class ContactObject inherits ObjectBase {
    public {
        #! The identifying name of the contact person/organization.
        *string name;

        #! The URL pointing to the contact information. MUST be in the format of a URL.
        *string url;

        #! The email address of the contact person/organization. MUST be in the format of an email address.
        *string email;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing contact information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Contact";
        optional_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "url", NT_STRING, \url);
        optional_field(objType, oh, "email", NT_STRING, \email);
    }
}

#! License information for the exposed API.
public class LicenseObject inherits ObjectBase {
    public {
        #! Required. The license name used for the API.
        string name;

        #! A URL to the license used for the API. MUST be in the format of a URL.
        *string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing license information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "License";
        required_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "url", NT_STRING, \url);
    }
}

#! Holds the relative paths to the individual endpoints.
/**
    The path is appended to the @ref SwaggerSchema::basePath "basePath" in order to construct the full URL.
    The Paths may be empty, due to ACL constraints.

    This class stores a tree or a component of a path for path matching, supports wildcard matching
 */
public class PathComponent {
    private {
        #! path prefix
        string pfx;

        #! current component name
        string name;

        #! if there is a wildcard to a PathComponent
        *PathComponent wildcard;

        #! the PathItemObject associated with this path (if any)
        *PathItemObject pio;

        #! hash of non-wildcard paths to the next level
        hash<string, PathComponent> paths;
    }

    #! creates the object
    constructor(hash oh, string pfx, SwaggerSchema swagger) {
        self.pfx = pfx;
        name = "/";
        foreach hash h in (oh.pairIterator()) {
            if (!pfx.val() && h.key !~ /^\//)
                throw "INVALID-FIELD-FORMAT", sprintf("Paths Object: root path %y does not begin with a slash", h.key);
            list l = h.key.split("/");
            shift l;
            add(h.key, l, 0, h.value, swagger);
        }
    }

    #! private constructor
    private constructor(string full_path, list l, int offset, hash oh) {
        list l0 = l;
        splice l0, offset + 1;
        pfx = l0.join("/");
        name = l[offset - 1];
        #printf("pfx: %y name: %y\n", pfx, name);
    }

    #! adds a component or a Path Item Object to the tree
    private add(string full_path, list l, int offset, hash oh, SwaggerSchema swagger) {
        #printf("PathComponent::add(): %y l: %y offset: %y\n", full_path, l, offset);
        if (offset == l.size()) {
            if (pio)
                throw "INVALID-PATH-COMPONENT", sprintf("cannot terminate path %y twice", full_path);
            pio = new PathItemObject(full_path, oh, swagger);
            return;
        }

        PathComponent next;
        string key = l[offset];
        if (key =~ /^{/)
            next = wildcard ?? (wildcard = new PathComponent(full_path, l, offset + 1, oh));
        else
            next = paths{key} ?? (paths{key} = new PathComponent(full_path, l, offset + 1, oh));

        next.add(full_path, l, offset + 1, oh, swagger);
    }

    #! returns either a PathItemObject for the path
    /** @throw INVALID-PATH the path could not be matched or has no API definition
    */
    PathItemObject match(list path) {
        PathComponent w = self;
        for (int i = 1; i < path.size(); ++i) {
            *PathComponent next = w.paths{path[i]} ?? w.wildcard;
            if (!next)
                throw "INVALID-PATH", sprintf("component %y cannot be matched in %y", path[i], path.join("/"));
            w = next;
        }
        if (!w.pio)
            throw "INVALID-PATH", sprintf("path %y is valid but has no API definition", path.join("/"));
        return w.pio;
    }
}

#! This class stores the path tree for URI path matching
public class PathsObject inherits ObjectBase {
    private {
        #! the tree of path components for path matching with wildcards
        PathComponent paths;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing paths to schema endpoints
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
     */
    public constructor(hash oh, SwaggerSchema swagger) : ObjectBase(oh) {
        paths = new PathComponent(oh, "", swagger);
    }

    #! matches a URI path with a PathItemObject
    /** @throw INVALID-PATH the path could not be matched
    */
    PathItemObject match(string path) {
        return paths.match(path.split("/"));
    }
}

#! Describes the operations available on a single path.
/**
    A Path Item may be empty, due to ACL constraints. The path itself is still
    exposed to the documentation viewer but they will not know which operations
    and parameters are available.
 */
public class PathItemObject inherits ObjectBase {
    public {
        #! Allows for an external definition of this path item.
        /**
            The referenced structure MUST be in the format of a @ref PathItemObject.
            If there are conflicts between the referenced definition and this
            PathItem's definition, the behavior is undefined.
         */
        *string ref;

        #! A hash of parameters that are applicable for all the operations described under this path.
        /**
            Hash values are @ref AbstractParameterObject "AbstractParameterObjects"

            These parameters can be overridden at the operation level, but cannot
            be removed there. The list MUST NOT include duplicated parameters.
            A unique parameter is defined by a combination of a
            @ref AbstractParameterObject::name "name" and @ref AbstractParameterObject::inLoc "location".
            There can be one \c body parameter at most.
         */
        hash<string, AbstractParameterObject> parameters();

        #! The body parameter, if defined for this path
        AbstractParameterObject body;
    }

    private {
        #! A hash of @ref OperationObject "OperationObjects" correspoding to different methods.
        /**
            Keys are lowercase method names, with possible values being:
            - "get"
            - "put"
            - "post"
            - "del"
            - "options"
            - "head"
            - "patch"
         */
        hash<string, OperationObject> operations;
    }

    #! Constructor.
    /**
        @param path the URI path for the object
        @param oh deserialized hash from the source schema description describing the operations available on a single path
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, hash oh, SwaggerSchema swagger) : ObjectBase(oh) {
        string objType = "Path Item";
        optional_field(objType, oh, "$ref", NT_STRING, \ref);

        *hash opObj;
        if (optional_field(objType, oh, "get", NT_HASH, \opObj))
            operations.get = new OperationObject(path, "get", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "put", NT_HASH, \opObj))
            operations.put = new OperationObject(path, "put", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "post", NT_HASH, \opObj))
            operations.post = new OperationObject(path, "post", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "delete", NT_HASH, \opObj))
            operations.del = new OperationObject(path, "delete", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "options", NT_HASH, \opObj))
            operations.options = new OperationObject(path, "options", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "head", NT_HASH, \opObj))
            operations.head = new OperationObject(path, "head", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "patch", NT_HASH, \opObj))
            operations.patch = new OperationObject(path, "patch", opObj, swagger);

        *list params;
        if (optional_field(objType, oh, "parameters", NT_LIST, \params)) {
            foreach any param in (params) {
                if (param.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Path Item Object: 'parameters' list value has invalid type %y",
                            param.type());
                AbstractParameterObject p = AbstractParameterObject::newParameter(sprintf("%d/%d", $# + 1, params.lsize()), param, swagger);
                if (p.inLoc == "body") {
                    if (body)
                        throw "INVALID-FIELD-VALUE", sprintf("path %y: more than one \"body\" parameter provided", path);
                    body = p;
                }
                else
                    parameters{p.name} = p;
            }
        }
    }

    #! returns the operation object for the given method
    /** @param path the path to be used in any error message
        @param method the HTTP method name

        @return the OperationObject corresponding to the arguments

        @throws INVALID-METHOD the given path does not have any operation defined for the given method
    */
    OperationObject getOperation(string method, string path) {
        *OperationObject op = operations{method};
        if (!op)
            throw "INVALID-METHOD", sprintf("%s %s: no operation defined for this path; known methods: %y", method.upr(), path, keys operations);
        return op;
    }
}

#! Describes a single API operation on a path.
public class OperationObject inherits ObjectBase {
    public {
        #! the URI path for the operation
        string path;

        #! the HTTP method for the operation
        string method;

        #! A list of tags (strings or @ref TagObject "TagObjects") for API documentation control.
        /**
            Tags can be used for logical grouping of operations by resources or any other qualifier.
         */
        list tags;

        #! A short summary of what the operation does.
        *string summary;

        #! A verbose explanation of the operation behavior. GFM syntax can be used for rich text representation.
        *string desc;

        #! Declares this operation to be deprecated.
        /**
            Usage of the declared operation should be refrained.
            Default value is \c false.
         */
        bool deprec = False;

        #! Additional external documentation for this operation.
        *ExternalDocumentationObject externalDocs;

        #! Unique string used to identify the operation.
        /**
            The id MUST be unique among all operations described in the API.
            Tools and libraries MAY use the operationId to uniquely identify
            an operation, therefore, it is recommended to follow common
            programming naming conventions.
         */
        *string operationId;

        #! A list of MIME types (strings) the operation can consume.
        /**
            This overrides the @ref SwaggerSchema::consumes "consumes" definition
            at the %Swagger Object. An empty value MAY be used to clear the global definition.
            Key values MUST be Mime Types.
         */
        hash<string, bool> consumes;

        #! A hash of MIME types (strings) the operation can produce.
        /**
            This overrides the @ref SwaggerSchema::produces "produces" definition
            at the %Swagger Object. An empty value MAY be used to clear the global definition.
            Key values MUST be Mime Types.
         */
        hash<string, bool> produces;

        #! A hash of parameters that are applicable for this operation.
        /**
            If a parameter is already defined at the @ref PathItemObject "Path Item",
            the new definition will override it, but can never remove it.
            The hash MUST NOT include duplicated parameters.
            A unique parameter is defined by a combination of a @ref AbstractParameterObject::name "name"
            and @ref AbstractParameterObject::inLoc "location".
            There can be one "body" parameter at most.
         */
        hash<string, AbstractParameterObject> parameters();

        #! the body parameter, if defined for this operation
        AbstractParameterObject body;

        #! Required. The list of possible responses as they are returned from executing this operation.
        ResponsesObject responses;

        #! The transfer protocol for the operation.
        /**
            Values MUST be from the list: \c "http", \c "https", \c "ws", \c "wss".
            The value overrides the SwaggerSchema @ref SwaggerSchema::schemes "schemes" definition.
         */
        list<string> schemes;

        #! A declaration of which security schemes are applied for this operation.
        /**
            The list of values describes alternative security schemes that can be
            used (that is, there is a logical OR between the security requirements).
            This definition overrides any declared top-level @ref SwaggerSchema::security "security".
            To remove a top-level security declaration, an empty array can be used.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref SwaggerSchema::securityDefinitions "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
         */
        list<hash<string, list<string>>> security;
    }

    #! Constructor.
    /** @param path the path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, string method, hash oh, SwaggerSchema swagger) : ObjectBase(oh) {
        self.path = path;
        self.method = method.upr();
        string objType = "Operation";
        *list tagsObj;
        if (optional_field(objType, oh, "tags", NT_LIST, \tagsObj)) {
            foreach any tag in (tagsObj) {
                if (tag.typeCode() == NT_STRING)
                    tags += tag;
                else if (tag.typeCode() == NT_HASH)
                    tags += new TagObject(tag);
                else
                    error("INVALID-FIELD-TYPE", "'tags' list value has invalid type %y; expecting \"hash\" or \"string\"", tag.type());
            }
        }

        optional_field(objType, oh, "summary", NT_STRING, \summary);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(objType, oh, "deprecated", NT_BOOLEAN, \deprec);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);

        optional_field(objType, oh, "operationId", NT_STRING, \operationId);
        # TODO check operationId uniqueness as per docs

        # use the global "consumes" definition if none is defined on the operation
        if (!optional_field(objType, oh, "consumes", SwaggerListToSet, \consumes) && swagger.consumes)
            consumes = swagger.consumes;

        # use the global "produces" definition if none is defined on the operation
        if (!optional_field(objType, oh, "produces", SwaggerListToSet, \produces) && swagger.produces)
            produces = swagger.produces;

        {
            list listObj;
            optional_field(objType, oh, "parameters", NT_LIST, \listObj);
            foreach any p in (listObj) {
                if (p.typeCode() != NT_HASH)
                    error("INVALID-FIELD-TYPE", "invalid 'parameters' list value datatype %y; expecing \"hash\"", p.type());
                AbstractParameterObject param = AbstractParameterObject::newParameter(sprintf("%d/%d", $# + 1, listObj.lsize()), p, swagger);
                if (param.inLoc == "body")
                    body = param;
                else
                    parameters{param.name} = param;
            }
        }

        {
            hash responsesObj;
            required_field(objType, oh, "responses", NT_HASH, \responsesObj);
            responses = new ResponsesObject(path, self.method, responsesObj, swagger);
        }

        # process schemes
        {
            list schemesList;
            optional_field(objType, oh, "schemes", NT_LIST, \schemesList);
            foreach any val in (schemesList) {
                if (val.typeCode() != NT_STRING)
                    error("INVALID-FIELD-TYPE", "invalid 'schemes' list value datatype %y; expecting \"string\"", val.type());
                if (!ValidSchemesHash{val})
                    error("INVALID-FIELD-VALUE", "invalid operation transfer protocol scheme value %y; expecting one of: %y", val, keys ValidSchemesHash);
            }
            schemes = cast<list<string>>(schemesList);
        }

        {
            list securityList;
            optional_field(objType, oh, "security", NT_LIST, \securityList);
            foreach any val in (securityList) {
                if (val.typeCode() != NT_HASH)
                    error("INVALID-FIELD-TYPE", "invalid 'security' list value datatype %y; expecting \"hash\"", val.type());
                hash h = val;
                foreach hash it in (h.pairIterator()) {
                    if (it.value.typeCode() != NT_LIST)
                        error("INVALID-FIELD-TYPE",
                                "invalid Security Requirement Object value type %y (should be a list of hashes)",
                                val.type());
                    if ((map True, it.value, $1.typeCode() != NT_STRING).size())
                        error("INVALID-FIELD-TYPE",
                                "invalid Security Requirement Object value type %y (should be a list of hashes with list values)",
                                val.type());
                }
            }
            security = cast<list<hash<string, list<string>>>>(securityList);
        }
    }

    #! processes a REST API client-side request to the operation
    /** @param serialize if request arguments should be processed for serialization (client-side) or not (server-side)
        @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the HTTP message body data hash
        @param headers a reference to a hash of HTTP headers
        @param mime_types a reference to a hash of valid mime types for the operation

        @throws INVALID-PARAMETER-NAME invalid parameter name
        @throws INVALID-PARAMETER-LOCATION invalid parameter location
        @throws MISSING-PARAMETER missing parameter and parameter has no default value
    */
    validateRequest(bool serialize, PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<hash> body, reference<hash> headers, *reference<hash<string, bool>> mime_types) {
        # check query parameters
        foreach string key in (keys h.params) {
            # find URI parameter object
            *AbstractParameterObject po = parameters{key} ?? pio.parameters{key};
            if (!po)
                error("INVALID-PARAMETER-NAME", "No parameter named %y defined for this path and method", key);
            if (po.inLoc != "query")
                error("INVALID-PARAMETER-LOCATION", "invalid parameter %y given in the URI query; expected location %y", key, po.inLoc);

            po.check(serialize, True, path, method, key, \h.params{key});
        }

        # check header parameters
        foreach string key in (keys headers) {
            # find URI parameter object
            *AbstractParameterObject po = parameters{key} ?? pio.parameters{key};
            # extra headers are OK
            if (!po || po.inLoc != "header")
                continue;

            po.check(serialize, True, path, method, key, \headers{key});
        }

        # check body parameters
        {
            *AbstractParameterObject body_po = self.body ?? pio.body;
            if (body_po)
                body_po.check(serialize, True, path, method, "body", \body);
            else if (body)
                error("INVALID-PARAMETER-NAME", "No message body is accepted; body keys passed: %y", keys body);
        }

        # check for missing required parameters
        checkMissingParams(h, headers, body, parameters);
        checkMissingParams(h, headers, body, pio.parameters, parameters);

        if (consumes)
            mime_types = consumes;
    }

    #! parses and processes a REST request on the server side
    /** @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the HTTP message body data hash
        @param headers a reference to a hash of HTTP headers

        @throws INVALID-PARAMETER-NAME invalid parameter name
        @throws INVALID-PARAMETER-LOCATION invalid parameter location
        @throws MISSING-PARAMETER missing parameter and parameter has no default value
    */
    parseRequest(PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<hash> body, reference<hash> headers) {
        # validate message
        validateRequest(False, pio, \h, \body, \headers);

        # set default parameter values
        doDefaultParams(\h, \headers, \body, parameters);
        doDefaultParams(\h, \headers, \body, pio.parameters, parameters);
    }

    #! validates a response against the response definition, if any
    validateResponse(string method, string path, PathItemObject pio, int code, any response_body, reference<hash<string, bool>> mime_types) {
        *ResponseObject res = getResponse(code);
        if (res.schema)
            res.schema.check(True, False, path, method, "response body", \response_body);

        if (produces)
            mime_types = produces;
    }

    #! returns example Qore code for the given request
    /** @param method the HTTP method (in lower case)
        @param path the URI path of the request
        @param pio the PathItemObject corresponding to the URI path
        @param swagger the schema object itself

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given request message
    */
    hash<RestQoreExampleCodeInfo> getQoreExampleRequest(string method, string path, PathItemObject pio, SwaggerSchema swagger) {
        hash<RestQoreExampleCodeInfo> rv();

        #! URI query arguments
        hash query;
        #! headers
        hash headers;

        getQoreExampleParams(\query, \headers, parameters);
        getQoreExampleParams(\query, \headers, pio.parameters, parameters);

        if (query)
            path = make_uri_query(cast<hash<UriQueryInfo>>(("method": path, "params": query)));

        rv.example = sprintf("RestClient client((\"url\": %y));\n", swagger.getTargetUrl());

        #! get example message body
        *BodyParameter body_po = body ?? pio.body;
        if (body_po)
            rv.example += body_po.getQoreExample(\rv);

        rv.example += "hash info;\n";
        if (headers) {
            rv.example += "hash hdr = (\n";
            rv.example += foldl $1 + "\n" + $2, (map sprintf("    %y: %y,", $1.key, $1.value), headers.pairIterator());
            rv.example += "\n);\n";
        }

        rv.example += sprintf("hash res = rest.%s", method.lwr());
        rv.example += sprintf("(%y, ", path);
        # body
        rv.example += body_po ? "rest_body, " : "NOTHING, ";
        # info reference
        rv.example += "\\info";
        # headers
        if (headers)
            rv.example += ", hdr";
        rv.example += ");\n";

        return rv;
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method (in lower case)
        @param path the URI path of the request
        @param pio the PathItemObject corresponding to the URI path
        @param swagger the schema object itself
        @param rbody the output example body value, if any

        @return a @ref RestSchemaValidator::RestExampleRequestInfo "RestExampleRequestInfo" hash of example message information for the given request
    */
    hash<RestSchemaValidator::RestExampleRequestInfo> getExampleRequest(string method, string path, PathItemObject pio, SwaggerSchema swagger, reference rbody) {
        hash<RestExampleRequestInfo> rv();

        #! URI query arguments
        hash query;

        getQoreExampleParams(\query, \rv.hdr, parameters);
        getQoreExampleParams(\query, \rv.hdr, pio.parameters, parameters);

        rv.request_uri = sprintf("%s %s HTTP/1.1", method.upr(), make_uri_query(cast<hash<UriQueryInfo>>(("method": path, "params": query))));

        #! get example message body
        *BodyParameter body_po = body ?? pio.body;
        if (body_po)
            rbody = body_po.getExampleValue();

        return rv;
    }

    #! returns example Qore code for the given response
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given response message
    */
    hash<RestQoreExampleCodeInfo> getQoreExampleResponse(string method, string path, int code) {
        hash<RestQoreExampleCodeInfo> rv();

        *ResponseObject res = getResponse(code);
        if (res.schema)
            rv.example = res.schema.getQoreExample(\rv, "body", True);

        rv.example += sprintf("return RestHandler::makeResponse(%d%s);\n", code, rv.example ? ", body" : "");

        return rv;
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response
        @param body the output example body value, if any

        @return a @ref RestSchemaValidator::RestExampleResponseInfo "RestExampleResponseInfo" hash giving example response message info
    */
    hash<RestExampleResponseInfo> getExampleResponse(string method, string path, int code, reference body) {
        hash<RestExampleResponseInfo> rv();

        *ResponseObject res = getResponse(code);
        if (res.schema)
            body = res.schema.getExampleValue();

        return rv;
    }

    private getQoreExampleParams(reference<hash> query, reference<hash> headers, hash<string, AbstractParameterObject> parameters, *hash<string, AbstractParameterObject> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked or if it's the single message body param
            if (child_params{ph.key} || ph.value.inLoc == "body")
                continue;
            switch (ph.value.inLoc) {
                case "query":
                    query{ph.key} = ph.value.getExampleValue();
                    break;
                case "header":
                    headers{ph.key} = ph.value.getExampleValue();
                    break;
                /*
                case "formData":
                    if (!exists body{ph.key})
                        body{ph.key} = val;
                    break;
                */
            }
        }
    }

    #! add default parameters
    private doDefaultParams(reference<hash<UriQueryInfo>> h, reference<hash> headers, reference<hash> body, hash<string, AbstractParameterObject> parameters, *hash<string, AbstractParameterObject> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked or if it's the single message body param
            if (child_params{ph.key} || ph.value.inLoc == "body")
                continue;
            if (exists (auto val = ph.value.getDefaultValue())) {
                switch (ph.value.inLoc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            h.params{ph.key} = val;
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            headers{ph.key} = val;
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            body{ph.key} = val;
                        break;
                    # NOTE: default "path" values are not possible, "body" is handled specially
                }
            }
        }
    }

    #! checks for missing params
    private checkMissingParams(hash<UriQueryInfo> h, *hash headers, *hash body, hash<string, AbstractParameterObject> parameters, *hash<string, AbstractParameterObject> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked
            if (child_params{ph.key} || ph.value.inLoc == "body")
                continue;
            if (ph.value.required) {
                switch (ph.value.inLoc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            error("MISSING-PARAMETER", "request is missing required query parameter %y", ph.key);
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            error("MISSING-PARAMETER", "request is missing required header parameter %y", ph.key);
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            error("MISSING-PARAMETER", "request is missing required formData parameter %y", ph.key);
                        break;
                    # NOTE: missing path parameters are not possible (path would not be matched in the first place)
                    #       "body" is handled specially
                }
            }
        }
    }

    #! returns the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    /** @return the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    */
    private *ResponseObject getResponse(int code) {
        return responses.responses{code} ?? responses.defaultResp;
    }

    #! raises an exception with context information
    private error(string err, string fmt) {
        throw err, sprintf("%s %s Operation Object: %s", method.upr(), path, vsprintf(fmt, argv));
    }
}

#! Allows referencing an external resource for extended documentation.
public class ExternalDocumentationObject inherits ObjectBase {
    public {
        #! A short description of the target documentation. GFM syntax can be used for rich text representation.
        *string desc;

        #! Required. The URL for the target documentation. Value MUST be in the format of a URL.
        string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing a reference to external documentation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "External Documentation";
        required_field(objType, oh, "url", NT_STRING, \url);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Describes a single operation parameter.
/**
    A unique parameter is defined by a combination of a @ref AbstractParameterObject::name "name"
    and @ref AbstractParameterObject::inLoc "location".

    There are five possible parameter types:
    - Path: Used together with Path Templating, where the parameter value is
        actually part of the operation's URL. This does not include the host or
        base path of the API. For example, in <tt>/items/{itemId}</tt>, the path
        parameter is \c itemId.
    - Query: Parameters that are appended to the URL. For example, in <tt>/items?id=###</tt>,
        the query parameter is \c id.
    - Header: Custom headers that are expected as part of the request.
    - Body: The payload that's appended to the HTTP request. Since there can only
        be one payload, there can only be one body parameter. The name of the
        body parameter has no effect on the parameter itself and is used for
        documentation purposes only. Since Form parameters are also in the payload,
        body and form parameters cannot exist together for the same operation.
    - Form: Used to describe the payload of an HTTP request when either
        <tt>application/x-www-form-urlencoded</tt>, <tt>multipart/form-data</tt>
        or both are used as the content type of the request (in %Swagger's definition,
        the \c consumes property of an operation). This is the only parameter
        type that can be used to send files, thus supporting the file type.
        Since form parameters are sent in the payload, they cannot be declared
        together with a body parameter for the same operation. Form parameters
        have a different format based on the content-type used (for further details,
        consult http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4):
            - <tt>application/x-www-form-urlencoded</tt> - Similar to the format
                of Query parameters but as a payload. For example,
                <tt>foo=1&bar=swagger</tt> - both foo and bar are form parameters.
                This is normally used for simple parameters that are being transferred.
            - <tt>multipart/form-data</tt> - each parameter takes a section in
                the payload with an internal header. For example, for the header
                <tt>Content-Disposition: form-data; name="submit-name"</tt> the name
                of the parameter is \c submit-name. This type of form parameters
                is more commonly used for file transfers.
 */
public class AbstractParameterObject inherits ObjectBase {
    public {
        #! Required. The name of the parameter. Parameter names are case sensitive.
        /**
            - If @ref AbstractParameterObject::inLoc "inLoc" is \c "path", the \c name
                field MUST correspond to the associated path segment from the
                \c "path" field in the @ref Swagger::PathsObject.
            - For all other cases, the name corresponds to the parameter name
                used based on the @ref AbstractParameterObject::inLoc "inLoc" property.
         */
        string name;

        #! Required. The location of the parameter.
        /**
            Possible values are \c "query", \c "header", \c "path",
            \c "formData" or \c "body".
         */
        string inLoc;

        #! A brief description of the parameter. This could contain examples of use. GFM syntax can be used for rich text representation.
        *string desc;

        #! Determines whether this parameter is mandatory.
        /**
            If the parameter is @ref AbstractParameterObject::inLoc "in" "path",
            this property is \b required and its value MUST be \c true.
            Otherwise, the property MAY be included and its default value is \c false.
         */
        bool required = False;
    }

    private {
        const OtherParameterMap = (
            "query": True,
            "header": True,
            "path": True,
            "formData": True,
        );
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description decscribing a single parameter

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Parameter";
        required_field(objType, oh, "name", NT_STRING, \name);
        required_field(objType, oh, "in", NT_STRING, \inLoc);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        if (inLoc == "path")
            required_field(objType, oh, "required", NT_BOOLEAN, \required);
        else
            optional_field(objType, oh, "required", NT_BOOLEAN, \required);
    }

    #! verifies the parameter in an actual REST API call
    abstract check(bool serialize, bool request, string path, string method, string name, reference value);

    #! returns the default value of the parameter (default: @ref nothing)
    any getDefaultValue() {
    }

    #! gets a concrete instance of an AbstractParameterObject
    static AbstractParameterObject newParameter(string name, hash oh, SwaggerSchema swagger) {
        if (oh.hasKey("$ref"))
            return swagger.resolveParameter(name, oh."$ref", oh);

        if (!oh.hasKey("in"))
            throw "REQUIRED-FIELD-MISSING", sprintf("Parameter Object %y: missing location parameter \"in\"", name);
        if (oh."in" == "body")
            return new BodyParameter(oh, swagger);
        else if (OtherParameterMap{oh."in"})
            return new OtherParameter(name, oh, swagger);
        throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid location (\"in\") parameter value: %y", name, oh."in");
    }
}

#! @ref AbstractParameterObject specialization for \c "body" parameters.
public class BodyParameter inherits AbstractParameterObject {
    public {
        #! Required. The schema defining the type used for the body parameter.
        SchemaObject schema;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a body parameter
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh, SwaggerSchema swagger) : AbstractParameterObject(oh) {
        hash schemaObj;
        required_field("Body Parameter", oh, "schema", NT_HASH, \schemaObj);
        schema = SchemaObject::newSchemaObject("body", schemaObj, swagger);
    }

    #! verifies the parameter in an actual REST API call
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        return schema.check(serialize, request, path, method, name, \value);
    }

    #! generates Qore example code for a REST API call
    string getQoreExample(reference<hash<RestQoreExampleCodeInfo>> rv) {
        return schema.getQoreExample(\rv, "rest_body", True);
    }

    # returns an example value for a REST API call
    any getExampleValue() {
        return schema.getExampleValue();
    }
}

#! @ref AbstractParameterObject specialization for parameters other than \c "body".
public class OtherParameter inherits AbstractParameterObject, SchemaBase {
    public {
        #! Required. The type of the parameter.
        /**
            Since the parameter is not located at the request body, it is
            limited to simple types (that is, not an object).
            The value MUST be one of \c "string", \c "number", \c "integer",
            \c "boolean", \c "array" or \c "file". If \c type is \c "file",
            the @ref OperationObject::consumes "consumes" MUST be either
            \c "multipart/form-data", \c " application/x-www-form-urlencoded" or
            both and the parameter MUST be @ref AbstractParameterObject::inLoc "in" \c "formData".
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! Sets the ability to pass empty-valued parameters.
        /**
            This is valid only for either \c query or \c formData parameters and
            allows you to send a parameter with a name only or an empty value.
            Default value is \c false.
         */
        bool allowEmptyValue = False;

        #! Required if @ref OtherParameter::type "type" is \c "array". Describes the type of items in the array.
        *ParameterItemsSchemaObject items;

        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\\tbar
            - \c "pipes": pipe separated values; ex: foo|bar
            - \c "multi": corresponds to multiple parameter instances instead of
                multiple values for a single instance <tt>foo=bar&foo=baz</tt>.
                This is valid only for parameters @ref AbstractParameterObject::inLoc "in"
                \c "query" or \c "formData".

            Default value is \c "csv".
         */
        *string collectionFormat;

        #! Declares the value of the parameter that the server will use if none is provided.
        /**
            For example a "count" to control the number of results per page
            might default to 100 if not supplied by the client in the request.
            (Note: "default" has no meaning for required parameters.)
            See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
            Unlike JSON Schema this value MUST conform to the defined type for this parameter.
         */
        any defaultVal;

        #! valid parameter types
        const ParameterTypes = SchemaObject::ScalarTypes + (
            "file": True,
        );
    }

    #! Constructor.
    /**
        @param name the parameter name
        @param oh deserialized hash from the source schema description describing general parameters (other than \c "body" parameters)
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string name, hash oh, SwaggerSchema swagger) : AbstractParameterObject(oh), SchemaBase("Parameter", oh) {
        string objType = "Parameter";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (!ParameterTypes{type})
            throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid parameter type value passed: %y, expecting one of: %y", name, type, keys ParameterTypes);
        if (type == "array") {
            items = ParameterItemsSchemaObject::newSchemaObject("items", oh.items, swagger);
            if (optional_field(objType, oh, "collectionFormat", NT_STRING, \collectionFormat)) {
                if (!ParameterCollectionFormats{collectionFormat})
                    throw "INVALID-FIELD-VALUE",
                        sprintf("Parameter Object %y: invalid collectionFormat value %y; expected one of: %y", name, collectionFormat, keys ParameterCollectionFormats);

                if (collectionFormat == "multi" && inLoc != "query" && inLoc != "formData")
                    throw "INVALID-FIELD-VALUE",
                        sprintf("Parameter Object %y: invalid collectionFormat value 'multi' - is only valid when 'in' (location) is either 'query' or 'formData'", name);
            }
        }
        else if (oh.collectionFormat)
            throw "INVALID-FIELD-TYPE", sprintf("Parameter Object %y: type %y (non-array) cannot have a \"collectionFormat\" property (%y)", name, type, oh.collectionFormat);

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid integer type format value passed: %y", name, format);
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid number type format value passed: %y", name, format);
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid string type format value passed: %y", name, format);
        }

        optional_field(objType, oh, "allowEmptyValue", NT_BOOLEAN, \allowEmptyValue);

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            OtherParameter::checkValueType(defaultVal, type, items);
        }
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        SchemaBase::check(serialize, request, type, items, path, method, name, \value);
        switch (value.typeCode()) {
            case NT_NOTHING:
                if (!allowEmptyValue)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y has empty value (allowEmptyValue=false)",
                            name, path, method);
        }
    }

    #! returns the default value of the parameter (default: @ref nothing)
    any getDefaultValue() {
        return defaultVal;
    }

    #! returns an example value of the parameter (default: @ref nothing)
    any getExampleValue() {
        if (exists defaultVal)
            return defaultVal;
        return getExampleValue(type, format);
    }

    #! validates string values
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, string v, reference value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = make_hex_string(v);
                    break;
            }
        }
        else {
            switch (format) {
                # NOTE: deserializes to a binary object
                case "byte":
                    value = parse_base64_string(v);
                    break;
                # NOTE: deserializes to a binary object
                case "binary":
                    value = parse_hex_string(v);
                    break;
                # NOTE: deserializes to a date/time value
                case "date":
                case "date-time":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    value = date(v);
                    break;
            }
        }
        checkStringIntern(path, method, name, value);
    }

    #! converts binary values to strings for supported formats
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, binary v, reference value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = make_hex_string(v);
                    break;
                default:
                    throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot serialize a binary value to a string value with format %y", method.upr(), path, name, format);
            }
        }
        # already-serialized dataa must be a string
        else
            throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot deserialize a binary value to a string value with format %y", method.upr(), path, name, format);

        checkStringIntern(path, method, name, value);
    }

    #! converts strings to/from date/time values for supported formats
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, date v, reference value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        if (serialize) {
            switch (format) {
                case "date":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    value = v.format("YYYY-MM-DD");
                    break;
                case "date-time":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    value = v.format("YYYY-MM-DD HH:mm:SS.y Z");
                    break;
                default:
                    throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot serialize a date/time value to a string value with format %y", method.upr(), path, name, format);
            }
        }
        # already-serialized data must be a string
        else
            throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot deserialize a date/time value to a string value with format %y", method.upr(), path, name, format);

        checkStringIntern(path, method, name, value);
    }

    #! validates default values
    private static checkValueType(any value, string type, *SchemaObject items, *string loc) {
        int vt = value.typeCode();
        if (type == "array") {
            if (vt != NT_LIST)
                throw "INVALID-FIELD-TYPE", sprintf("Parameter Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
            OtherParameter::checkValueType(value[0], items.type, items.items, loc + "[0]");
        }
        if ((vt == NT_BOOLEAN && type != "boolean") ||
            (vt == NT_INT && type != "integer") ||
            (vt == NT_FLOAT && type != "number") ||
            (vt == NT_STRING && (type != "string" && type != "file")) ||
            (vt == NT_LIST && type != "array"))
            throw "INVALID-FIELD-TYPE", sprintf("Parameter Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
    }
}

#! contains the possible responses for an operation
public class ResponsesObject inherits ObjectBase {
    public {
        # The documentation of responses other than the ones declared for specific HTTP response codes.
        /**
            It can be used to cover undeclared responses.
         */
        ResponseObject defaultResp;

        # A hash mapping HTTP status codes to @ref ResponseObject "ResponseObjects".
        /**
            Any HTTP status code can be used as the property name (one property
            per HTTP status code). Describes the expected response for that HTTP status code.
         */
        hash<string, ResponseObject> responses;
    }

    #! Constructor.
    /**
        @param path the URI path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the responses for an operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws EMPTY-RESPONSES no responses given
     */
    public constructor(string path, string method, hash oh, SwaggerSchema swagger) : ObjectBase(oh) {
        string objType = "Responses";
        *hash defaultObj;
        if (optional_field(objType, oh, "default", NT_HASH, \defaultObj))
            defaultResp = ResponseObject::newResponse("default", defaultObj, swagger);

        *hash r = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^[0-9]+$/;
        foreach hash resp in (r.pairIterator()) {
            if (resp.value.typeCode() != NT_HASH)
                throw "INVALID-FIELD-TYPE", sprintf("%s %s: Responses Object: response has invalid type %y", method, path, resp.value.type());
            responses{resp.key} = ResponseObject::newResponse(resp.key, resp.value, swagger);
        }

        if (responses.empty() && !defaultObj)
            throw "EMPTY-RESPONSES", sprintf("%s %s: no valid responses provided for operation", method, path);
    }
}

#! Describes a single response from an API Operation.
public class ResponseObject inherits ObjectBase {
    public {
        #! Required. A short description of the response. GFM syntax can be used for rich text representation.
        string desc;

        #! A definition of the response structure.
        /**
            It can be a primitive, an array or an object. If this field does not exist,
            it means no content is returned as part of the response. As an extension
            to the @ref SchemaObject "SchemaObject", its root \c type value may also
            be \c "file". This SHOULD be accompanied by a relevant \c produces mime-type.
         */
        *SchemaObject schema;

        #! A hash of headers that are (can be) sent with the response.
        /**
            A hash of @ref HeaderObject objects. Keys are header names.
         */
        hash headers;

        #! A hash of example response messages.
        /**
            A hash of example responses in the form of <tt>Example Object</tt>.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#exampleObject
            Keys MUST be one of the Operation @ref OperationObject::produces "produces"
            values (either implicit or inherited). The value SHOULD be an example
            of what such a response would look like.
         */
        hash examples;
    }

    #! private constructor; use newResponse() instead
    /**
        @param key the response code for error reporting
        @param oh deserialized hash from the source schema description describing a single response for an API operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string key, hash oh, SwaggerSchema swagger) : ObjectBase(oh) {
        string objType = key + " Response";
        required_field(objType, oh, "description", NT_STRING, \desc);

        *hash schemaObj;
        if (optional_field(objType, oh, "schema", NT_HASH, \schemaObj))
            schema = SchemaObject::newSchemaObject("response_" + key, schemaObj, swagger);

        *hash headersObj;
        if (optional_field(objType, oh, "headers", NT_HASH, \headersObj))
            headers = map {$1.key: new HeaderObject($1.value, swagger)}, headersObj.pairIterator();

        optional_field(objType, oh, "examples", NT_HASH, \examples);
        # TODO keys should be Operation 'produces' values
    }

    #! returns a new ResponseObject corresponding to the schema definition passed
    /**
        @param key the response code for the response
        @param oh deserialized hash from the source schema description describing a single response for an API operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    static ResponseObject newResponse(string key, hash oh, SwaggerSchema swagger) {
        if (oh.hasKey("$ref"))
            return swagger.resolveResponse(key, oh."$ref", oh);
        return new ResponseObject(key, oh, swagger);
    }
}

#! describes a single HTTP header
public class HeaderObject inherits ObjectBase, SchemaBase {
    public {
        #! A short description of the header.
        *string desc;

        #! Required. The type of the object.
        /**
            The value MUST be one of \c "string", \c "number", \c "integer",
            \c "boolean", or \c "array".
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! Required if @ref HeaderObject::type "type" is \c "array". Describes the type of items in the array.
        *SchemaObject items;

        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\\tbar
            - \c "pipes": pipe separated values; ex: foo|bar

            Default value is \c "csv".
         */
        *string collectionFormat;

        #! Declares the value of the header that the server will use if none is provided.
        /**
            (Note: "default" has no meaning for required headers.)
            See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
            Unlike JSON Schema this value MUST conform to the defined
            @ref HeaderObject::type "type" for the header.
         */
        any defaultVal;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a single HTTP header
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh, SwaggerSchema swagger) : ObjectBase(oh), SchemaBase("Header", oh) {
        string objType = "Header";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (!SchemaObject::ScalarTypes{type})
            throw "INVALID-FIELD-VALUE", "Header Object: invalid header type value passed: " + type;

        if (type == "array") {
            items = SchemaObject::newSchemaObject("items", oh.items, swagger);
            if (optional_field(objType, oh, "collectionFormat", NT_STRING, \collectionFormat)) {
                if (!CollectionFormats{collectionFormat})
                    throw "INVALID-FIELD-VALUE",
                        sprintf("Header Object: invalid collectionFormat value %y; expected one of: %y", collectionFormat, keys CollectionFormats);
            }
        }
        else if (oh.collectionFormat)
            throw "INVALID-FIELD-TYPE", sprintf("Header Object: type %y (non-array) cannot have a \"collectionFormat\" property (%y)", type, oh.collectionFormat);

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid integer type format value passed: " + format;
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid number type format value passed: " + format;
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid string type format value passed: " + format;
        }

        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            HeaderObject::checkValueType(defaultVal, type, items);
        }
    }

    #! validates default values
    private static checkValueType(any value, string type, *SchemaObject items, *string loc) {
        int vt = value.typeCode();
        if (type == "array") {
            if (vt != NT_LIST)
                throw "INVALID-FIELD-TYPE", sprintf("Header Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
            HeaderObject::checkValueType(value[0], items.type, items.items, loc + "[0]");
        }
        if ((vt == NT_BOOLEAN && type != "boolean") ||
            (vt == NT_INT && type != "integer") ||
            (vt == NT_FLOAT && type != "number") ||
            (vt == NT_STRING && (type != "string" && type != "file")) ||
            (vt == NT_LIST && type != "array"))
            throw "INVALID-FIELD-TYPE", sprintf("Header Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
    }
}

#! Allows adding metadata to a single tag that is used by the @ref OperationObject. It is not mandatory to have a TagObject per tag used there.
public class TagObject inherits ObjectBase {
    public {
        #! Required. The name of the tag.
        string name;

        #! A short description for the tag. GFM syntax can be used for rich text representation.
        *string desc;

        #! Additional external documentation for this tag.
        *ExternalDocumentationObject externalDocs;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a metadata tag associated with an operation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Tag";
        required_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);
    }
}

#! defines an object in a schema
public class SchemaObject inherits ObjectBase, SchemaBase {
    public {
        #! the name of this object for documentation and example purposes
        string name;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.2.
        /**
            MUST be either a string or an array (list). If it's an array,
            it's elements MUST be strings and MUST be unique.
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string title;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string desc;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.1.
        *SchemaObject items;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        any defaultVal;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.1.
        *int maxProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.2.
        *int minProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be an object. Each value of this object MUST be an object,
            and each object MUST be a valid JSON Schema (@ref SchemaObject).
         */
        hash<string, SchemaObject> properties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be a bool or an object. If it is an object, it MUST also be
            a valid JSON Schema (@ref SchemaObject).
         */
        any additionalProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.3.
        /**
            Set of strings. Must have at least one element.
         */
        hash<string, bool> required;

        #! Adds support for polymorphism.
        /**
            The discriminator is the schema property name that is used to
            differentiate between other schemas that inherit this schema.
            The property name used MUST be defined at this schema and it MUST
            be in the @ref SchemaObject::required "required" property list.
            When used, the value MUST be the name of this schema or any schema
            that inherits it.

            While composition offers model extensibility, it does not imply
            a hierarchy between the models. To support polymorphism, Swagger
            adds the support of the \c discriminator field. When used,
            the \c discriminator will be the name of the property used to decide
            which schema definition is used to validate the structure of the model.
            As such, the \c discriminator field MUST be a required field.
            The value of the chosen property has to be the friendly name given to
            the model under the \c definitions property. As such, inline schema
            definitions, which do not have a given id, \e cannot be used in polymorphism.
         */
        *string discriminator;

        #! Relevant only for Schema \c "properties" definitions. Declares the property as "read only".
        /**
            Declares the property as "read only". This means that it MAY be sent
            as part of a response but MUST NOT be sent as part of the request.
            Properties marked as \c readOnly being \c true SHOULD NOT be in the
            @ref SchemaObject::required "required" list of the defined schema.
            Default value is \c false.
         */
        bool readOnly = False;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.3.
        /**
            List of @ref SchemaObject "SchemaObjects"; MUST have at least one element.

            %Swagger allows combining and extending model definitions using the
            \c allOf property of JSON Schema, in effect offering model composition.
            \c allOf takes in an array of object definitions that are validated
            independently but together compose a single object.
         */
        list<SchemaObject> allOf();

        #! This MAY be used only on properties schemas. It has no effect on root schemas.
        /**
            Adds Additional metadata to describe the XML representation format of this property.

            The \c xml property allows extra definitions when translating the
            JSON definition to XML. The @ref XmlObject contains additional
            information about the available options.
         */
        *XmlObject xml;

        #! Additional external documentation for this schema.
        *ExternalDocumentationObject externalDocs;

        #! A free-form property to include an example of an instance for this schema.
        any example;

        #! valid scalar types
        const ScalarTypes = (
            "string": True,
            "number": True,
            "integer": True,
            "boolean": True,
            "array": True,
        );

        #! valid reference types
        const ReferenceTypes = ScalarTypes + (
            "object": True,
        );
    }

    #! private constructor; use newSchemaObject() instead
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string name, hash oh, SwaggerSchema swagger) : ObjectBase(oh), SchemaBase("Schema", oh) {
        self.name = name;
        string objType = "Schema";

        required_field(objType, oh, "type", NT_STRING, \type);
        if (!ReferenceTypes{type})
            throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid schema type value passed: %y; expected one of: %y", name, type, keys ReferenceTypes);
        if (type == "array")
            items = newSchemaObject("items", oh.items, swagger);

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            SchemaObject::checkValueType(defaultVal, type, items);
        }

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid integer type format value passed: %y", name, format);
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid number type format value passed: %y", name, format);
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid string type format value passed: %y", name, format);
        }

        optional_field(objType, oh, "title", NT_STRING, \title);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        if (optional_field(objType, oh, "maxProperties", NT_INT, \maxProperties)) {
            checkObjectProperty(name, "maxProperties");
            if (maxProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'maxProperties' field less than 0", name);
        }
        if (optional_field(objType, oh, "minProperties", NT_INT, \minProperties)) {
            checkObjectProperty(name, "minProperties");
            if (minProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'minProperties' field less than 0", name);
        }

        {
            hash props;
            if (optional_field(objType, oh, "properties", NT_HASH, \props)) {
                checkObjectProperty(name, "properties");
                foreach string k in (keys props) {
                    any val = props{k};
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'properties' field is not a hash of Schema Objects", name);
                    properties{k} = SchemaObject::newSchemaObject(k, val, swagger);
                }
            }
        }

        if (optional_field(objType, oh, "additionalProperties", (NT_BOOLEAN: True, NT_HASH: True), \additionalProperties)) {
            checkObjectProperty(name, "additionalProperties");
            if (additionalProperties.typeCode() == NT_HASH)
                additionalProperties = SchemaObject::newSchemaObject("additionalProperties", additionalProperties, swagger);
        }

        # process "required"
        if (optional_field(objType, oh, "required", SwaggerListToSet, \required)) {
            if (!required)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'required' is an empty list", name);
        }

        if (optional_field(objType, oh, "discriminator", NT_STRING, \discriminator)) {
            if (!required{discriminator})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: 'discriminator' field value not in the 'required' list", name);
        }

        optional_field(objType, oh, "readOnly", NT_BOOLEAN, \readOnly);

        {
            *list allOfList;
            if (optional_field(objType, oh, "allOf", NT_LIST, \allOfList)) {
                if (allOfList.size() < 1)
                    throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'allOf' is an empty list", name);
                foreach any val in (allOfList) {
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-TYPE", sprintf("Schema Object %y: invalid 'allOf' list value datatype: %y", name, val.type());
                    allOf += SchemaObject::newSchemaObject(name + "AllOf", val, swagger);
                }
            }
        }

        *hash xmlObj;
        if (optional_field(objType, oh, "xml", NT_HASH, \xmlObj))
            xml = new XmlObject(xmlObj);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);

        if (oh.hasKey("example"))
            example = oh.example;
    }

    #! returns example Qore code for the object
    string getQoreExample(reference<hash<RestQoreExampleCodeInfo>> rv, string name, bool decl) {
        string typestr = get_qore_type(self.name, type, format, items);
        if (type == "array") {
            if (decl)
                return sprintf("%s %s(%s,);\n", typestr, self.name, items.getQoreExample(\rv, name, False));
            else
                return sprintf("(%s,)", items.getQoreExample(\rv, self.name, False));
        }

        if (type != "object") {
            softstring example = sprintf("%y", getExampleValue());
            if (decl)
                return sprintf("%s %s = %s;\n", typestr, self.name, example);
            return example;
        }

        if (!rv.hashdecls{name}) {
            string str = sprintf("hashdecl %s {\n", self.name);
            foreach hash h in (properties.pairIterator()) {
                str += sprintf("    %s %s", get_qore_type(h.value.name, h.value.type, h.value.format, h.value.items), h.key);
                if (exists h.value.defaultVal)
                    str += sprintf(" = %y", h.value.defaultVal);
                str += ";\n";
            }
            str += "}\n";
            rv.hashdecls{name} = str;
        }

        string str;
        if (decl)
            str = sprintf("hash<%s> %s(", self.name, name);
        else
            str = sprintf("new hash<%s>(", self.name);
        str += "{\n";
        foreach hash h in (properties.pairIterator()) {
            string pstr = sprintf("%y: %s", h.key, h.value.getQoreExample(\rv, h.key, False));
            # add 4 spaces to the beginning of each line
            str += foldl $1 + "\n" + $2, (map "    " + $1, pstr.split("\n"));
            str += ",\n";
        }
        str += "})";
        if (decl)
            str += ";\n";
        return str;
    }

    # returns an example value for a REST API call
    any getExampleValue() {
        if (exists example)
            return example;
        if (exists defaultVal)
            return defaultVal;

        if (type == "object") {
            return map {$1.key: $1.value.getExampleValue()}, properties.pairIterator();
        }

        if (type == "array") {
            return (items.getExampleValue(),);
        }

        return SchemaBase::getExampleValue(type, format);
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        if (request && readOnly)
            throw "READONLY-PROPERTY-ERROR", sprintf("%s %s: property %y is read-only and therefore cannot be included in a request", method.upr(), path, name);

        SchemaBase::check(serialize, request, type, items, path, method, name, \value);
    }

    private checkObjectProperty(string name, string prop) {
        if (type != "object")
            throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: %y cannot be given on an object of type %y", name, prop, type);
    }

    #! validates a schema object against a value
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, hash v, reference<hash> value) {
        if (type != "object")
            throwInvalidType(name, "object", type);

        # check "allOf" schemas, if any
        map $1.checkIntern(serialize, request, type, path, method, name, v, \value), allOf;

        /*
        If additionalProperties is set to true, any number of additionalProperties may be present of any data type.
        If additionalProperties is a schema, additional properties (beyond what are defined in properties) are allowed and must match the schema
        */
        # check properties in this schema definition
        if (additionalProperties !== True) {
            foreach string key in (keys value) {
                *SchemaObject prop = properties{key};
                if (!prop) {
                    if (additionalProperties instanceof SchemaObject)
                        prop = additionalProperties;
                    if (!prop)
                        throw "INVALID-PROPERTY", sprintf("property %y is not valid for object %y", key, name);
                }
                prop.check(serialize, request, path, method, name, \value{key});
            }
        }
        # check for missing required properties
        foreach string prop in (keys required) {
            if (!value.hasKey(prop))
                throw "MISSING-PROPERTY", sprintf("object %y: missing required property %y", name, prop);
        }
        #printf("SchemaObject::checkIntern() %y type: %y val: %y self: %N\n", name, type, value, self);
    }

    #! validates default values
    private static checkValueType(any value, string type, *SchemaObject items, *string loc) {
        int vt = value.typeCode();
        if (type == "array") {
            if (vt != NT_LIST)
                throw "INVALID-FIELD-TYPE", sprintf("Schema Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
            SchemaObject::checkValueType(value[0], items.type, items.items, loc + "[0]");
        }
        if ((vt == NT_BOOLEAN && type != "boolean") ||
            (vt == NT_INT && type != "integer") ||
            (vt == NT_FLOAT && type != "number") ||
            (vt == NT_STRING && (type != "string" && type != "file")) ||
            (vt == NT_LIST && type != "array"))
            throw "INVALID-FIELD-TYPE", sprintf("Schema Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
    }

    #! returns a SchemaObject for the schema definition; resolves references
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    static SchemaObject newSchemaObject(string name, hash oh, SwaggerSchema swagger) {
        string refstr;
        if (optional_field("Schema", oh, "$ref", NT_STRING, \refstr))
            return swagger.resolveSchemaObject(name, refstr, oh);
        return new SchemaObject(name, oh, swagger);
    }

    #! throws an \c "INVALID-FIELD-TYPE" exception
    /** @throws INVALID-FIELD-TYPE due to a type error in the call
    */
    static SchemaObject newSchemaObject(string name, any error, SwaggerSchema swagger) {
        throw "INVALID-FIELD-TYPE", sprintf("invalid field type %y for key %y; expecting \"hash\"", error.type(), name);
    }
}

#! items schema object for non-body parameters
public class ParameterItemsSchemaObject inherits SchemaObject {
    public {
        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\\tbar
            - \c "pipes": pipe separated values; ex: foo|bar
            - \c "multi": corresponds to multiple parameter instances instead of
                multiple values for a single instance <tt>foo=bar&foo=baz</tt>.
                This is valid only for parameters @ref AbstractParameterObject::inLoc "in"
                \c "query" or \c "formData".

            Default value is \c "csv".
         */
        *string collectionFormat;
    }

    #! private constructor; use newSchemaObject() instead
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-COLLECTION-FORMAT invalid collectionFormat value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string name, hash oh, SwaggerSchema swagger) : SchemaObject(name, oh, swagger) {
        if (optional_field("Parameter Items Schema", oh, "collectionFormat", NT_STRING, \collectionFormat)) {
            if (!CollectionFormats{collectionFormat})
                throw "INVALID-FIELD-VALUE",
                    sprintf("Parameter Items Schema Object %y: invalid collectionFormat value %y; expected one of: %y", name, collectionFormat, keys CollectionFormats);
        }
        if (type == "object")
            throw "INVALID-FIELD-VALUE",
                sprintf("Parameter Items Schema Object %y: invalid type value \"object\"; parameter items must be basic types and cannot be objects", name);
    }

    #! returns a SchemaObject for the schema definition; resolves references
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-COLLECTION-FORMAT invalid collectionFormat value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    static ParameterItemsSchemaObject newSchemaObject(string name, hash oh, SwaggerSchema swagger) {
        string refstr;
        if (optional_field("Parameter Items Schema", oh, "$ref", NT_STRING, \refstr))
            return swagger.resolveParameterItemsSchemaObject(name, refstr, oh);
        return new ParameterItemsSchemaObject(name, oh, swagger);
    }

    #! throws an \c "INVALID-FIELD-TYPE" exception
    /** @throws INVALID-FIELD-TYPE due to a type error in the call
    */
    static ParameterItemsSchemaObject newSchemaObject(string name, any error, SwaggerSchema swagger) {
        throw "INVALID-FIELD-TYPE", sprintf("invalid field type %y for key %y; expecting \"hash\"", error.type(), name);
    }
}

#! A metadata object that allows for more fine-tuned XML model definitions.
/**
    When using arrays, XML element names are not inferred (for singular/plural
    forms) and the @ref XmlObject::name "name" property should be used to add that information.
    See examples for expected behavior.
 */
public class XmlObject inherits ObjectBase {
    public {
        #! Replaces the name of the element/attribute used for the described schema property.
        /**
            When defined within the \c items, it will affect
            the name of the individual XML elements within the list.
            When defined alongside \c type being \c array (outside the \c items),
            it will affect the wrapping element and only if \c wrapped is \c true.
            If \c wrapped is \c false, it will be ignored.
         */
        *string name;

        #! The URL of the namespace definition. Value SHOULD be in the form of a URL.
        *string ns;

        #! The prefix to be used for the @ref XmlObject::name "name".
        *string prefix;

        #! Declares whether the property definition translates to an attribute instead of an element. Default value is \c false.
        bool attribute = False;

        #! MAY be used only for an array definition. Signifies whether the array is wrapped (for example, \c &lt;books&gt;&lt;book/&gt;&lt;book/&gt;&lt;/books&gt;) or unwrapped (\c &lt;book/&gt;&lt;book/&gt;).
        /**
            Default value is \c false. The definition takes effect only when
            defined alongside \c type being \c array (outside the \c items).
         */
        bool wrapped = False;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing XML model definitions

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "XML";
        optional_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "namespace", NT_STRING, \ns);
        optional_field(objType, oh, "prefix", NT_STRING, \prefix);
        optional_field(objType, oh, "attribute", NT_BOOLEAN, \attribute);
        optional_field(objType, oh, "wrapped", NT_BOOLEAN, \wrapped);
    }
}

#! Allows the definition of a security scheme that can be used by the operations.
/**
    Supported schemes are basic authentication, an API key (either as a header
    or as a query parameter) and OAuth2's common flows (implicit, password,
    application and access code).
 */
public class SecuritySchemeObject inherits ObjectBase {
    public {
        #! Required. The type of the security scheme. Valid values are \c "basic", \c "apiKey" or \c "oauth2".
        string type;

        #! A short description for security scheme.
        *string desc;

        #! The name of the header or query parameter to be used.
        /**
            Required when type is \c "apiKey".
         */
        *string name;

        #! The location of the API key. Valid values are \c "query" or \c "header".
        /**
            Required when type is \c "apiKey".
         */
        *string inLoc;

        #! The flow used by the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            Valid values are \c "implicit", \c "password", \c "application" or \c "accessCode".
         */
        *string flow;

        #! The authorization URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is \c "implicit" or \c "accessCode".
         */
        *string authorizationUrl;

        #! The token URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is one of \c "password", \c "application" or \c "accessCode".
         */
        *string tokenUrl;

        #! The available scopes for the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            A hash in the form of <tt>Scopes Object</tt> mapping scope names to short descriptions of them.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#scopesObject
            Keys are scope names. Values are short string descriptions.
         */
        *ScopesObject scopes;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a security schema that can be used by REST API operations

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FLOW invalid OAuth2 flow value
        @throws INVALID-APIKEY-LOCATION invalid 'in' (location) value
        @throws INVALID-SCHEME-TYPE invalid security scheme type; see @ref SecuritySchemeObject::type "type"
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Security Scheme";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (type == "apiKey") {
            required_field(objType, oh, "name", NT_STRING, \name);
            required_field(objType, oh, "in", NT_STRING, \inLoc);
            if (inLoc != "query" && inLoc != "header")
                throw "INVALID-APIKEY-LOCATION", "Security Scheme Object: invalid 'in' (location) value passed: " + inLoc;
        }
        else if (type == "oauth2") {
            required_field(objType, oh, "flow", NT_STRING, \flow);
            if (flow == "accessCode") {
                required_field(objType, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
                required_field(objType, oh, "tokenUrl", NT_STRING, \tokenUrl);
            }
            else if (flow == "application" || flow == "password") {
                required_field(objType, oh, "tokenUrl", NT_STRING, \tokenUrl);
            }
            else if (flow == "implicit") {
                required_field(objType, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
            }
            else {
                throw "INVALID-FLOW", "Security Scheme Object: invalid OAuth2 flow value passed: " + flow;
            }

            hash scopesObj;
            required_field(objType, oh, "scopes", NT_HASH, \scopesObj);
            scopes = new ScopesObject(scopesObj);
        }
        else if (type != "basic") {
            throw "INVALID-SCHEME-TYPE", "Security Scheme Object: invalid security scheme type passed: " + type;
        }
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Lists the available scopes for an OAuth2 security scheme.
public class ScopesObject inherits ObjectBase {
    public {
        #! Maps between a name of a scope to a short description of it (as the value of the property).
        /**
            Hash of string values.
         */
        hash<string, string> fields;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the available scopes for an OAuth2 security scheme

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash oh) : ObjectBase(oh) {
        foreach hash item in (oh.pairIterator()) {
            if (item.key !~ /^x-/) { # if not vendor extension
                if (item.value.typeCode() != NT_STRING)
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Scopes Object: %y field has invalid type %y, instead of 'string'",
                            item.key, item.value.type());
                fields{item.key} = item.value;
            }
        }
    }
}

} # end public namespace swagger

# private namespace for internal definitions
namespace Priv {
    const SwaggerListToSet = -1;
    const SwaggerListToHashOfStrings = -2;

    const TypeMap = (
        NT_INT: "int",
        NT_STRING: "string",
        NT_FLOAT: "float",
        NT_LIST: "list",
        NT_HASH: "hash",
        NT_NOTHING: "nothing",
        NT_BOOLEAN: "bool",
        SwaggerListToSet: "list<string>",
    );

    #! Check and assign a required field.
    /**
        @param objType type of object (e.g. "External Documentation")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    sub required_field(string objType, hash oh, string name, int typeCode, reference<any> target) {
        if (!oh.hasKey(name))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: %y field is missing; fields present: %y", objType, name, keys oh);
        any val = oh{name};
        check_type_code(objType, name, val, typeCode);
        get_value(objType, name, typeCode, val, \target);
    }

    #! Check and assign a field.
    /**
        @param objType type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string objType, hash oh, string name, int typeCode, reference<any> target) {
        if (!oh.hasKey(name))
            return False;
        any val = oh{name};
        check_type_code(objType, name, val, typeCode);
        get_value(objType, name, typeCode, val, \target);
        return True;
    }

    #! Check and assign a field.
    /**
        @param objType type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCodes possible field typeCodes
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string objType, hash oh, string name, hash<string, bool> typeCodes, reference<any> target) {
        if (!oh.hasKey(name))
            return False;
        any val = oh{name};
        if (!typeCodes{val.typeCode()})
            throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y field has invalid type %y", objType, name, val.type());
        get_value(objType, name, val.typeCode(), val, \target);
        return True;
    }

    #! verifies the type of a field
    sub check_type_code(string objType, string name, any val, int typeCode) {
        int vtc = val.typeCode();
        if ((typeCode == SwaggerListToSet || typeCode == SwaggerListToHashOfStrings) && vtc == NT_LIST)
            return;
        if (vtc != typeCode)
            throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y field has invalid type %y; expecting %y", objType, name, val.type(), TypeMap{typeCode});
    }

    #! assigns a value to a field
    sub get_value(string objType, string name, int typeCode, any val, reference<any> target) {
        if (typeCode == SwaggerListToSet) {
            foreach any v in (val) {
                if (v.typeCode() != NT_STRING)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in %y list value has type %y; expecting \"string\"", objType, name, $# + 1, val.size(), v.type());
                target{v} = True;
            }
        }
        else if (typeCode == SwaggerListToHashOfStrings) {
            foreach any v in (val) {
                int pos = $# + 1;
                if (v.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has type %y; expecting \"hash\"", objType, name, pos, val.size(), v.type());
                if (v.size() > 1)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has a hash with more than one key: %y; expecting a hash with a single key", objType, name, pos, val.size(), v);
                string key = v.firstKey();
                if (target.hasKey(key))
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d has duplicate key %y", objType, name, pos, val.size(), key);
                foreach any fv in (v.firstValue()) {
                    if (fv.typeCode() != NT_STRING)
                        throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in %y list value has type %y in position %d/%d; expecting \"string\"", objType, name, pos, val.size(), key, fv.type(), $# + 1, fv.lsize());
                }
                target += v;
            }
        }
        else
            target = val;
    }

    #! returns the Qore type for the given schema type
    string sub get_qore_type(string name, string type, *string format, *SchemaObject items) {
        switch (type) {
            case "array": return sprintf("list<%s>", get_qore_type(items.name, items.type, items.format, items.items));
            case "integer": return "int";
            case "boolean": return "bool";
            case "number": return format && ValidNumberFormatsHash{format} ? "float" : "number";
            case "string": {
                switch (format) {
                    case "byte":
                    case "binary":
                        return "binary";
                    case "date":
                    case "date-time":
                        return "date";
                }
                return "string";
            }
            case "null": return "nothing";
            case "object": return sprintf("hash<%s>", name);
        }
        return sprintf("unknown<%s = %s>", name, type);
    }
}