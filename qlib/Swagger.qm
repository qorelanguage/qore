# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Swagger.qm Swagger: https://swagger.io/, OpenAPI: https://github.com/OAI/OpenAPI-Specification

/*  Swagger.qm Copyright (C) 2017 - 2020 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%new-style
%enable-all-warnings
%require-types
%strict-args

# make sure we have the required qore version
%requires qore >= 0.9.7

# try importing JSON and YAML modules
%try-module json
%define NoJson
%endtry

%try-module yaml
%define NoYaml
%endtry

%try-module xml
%define NoXml
%endtry

%requires(reexport) Mime >= 1.4
%requires(reexport) Util >= 1.3
%requires(reexport) HttpServerUtil >= 0.3.12
%requires(reexport) RestSchemaValidator >= 1.0
%requires(reexport) FileLocationHandler

module Swagger {
    version = "2.0.4";
    desc = "Swagger module providing functionality for Swagger 2.0 schema definitions";
    author = "Ondrej Musil <ondrej.musil@qoretechnologies.com>, David Nichols <david.nichols@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Swagger module

    @tableofcontents

    @section swaggerintro Swagger Module Introduction

    The %Swagger module provides a <a href="https://swagger.io/">Swagger 2.0 REST API validation API</a> to %Qore.

    The primary classes provided by this module:
    - @ref Swagger::SwaggerLoader "SwaggerLoader": provides static methods for loading %Swagger schemas
    - @ref Swagger::SwaggerSchema "SwaggerSchema": the %Swagger schema object for client/server REST API validation and example code and message generation

    This class is most often used in the <a href="../../RestClient/html/index.html">RestClient</a> and <a href="../../RestHandler/html/index.html">RestHandler</a> modules to register a
    <a href="https://swagger.io/">Swagger 2.0</a> schema for
    automatic REST API validation.

    JSON and YAML serialization and deserialization are supported; XML is currently not supported.

    @section swagger_usage Swagger Usage

    @subsection swagger_client Swagger Client-Side Usage

    Use the \a swagger or \a validator options in the \c RestClient::constructor() call to use <a href="https://swagger.io/">Swagger 2.0</a>
    REST schema validation on the client side with the \c RestClient class.

    To override the target URL specified in the <a href="https://swagger.io/">Swagger</a> schema, use the \c "url" option in the
    \c RestClient::constructor() call.

    To override the URI base path specified in the <a href="https://swagger.io/">Swagger</a> schema,
    get the <a href="https://swagger.io/">Swagger</a> schema object by calling
    \c RestClient::getValidator(), and then call
    @ref RestSchemaValidator::AbstractRestSchemaValidator::setBasePath() "AbstractRestSchemaValidator::setBasePath()" on the validator object.

    @par Client Example
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

# the RestClient module imports and reexports the Swagger module automatically
%requires RestClient

# create the RestClient options with a Swagger schema
hash opts = (
    "swagger": ENV.SCHEMA_DIR + DirSep + "MySchema.yaml",
);

# there is no need to add the "url" option if the target URL provided by the schema is valid
# (otherwise you can override the target URL provided by the Swagger schema by using the
# "url" option in the RestClient constructor options)
RestClient rc(opts);

# afterwards all REST calls made with the RestClient objects with automatic Swagger 2.0
# schema validation; do not include the Swagger schema's basePath in the URI path in the
# requests
hash<auto> h = rc.get("get", "/some_api");
    @endcode

    @par Override Base Path Client Example
    @code{.py}
# create the RestClient options with a Swagger schema
hash<auto> opts = (
    "swagger": ENV.SCHEMA_DIR + DirSep + "MySchema.yaml",
);
RestClient rc(opts);
# get the SwaggerSchema validator object
AbstractRestSchemaValidator schema = rc.getValidator();
# override the base path in requests
schema.setBasePath("/new/path");
    @endcode

    @subsection swagger_server Swagger Server-Side Usage

    Enforce <a href="https://swagger.io/">Swagger</a> REST API validation on the server side by passing a @ref Swagger::SwaggerSchema "SwaggerSchema"
    object to the \c RestHandler::constructor() call as in the following example.

    @par Server Example
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

%requires RestHandler
%requires Swagger

SwaggerSchema swagger = SwaggerLoader::fromFile(ENV.SCHEMA_DIR + DirSep + "MySchema.yaml");
RestHandler handler(NOTHING, swagger);
    @endcode

    @section swagger_relnotes Swagger Module Release Notes

    @subsection swagger_2_0_4 Swagger v2.0.4
    - fixed a type error in @ref Swagger::Swagger::getBasePath() "Swagger::getBasePath()" for the case when the base
      path is not set
      (<a href="https://github.com/qorelanguage/qore/issues/4064">issue 4064</a>)

    @subsection swagger_2_0_3 Swagger v2.0.3
    - fixed a bug supporting number formats
      (<a href="https://github.com/qorelanguage/qore/issues/3979">issue 3979</a>)

    @subsection swagger_2_0_2 Swagger v2.0.2
    - fixed \c date-time value handling
      (<a href="https://github.com/qorelanguage/qore/issues/3847">issue 3847</a>)
    - fixed a bug where sibling elements to a \c "$ref" were not ignored (see
      <a href="https://swagger.io/docs/specification/using-ref/">https://swagger.io/docs/specification/using-ref/</a>)
      (<a href="https://github.com/qorelanguage/qore/issues/3843">issue 3843</a>)
    - fixed support for query parameters of type object
      (<a href="https://github.com/qorelanguage/qore/issues/3799">issue 3799</a>)

    @subsection swagger_2_0_1 Swagger v2.0.1
    - added support for the <tt>x-nullable</tt> attribute to allow for nullable values
      (<a href="https://github.com/qorelanguage/qore/issues/3785">issue 3785</a>)
    - added location support from the @ref filelocationhandlerintro "FileLocationHandler" module
      (<a href="https://github.com/qorelanguage/qore/issues/3781">issue 3781</a>)
    - fixed support for types with no type declaration
      (<a href="https://github.com/qorelanguage/qore/issues/3775">issue 3775</a>)

    @subsection swagger_2_0 Swagger v2.0
    - fixed support for additional YAML MIME types
      (<a href="https://github.com/qorelanguage/qore/issues/3699">issue 3699</a>)
    - implemented support for the DataProvider API
      (<a href="https://github.com/qorelanguage/qore/issues/3545">issue 3545</a>)

    @subsection swagger_1_1_0 Swagger v1.1.0
    - fixed accepting multipart/form-data content-type and also working with list and hash parameters
      (<a href="https://github.com/qorelanguage/qore/issues/2932">issue 2932</a>)

    @subsection swagger_1_0_2 Swagger v1.0.2
    - fixed sending of simple string responses to use text/plain Content-Type if possible
      (<a href="https://github.com/qorelanguage/qore/issues/2893">issue 2893</a>)
    - fixed checking of response body in case response schema is not present
      (<a href="https://github.com/qorelanguage/qore/issues/2894">issue 2894</a>)

    @subsection swagger_1_0_1 Swagger v1.0.1
    - fixed handling of string type date and date-time formats (<a href="https://github.com/qorelanguage/qore/issues/2341">issue 2341</a>)
    - fixed example value for binary type (<a href="https://github.com/qorelanguage/qore/issues/2342">issue 2342</a>)
    - fixed serialization of date/time values (<a href="https://github.com/qorelanguage/qore/issues/2349">issue 2349</a>)
    - fixed handling of non-string enum types (<a href="https://github.com/qorelanguage/qore/issues/2364">issue 2364</a>)
    - fixed confusing error messages with invalid parameter types (<a href="https://github.com/qorelanguage/qore/issues/2365">issue 2365</a>)
    - fixed handling of messages with non-object (i.e. non-hash) bodies (<a href="https://github.com/qorelanguage/qore/issues/2366">issue 2366</a>)
    - fixed handling of optional parameters (<a href="https://github.com/qorelanguage/qore/issues/2369">issue 2369</a>)
    - fixed handling of non-string query parameters (<a href="https://github.com/qorelanguage/qore/issues/2388">issue 2388</a>)
    - fixed a bug where string value constraints were only enforced in requests but not responses (<a href="https://github.com/qorelanguage/qore/issues/2396">issue 2396</a>)
    - fixed a bug where invalid date, binary, and byte values would cause a <tt>500 Internal Server Error</tt> response to be returned instead of a <tt>400 Bad Request</tt> error (<a href="https://github.com/qorelanguage/qore/issues/2397">issue 2397</a>)
    - fixed a bug where date values were formatted incorrectly in Swagger responses (<a href="https://github.com/qorelanguage/qore/issues/2409">issue 2409</a>)
    - fixed a bug which made it impossible to send data with other content/mime types than json, yamlrpc, FormUrlEncoded or MultipartFormData (<a href="https://github.com/qorelanguage/qore/issues/2497">issue 2497</a>)
    - fixed handling of string/binary values (<a href="https://github.com/qorelanguage/qore/issues/2505">issue 2505</a>)
    - fixed a bug where consumes property of operations was sometimes ignored (<a href="https://github.com/qorelanguage/qore/issues/2507">issue 2507</a>)
    - fixed parsing of responses without Content-Type header (<a href="https://github.com/qorelanguage/qore/issues/2517">issue 2517</a>)
    - fixed path matching for paths not beginning with a slash (<a href="https://github.com/qorelanguage/qore/issues/2516">issue 2516</a>)

    @subsection swagger_1_0 Swagger v1.0

    - initial release of the %Swagger module
*/

#! main namespace for all public %Swagger declarations
public namespace Swagger {
#! Valid integer type formats
public const ValidIntFormats = ("int32", "int64");
#! Valid number type formats
public const ValidNumberFormats = ("double", "float");
#! Valid string type formats
public const ValidStringFormats = ("binary", "byte", "date", "date-time", "password");

#! allowed collection formats
public const CollectionFormats = (
    "csv": True,
    "ssv": True,
    "tsv": True,
    "pipes": True,
);

#! valid parameter collection formats
public const ParameterCollectionFormats = CollectionFormats + (
    "multi": True,
);

#! A hash of valid integer type formats
public const ValidIntFormatsHash = map {$1: True}, ValidIntFormats;
#! A hash of valid number type formats
public const ValidNumberFormatsHash = map {$1: True}, ValidNumberFormats;
#! A hash of valid string type formats
public const ValidStringFormatsHash = map {$1: True}, ValidStringFormats;

%ifndef NoYaml
#! Yaml serialization
const YamlSerialization = {
    "serialize": \make_yaml(),
    "serialize_verbose": string sub (auto val) {return make_yaml(val, BlockStyle);},
    "deserialize": \parse_yaml(),
    "module": "yaml",
};
%endif

#! supported mime types for de/serializing data
public const MimeDataTypes = {
%ifndef NoJson
    MimeTypeJson: (
        "serialize": \make_json(),
        "serialize_verbose": string sub (auto val) {return make_json(val, JGF_ADD_FORMATTING);},
        "deserialize": \parse_json(),
        "module": "json",
    ),
%endif
%ifndef NoYaml
    # issue #3699: more YAML MIME types must be supported
    MimeTypeYaml: YamlSerialization,
    MimeTypeYamlRpc: YamlSerialization,
    "text/yaml": YamlSerialization,
    "application/yaml": YamlSerialization,
%endif
%ifndef NoXml
    MimeTypeXmlApp: (
        "serialize": \make_xml(),
        "serialize_verbose": string sub (auto val) {return make_xml(val, XGF_ADD_FORMATTING);},
        "deserialize": \parse_xml(),
        "module": "xml",
    ),
%endif
    # Content-Type: application/x-www-form-urlencoded
    MimeTypeFormUrlEncoded: (
        "serialize": \mime_get_form_urlencoded_string(),
        "serialize_verbose": \mime_get_form_urlencoded_string(),
        "deserialize": \mime_parse_form_urlencoded_string(),
    ),
    # Content-Type: multipart/form-data (handled manually)
    MimeTypeMultipartFormData: {},
};

#! modules available for data serialization and/or deserialization
public const SerializationModules = keys (map {$1.module: True}, MimeDataTypes.iterator(), $1.module);

#! MIME types for data serialization
public const MimeContentTypes = keys MimeDataTypes;

#! Valid transfer protocol schemes.
public const ValidSchemes = ("http", "https", "ws", "wss");
public const ValidSchemesHash = map {$1: True}, ValidSchemes;

#! Base class for the %Swagger specification objects, wrapping the vendor extensions.
class ObjectBase {
    public {
        #! Allows extensions to the %Swagger Schema.
        /**
            The field name MUST begin with \c x-, for example, \c x-internal-id.
            The value can be \c null, a primitive, an array or an object.
         */
        hash<auto> vendorExtensions;
    }

    #! Constructor.
    public constructor() {
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the object
     */
    public constructor(hash<auto> oh) {
        initialize(oh);
    }

    #! copy constructor
    constructor(ObjectBase other) {
        vendorExtensions = other.vendorExtensions;
    }

    #! Initialize.
    /**
        @param oh deserialized hash from the source schema description
    */
    public initialize(hash<auto> oh) {
        vendorExtensions = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^x-/;
    }
}

#! Base used by @ref OtherParameter, @ref HeaderObject and @ref SchemaObject.
class SchemaBase {
    public {
        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *float maximum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *float minimum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *bool exclusiveMax;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *bool exclusiveMin;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.1.
        *int maxLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.2.
        *int minLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        *string pattern;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.2.
        *int maxItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.3.
        *int minItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.4.
        *bool uniqueItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1.
        /** @note Swagger enums can be of any type, but we only support enums of simple types that can be converted
            to a string for fast lookups in a hash
        */
        hash<string, bool> enum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.1.
        *float multipleOf;
    }

    #! Constructor.
    /** @param objType the type of object
        @param oh deserialized hash from the source schema description
     */
    public constructor(string objType, hash<auto> oh) {
        optional_field(objType, oh, "maximum", (NT_FLOAT: True, NT_INT: True), \maximum);
        optional_field(objType, oh, "minimum", (NT_FLOAT: True, NT_INT: True), \minimum);
        optional_field(objType, oh, "exclusiveMaximum", NT_BOOLEAN, \exclusiveMax);
        optional_field(objType, oh, "exclusiveMinimum", NT_BOOLEAN, \exclusiveMin);
        optional_field(objType, oh, "maxLength", NT_INT, \maxLength);
        optional_field(objType, oh, "minLength", NT_INT, \minLength);
        optional_field(objType, oh, "pattern", NT_STRING, \pattern);
        optional_field(objType, oh, "maxItems", NT_INT, \maxItems);
        optional_field(objType, oh, "minItems", NT_INT, \minItems);
        optional_field(objType, oh, "uniqueItems", NT_BOOLEAN, \uniqueItems);
        optional_field(objType, oh, "enum", SwaggerListToAnySet, \enum);
        optional_field(objType, oh, "multipleOf", (NT_FLOAT: True, NT_INT: True), \multipleOf);
    }

    #! Copy constructor
    constructor(SchemaBase other) {
        self += map {$1: other.$1}, (
            "maximum", "minimum", "exclusiveMax", "exclusiveMin",
            "maxLength", "minLength", "pattern", "maxItems", "minItems",
            "uniqueItems", "enum", "multipleOf"), exists other.$1;
    }

    #! returns an example value for the given type
    private auto getExampleValue(string type, *string format) {
        if (enum) {
            auto rv = enum.firstKey();
            switch (type) {
                case "integer": rv = rv.toInt(); break;
                case "number": rv = (format && ValidNumberFormatsHash{format} ? rv.toFloat() : rv.toNumber()); break;
                case "boolean": rv = rv.toBool(); break;
                case "string": {
                    switch (format) {
                        case "byte": return parse_base64_string(rv);
                        case "date":
                        case "date-time":
                            return date(rv);
                        default:
                            break;
                    }
                }
            }
            return rv;
        }
        switch (type) {
            case "string": {
                switch (format) {
                    case "byte":
                    case "binary": return <feedface>;
                    case "date": return 1987-05-23;
                    case "date-time": return 1987-05-23T07:45:30Z;
                    default:
                        return "value";
                }
            }
            case "integer": {
                if (exists minimum)
                    return exclusiveMin ? minimum + 1 : minimum;
                if (exists maximum)
                    return exclusiveMax ? maximum - 1 : maximum;
                return 1;
            }
            case "number": {
                number rv;
                if (exists minimum)
                    rv = exclusiveMin ? minimum + 0.1 : minimum;
                else if (exists maximum)
                    rv = exclusiveMax ? maximum - 0.1 : maximum;
                else
                    rv = 1.1n;
                if (format && ValidNumberFormatsHash{format})
                    return rv.toFloat();
                return rv;
            }
            case "boolean":
                return True;
            case "null":
                return NOTHING;
            case "any": {
                return "any value";
            }
        }
    }

    #! validates the value against the schema definition
    private check(bool serialize, bool request, string type, *string format, *SchemaObject items, string path, string method, string name, reference<auto> value) {
        # accept a single value for an array (= one-element list)
        if (type == "array")
            checkArrayParam(serialize, request, items, path, method, name, \value);
        else
            checkIntern(serialize, request, type, format, path, method, name, value, \value);
    }

    private checkStringIntern(string path, string method, string name, string value) {
        # minLength and maxLength are based on the number of characters in the string, not bytes
        if (exists maxLength && value.length() > maxLength)
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y is too long (maxLength: %d, actual: %d)",
                    name, path, method, maxLength, value.length());
        if (exists minLength && value.length() < minLength)
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y is too short (minLength: %d, actual: %d)",
                    name, path, method, minLength, value.length());
        if (exists pattern && !value.regex(pattern))
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the parameter string pattern (pattern: %y, value: %y)",
                    name, path, method, pattern, value);
        if (enum && !enum{value})
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %y)",
                    name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, list<auto> v, reference<list> value) {
        if (type != "list" && type != "any")
            throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y is an array (%y), but the expected type is %y", name, path, method, v, type);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, hash<auto> v, reference<hash> value) {
        if (type != "file" && type != "any")
            throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y is an object (%y), but the expected type is %y", name, path, method, v, type);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, int v, reference<auto> value) {
        # NOTE: "number" also accepts "int"
        if (type == "number") {
            checkIntern(serialize, request, type, format, path, method, name, v.toNumber(), \value);
            return;
        }
        if (type != "integer" && type != "any")
            throwInvalidType(name, "integer", type, v);
        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            } else {
                if (value > maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            } else {
                if (value < minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value})
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %d)",
                    name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, number v, reference<number> value) {
        checkInternNumber(serialize, request, type, format, path, method, name, v, \value);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, float v, reference<number> value) {
        checkInternNumber(serialize, request, type, format, path, method, name, v, \value);
    }

    private checkInternNumber(bool serialize, bool request, string type, *string format, string path, string method, string name, auto v, reference<auto> value) {
        if (type != "number" && type != "any")
            throwInvalidType(name, "number", type, v);
        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            } else {
                if (value > maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            } else {
                if (value < minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value})
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %f)",
                    name, path, method, keys enum, value);

        switch (format) {
            case "float":
            case "double":
            case NOTHING:
                value = v.toFloat();
                break;

            default:
                throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y has an invalid format: %y; expecting (\"float\", "
                    "\"double\", or no value; value provided: %y)", name, path, method, format, value);
        }
    }

    #! converts binary values to strings for supported formats
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, binary v, reference value) {
        if (type != "string" && type != "any")
            throwInvalidType(name, "string", type, v);

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = v;
                    return;
                default:
                    throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: parameters %y: cannot serialize a binary value to a string value with format %y", method.upr(), path, name, format);
            }
            checkStringIntern(path, method, name, value);
        }
    }

    #! validates string values
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, string v, reference<auto> value) {
        if (type != "string" && type != "any") {
            throwInvalidType(name, "string", type, v);
        }

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = binary(v);
                    break;
                case "date":
                case "date-time":
                    # issue #3847: with non-YAML serialization, this will always be a string
                    value = date(v);
                    break;
            }
        } else {
            switch (format) {
                # NOTE: deserializes to a binary object
                case "byte":
                    try {
                        value = parse_base64_string(v);
                    }
                    catch (hash<ExceptionInfo> ex) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type %y is invalid; value provided: %y (%s)", name, path, method, format, v, ex.desc);
                    }
                    break;
                # NOTE: deserializes to a binary object
                case "binary":
                    try {
                        value = binary(v);
                    }
                    catch (hash<ExceptionInfo> ex) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type %y is invalid; value provided: %y (%s)", name, path, method, format, v, ex.desc);
                    }
                    break;
                # NOTE: deserializes to a date/time value
                case "date":
                case "date-time":
                    try {
                        # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                        value = date(v);
                    }
                    catch (hash<ExceptionInfo> ex) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type %y is invalid; value provided: %y (%s)", name, path, method, format, v, ex.desc);
                    }
                    break;
            }
        }
        if (value.typeCode() == NT_STRING)
            checkStringIntern(path, method, name, value);
    }

    #! converts strings to/from date/time values for supported formats
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, date v, reference value) {
        if (type != "string" && type != "any")
            throwInvalidType(name, "string", type, v);

        if (serialize) {
            switch (format) {
                case "date":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    value = v.format("YYYY-MM-DD");
                    break;
                case "date-time":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    if (v.milliseconds() != 0)
                        value = v.format("YYYY-MM-DDTHH:mm:SS.yZ");
                    else
                        value = v.format("YYYY-MM-DDTHH:mm:SSZ");
                    break;
                default:
                    throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: parameters %y: cannot serialize a date/time value to a string value with format %y", method.upr(), path, name, format);
            }
            checkStringIntern(path, method, name, value);
        }
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, bool v, reference<bool> value) {
        if (type != "boolean" && type != "any")
            throwInvalidType(name, "boolean", type, v);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, nothing v, reference<nothing> value) {
        if (type != "null" && type != "any")
            throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y is null, but the expected type is %y", name, path, method, type);
    }

    #! validates the value against the schema definition
    private checkArrayParam(bool serialize, bool request, SchemaObject items, string path, string method, string name, reference<softlist> value) {
        if (exists maxItems && value.size() > maxItems)
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y has too many items (maxItems: %d, actual: %d)",
                    name, path, method, maxItems, value.size());
        if (exists minItems && value.size() < minItems)
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y has too few items (minItems: %d, actual: %d)",
                    name, path, method, minItems, value.size());

        # check array element types
        if (!uniqueItems || items.type != "array") {
            # hash for checking uniqueness if uniqueItems is true
            #printf("v: %y self: %N\n", value, self);
            hash<string, bool> h;
            foreach auto v in (\value) {
                items.check(serialize, request, path, method, name, \v);
                if (uniqueItems) {
                    if (h{v})
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: parameter value %y is duplicated in the array", method, path, v);
                    h{v} = True;
                }
            }
        } else {
            # perform slow array uniqueness check
            list<auto> uniqueItems = ();
            foreach auto val in (\value) {
                items.check(serialize, request, path, method, name, \val);
                if (uniqueItems.contains(val))
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("%s %s: Array parameter %y does not have unique items",
                            method, path, name);
                uniqueItems += val;
            }
        }
    }

    #! throws an \c SCHEMA-VALIDATION-ERROR exception
    static private throwInvalidType(string name, string actual, string expected, auto value) {
        throw "SCHEMA-VALIDATION-ERROR",
            sprintf("Parameter %y has invalid type %y (should be %y); value: %y", name, actual, expected, value);
    }

    #! Checks the value against the type
    /** @return True if the value is OK, False if not
    */
    static bool checkValueType(reference<auto> value, string type) {
        int vt = value.typeCode();

        # check for string values
        if (vt == NT_STRING) {
            if (type == "boolean") {
                if (value == "true") {
                    value = True;
                    return True;
                } else if (value == "false") {
                    value = False;
                    return True;
                }
            } else if (type == "int" && value =~ /^[0-9]+$/) {
                value = value.toInt();
                return True;
            }
        }

        if ((vt == NT_BOOLEAN && type != "boolean") ||
            (vt == NT_INT && type != "integer") ||
            (vt == NT_FLOAT && type != "number") ||
            (vt == NT_STRING && (type != "string" && type != "file")) ||
            (vt == NT_LIST && type != "array")) {
            return False;
        }
        return True;
    }
}

#! Used for loading the %Swagger definitions.
public class SwaggerLoader {
    #! Load %Swagger definition from a string.
    /**
        @param swaggerSpecification <a href="https://swagger.io/">Swagger</a> API specification
        @param json whether the specification is in JSON or YAML format; if not given the source encoding will be
        detected automatically

        @throws JSON-MODULE-MISSING trying to parse a JSON %Swagger specification with JSON module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %Swagger specification with YAML module unavailable
    */
    static SwaggerSchema fromString(string swaggerSpecification, *bool json) {
        string ser;
        if (!exists json) {
            ser = SwaggerLoader::detectSourceEncoding(swaggerSpecification);
        } else {
            ser = json ? "json" : "yaml";
        }
        return new SwaggerSchema(swaggerSpecification, SwaggerLoader::parseSchemaSource(swaggerSpecification, ser));
    }

    #! Load <a href="https://swagger.io/">Swagger</a> definition from a file.
    /**
        @param filepath path to the <a href="https://swagger.io/">Swagger</a> file

        @throws EMPTY-SCHEMA-FILE %Swagger file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON %Swagger specification with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %Swagger specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML %Swagger specification with the xml module unavailable
    */
    static SwaggerSchema fromFile(string filepath) {
        string file_data = ReadOnlyFile::readTextFile(filepath);
        return new SwaggerSchema(file_data, SwaggerLoader::parseSchemaContent(filepath, file_data));
    }

    #! Load <a href="https://swagger.io/">Swagger</a> definition from a URL or file path.
    /**
        @param url URL to the <a href="https://swagger.io/">Swagger</a> file; uses the
        @ref filelocationhandlerintro "FileLocationHandler" to load the file
        @param json whether the specification is in JSON or YAML format; if not given the source encoding will be
        detected automatically

        @throws EMPTY-SCHEMA-FILE %Swagger file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON %Swagger specification with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %Swagger specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML %Swagger specification with the xml module unavailable
    */
    static SwaggerSchema fromUrl(string url, *bool json) {
        return SwaggerLoader::fromString(FileLocationHandler::getTextFileFromLocation(url), json);
    }

    #! Load a schema definition from a file
    /**
        @param filepath path to the schema file
        @param str the file content to parse

        @throws EMPTY-SCHEMA-FILE schema file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON schema with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML schema specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML schema specification with the xml module unavailable
    */
    static hash<auto> parseSchemaContent(string filepath, string str) {
        if (!str)
            throw "EMPTY-SCHEMA-FILE", sprintf("%y: file is empty", filepath);

        string ser;
        string filename = basename(filepath);
        if (filename =~ /.*\.json$/i) {
            ser = "json";
        } else if (filename =~ /.*\.yaml$/i) {
            ser = "yaml";
        } else if (filename =~ /.*\.xml$/i) {
            ser = "xml";
        } else {
            ser = SwaggerLoader::detectSourceEncoding(str);
        }

        return SwaggerLoader::parseSchemaSource(str, ser);
    }

    #! parses the source encoding from the given string
    static hash<auto> parseSchemaSource(string str, string ser) {
        hash<auto> rv;
        switch (ser) {
            case "json": {
%ifdef NoJson
                throw "JSON-MODULE-MISSING", "Trying to parse a JSON schema, but the json module is unavailable";
%else
                rv = parse_json(str);
                break;
%endif
            }
            case "yaml": {
%ifdef NoYaml
                throw "YAML-MODULE-MISSING", "Trying to parse a YAML schema, but the yaml module is unavailable";
%else
                rv = parse_yaml(str);
                break;
%endif
            }
            case "xml": {
%ifdef NoXml
                throw "XML-MODULE-MISSING", "Trying to parse an XML schema, but the xml module is unavailable";
%else
                rv = parse_xml(str);
                break;
%endif
            }
        }
        return rv;
    }

    #! tries to determine the Swagger schema source encoding automatically
    static string detectSourceEncoding(string str) {
        DataLineIterator it(str);
        while (it.next()) {
            string line = trim(it.getValue());
            if (line.size()) {
                if (line =~ /^<\?xml/) {
                    return "xml";
                } else if (line =~ /^([^{])+:/ || line =~ /^(---|%YAML)/) {
                    return "yaml";
                }
                return "json";
            }
        }
        return "json";
    }
}

#! This is the root document object for the API specification. It combines what previously was the Resource Listing and API Declaration (version 1.2 and earlier) together into one document.
public class SwaggerSchema inherits ObjectBase, AbstractRestSchemaValidator {
    public {
        #! <a href="https://swagger.io/">Swagger</a> Specification version being used.
        /**
            It can be used by the %Swagger UI and other clients to interpret the
            API listing. The value MUST be \c "2.0".
         */
        string swaggerSpec;

        #! Required. Provides metadata about the API. The metadata can be used by the clients if needed.
        InfoObject info;

        #! Required. The available paths and operations for the API.
        PathsObject paths;

        #! The host (name or IP) serving the API.
        /**
            This MUST be the host only and does not include the scheme nor sub-paths.
            It MAY include a port. If the \c host is not included, the host serving
            the documentation is to be used (including the port).
            The host does not support path templating.
         */
        *string host;

        #! The base path on which the API is served, which is relative to the @ref SwaggerSchema::host "host".
        /**
            If it is not included, the API is served directly under the \c host.
            The value MUST start with a leading slash (/).
            The \c basePath does not support path templating.
         */
        *string basePath;

        #! The transfer protocol of the API.
        /**
            Values MUST be from the list: \c "http", \c "https", \c "ws", \c "wss".
            If the schemes is not included, the default scheme to be used is
            the one used to access the %Swagger definition itself.
         */
        hash<string, bool> schemes;

        #! A set of MIME types (strings) the APIs can consume.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Key values MUST be Mime Types.
         */
        hash<string, bool> consumes;

        #! A set of MIME types (strings) the APIs can produce.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Key values MUST be Mime Types.
         */
        hash<string, bool> produces;

        #! An object to hold data types produced and consumed by operations.
        /**
            A hash of @ref SchemaObject objects. Keys are schema names.
         */
        hash<string, SchemaObject> definitions();

        #! Parameter definitions that can be used across operations. This property does not define global parameters for all operations.
        /**
            A hash of @ref AbstractParameterObject objects. Keys are parameter names.
         */
        hash<string, AbstractParameterObject> parameters();

        #! Response definitions that can be used across operations. This property does not define global responses for all operations.
        /**
            A hash of @ref ResponseObject objects. Keys are response names.
         */
        hash<string, ResponseObject> responses;

        #! Security scheme definitions that can be used across the specification.
        /**
            A hash of @ref SecuritySchemeObject objects. Keys are scheme names.
         */
        hash<string, SecuritySchemeObject> securityDefinitions;

        #! A declaration of which security schemes are applied for the API as a whole.
        /**
            The list of values describes alternative security schemes that can
            be used (that is, there is a logical OR between the security
            requirements). Individual operations can override this definition.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref SwaggerSchema::securityDefinitions "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
         */
        hash<string, softlist<string>> security;

        #! A list of @ref TagObject "tags" used by the specification with additional metadata.
        /**
            The order of the tags can be used to reflect on their order by the
            parsing tools. Not all tags that are used by the @ref OperationObject
            must be declared. The tags that are not declared may be organized
            randomly or based on the tools' logic. Each tag name in the list
            MUST be unique.

            Individual values in this list are of type @ref TagObject "TagObject".
         */
        list<TagObject> tags;

        #! Additional external documentation.
        *ExternalDocumentationObject externalDocs;

        #! SwaggerSchema options
        const SwaggerOptions = (
            "compact_serialization": True,
            "def_path": True,
            "try_import": True,
        );
    }

    private {
        #! if serialized data should be subject to compact serialization (default: @ref True "True")
        bool compact_serialization;

        #! the default path to use when retrieving external schema references
        *string def_path;

        #! a call reference or closure to be passed a string name for external schema references, must take a string argument (the resource name) and return a string (the resource data)
        *code try_import;

        #! the hash for the schema
        string hash_str;
    }

    private:internal {
        #! the raw parsed definitions; used for resolving out-of-order references
        *hash<auto> source_definition_hash;
    }

    #! Builds the schema representation from the deserialized schema hash describing the root document object
    /**
        @param oh deserialized hash from the source schema description describing the root document object
        @param opts options as per @ref SwaggerOptions as follows:
        - \c compact_serialization (default @ref True "True"): optimize the size of serialized data strings
        - \c def_path: the default path to use when retrieving external schema references
        - \c try_import: a call reference or closure to be passed a string name for external schema references, must take a string argument (the resource name) and return a string (the resource data)

        @throws SWAGGER-OPTION-ERROR unsuported options in constructor
        @throws INVALID-SWAGGER-VERSION invalid or missing Swagger schema version
        @throws INVALID-FIELD-FORMAT field has an invalid format
        @throws INVALID-FIELD-TYPE field has an invalid type
        @throws INVALID-FIELD-VALUE field has an invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws SECURITY-ERROR inconsistent security information in schema
     */
    public constructor(string schema_source, hash<auto> oh, *hash<auto> opts) : ObjectBase(oh) {
        hash_str = digest("sha256", schema_source).toHex();

        # process options
        compact_serialization = remove opts.compact_serialization ?? True;
        def_path = remove opts.def_path;
        try_import = remove opts.try_import;
        if (opts)
            throw "SWAGGER-OPTION-ERROR", sprintf("unknown options in SwaggerSchema constructor: %y; known options: %y", keys opts, keys SwaggerOptions);

        string objType = "Swagger";
        if (!oh.hasKey("swagger"))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: 'swagger' field is missing", objType);
        if (oh.swagger.typeCode() == NT_STRING)
            swaggerSpec = oh.swagger;
        else if (oh.swagger.typeCode() == NT_FLOAT || oh.swagger.typeCode() == NT_INT)
            swaggerSpec = sprintf("%.1f", oh.swagger);
        else
            throw "INVALID-FIELD-TYPE",
                sprintf("%s Object: 'swagger' field has invalid type %y (should be string or float)", objType, oh.swagger.type());
        if (swaggerSpec != "2.0")
            throw "INVALID-SWAGGER-VERSION", sprintf("invalid schema version %y; expecting \"2.0\"", swaggerSpec);

        {
            optional_field(objType, oh, "definitions", NT_HASH, \source_definition_hash);
            map processDefinition($1.key, $1.value), source_definition_hash.pairIterator();
            # all definitions must be resolved now; delete the intermediate definition hash
            delete source_definition_hash;

            hash<auto> obj;
            optional_field(objType, oh, "parameters", NT_HASH, \obj);
            foreach hash<auto> item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid parameter datatype: " + item.value.type();
                parameters{item.key} = AbstractParameterObject::newParameter(item.key, item.value, self);
            }

            delete obj;
            optional_field(objType, oh, "responses", NT_HASH, \obj);
            foreach hash<auto> item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid response datatype: " + item.value.type();
                responses{item.key} = ResponseObject::newResponse(item.key, item.value, self);
            }
        }

        {
            hash<auto> infoObj;
            required_field(objType, oh, "info", NT_HASH, \infoObj);
            info = new InfoObject(infoObj);
        }

        {
            hash<auto> pathsObj;
            required_field(objType, oh, "paths", NT_HASH, \pathsObj);
            paths = new PathsObject(pathsObj, self);
        }

        optional_field(objType, oh, "host", NT_STRING, \host);
        if (optional_field(objType, oh, "basePath", NT_STRING, \basePath)) {
            if (exists basePath && basePath[0] != "/")
                throw "INVALID-FIELD-FORMAT", "Swagger Object: basePath does not begin with a slash: " + basePath;
        }

        if (oh.schemes) {
            optional_field(objType, oh, "schemes", SwaggerListToStringSet, \schemes);
            # check for invalid schemes
            if ((hash h = (schemes - ValidSchemes)))
                throw "INVALID-FIELD-VALUE", sprintf("Swagger Object: invalid transfer protocol scheme%s: %y", h.size() == 1 ? "" : "s", keys h);
        }

        optional_field(objType, oh, "consumes", SwaggerListToStringSet, \consumes);

        optional_field(objType, oh, "produces", SwaggerListToStringSet, \produces);

        {
            hash<auto> obj;
            optional_field(objType, oh, "securityDefinitions", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid security definition datatype: " + item.value.type();
                securityDefinitions{item.key} = new SecuritySchemeObject(item.value);
            }
        }

        optional_field(objType, oh, "security", SwaggerListToHashOfStrings, \security);

        # verify security consistency
        if (security) {
            hash<auto> h = security - securityDefinitions.keys();
            if (h)
                throw "SECURITY-ERROR", sprintf("the following security schemes are not defined: %y", keys h);
        }

        {
            list<auto> lobj = ();
            optional_field(objType, oh, "tags", NT_LIST, \lobj);
            foreach auto val in (lobj) {
                if (val.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid tag datatype: " + val.type();
                tags += new TagObject(val);
            }
        }

        {
            *hash<auto> extDocsObj;
            if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
                externalDocs = new ExternalDocumentationObject(extDocsObj);
        }
    }

    #! resolves a reference to a schema object
    /** @throw INVALID-REFERENCE invalid reference
    */
    SchemaObject resolveSchemaObject(string name, string refstr, hash<auto> oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return SchemaObject::newSchemaObject(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/definitions\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y", name, refstr);
        string rstr = (refstr =~ x/^#\/definitions\/(.*)$/)[0];
        *SchemaObject ref = definitions{rstr};
        if (!ref) {
            if (*hash<auto> def = source_definition_hash{rstr}) {
                ref = processDefinition(rstr, def);
            } else {
                throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y", name, refstr);
            }
        }
        # get all non "x-" attributes
        *hash<auto> attr = map {$1.key: $1.value}, oh.pairIterator(), $1.key !~ /^x-/ && $1.key != "$ref";
        *hash<auto> xmlObj;
        # process additional attributes
        if (optional_field("Swagger", attr, "xml", NT_HASH, \xmlObj)) {
            attr -= "xml";
            ref = ref.copy();
            ref.xml = new XmlObject(xmlObj);
        }
        # additional subling elements are ignored...
        return ref;
    }

    #! resolves a reference to a parameter items schema object
    /** @throw INVALID-REFERENCE invalid reference
    */
    ParameterItemsSchemaObject resolveParameterItemsSchemaObject(string name, string refstr, hash<auto> oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ParameterItemsSchemaObject::newSchemaObject(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/definitions\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve parameter items SchemaObject %y reference %y", name, refstr);
        string rstr = (refstr =~ x/^#\/definitions\/(.*)$/)[0];
        *SchemaObject ref = definitions{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve parameter items SchemaObject %y reference %y", name, refstr);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a parameter
    /** @throw INVALID-REFERENCE invalid reference
    */
    AbstractParameterObject resolveParameter(string name, string refstr, hash<auto> oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return AbstractParameterObject::newParameter(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/parameters\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; expecting \"#/parameters/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/parameters\/(.*)$/)[0];
        *AbstractParameterObject ref = parameters{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; known parameter references: %y", name, refstr, keys parameters);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a response
    /** @throw INVALID-RESPONSE invalid response
    */
    ResponseObject resolveResponse(string name, string refstr, hash<auto> oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ResponseObject::newResponse(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/responses\//)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; expecting \"#/responses/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/responses\/(.*)$/)[0];
        *ResponseObject res = responses{rstr};
        if (!res)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; known response references: %y", name, refstr, keys responses);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-RESPONSE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return res;
    }

    #! returns a unique hash for the schema that can be used to compare schemas
    /** @return a unique hash for the schema that can be used to compare schemas

        @since Swagger 2.0
    */
    private string getHashImpl() {
        return hash_str;
    }

    #! returns the target URL for the schema
    /** @return the target URL for the schema

        @throws MISSING-TARGET-URL no target URL provided for the schema
    */
    private string getTargetUrlImpl() {
        return sprintf("%s://%s%s", schemes ? schemes.firstKey() : "http", host, basePath);
    }

    #! processes a client-side REST request and returns a hash that can be used to make the outgoing client-side HTTP request
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body data
        @param headers any headers to include in the request; note that the \c Content-Type header should not be sent here as it will be overridden when the message is serialized
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return a @ref RestSchemaValidator::RestRequestClientInfo "RestRequestClientInfo" hash with information about the request

        @throws SERIALIZATION-ERROR unsupported message body MIME type requested or missing serialization module
    */
    private hash<RestSchemaValidator::RestRequestClientInfo> processRequestImpl(string method, string path, auto body, *hash<auto> headers, *softlist<string> content_types) {
        return processRequestIntern(method, path, body, headers, content_types, compact_serialization);
    }

    #! processes and parses a client request and returns the deserialized message body (if any)
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param http_body the serialized message body
        @param headers a reference to the hash of HTTP headers received; any default header values to be assumed by the server for the request will be added here

        @return a @ref RestSchemaValidator::RestRequestServerInfo hash of request information

        @throw DESERIALIZATION-ERROR the path does not match the basePath, the request body could not be deserialized or the \c Content-Type is missing or it is invalid for the operation
    */
    private hash<RestSchemaValidator::RestRequestServerInfo> parseRequestImpl(string method, string path, *data http_body, reference<hash> headers) {
        auto body;
        # deserialize body according to Content-Type
        if (exists http_body) {
            if (!headers.hasKey("content-type"))
                throw "DESERIALIZATION-ERROR", "message includes body but is missing Content-Type header";
            if (headers."content-type" =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h = MultiPartFormDataMessage::parseMessage(headers."content-type", http_body.toString());
                body = map {$1.key: $1.value.body}, h.pairIterator();
            } else {
                *code ds = MimeDataTypes.(headers."content-type").deserialize;
                if (!ds) {
                    body = http_body;
                } else {
                    auto any_body = ds(http_body);
                    if (exists any_body)
                        body = any_body;
                }
            }
        }

        # path must be absolute for matching to work correctly
        if (path !~ /^\//)
            path = "/" + path;

        # remove basePath if present; note that "basePath" must always have a leading /
        fixPath(\path);

        hash<UriQueryInfo> h = parse_uri_query(path);
        method = method.lwr();
        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        op.parseRequest(pio, \h, \body, \headers);
        return <RestRequestServerInfo>{
            "path": h.method,
            "query": h.params,
            "body": body,
        };
    }

    #! processes a REST response with a serialized message body, validates any response data against schema definitions if possible
    /** @param method the HTTP method of the original request
        @param path the URI path of the original request (without query arguments)
        @param code the HTTP response code
        @param response_body the response body data (if any)
        @param headers HTTP headers to include in the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return an HttpResponseInfo hash for the response

        @throw ACCEPT-ERROR the response body could not be serialized because the client does not accept a supported type
        @throw SERIALIZATION-ERROR the response body could not be serialized due to an error

        @note <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>RFC 2616 section 14</a>: If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.  To ensure this happens, if
        an Accept error of this nature occurs in this call, an \c "ACCEPT-ERROR" must be thrown
    */
    private hash<HttpResponseInfo> processResponseImpl(string method, string path, int code, auto response_body, *hash<auto> headers, *softlist<string> content_types) {
        return processResponseIntern(method, path, code, response_body, headers, content_types, compact_serialization);
    }

    #! parses and validates the response from the server and returns a hash of the processed info
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the original request (without any query arguments)
        @param code the HTTP response code
        @param response_body the HTTP response body data (if any)
        @param hdr as hash of HTTP headers received

        @return a @ref RestSchemaValidator::RestResponseClientInfo hash describing the response

        @throw DESERIALIZATION-ERROR the response body could not be deserialized or had an invalid \c Content-Type
    */
    private hash<RestSchemaValidator::RestResponseClientInfo> parseResponseImpl(string method, string path, int code, *data response_body, hash<auto> hdr) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        hash<RestResponseClientInfo> rv((
            "code": code,
            "hdr": hdr,
        ));

        *string content = hdr."content-type" ?? hdr."Content-Type";

        # deserialize body according to Content-Type
        if (exists response_body && content) {
            if (content =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h = MultiPartFormDataMessage::parseMessage(hdr."content-type", response_body.toString());
                rv.body = map {$1.key: $1.value.body}, h.pairIterator();
                content = MimeTypeMultipartFormData;
            } else {
                *code ds = MimeDataTypes{content}.deserialize;
                # if the content-type is unknown, then assume it is a type that cannot be deserialized
                # the validity of the type is checked below in any case
                rv.body = ds ? ds(response_body) : response_body;
            }
        }

        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, \rv.body, \mime_types);

        if (content && !mime_types{content})
            throw "DESERIALIZATION-ERROR", sprintf("%s %s: content type %y is not accepted by this operation; "
                "accepted content types: %y", method.upr(), path, content, keys mime_types);

        return rv;
    }

    #! removes the base path from the beginning of the path, if present
    private fixPath(reference<string> path) {
        # ensure that path is absolute
        if (path !~ /^\//) {
            path = "/" + path;
        }
        # issue #4087: remove the base path if it matches the prefix of the path
        if (basePath.val()) {
            if (!path.comparePartial(basePath)) {
                splice path, 0, basePath.length();
            }
        }
    }

    #! returns a hash of URI paths as keys with values as lists of supported HTTP methods
    /** @return a hash of URI paths as keys with values as lists of supported HTTP methods
    */
    private hash<string, list<string>> getPathOperationHashImpl() {
        return paths.getPathOperationHash();
    }

    #! returns the base path prefix for all requests in this schema
    /** @return the base path prefix for all requests in this schema

        @note if none is set, then \c "/" is returned
    */
    private string getBasePathImpl() {
        return basePath ?? "/";
    }

    #! overrides the basePath value
    /** @param basePath the new base path value; use an empty string here to clear the basePath
    */
    private setBasePathImpl(string basePath) {
        # remove any trailing '/'s from path
        basePath =~ s/\/+$//;
        if (basePath.val()) {
            # ensure that basePath starts with a '/'
            if (basePath !~ /^\//) {
                basePath = "/" + basePath;
            }
            self.basePath = basePath;
        } else {
            remove basePath;
        }
    }

    #! returns example Qore code for the given request
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the request

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given request message
    */
    private hash<RestQoreExampleCodeInfo> getQoreExampleRequestImpl(string method, string path) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        return op.getQoreExampleRequest(method, path, pio, self);
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the request
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown

        @return a @ref RestSchemaValidator::RestExampleRequestInfo "RestExampleRequestInfo" hash of example message information for the given request
    */
    private hash<RestSchemaValidator::RestExampleRequestInfo> getExampleRequestImpl(string method, string path, *softlist<string> content_types) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        auto body;
        hash<RestExampleRequestInfo> rv = op.getExampleRequest(method, path, pio, self, \body);
        if (exists body) {
            # serialize example body
            hash<RestRequestClientInfo> req = processRequestIntern(method, path, body, rv.hdr, content_types, False);
            rv.hdr."Content-Type" = req.content;
            if (req.response_content) {
                rv.hdr.Accept = foldl $1 + "," + $2, req.response_content;
            }
            rv.body = req.body;
        }

        return rv;
    }

    #! returns example Qore code for the given response
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given response message
    */
    private hash<RestQoreExampleCodeInfo> getQoreExampleResponseImpl(string method, string path, int code) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        return op.getQoreExampleResponse(method, path, code);
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown

        @return a @ref RestSchemaValidator::RestExampleResponseInfo "RestExampleResponseInfo" hash giving example response message info
    */
    private hash<RestExampleResponseInfo> getExampleResponseImpl(string method, string path, int code, *softlist<string> content_types) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        auto body;
        hash<RestExampleResponseInfo> rv = op.getExampleResponse(method, path, code, \body);
        if (exists body) {
            # serialize example body
            hash<HttpResponseInfo> res = processResponseIntern(method, path, code, body, rv.hdr, content_types, False);
            rv += res.("code", "hdr", "body");
        }

        return rv;
    }

    #! retrieves external references
    /** @throw INVALID-REFERENCE invalid reference
    */
    private hash<auto> getExternalReference(string refstr) {
        (string ext_ref, *string int_ref) = (refstr =~ x/([^#]+)(?:#\/(.*))/);

        #! get file content
        string content;

        if (try_import)
            content = call_function(try_import, ext_ref);
        else {
            # do environment variable substitution
            map ext_ref = replace(ext_ref, "\$" + $1, ENV.$1), (ext_ref =~ x/\$(\w+)/g);
            # derive target file name if def_path is set and the reference is not an absolute path
            if (def_path && !absolute_path(ext_ref))
                ext_ref = def_path + DirSep + ext_ref;
            content = ReadOnlyFile::readTextFile(ext_ref);
        }

        hash<auto> h = SwaggerLoader::parseSchemaContent(ext_ref, content);
        if (int_ref) {
            if (!h.hasKey(int_ref))
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but internal reference %y is not available; known internal references: %y", refstr, ext_ref, content.size(), int_ref, keys h);
            if (h{int_ref}.typeCode() != NT_HASH)
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but internal reference %y is not a hash; got type %y instead", refstr, ext_ref, content.size(), int_ref, h{int_ref}.type());
            return h{int_ref};
        }
        return h;
    }

    #! returns a data provider object for this connection
    /** @param rest the \c RestClient object to make the connection

        @return a data provider object for this connection, if supported by any REST schema validator object
    */
    private AbstractDataProvider getDataProviderImpl(HTTPClient rest) {
        # to avoid circular dependencies, this object loads the SwaggerDataProvider and creates the data provider
        # object dynamically
        load_module("SwaggerDataProvider");
        return create_object("SwaggerDataProvider", self, rest);
    }

    #! processes a client-side REST request and returns a hash that can be used to make the outgoing client-side HTTP request
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body data
        @param headers any headers to include in the request; note that the \c Content-Type header should not be sent here as it will be overridden when the message is serialized
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml
        @param compact_serialization overrides the internal \c compact_serialization flag

        @return a @ref RestSchemaValidator::RestRequestClientInfo "RestRequestClientInfo" hash with information about the request

        @throws SERIALIZATION-ERROR unsupported path, message body MIME type requested, or missing serialization module
    */
    private:internal hash<RestSchemaValidator::RestRequestClientInfo> processRequestIntern(string method, string path, auto body, *hash<auto> headers, *softlist<string> content_types, bool compact_serialization) {
        # remove basePath if present
        fixPath(\path);

        hash<UriQueryInfo> h = parse_uri_query(path);

        # find path item object and operation
        method = method.lwr();
        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        # perform validation
        hash<string, bool> mime_types;
        op.validateRequest(True, pio, \h, \body, \headers, \mime_types);

        hash<RestRequestClientInfo> rv((
            "uri_path": h.method,
        ));

        if (op.produces) {
            rv.response_content = keys op.produces;
        }

        # add the basePath to the request
        if (exists basePath) {
            rv.uri_path = basePath + (h.method =~ /^\// ? "" : "/") + h.method;
        }

        # rebuild URI query after processing
        if (h.params) {
            string query_arg_separator = (path =~ x/([;&])/)[0] ?? ";";
            rv.uri_path = make_uri_query(cast<hash<UriQueryInfo>>(h), query_arg_separator);
        }

        if (!body)
            return rv;

        if (!exists content_types) {
            # if the request has already set \c Content-Type header, we assume
            # that the body is in the right format
            if (checkRequestContentTypeHeader(\rv, body, headers))
                return rv;

            # otherwise we continue with the default content types
            content_types = MimeContentTypes;
        }

        foreach string content in (content_types) {
            if (!mime_types{content})
                continue;
            if (content == MimeTypeMultipartFormData) {
                hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>((
                    "name": $1.key,
                    "filename": $1.key,
                    "hdr": ("Content-Type": MimeTypeText),
                    "body": $1.value,
                  ))}, body.pairIterator());

                hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                return rv += (
                    "body": mh.body,
                    "content": mh.hdr."Content-Type",
                );
            }
            if (MimeDataTypes{content}) {
                return rv += (
                    "body": compact_serialization ? MimeDataTypes{content}.serialize(body) : MimeDataTypes{content}.serialize_verbose(body),
                    "content": content,
                );
            }
        }

        # check if the \c Content-Type header is already set
        if (checkRequestContentTypeHeader(\rv, body, headers))
            return rv;

        if (content_types == MimeContentTypes)
            throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; available MIME type(s): %y; available serialization modules: %y", method.upr(), path, mime_types, SerializationModules);
        else
            throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; requested MIME type(s): %y; available MIME types: %y; available serialization modules: %y", method.upr(), path, content_types, mime_types, SerializationModules);
    }

    #! processes a REST response with a serialized message body, validates any response data against schema definitions if possible
    /** @param method the HTTP method of the original request
        @param path the URI path of the original request (without query arguments)
        @param code the HTTP response code
        @param response_body the response body data (if any)
        @param headers HTTP headers to include in the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml
        @param compact_serialization allows the \a compact_serialization property to be overridden

        @return an HttpResponseInfo hash for the response

        @throw ACCEPT-ERROR the response body could not be serialized because the client does not accept a supported type
        @throw SERIALIZATION-ERROR the response body could not be serialized due to an error

        @note <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>RFC 2616 section 14</a>: If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.  To ensure this happens, if
        an Accept error of this nature occurs in this call, an \c "ACCEPT-ERROR" must be thrown
    */
    private:internal hash<HttpResponseInfo> processResponseIntern(string method, string path, int code, auto response_body, *hash<auto> headers, *softlist<string> content_types, bool compact_serialization) {
        # find path item object and operation
        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        # perform validation
        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, \response_body, \mime_types);

        hash<HttpResponseInfo> rv((
            "code": code,
            "hdr": headers,
        ));

        if (exists response_body) {
            if (!exists content_types) {
                # no content types mean "accept: */*" header was sent with the request
                # so, if the response has already set \c Content-Type header, we assume
                # that the body is in the right format
                if (checkResponseContentTypeHeader(\rv, response_body, headers))
                    return rv;

                if (checkResponseTextPlain(\rv, response_body, mime_types, NOTHING))
                    return rv;

                # otherwise we continue with the default content types
                content_types = MimeContentTypes;
            }

            if (checkResponseTextPlain(\rv, response_body, mime_types, content_types))
                return rv;

            # there are content_types -> test them one by one
            list<string> mimeTypeKeys = keys mime_types;
            foreach string content in (content_types) {
                # test for the special asterisk case
                if (content == "*/*") {
                    if (checkResponseContentTypeHeader(\rv, response_body, headers))
                        return rv;
                }

                # test if the content type contains asterisk and generate regex for it
                bool asteriskCt = (content.find("*") != -1);
                *string ctRegex = replace(content, "*", ".*");

                # check that the content type is valid for the response
                if (asteriskCt) {
                    *list<auto> mt = map $1, mimeTypeKeys, $1.regex(ctRegex);
                    if (!mt)
                        continue;
                } else if (!mime_types{content})
                    continue;

                # check for multipart-form-data case
                if (content == MimeTypeMultipartFormData) {
                    if (response_body.typeCode() != NT_HASH)
                        throw "SERIALIZATION-ERROR", sprintf("response to %s %s: cannot serialize type %y to MIME type %y; expecing \"hash\"", method.upr(), path, response_body.type(), content);
                    hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>((
                        "name": $1.key,
                        "filename": $1.key,
                        "hdr": ("Content-Type": MimeTypeText),
                        "body": $1.value,
                    ))}, response_body.pairIterator());

                    hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                    return rv += (
                        "body": mh.body,
                        "hdr": rv.hdr + ("Content-Type": mh.hdr."Content-Type"),
                    );
                }

                # check the default set of mime types
                if (asteriskCt) {
                    *list mt = map $1, MimeContentTypes, $1.regex(ctRegex);
                    if (mt && mt.size()) {
                        string mimeType = mt[0];
                        return rv += (
                            "body": compact_serialization ? MimeDataTypes{mimeType}.serialize(response_body) : MimeDataTypes{mimeType}.serialize_verbose(response_body),
                            "hdr": rv.hdr + ("Content-Type": mimeType),
                        );
                    }
                } else if (MimeDataTypes{content}) {
                    return rv += (
                        "body": compact_serialization ? MimeDataTypes{content}.serialize(response_body) : MimeDataTypes{content}.serialize_verbose(response_body),
                        "hdr": rv.hdr + ("Content-Type": content),
                    );
                }

                # check if the \c Content-Type header is already set
                if (checkResponseContentTypeHeader(\rv, response_body, headers)) {
                    return rv;
                }
            }

            # none of the content types was ok
            if (content_types == MimeContentTypes)
                throw "ACCEPT-ERROR", sprintf("response to %s %s: message body cannot be serialized; available MIME type(s) for this call: %y; available serialization modules: %y", method.upr(), path, mime_types, SerializationModules), ("types": mime_types);
            else
                throw "ACCEPT-ERROR", sprintf("response to %s %s: message body cannot be serialized; requested MIME type(s): %y; available MIME types for this call: %y; available serialization modules: %y", method.upr(), path, content_types, mime_types, SerializationModules), ("types": mime_types);
        }

        return rv;
    }

    #! Check if the headers contain a content-type header and if so, modify the request hash
    /** @param resp request hash
        @param body request body data (if any)
        @param headers HTTP headers to include in the request

        @return whether the headers contained a \c Content-Type header and the rv was modified

        @note if there are more \c Content-Type headers, then @ref False is returned and request is not modified
    */
    private:internal bool checkRequestContentTypeHeader(reference<hash<RestRequestClientInfo>> req, auto body, *hash<auto> headers) {
        # quickly return if body is not in data format
        if (body.typeCode() != NT_BINARY && body.typeCode() != NT_STRING)
            return False;

        # try to find \c Content-Type header
        *list<string> ct = map $1, keys headers, $1 =~ /content-type/i;

        # if found and it's not one of the default ones, use it
        if (ct && ct.size() == 1 && !MimeDataTypes{headers{ct[0]}}) {
            req.body = body;
            req.content = headers{ct[0]};
            return True;
        }
        return False;
    }

    #! Check if the headers contain a content-type header and if so, modify the response hash
    /** @param resp response hash
        @param body response body data (if any)
        @param headers HTTP headers to include in the response

        @return whether the headers contained a \c Content-Type header and the rv was modified

        @note if there are more \c Content-Type headers, then @ref False is returned and response is not modified
    */
    private:internal bool checkResponseContentTypeHeader(reference<hash<HttpResponseInfo>> resp, auto body, *hash<auto> headers) {
        # quickly return if body is not in data format
        if (body.typeCode() != NT_BINARY && body.typeCode() != NT_STRING)
            return False;

        # try to find \c Content-Type header
        *list<string> ct = map $1, keys headers, $1 =~ /content-type/i;

        # if found, use it and don't serialize the body
        if (ct && ct.size() == 1) {
            resp.body = body;
            resp.hdr = resp.hdr + ("Content-Type": remove resp.hdr{ct[0]});
            return True;
        }
        return False;
    }

    #! Check if the response body can be sent as text/plain and if so, modify the response hash.
    /** @param resp response hash
        @param body response body data (if any)
        @param mime_types MIME types produced by the operation
        @param content_types content types accepted by the client

        @return whether the response body can be sent as text/plain and the \c resp was modified
    */
    private:internal bool checkResponseTextPlain(reference<hash<HttpResponseInfo>> resp, auto body, hash<string, bool> mime_types, *list<auto> content_types) {
        # quickly return if body is not string
        if (body.typeCode() != NT_STRING)
            return False;

        # return if text/plain is not allowed for this operation
        if (!mime_types."text/plain")
            return False;

        if (content_types) {
            # check that text/plain is accepted as a response
            *hash<string, bool> ctypesHash = map {$1 : True}, content_types;
            if (ctypesHash."text/plain" || ctypesHash."*/*" || ctypesHash."text/*") {
                resp.body = body;
                resp.hdr."Content-Type" = "text/plain";
                return True;
            }
            return False;
        }

        resp.body = body;
        resp.hdr."Content-Type" = "text/plain";
        return True;
    }

    #! Processes a schema definition
    private:internal SchemaObject processDefinition(string key, auto value) {
        if (value.typeCode() != NT_HASH)
            throw "INVALID-FIELD-TYPE", sprintf("Swagger Object: invalid definition datatype %y (val %y) for key %y",
                value.type(), value, key);
        return definitions{key} = SchemaObject::newSchemaObject(key, value, self);
    }
}

#! The object provides metadata about the API. The metadata can be used by the clients if needed, and can be presented in the %Swagger-UI for convenience.
public class InfoObject inherits ObjectBase {
    public {
        #! Required. The title of the application.
        string title;

        #! A short description of the application. GFM syntax can be used for rich text representation.
        *string desc;

        #! The Terms of Service for the API.
        *string termsOfService;

        #! Required. Provides the version of the application API (not to be confused with the specification version).
        string version;

        #! The contact information for the exposed API.
        *ContactObject contact;

        #! The license information for the exposed API.
        *LicenseObject license;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing metadata about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "Info";
        required_field(objType, oh, "title", NT_STRING, \title);
        required_field(objType, oh, "version", NT_STRING, \version);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(objType, oh, "termsOfService", NT_STRING, \termsOfService);

        *hash<auto> contactObj;
        if (optional_field(objType, oh, "contact", NT_HASH, \contactObj))
            contact = new ContactObject(contactObj);

        *hash<auto> licenseObj;
        if (optional_field(objType, oh, "license", NT_HASH, \licenseObj))
            license = new LicenseObject(licenseObj);
    }
}

#! Contact information for the exposed API.
public class ContactObject inherits ObjectBase {
    public {
        #! The identifying name of the contact person/organization.
        *string name;

        #! The URL pointing to the contact information. MUST be in the format of a URL.
        *string url;

        #! The email address of the contact person/organization. MUST be in the format of an email address.
        *string email;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing contact information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "Contact";
        optional_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "url", NT_STRING, \url);
        optional_field(objType, oh, "email", NT_STRING, \email);
    }
}

#! License information for the exposed API.
public class LicenseObject inherits ObjectBase {
    public {
        #! Required. The license name used for the API.
        string name;

        #! A URL to the license used for the API. MUST be in the format of a URL.
        *string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing license information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "License";
        required_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "url", NT_STRING, \url);
    }
}

#! Holds the relative paths to the individual endpoints.
/**
    The path is appended to the @ref SwaggerSchema::basePath "basePath" in order to construct the full URL.
    The Paths may be empty, due to ACL constraints.

    This class stores a tree or a component of a path for path matching, supports wildcard matching
 */
public class PathComponent {
    private {
        #! path prefix
        string pfx;

        #! current component name
        string name;

        #! if there is a wildcard to a PathComponent
        *PathComponent wildcard;

        #! the PathItemObject associated with this path (if any)
        *PathItemObject pio;

        #! hash of non-wildcard paths to the next level
        hash<string, PathComponent> paths;
    }

    #! creates the object
    constructor(hash<auto> oh, string pfx, SwaggerSchema swagger) {
        self.pfx = pfx;
        name = "/";
        foreach hash<auto> h in (oh.pairIterator()) {
            if (!pfx.val() && h.key !~ /^\//)
                throw "INVALID-FIELD-FORMAT", sprintf("Paths Object: root path %y does not begin with a slash", h.key);
            list<string> l = h.key.split("/");
            shift l;
            add(h.key, l, 0, h.value, swagger);
        }
    }

    #! private constructor
    private constructor(string full_path, list<auto> l, int offset, hash<auto> oh) {
        list<auto> l0 = l;
        splice l0, offset + 1;
        pfx = l0.join("/");
        name = l[offset - 1];
        #printf("pfx: %y name: %y\n", pfx, name);
    }

    #! adds a component or a Path Item Object to the tree
    private add(string full_path, list<auto> l, int offset, hash<auto> oh, SwaggerSchema swagger) {
        #printf("PathComponent::add(): pfx: %y name: %y: %y l: %y offset: %y\n", pfx, name, full_path, l, offset);
        if (offset == l.size()) {
            if (pio)
                throw "INVALID-PATH-COMPONENT", sprintf("cannot terminate path %y twice", full_path);
            pio = new PathItemObject(full_path, oh, swagger);
            return;
        }

        PathComponent next;
        string key = l[offset];
        if (key =~ /^{/)
            next = wildcard ?? (wildcard = new PathComponent(full_path, l, offset + 1, oh));
        else
            next = paths{key} ?? (paths{key} = new PathComponent(full_path, l, offset + 1, oh));

        next.add(full_path, l, offset + 1, oh, swagger);
    }

    #! returns either a PathItemObject for the path
    /** @throw SCHEMA-VALIDATION-ERROR the path could not be matched or has no API definition
    */
    PathItemObject match(list<auto> path) {
        *PathItemObject rv = tryMatch(path);
        if (!rv)
            throw "SCHEMA-VALIDATION-ERROR", sprintf("path %y is valid but has no API definition", path.join("/"));
        return rv;
    }

    #! returns either a PathItemObject for the path
    /** @throw SCHEMA-VALIDATION-ERROR the path could not be matched or has no API definition
    */
    *PathItemObject tryMatch(list<auto> path) {
        PathComponent w = self;
        for (int i = 1; i < path.size(); ++i) {
            *PathComponent next = w.paths{path[i]} ?? w.wildcard;
            if (!next) {
                if (w.paths) {
                    throw "SCHEMA-VALIDATION-ERROR", sprintf("path component %y cannot be matched in %y; expected "
                        "one of: %y", path[i], path.join("/"), keys w.paths);
                } else {
                    throw "SCHEMA-VALIDATION-ERROR", sprintf("path component %y cannot be matched in %y", path[i],
                        path.join("/"));
                }
            }
            w = next;
        }
        return w.pio;
    }

    #! returns a hash of URI paths as keys with values as lists of supported HTTP methods
    /** @return a hash of URI paths as keys with values as lists of supported HTTP methods
    */
    getPathOperationHash(reference<hash<string, list<string>>> h) {
        if (pio)
            h{pfx} = pio.getMethods();
        map $1.getPathOperationHash(\h), paths.iterator();
        if (wildcard)
            wildcard.getPathOperationHash(\h);
    }
}

#! This class stores the path tree for URI path matching
public class PathsObject inherits ObjectBase {
    private {
        #! the tree of path components for path matching with wildcards
        PathComponent paths;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing paths to schema endpoints
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
     */
    public constructor(hash<auto> oh, SwaggerSchema swagger) : ObjectBase(oh) {
        paths = new PathComponent(oh, "", swagger);
    }

    #! matches a URI path with a PathItemObject
    /** @throw INVALID-PATH the path could not be matched
    */
    PathItemObject match(string path) {
        if (!path.equalPartial("/")) {
            path = "/" + path;
        }
        return paths.match(path.split("/"));
    }

    #! matches a URI path with a PathItemObject
    /** @throw INVALID-PATH the path could not be matched
    */
    *PathItemObject tryMatch(string path) {
        if (!path.equalPartial("/")) {
            path = "/" + path;
        }
        return paths.tryMatch(path.split("/"));
    }

    #! returns a hash of URI paths as keys with values as lists of supported HTTP methods
    /** @return a hash of URI paths as keys with values as lists of supported HTTP methods
    */
    hash<string, list<string>> getPathOperationHash() {
        hash<string, list<string>> rv();
        paths.getPathOperationHash(\rv);
        return rv;
    }
}

#! Describes the operations available on a single path.
/**
    A Path Item may be empty, due to ACL constraints. The path itself is still
    exposed to the documentation viewer but they will not know which operations
    and parameters are available.
 */
public class PathItemObject inherits ObjectBase {
    public {
        #! Allows for an external definition of this path item.
        /**
            The referenced structure MUST be in the format of a @ref PathItemObject.
            If there are conflicts between the referenced definition and this
            PathItem's definition, the behavior is undefined.
         */
        *string ref;

        #! A hash of parameters that are applicable for all the operations described under this path.
        /**
            Hash values are @ref AbstractParameterObject "AbstractParameterObjects"

            These parameters can be overridden at the operation level, but cannot
            be removed there. The list MUST NOT include duplicated parameters.
            A unique parameter is defined by a combination of a
            @ref AbstractParameterObject::name "name" and @ref AbstractParameterObject::inLoc "location".
            There can be one \c body parameter at most.
         */
        hash<string, AbstractParameterObject> parameters();

        #! The body parameter, if defined for this path
        AbstractParameterObject body;
    }

    private {
        #! A hash of @ref OperationObject "OperationObjects" correspoding to different methods.
        /**
            Keys are lowercase method names, with possible values being:
            - \c "get"
            - \c "put"
            - \c "post"
            - \c "delete"
            - \c "options"
            - \c "head"
            - \c "patch"
         */
        hash<string, OperationObject> operations;
    }

    #! Constructor.
    /**
        @param path the URI path for the object
        @param oh deserialized hash from the source schema description describing the operations available on a single path
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, hash<auto> oh, SwaggerSchema swagger) : ObjectBase(oh) {
        string objType = "Path Item";
        optional_field(objType, oh, "$ref", NT_STRING, \ref);

        *hash opObj;
        if (optional_field(objType, oh, "get", NT_HASH, \opObj))
            operations.get = new OperationObject(path, "get", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "put", NT_HASH, \opObj))
            operations.put = new OperationObject(path, "put", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "post", NT_HASH, \opObj))
            operations.post = new OperationObject(path, "post", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "delete", NT_HASH, \opObj))
            operations."delete" = new OperationObject(path, "delete", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "options", NT_HASH, \opObj))
            operations.options = new OperationObject(path, "options", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "head", NT_HASH, \opObj))
            operations.head = new OperationObject(path, "head", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "patch", NT_HASH, \opObj))
            operations.patch = new OperationObject(path, "patch", opObj, swagger);

        *list params;
        if (optional_field(objType, oh, "parameters", NT_LIST, \params)) {
            foreach auto param in (params) {
                if (param.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Path Item Object: 'parameters' list value has invalid type %y",
                            param.type());
                AbstractParameterObject p = AbstractParameterObject::newParameter(sprintf("%d/%d", $# + 1, params.lsize()), param, swagger);
                if (p.inLoc == "body") {
                    if (body)
                        throw "INVALID-FIELD-VALUE", sprintf("path %y: more than one \"body\" parameter provided", path);
                    body = p;
                }
                else
                    parameters{p.name} = p;
            }
        }
    }

    #! returns the operation object for the given method
    /** @param path the path to be used in any error message
        @param method the HTTP method name

        @return the OperationObject corresponding to the arguments

        @throws INVALID-METHOD the given path does not have any operation defined for the given method
    */
    OperationObject getOperation(string method, string path) {
        *OperationObject op = operations{method};
        if (!op)
            throw "INVALID-METHOD", sprintf("%s %s: no operation defined for this path; known methods: %y",
                method.upr(), path, keys operations), keys operations;
        return op;
    }

    #! returns a list of HTTP methods supported by this object
    /** @return a list of HTTP methods supported by this object
    */
    softlist getMethods() {
        return keys operations;
    }
}

#! Describes a single API operation on a path.
public class OperationObject inherits ObjectBase {
    public {
        #! the URI path for the operation
        string path;

        #! the HTTP method for the operation
        string method;

        #! A list of tags (strings or @ref TagObject "TagObjects") for API documentation control.
        /**
            Tags can be used for logical grouping of operations by resources or any other qualifier.
         */
        list tags;

        #! A short summary of what the operation does.
        *string summary;

        #! A verbose explanation of the operation behavior. GFM syntax can be used for rich text representation.
        *string desc;

        #! Declares this operation to be deprecated.
        /**
            Usage of the declared operation should be refrained.
            Default value is \c false.
         */
        bool deprec = False;

        #! Additional external documentation for this operation.
        *ExternalDocumentationObject externalDocs;

        #! Unique string used to identify the operation.
        /**
            The id MUST be unique among all operations described in the API.
            Tools and libraries MAY use the operationId to uniquely identify
            an operation, therefore, it is recommended to follow common
            programming naming conventions.
         */
        *string operationId;

        #! A list of MIME types (strings) the operation can consume.
        /**
            This overrides the @ref SwaggerSchema::consumes "consumes" definition
            at the %Swagger Object. An empty value MAY be used to clear the global definition.
            Key values MUST be Mime Types.
         */
        hash<string, bool> consumes;

        #! A hash of MIME types (strings) the operation can produce.
        /**
            This overrides the @ref SwaggerSchema::produces "produces" definition
            at the %Swagger Object. An empty value MAY be used to clear the global definition.
            Key values MUST be Mime Types.
         */
        hash<string, bool> produces;

        #! A hash of parameters that are applicable for this operation.
        /**
            If a parameter is already defined at the @ref PathItemObject "Path Item",
            the new definition will override it, but can never remove it.
            The hash MUST NOT include duplicated parameters.
            A unique parameter is defined by a combination of a @ref AbstractParameterObject::name "name"
            and @ref AbstractParameterObject::inLoc "location".
            There can be one "body" parameter at most.
         */
        hash<string, AbstractParameterObject> parameters();

        #! body parameter; if defined for this operation, formData parameter will be excluded
        AbstractParameterObject body;

        #! formData parameter; if defined for this operation, body parameter will be excluded
        hash<string, AbstractParameterObject> formData;

        #! Required. The list of possible responses as they are returned from executing this operation.
        ResponsesObject responses;

        #! The transfer protocol for the operation.
        /**
            Values MUST be from the list: \c "http", \c "https", \c "ws", \c "wss".
            The value overrides the SwaggerSchema @ref SwaggerSchema::schemes "schemes" definition.
         */
        list<string> schemes;

        #! A declaration of which security schemes are applied for this operation.
        /**
            The list of values describes alternative security schemes that can be
            used (that is, there is a logical OR between the security requirements).
            This definition overrides any declared top-level @ref SwaggerSchema::security "security".
            To remove a top-level security declaration, an empty array can be used.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref SwaggerSchema::securityDefinitions "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
         */
        list<hash<string, list<string>>> security;
    }

    #! Constructor.
    /** @param path the path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, string method, hash<auto> oh, SwaggerSchema swagger) : ObjectBase(oh) {
        self.path = path;
        self.method = method.upr();
        string objType = "Operation";
        *list tagsObj;
        if (optional_field(objType, oh, "tags", NT_LIST, \tagsObj)) {
            foreach auto tag in (tagsObj) {
                if (tag.typeCode() == NT_STRING)
                    tags += tag;
                else if (tag.typeCode() == NT_HASH)
                    tags += new TagObject(tag);
                else
                    error("INVALID-FIELD-TYPE", "'tags' list value has invalid type %y; expecting \"hash\" or \"string\"", tag.type());
            }
        }

        optional_field(objType, oh, "summary", NT_STRING, \summary);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(objType, oh, "deprecated", NT_BOOLEAN, \deprec);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);

        optional_field(objType, oh, "operationId", NT_STRING, \operationId);
        # TODO check operationId uniqueness as per docs

        # use the global "consumes" definition if none is defined on the operation
        if (!optional_field(objType, oh, "consumes", SwaggerListToStringSet, \consumes) && swagger.consumes)
            consumes = swagger.consumes;

        # use the global "produces" definition if none is defined on the operation
        if (!optional_field(objType, oh, "produces", SwaggerListToStringSet, \produces) && swagger.produces)
            produces = swagger.produces;

        {
            list listObj;
            optional_field(objType, oh, "parameters", NT_LIST, \listObj);
            foreach auto p in (listObj) {
                if (p.typeCode() != NT_HASH)
                    error("INVALID-FIELD-TYPE", "invalid 'parameters' list value datatype %y; expecing \"hash\"", p.type());
                AbstractParameterObject param = AbstractParameterObject::newParameter(sprintf("%d/%d", $# + 1, listObj.lsize()), p, swagger);
                if (param.inLoc == "body")
                    body = param;
                else if (param.inLoc == "formData")
                    formData{param.name} = param;
                else
                    parameters{param.name} = param;
            }
        }

        {
            hash responsesObj;
            required_field(objType, oh, "responses", NT_HASH, \responsesObj);
            responses = new ResponsesObject(path, self.method, responsesObj, swagger);
        }

        # process schemes
        {
            list schemesList;
            optional_field(objType, oh, "schemes", NT_LIST, \schemesList);
            foreach auto val in (schemesList) {
                if (val.typeCode() != NT_STRING)
                    error("INVALID-FIELD-TYPE", "invalid 'schemes' list value datatype %y; expecting \"string\"", val.type());
                if (!ValidSchemesHash{val})
                    error("INVALID-FIELD-VALUE", "invalid operation transfer protocol scheme value %y; expecting one of: %y", val, keys ValidSchemesHash);
            }
            if (schemesList) {
                schemes = cast<list<string>>(schemesList);
            }
        }

        {
            list securityList;
            optional_field(objType, oh, "security", NT_LIST, \securityList);
            foreach auto val in (securityList) {
                if (val.typeCode() != NT_HASH)
                    error("INVALID-FIELD-TYPE", "invalid 'security' list value datatype %y; expecting \"hash\"", val.type());
                hash h = val;
                foreach hash it in (h.pairIterator()) {
                    if (it.value.typeCode() != NT_LIST)
                        error("INVALID-FIELD-TYPE",
                                "invalid Security Requirement Object value type %y (should be a list of hashes)",
                                val.type());
                    if ((map True, it.value, $1.typeCode() != NT_STRING).size())
                        error("INVALID-FIELD-TYPE",
                                "invalid Security Requirement Object value type %y (should be a list of hashes with list values)",
                                val.type());
                }
            }
            if (securityList) {
                security = cast<list<hash<string, list<string>>>>(securityList);
            }
        }
    }

    #! Processes a generated request
    *data getRequestBody(PathItemObject pio, auto body, reference<hash<auto>> headers) {
        *AbstractParameterObject body_po = self.body ?? pio.body;
        if (body_po) {
            body_po.check(True, True, path, method, "body", \body);
        } else if (formData) {
            map $1.value.check(True, True, path, method, "formData." + $1.key, \body{$1.key}),
                formData.pairIterator();
        } else if (body) {
            error("SCHEMA-VALIDATION-ERROR", "No message body is accepted; body keys passed: %y", keys body);
        }

        if (!exists body) {
            return;
        }

        # get content type
        string ct = consumes.firstKey();

        if (ct == MimeTypeMultipartFormData) {
            hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>((
                "name": $1.key,
                "filename": $1.key,
                "hdr": ("Content-Type": MimeTypeText),
                "body": $1.value,
                ))}, body.pairIterator());

            hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
            headers."Content-Type" = mh.hdr."Content-Type";
            return mh.body;
        }

        if (MimeDataTypes{ct}) {
            headers."Content-Type" = ct;
            return MimeDataTypes{ct}.serialize(body);
        }

        throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; available MIME type(s): %y; "
            "available serialization modules: %y", method.upr(), path, keys consumes, SerializationModules);
    }

    #! processes a REST API client-side request to the operation
    /** @param serialize if request arguments should be processed for serialization (client-side) or not (server-side)
        @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the deserialized HTTP message body data
        @param headers a reference to a hash of HTTP headers
        @param mime_types a reference to a hash of valid mime types for the operation

        @throws SCHEMA-VALIDATION-ERROR invalid parameter name or location, missing parameter and parameter has no default value
    */
    validateRequest(bool serialize, PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<auto> body, reference<hash> headers, *reference<hash<string, bool>> mime_types) {
        # check query parameters
        foreach string key in (keys h.params) {
            # find URI parameter object
            *AbstractParameterObject po = parameters{key} ?? pio.parameters{key};
            if (!po)
                error("SCHEMA-VALIDATION-ERROR", "No parameter named %y defined for this path and method", key);
            if (po.inLoc != "query")
                error("SCHEMA-VALIDATION-ERROR", "invalid parameter %y given in the URI query; expected location %y", key, po.inLoc);

            po.check(serialize, True, path, method, key, \h.params{key});
        }

        # check header parameters
        foreach string key in (keys headers) {
            # find URI parameter object
            *AbstractParameterObject po = parameters{key} ?? pio.parameters{key};
            # extra headers are OK
            if (!po || po.inLoc != "header")
                continue;

            po.check(serialize, True, path, method, key, \headers{key});
        }

        # check body parameters
        {
            *AbstractParameterObject body_po = self.body ?? pio.body;
            if (body_po)
                body_po.check(serialize, True, path, method, "body", \body);
            else if (formData) {
                foreach hash<auto> i in (formData.pairIterator()) {
                    i.value.check(serialize, True, path, method, "formData." + i.key, \body{i.key});
                }
            } else if (body)
                error("SCHEMA-VALIDATION-ERROR", "No message body is accepted; body keys passed: %y", keys body);
        }

        # check for missing required parameters
        checkMissingParams(h, headers, body, parameters);
        checkMissingParams(h, headers, body, pio.parameters, parameters);

        if (consumes)
            mime_types = consumes;
    }

    #! parses and processes a REST request on the server side
    /** @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the deserialized HTTP message body data
        @param headers a reference to a hash of HTTP headers

        @throw DESERIALIZATION-ERROR invalid content-type
        @throws INVALID-PARAMETER-NAME invalid parameter name
        @throws INVALID-PARAMETER-LOCATION invalid parameter location
        @throws MISSING-PARAMETER missing parameter and parameter has no default value
    */
    parseRequest(PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<auto> body, reference<hash> headers) {
        # validate message
        hash<string, bool> mime_types();
        validateRequest(False, pio, \h, \body, \headers, \mime_types);

        # check content-type
        if (exists body && mime_types) {
            string content = headers."content-type" ?? headers."Content-Type";
            int pos = content.find(";");
            if (pos != -1)
                content = content.substr(0, pos);
            if (!mime_types{content})
                throw "DESERIALIZATION-ERROR", sprintf("%s: invalid Content-Type: %y; valid MIME types: %y", h.method, content, mime_types);
        }

        # set default parameter values
        doDefaultParams(\h, \headers, \body, parameters);
        doDefaultParams(\h, \headers, \body, pio.parameters, parameters);
    }

    #! validates a response against the response definition, if any
    validateResponse(string method, string path, PathItemObject pio, int code, reference<auto> response_body, reference<hash<string, bool>> mime_types) {
        *ResponseObject res = getResponse(code);
        if (res.schema) {
            res.schema.check(True, False, path, method, "response body", \response_body);
        } else if (response_body != NOTHING)
            error("SCHEMA-VALIDATION-ERROR", "Response to this path and method should not have any body");

        if (produces)
            mime_types = produces;
    }

    #! returns example Qore code for the given request
    /** @param method the HTTP method (in lower case)
        @param path the URI path of the request
        @param pio the PathItemObject corresponding to the URI path
        @param swagger the schema object itself

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given request message
    */
    hash<RestQoreExampleCodeInfo> getQoreExampleRequest(string method, string path, PathItemObject pio, SwaggerSchema swagger) {
        hash<RestQoreExampleCodeInfo> rv();

        #! URI query arguments
        hash<auto> query;
        #! headers
        hash<auto> headers;

        getQoreExampleParams(\query, \headers, parameters);
        getQoreExampleParams(\query, \headers, pio.parameters, parameters);

        if (query)
            path = make_uri_query(cast<hash<UriQueryInfo>>({"method": path, "params": query}));

        rv.example = sprintf("RestClient client((\"url\": %y));\n", swagger.getTargetUrl());

        #! get example message body
        *BodyParameter body_po = body ?? pio.body;
        if (body_po)
            rv.example += body_po.getQoreExample(\rv);

        rv.example += "hash<auto> info;\n";
        if (headers) {
            rv.example += "hash<auto> hdr = (\n";
            rv.example += foldl $1 + "\n" + $2, (map sprintf("    %y: %y,", $1.key, $1.value), headers.pairIterator());
            rv.example += "\n);\n";
        }

        rv.example += sprintf("hash<auto> res = rest.%s", method.lwr());
        rv.example += sprintf("(%y, ", path);
        # body
        rv.example += body_po ? "rest_body, " : "NOTHING, ";
        # info reference
        rv.example += "\\info";
        # headers
        if (headers)
            rv.example += ", hdr";
        rv.example += ");\n";

        return rv;
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method (in lower case)
        @param path the URI path of the request
        @param pio the PathItemObject corresponding to the URI path
        @param swagger the schema object itself
        @param rbody the output example body value, if any

        @return a @ref RestSchemaValidator::RestExampleRequestInfo "RestExampleRequestInfo" hash of example message information for the given request
    */
    hash<RestSchemaValidator::RestExampleRequestInfo> getExampleRequest(string method, string path, PathItemObject pio, SwaggerSchema swagger, reference rbody) {
        hash<RestExampleRequestInfo> rv();

        #! URI query arguments
        hash<auto> query;

        getQoreExampleParams(\query, \rv.hdr, parameters);
        getQoreExampleParams(\query, \rv.hdr, pio.parameters, parameters);

        rv.request_uri = sprintf("%s %s HTTP/1.1", method.upr(), make_uri_query(cast<hash<UriQueryInfo>>(("method": path, "params": query))));

        #! get example message body
        *BodyParameter body_po = body ?? pio.body;
        if (body_po)
            rbody = body_po.getExampleValue();

        return rv;
    }

    #! returns example Qore code for the given response
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given response message
    */
    hash<RestQoreExampleCodeInfo> getQoreExampleResponse(string method, string path, int code) {
        hash<RestQoreExampleCodeInfo> rv();

        *ResponseObject res = getResponse(code);
        if (res.schema)
            rv.example = res.schema.getQoreExample(\rv, "body", True);

        rv.example += sprintf("return RestHandler::makeResponse(%d%s);\n", code, rv.example ? ", body" : "");

        return rv;
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response
        @param body the output example body value, if any

        @return a @ref RestSchemaValidator::RestExampleResponseInfo "RestExampleResponseInfo" hash giving example response message info
    */
    hash<RestExampleResponseInfo> getExampleResponse(string method, string path, int code, reference<auto> body) {
        hash<RestExampleResponseInfo> rv();

        *ResponseObject res = getResponse(code);
        if (res.schema)
            body = res.schema.getExampleValue();

        return rv;
    }

    private getQoreExampleParams(reference<hash<auto>> query, reference<hash<auto>> headers, hash<string, AbstractParameterObject> parameters, *hash<string, AbstractParameterObject> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked or if it's the single message body param
            if (child_params{ph.key} || ph.value.inLoc == "body" || ph.value.inLoc == "formData")
                continue;
            switch (ph.value.inLoc) {
                case "query":
                    query{ph.key} = ph.value.getExampleValue();
                    break;
                case "header":
                    headers{ph.key} = ph.value.getExampleValue();
                    break;
            }
        }
    }

    #! add default parameters
    private doDefaultParams(reference<hash<UriQueryInfo>> h, reference<hash> headers, reference<auto> body, hash<string, AbstractParameterObject> parameters, *hash<string, AbstractParameterObject> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked or if it's the single message body param
            if (child_params{ph.key} || ph.value.inLoc == "body")
                continue;
            if (exists (auto val = ph.value.getDefaultValue())) {
                switch (ph.value.inLoc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            h.params{ph.key} = val;
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            headers{ph.key} = val;
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            body{ph.key} = val;
                        break;
                    # NOTE: default "path" values are not possible, "body" is handled specially
                }
            }
        }
    }

    #! checks for missing params
    private checkMissingParams(hash<UriQueryInfo> h, *hash<auto> headers, auto body, hash<string, AbstractParameterObject> parameters, *hash<string, AbstractParameterObject> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked
            if (child_params{ph.key} || ph.value.inLoc == "body")
                continue;
            if (ph.value.required) {
                switch (ph.value.inLoc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            error("SCHEMA-VALIDATION-ERROR", "request is missing required query parameter %y", ph.key);
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            error("SCHEMA-VALIDATION-ERROR", "request is missing required header parameter %y", ph.key);
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            error("SCHEMA-VALIDATION-ERROR", "request is missing required formData parameter %y", ph.key);
                        break;
                    # NOTE: missing path parameters are not possible (path would not be matched in the first place)
                    #       "body" is handled specially
                }
            }
        }
    }

    #! returns the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    /** @return the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    */
    private *ResponseObject getResponse(int code) {
        return responses.responses{code} ?? responses.defaultResp;
    }

    #! raises an exception with context information
    private error(string err, string fmt) {
        throw err, sprintf("%s %s Operation Object: %s", method.upr(), path, vsprintf(fmt, argv));
    }
}

#! Allows referencing an external resource for extended documentation.
public class ExternalDocumentationObject inherits ObjectBase {
    public {
        #! A short description of the target documentation. GFM syntax can be used for rich text representation.
        *string desc;

        #! Required. The URL for the target documentation. Value MUST be in the format of a URL.
        string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing a reference to external documentation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "External Documentation";
        required_field(objType, oh, "url", NT_STRING, \url);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Describes a single operation parameter.
/**
    A unique parameter is defined by a combination of a @ref AbstractParameterObject::name "name"
    and @ref AbstractParameterObject::inLoc "location".

    There are five possible parameter types:
    - Path: Used together with Path Templating, where the parameter value is
        actually part of the operation's URL. This does not include the host or
        base path of the API. For example, in <tt>/items/{itemId}</tt>, the path
        parameter is \c itemId.
    - Query: Parameters that are appended to the URL. For example, in <tt>/items?id=###</tt>,
        the query parameter is \c id.
    - Header: Custom headers that are expected as part of the request.
    - Body: The payload that's appended to the HTTP request. Since there can only
        be one payload, there can only be one body parameter. The name of the
        body parameter has no effect on the parameter itself and is used for
        documentation purposes only. Since Form parameters are also in the payload,
        body and form parameters cannot exist together for the same operation.
    - Form: Used to describe the payload of an HTTP request when either
        <tt>application/x-www-form-urlencoded</tt>, <tt>multipart/form-data</tt>
        or both are used as the content type of the request (in %Swagger's definition,
        the \c consumes property of an operation). This is the only parameter
        type that can be used to send files, thus supporting the file type.
        Since form parameters are sent in the payload, they cannot be declared
        together with a body parameter for the same operation. Form parameters
        have a different format based on the content-type used (for further details,
        consult http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4):
            - <tt>application/x-www-form-urlencoded</tt> - Similar to the format
                of Query parameters but as a payload. For example,
                <tt>foo=1&bar=swagger</tt> - both foo and bar are form parameters.
                This is normally used for simple parameters that are being transferred.
            - <tt>multipart/form-data</tt> - each parameter takes a section in
                the payload with an internal header. For example, for the header
                <tt>Content-Disposition: form-data; name="submit-name"</tt> the name
                of the parameter is \c submit-name. This type of form parameters
                is more commonly used for file transfers.
 */
public class AbstractParameterObject inherits ObjectBase {
    public {
        #! Required. The name of the parameter. Parameter names are case sensitive.
        /**
            - If @ref AbstractParameterObject::inLoc "inLoc" is \c "path", the \c name
                field MUST correspond to the associated path segment from the
                \c "path" field in the @ref Swagger::PathsObject.
            - For all other cases, the name corresponds to the parameter name
                used based on the @ref AbstractParameterObject::inLoc "inLoc" property.
         */
        string name;

        #! Required. The location of the parameter.
        /**
            Possible values are \c "query", \c "header", \c "path",
            \c "formData" or \c "body".
         */
        string inLoc;

        #! A brief description of the parameter. This could contain examples of use. GFM syntax can be used for rich text representation.
        *string desc;

        #! Determines whether this parameter is mandatory.
        /**
            If the parameter is @ref AbstractParameterObject::inLoc "in" "path",
            this property is \b required and its value MUST be \c true.
            Otherwise, the property MAY be included and its default value is \c false.
         */
        bool required = False;
    }

    private {
        const OtherParameterMap = (
            "query": True,
            "header": True,
            "path": True,
            "formData": True,
        );
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description decscribing a single parameter

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "Parameter";
        required_field(objType, oh, "name", NT_STRING, \name);
        required_field(objType, oh, "in", NT_STRING, \inLoc);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        if (inLoc == "path")
            required_field(objType, oh, "required", NT_BOOLEAN, \required);
        else
            optional_field(objType, oh, "required", NT_BOOLEAN, \required);
    }

    #! verifies the parameter in an actual REST API call
    abstract check(bool serialize, bool request, string path, string method, string name, reference value);

    #! returns the default value of the parameter (default: @ref nothing)
    auto getDefaultValue() {
    }

    #! gets a concrete instance of an AbstractParameterObject
    static AbstractParameterObject newParameter(string name, hash<auto> oh, SwaggerSchema swagger) {
        if (oh.hasKey("$ref"))
            return swagger.resolveParameter(name, oh."$ref", oh);

        if (!oh.hasKey("in"))
            throw "REQUIRED-FIELD-MISSING", sprintf("Parameter Object %y: missing location parameter \"in\"", name);
        if (oh."in" == "body")
            return new BodyParameter(oh, swagger);
        else if (OtherParameterMap{oh."in"})
            return new OtherParameter(name, oh, swagger);
        throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid location (\"in\") parameter value: %y", name, oh."in");
    }
}

#! @ref AbstractParameterObject specialization for \c "body" parameters.
public class BodyParameter inherits AbstractParameterObject {
    public {
        #! Required. The schema defining the type used for the body parameter.
        SchemaObject schema;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a body parameter
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh, SwaggerSchema swagger) : AbstractParameterObject(oh) {
        hash schemaObj;
        required_field("Body Parameter", oh, "schema", NT_HASH, \schemaObj);
        schema = SchemaObject::newSchemaObject("body", schemaObj, swagger);
    }

    #! verifies the parameter in an actual REST API call
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        # issue #2369 ignore the parameter if it's not required
        if (!exists value && !required)
            return;

        return schema.check(serialize, request, path, method, name, \value);
    }

    #! generates Qore example code for a REST API call
    string getQoreExample(reference<hash<RestQoreExampleCodeInfo>> rv) {
        return schema.getQoreExample(\rv, "rest_body", True);
    }

    # returns an example value for a REST API call
    auto getExampleValue() {
        return schema.getExampleValue();
    }
}

#! @ref AbstractParameterObject specialization for parameters other than \c "body".
public class OtherParameter inherits AbstractParameterObject, SchemaBase {
    public {
        #! Required. The type of the parameter.
        /**
            Since the parameter is not located at the request body, it is
            limited to simple types (that is, not an object).
            The value MUST be one of \c "string", \c "number", \c "integer",
            \c "boolean", \c "array" or \c "file". If \c type is \c "file",
            the @ref OperationObject::consumes "consumes" MUST be either
            \c "multipart/form-data", \c " application/x-www-form-urlencoded" or
            both and the parameter MUST be @ref AbstractParameterObject::inLoc "in" \c "formData".
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! Sets the ability to pass empty-valued parameters.
        /**
            This is valid only for either \c query or \c formData parameters and
            allows you to send a parameter with a name only or an empty value.
            Default value is \c false.
         */
        bool allowEmptyValue = False;

        #! Required if @ref OtherParameter::type "type" is \c "array". Describes the type of items in the array.
        *ParameterItemsSchemaObject items;

        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\\tbar
            - \c "pipes": pipe separated values; ex: foo|bar
            - \c "multi": corresponds to multiple parameter instances instead of
                multiple values for a single instance <tt>foo=bar&foo=baz</tt>.
                This is valid only for parameters @ref AbstractParameterObject::inLoc "in"
                \c "query" or \c "formData".

            Default value is \c "csv".
         */
        *string collectionFormat;

        #! Declares the value of the parameter that the server will use if none is provided.
        /**
            For example a "count" to control the number of results per page
            might default to 100 if not supplied by the client in the request.
            (Note: "default" has no meaning for required parameters.)
            See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
            Unlike JSON Schema this value MUST conform to the defined type for this parameter.
         */
        auto defaultVal;

        #! valid parameter types
        const ParameterTypes = SchemaObject::ScalarTypes + (
            "file": True,
            "object": True,
        );
    }

    #! Constructor.
    /**
        @param name the parameter name
        @param oh deserialized hash from the source schema description describing general parameters (other than \c "body" parameters)
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string name, hash<auto> oh, SwaggerSchema swagger) : AbstractParameterObject(oh), SchemaBase("Parameter", oh) {
        string objType = "Parameter";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (!ParameterTypes{type})
            throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid parameter type value passed: %y, expecting one of: %y", name, type, keys ParameterTypes);
        if (type == "array") {
            items = ParameterItemsSchemaObject::newSchemaObject("items", oh.items, swagger);
            if (optional_field(objType, oh, "collectionFormat", NT_STRING, \collectionFormat)) {
                if (!ParameterCollectionFormats{collectionFormat})
                    throw "INVALID-FIELD-VALUE",
                        sprintf("Parameter Object %y: invalid collectionFormat value %y; expected one of: %y", name, collectionFormat, keys ParameterCollectionFormats);

                if (collectionFormat == "multi" && inLoc != "query" && inLoc != "formData")
                    throw "INVALID-FIELD-VALUE",
                        sprintf("Parameter Object %y: invalid collectionFormat value 'multi' - is only valid when 'in' (location) is either 'query' or 'formData'", name);
            }
        }
        else if (oh.collectionFormat)
            throw "INVALID-FIELD-TYPE", sprintf("Parameter Object %y: type %y (non-array) cannot have a \"collectionFormat\" property (%y)", name, type, oh.collectionFormat);

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid integer type format value passed: %y", name, format);
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid number type format value passed: %y", name, format);
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid string type format value passed: %y", name, format);
        }

        optional_field(objType, oh, "allowEmptyValue", NT_BOOLEAN, \allowEmptyValue);

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            OtherParameter::checkValueType(\defaultVal, type, items);
        }
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference<auto> value) {
        # issue #2388 ensure that query parameters are converted to their target type first
        if (inLoc == "query") {
            switch (type) {
                case "integer":
                    if (value !~ /^([+-])?[0-9]+$/)
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type \"integer\" is invalid; value provided: %y", name, path, method, value);
                    value = value.toInt();
                    break;
                case "number":
                    value = value.toNumber();
                    break;
                case "string":
                    switch (format) {
                        case "date":
                        case "date-time":
                            try {
                                value = date(value);
                            }
                            catch (hash<ExceptionInfo> ex) {
                                throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type \"date\" is invalid; value provided: %y (%s)", name, path, method, value, ex.desc);
                            }
                            break;
                        case "binary":
                            try {
                                value = binary(value);
                            }
                            catch (hash<ExceptionInfo> ex) {
                                throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type \"binary\" is invalid; value provided: %y (%s)", name, path, method, value, ex.desc);
                            }
                            break;
                        case "byte":
                            try {
                                value = parse_base64_string(value);
                            }
                            catch (hash<ExceptionInfo> ex) {
                                throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type \"binary\" is invalid; value provided: %y (%s)", name, path, method, value, ex.desc);
                            }
                            break;
                    }
                    break;
                case "boolean":
                   value = parse_boolean(value);
                   break;
            }
        }
        SchemaBase::check(serialize, request, type, format, items, path, method, name, \value);
        switch (value.typeCode()) {
            case NT_NOTHING:
                if (!allowEmptyValue)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y has empty value (allowEmptyValue=false)",
                            name, path, method);
        }
    }

    #! returns the default value of the parameter (default: @ref nothing)
    auto getDefaultValue() {
        return defaultVal;
    }

    #! returns an example value of the parameter (default: @ref nothing)
    auto getExampleValue() {
        if (exists defaultVal)
            return defaultVal;
        return getExampleValue(type, format);
    }

    #! validates default values
    private static checkValueType(reference<auto> value, string type, *SchemaObject items, *string loc) {
        int vt = value.typeCode();
        if (type == "array") {
            if (vt != NT_LIST)
                throw "INVALID-FIELD-TYPE", sprintf("Parameter Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
            OtherParameter::checkValueType(\value[0], items.type, items.items, loc + "[0]");
        }

        if (!SchemaBase::checkValueType(\value, type)) {
            throw "INVALID-FIELD-TYPE", sprintf("Parameter Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
        }
    }
}

#! contains the possible responses for an operation
public class ResponsesObject inherits ObjectBase {
    public {
        # The documentation of responses other than the ones declared for specific HTTP response codes.
        /**
            It can be used to cover undeclared responses.
         */
        ResponseObject defaultResp;

        # A hash mapping HTTP status codes to @ref ResponseObject "ResponseObjects".
        /**
            Any HTTP status code can be used as the property name (one property
            per HTTP status code). Describes the expected response for that HTTP status code.
         */
        hash<string, ResponseObject> responses;
    }

    #! Constructor.
    /**
        @param path the URI path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the responses for an operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws EMPTY-RESPONSES no responses given
     */
    public constructor(string path, string method, hash<auto> oh, SwaggerSchema swagger) : ObjectBase(oh) {
        string objType = "Responses";
        *hash defaultObj;
        if (optional_field(objType, oh, "default", NT_HASH, \defaultObj))
            defaultResp = ResponseObject::newResponse("default", defaultObj, swagger);

        *hash r = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^[0-9]+$/;
        foreach hash resp in (r.pairIterator()) {
            if (resp.value.typeCode() != NT_HASH)
                throw "INVALID-FIELD-TYPE", sprintf("%s %s: Responses Object: response has invalid type %y", method, path, resp.value.type());
            responses{resp.key} = ResponseObject::newResponse(resp.key, resp.value, swagger);
        }

        if (responses.empty() && !defaultObj)
            throw "EMPTY-RESPONSES", sprintf("%s %s: no valid responses provided for operation", method, path);
    }
}

#! Describes a single response from an API Operation.
public class ResponseObject inherits ObjectBase {
    public {
        #! Required. A short description of the response. GFM syntax can be used for rich text representation.
        string desc;

        #! A definition of the response structure.
        /**
            It can be a primitive, an array or an object. If this field does not exist,
            it means no content is returned as part of the response. As an extension
            to the @ref SchemaObject "SchemaObject", its root \c type value may also
            be \c "file". This SHOULD be accompanied by a relevant \c produces mime-type.
         */
        *SchemaObject schema;

        #! A hash of headers that are (can be) sent with the response.
        /**
            A hash of @ref HeaderObject objects. Keys are header names.
         */
        hash<auto> headers;

        #! A hash of example response messages.
        /**
            A hash of example responses in the form of <tt>Example Object</tt>.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#exampleObject
            Keys MUST be one of the Operation @ref OperationObject::produces "produces"
            values (either implicit or inherited). The value SHOULD be an example
            of what such a response would look like.
         */
        hash examples;
    }

    #! private constructor; use newResponse() instead
    /**
        @param key the response code for error reporting
        @param oh deserialized hash from the source schema description describing a single response for an API operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string key, hash<auto> oh, SwaggerSchema swagger) : ObjectBase(oh) {
        string objType = key + " Response";
        required_field(objType, oh, "description", NT_STRING, \desc);

        *hash<auto> schemaObj;
        if (optional_field(objType, oh, "schema", NT_HASH, \schemaObj))
            schema = SchemaObject::newSchemaObject("response_" + key, schemaObj, swagger);

        *hash<auto> headersObj;
        if (optional_field(objType, oh, "headers", NT_HASH, \headersObj))
            headers = map {$1.key: new HeaderObject($1.value, swagger)}, headersObj.pairIterator();

        optional_field(objType, oh, "examples", NT_HASH, \examples);
        # TODO keys should be Operation 'produces' values
    }

    #! returns a new ResponseObject corresponding to the schema definition passed
    /**
        @param key the response code for the response
        @param oh deserialized hash from the source schema description describing a single response for an API operation
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    static ResponseObject newResponse(string key, hash<auto> oh, SwaggerSchema swagger) {
        if (oh.hasKey("$ref"))
            return swagger.resolveResponse(key, oh."$ref", oh);
        return new ResponseObject(key, oh, swagger);
    }
}

#! describes a single HTTP header
public class HeaderObject inherits ObjectBase, SchemaBase {
    public {
        #! A short description of the header.
        *string desc;

        #! Required. The type of the object.
        /**
            The value MUST be one of \c "string", \c "number", \c "integer",
            \c "boolean", or \c "array".
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! Required if @ref HeaderObject::type "type" is \c "array". Describes the type of items in the array.
        *SchemaObject items;

        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\\tbar
            - \c "pipes": pipe separated values; ex: foo|bar

            Default value is \c "csv".
         */
        *string collectionFormat;

        #! Declares the value of the header that the server will use if none is provided.
        /**
            (Note: "default" has no meaning for required headers.)
            See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
            Unlike JSON Schema this value MUST conform to the defined
            @ref HeaderObject::type "type" for the header.
         */
        auto defaultVal;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a single HTTP header
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh, SwaggerSchema swagger) : ObjectBase(oh), SchemaBase("Header", oh) {
        string objType = "Header";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (!SchemaObject::ScalarTypes{type})
            throw "INVALID-FIELD-VALUE", "Header Object: invalid header type value passed: " + type;

        if (type == "array") {
            items = SchemaObject::newSchemaObject("items", oh.items, swagger);
            if (optional_field(objType, oh, "collectionFormat", NT_STRING, \collectionFormat)) {
                if (!CollectionFormats{collectionFormat})
                    throw "INVALID-FIELD-VALUE",
                        sprintf("Header Object: invalid collectionFormat value %y; expected one of: %y", collectionFormat, keys CollectionFormats);
            }
        } else if (oh.collectionFormat)
            throw "INVALID-FIELD-TYPE", sprintf("Header Object: type %y (non-array) cannot have a \"collectionFormat\" property (%y)", type, oh.collectionFormat);

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid integer type format value passed: " + format;
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid number type format value passed: " + format;
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid string type format value passed: " + format;
        }

        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            HeaderObject::checkValueType(\defaultVal, type, items);
        }
    }

    #! validates default values
    private static checkValueType(reference<auto> value, string type, *SchemaObject items, *string loc) {
        int vt = value.typeCode();
        if (type == "array") {
            if (vt != NT_LIST)
                throw "INVALID-FIELD-TYPE", sprintf("Header Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
            HeaderObject::checkValueType(value[0], items.type, items.items, loc + "[0]");
        }
        if (!SchemaBase::checkValueType(\value, type)) {
            throw "INVALID-FIELD-TYPE", sprintf("Header Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
        }
    }
}

#! Allows adding metadata to a single tag that is used by the @ref OperationObject. It is not mandatory to have a TagObject per tag used there.
public class TagObject inherits ObjectBase {
    public {
        #! Required. The name of the tag.
        string name;

        #! A short description for the tag. GFM syntax can be used for rich text representation.
        *string desc;

        #! Additional external documentation for this tag.
        *ExternalDocumentationObject externalDocs;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a metadata tag associated with an operation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "Tag";
        required_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);
    }
}

#! defines an object in a schema
public class SchemaObject inherits ObjectBase, SchemaBase {
    public {
        #! the name of this object for documentation and example purposes
        string name;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.2.
        /**
            MUST be either a string or an array (list). If it's an array,
            it's elements MUST be strings and MUST be unique.
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string title;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string desc;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.1.
        *SchemaObject items;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        auto defaultVal;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.1.
        *int maxProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.2.
        *int minProperties;

        #! extension that allows types to be nullable
        /** the OpenAPI specification 2.0 otherwise does not allow for nullable types
        */
        bool nullable = False;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be an object. Each value of this object MUST be an object,
            and each object MUST be a valid JSON Schema (@ref SchemaObject).
         */
        hash<string, SchemaObject> properties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be a bool or an object. If it is an object, it MUST also be
            a valid JSON Schema (@ref SchemaObject).
         */
        auto additionalProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.3.
        /**
            Set of strings. Must have at least one element.
         */
        hash<string, bool> required;

        #! Adds support for polymorphism.
        /**
            The discriminator is the schema property name that is used to
            differentiate between other schemas that inherit this schema.
            The property name used MUST be defined at this schema and it MUST
            be in the @ref SchemaObject::required "required" property list.
            When used, the value MUST be the name of this schema or any schema
            that inherits it.

            While composition offers model extensibility, it does not imply
            a hierarchy between the models. To support polymorphism, Swagger
            adds the support of the \c discriminator field. When used,
            the \c discriminator will be the name of the property used to decide
            which schema definition is used to validate the structure of the model.
            As such, the \c discriminator field MUST be a required field.
            The value of the chosen property has to be the friendly name given to
            the model under the \c definitions property. As such, inline schema
            definitions, which do not have a given id, \e cannot be used in polymorphism.
         */
        *string discriminator;

        #! Relevant only for Schema \c "properties" definitions. Declares the property as "read only".
        /**
            Declares the property as "read only". This means that it MAY be sent
            as part of a response but MUST NOT be sent as part of the request.
            Properties marked as \c readOnly being \c true SHOULD NOT be in the
            @ref SchemaObject::required "required" list of the defined schema.
            Default value is \c false.
         */
        bool readOnly = False;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.3.
        /**
            List of @ref SchemaObject "SchemaObjects"; MUST have at least one element.

            %Swagger allows combining and extending model definitions using the
            \c allOf property of JSON Schema, in effect offering model composition.
            \c allOf takes in an array of object definitions that are validated
            independently but together compose a single object.
         */
        list<SchemaObject> allOf();

        #! This MAY be used only on properties schemas. It has no effect on root schemas.
        /**
            Adds Additional metadata to describe the XML representation format of this property.

            The \c xml property allows extra definitions when translating the
            JSON definition to XML. The @ref XmlObject contains additional
            information about the available options.
         */
        *XmlObject xml;

        #! Additional external documentation for this schema.
        *ExternalDocumentationObject externalDocs;

        #! A free-form property to include an example of an instance for this schema.
        auto example;

        #! valid scalar types
        const ScalarTypes = (
            "string": True,
            "number": True,
            "integer": True,
            "boolean": True,
            "array": True,
        );

        #! valid reference types
        const ReferenceTypes = ScalarTypes + (
            "object": True,
        );
    }

    #! private constructor; use newSchemaObject() instead
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string name, hash<auto> oh, SwaggerSchema swagger) : ObjectBase(oh), SchemaBase("Schema", oh) {
        self.name = name;
        string objType = "Schema";

        if (optional_field(objType, oh, "type", NT_STRING, \type)) {
            if (!ReferenceTypes{type})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid schema type value passed: %y; expected one of: %y", name, type, keys ReferenceTypes);
            if (type == "array")
                items = newSchemaObject("items", oh.items, swagger);

            if (oh.hasKey("default")) {
                defaultVal = oh."default";
                SchemaObject::checkValueType(\defaultVal, type, items);
            }
        } else if (oh.properties) {
            type = "object";
        } else {
            type = "any";
        }

        # check for x-nullable
        optional_field(objType, oh, "x-nullable", NT_BOOLEAN, \nullable);

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid integer type format value passed: %y", name, format);
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid number type format value passed: %y", name, format);
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid string type format value passed: %y", name, format);
        }

        optional_field(objType, oh, "title", NT_STRING, \title);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        if (optional_field(objType, oh, "maxProperties", NT_INT, \maxProperties)) {
            checkObjectProperty(name, "maxProperties");
            if (maxProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'maxProperties' field less than 0", name);
        }
        if (optional_field(objType, oh, "minProperties", NT_INT, \minProperties)) {
            checkObjectProperty(name, "minProperties");
            if (minProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'minProperties' field less than 0", name);
        }

        {
            hash props;
            if (optional_field(objType, oh, "properties", NT_HASH, \props)) {
                checkObjectProperty(name, "properties");
                foreach string k in (keys props) {
                    auto val = props{k};
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'properties' field is not a hash of Schema Objects", name);
                    properties{k} = SchemaObject::newSchemaObject(k, val, swagger);
                }
            }
        }

        if (optional_field(objType, oh, "additionalProperties", (NT_BOOLEAN: True, NT_HASH: True), \additionalProperties)) {
            checkObjectProperty(name, "additionalProperties");
            if (additionalProperties.typeCode() == NT_HASH)
                additionalProperties = SchemaObject::newSchemaObject("additionalProperties", additionalProperties, swagger);
        }

        # process "required"
        if (optional_field(objType, oh, "required", SwaggerListToStringSet, \required)) {
            if (!required)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'required' is an empty list", name);
        }

        if (optional_field(objType, oh, "discriminator", NT_STRING, \discriminator)) {
            if (!required{discriminator})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: 'discriminator' field value not in the 'required' list", name);
        }

        optional_field(objType, oh, "readOnly", NT_BOOLEAN, \readOnly);

        {
            *list allOfList;
            if (optional_field(objType, oh, "allOf", NT_LIST, \allOfList)) {
                if (allOfList.size() < 1)
                    throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'allOf' is an empty list", name);
                foreach auto val in (allOfList) {
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-TYPE", sprintf("Schema Object %y: invalid 'allOf' list value datatype: %y", name, val.type());
                    allOf += SchemaObject::newSchemaObject(name + "AllOf", val, swagger);
                }
            }
        }

        *hash xmlObj;
        if (optional_field(objType, oh, "xml", NT_HASH, \xmlObj))
            xml = new XmlObject(xmlObj);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);

        if (oh.hasKey("example"))
            example = oh.example;
    }

    #! returns example Qore code for the object
    string getQoreExample(reference<hash<RestQoreExampleCodeInfo>> rv, string name, bool decl) {
        string typestr = get_qore_type(self.name, type, format, items);
        if (type == "array") {
            if (decl)
                return sprintf("%s %s(%s,);\n", typestr, name, items.getQoreExample(\rv, name, False));
            else
                return sprintf("(%s,)", items.getQoreExample(\rv, self.name, False));
        }

        if (type != "object") {
            auto val = getExampleValue();
            string example;
            switch (val.typeCode()) {
                case NT_DATE:
                    example = val.format("YYYY-MM-DDTHH:mm:SS.xxZ");
                    break;
                case NT_BINARY:
                    example = sprintf("<%s>", val.toHex());
                    break;
                default:
                    example = sprintf("%y", val);
                    break;
            }
            if (decl)
                return sprintf("%s %s = %s;\n", typestr, name, example);
            return example;
        }

        if (properties) {
            string str = sprintf("hashdecl %s {\n", self.name);
            foreach hash h in (properties.pairIterator()) {
                str += sprintf("    %s %s", get_qore_type(h.value.name, h.value.type, h.value.format, h.value.items), h.key);
                if (exists h.value.defaultVal)
                    str += sprintf(" = %y", h.value.defaultVal);
                str += ";\n";
            }
            str += "}\n";
            rv.hashdecls{self.name} = str;
        }

        string str;
        if (properties) {
            if (decl)
                str = sprintf("hash<%s> %s(", self.name, name);
            else
                str = sprintf("new hash<%s>(", self.name);

            str += "{\n";
            foreach hash h in (properties.pairIterator()) {
                string pstr;
                if (h.value.type == "string" && (h.value.format =~ /date(-time)?/))
                    pstr = sprintf("%y: date(%s)", h.key, h.value.getQoreExample(\rv, h.key, False));
                else
                    pstr = sprintf("%y: %s", h.key, h.value.getQoreExample(\rv, h.key, False));
                # add 4 spaces to the beginning of each line
                str += foldl $1 + "\n" + $2, (map "    " + $1, pstr.split("\n"));
                str += ",\n";
            }
            str += "})";
        } else if (additionalProperties instanceof SchemaObject) {
            string ptype = get_qore_type(additionalProperties.name, additionalProperties.type, additionalProperties.format, additionalProperties.items);
            if (decl)
                str = sprintf("hash<string, %s> %s()", ptype, name);
            else
                str = sprintf("new hash<string, %s>()", ptype);
        }
        if (decl)
            str += ";\n";
        return str;
    }

    # returns an example value for a REST API call
    auto getExampleValue() {
        if (exists example)
            return example;
        if (exists defaultVal)
            return defaultVal;

        if (type == "object") {
            return map {$1.key: $1.value.getExampleValue()}, properties.pairIterator();
        }

        if (type == "array") {
            return (items.getExampleValue(),);
        }

        return SchemaBase::getExampleValue(type, format);
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        if (request && readOnly)
            throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: property %y is read-only and therefore cannot be included in a request", method.upr(), path, name);
        if (!exists value && nullable) {
            return;
        }

        SchemaBase::check(serialize, request, type, format, items, path, method, name, \value);
    }

    private checkObjectProperty(string name, string prop) {
        if (type != "object")
            throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: %y cannot be given on an object of type %y", name, prop, type);
    }

    #! validates a schema object against a value
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method, string name, hash<auto> v, reference<hash<auto>> value) {
        if (type != "object" && type != "any")
            throwInvalidType(name, "object", type, v);

        # check "allOf" schemas, if any
        map $1.checkIntern(serialize, request, type, NOTHING, path, method, name, v, \value), allOf;

        /*
        If additionalProperties is set to true, any number of additionalProperties may be present of any data type.
        If additionalProperties is a schema, additional properties (beyond what are defined in ‘properties’) are allowed and must match the schema
        */
        # check properties in this schema definition
        if (!additionalProperties && type != "any") {
            foreach string key in (keys value) {
                *SchemaObject prop = properties{key};
                if (!prop) {
                    if (additionalProperties instanceof SchemaObject)
                        prop = additionalProperties;
                    if (!prop)
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("property %y is not valid for object %y", key, name);
                }
                prop.check(serialize, request, path, method, key, \value{key});
            }
        }
        # check for missing required properties
        foreach string prop in (keys required) {
            if (!value.hasKey(prop))
                throw "SCHEMA-VALIDATION-ERROR", sprintf("object %y: missing required property %y", name, prop);
        }
        #printf("SchemaObject::checkIntern() %y type: %y val: %y self: %N\n", name, type, value, self);
    }

    #! validates default values
    private static checkValueType(reference<auto> value, string type, *SchemaObject items, *string loc) {
        int vt = value.typeCode();
        if (type == "array") {
            if (vt != NT_LIST)
                throw "INVALID-FIELD-TYPE", sprintf("Schema Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
            SchemaObject::checkValueType(\value[0], items.type, items.items, loc + "[0]");
        }
        if (!SchemaBase::checkValueType(\value, type)) {
            throw "INVALID-FIELD-TYPE", sprintf("Schema Object: 'default' value%s has invalid type %y (expecting schema type %y)", loc, value.type(), type);
        }
    }

    #! returns a SchemaObject for the schema definition; resolves references
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    static SchemaObject newSchemaObject(string name, hash<auto> oh, SwaggerSchema swagger) {
        string refstr;
        if (optional_field("Schema", oh, "$ref", NT_STRING, \refstr))
            return swagger.resolveSchemaObject(name, refstr, oh);
        return new SchemaObject(name, oh, swagger);
    }

    #! throws an \c "INVALID-FIELD-TYPE" exception
    /** @throws INVALID-FIELD-TYPE due to a type error in the call
    */
    static SchemaObject newSchemaObject(string name, auto error, SwaggerSchema swagger) {
        throw "INVALID-FIELD-TYPE", sprintf("invalid field type %y for key %y; expecting \"hash\"", error.type(), name);
    }
}

#! items schema object for non-body parameters
public class ParameterItemsSchemaObject inherits SchemaObject {
    public {
        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\\tbar
            - \c "pipes": pipe separated values; ex: foo|bar
            - \c "multi": corresponds to multiple parameter instances instead of
                multiple values for a single instance <tt>foo=bar&foo=baz</tt>.
                This is valid only for parameters @ref AbstractParameterObject::inLoc "in"
                \c "query" or \c "formData".

            Default value is \c "csv".
         */
        *string collectionFormat;
    }

    #! private constructor; use newSchemaObject() instead
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-COLLECTION-FORMAT invalid collectionFormat value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string name, hash<auto> oh, SwaggerSchema swagger) : SchemaObject(name, oh, swagger) {
        if (optional_field("Parameter Items Schema", oh, "collectionFormat", NT_STRING, \collectionFormat)) {
            if (!CollectionFormats{collectionFormat})
                throw "INVALID-FIELD-VALUE",
                    sprintf("Parameter Items Schema Object %y: invalid collectionFormat value %y; expected one of: %y", name, collectionFormat, keys CollectionFormats);
        }
        if (type == "object")
            throw "INVALID-FIELD-VALUE",
                sprintf("Parameter Items Schema Object %y: invalid type value \"object\"; parameter items must be basic types and cannot be objects", name);
    }

    #! returns a SchemaObject for the schema definition; resolves references
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-COLLECTION-FORMAT invalid collectionFormat value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    static ParameterItemsSchemaObject newSchemaObject(string name, hash<auto> oh, SwaggerSchema swagger) {
        string refstr;
        if (optional_field("Parameter Items Schema", oh, "$ref", NT_STRING, \refstr))
            return swagger.resolveParameterItemsSchemaObject(name, refstr, oh);
        return new ParameterItemsSchemaObject(name, oh, swagger);
    }

    #! throws an \c "INVALID-FIELD-TYPE" exception
    /** @throws INVALID-FIELD-TYPE due to a type error in the call
    */
    static ParameterItemsSchemaObject newSchemaObject(string name, auto error, SwaggerSchema swagger) {
        throw "INVALID-FIELD-TYPE", sprintf("invalid field type %y for key %y; expecting \"hash\"", error.type(), name);
    }
}

#! A metadata object that allows for more fine-tuned XML model definitions.
/**
    When using arrays, XML element names are not inferred (for singular/plural
    forms) and the @ref XmlObject::name "name" property should be used to add that information.
    See examples for expected behavior.
 */
public class XmlObject inherits ObjectBase {
    public {
        #! Replaces the name of the element/attribute used for the described schema property.
        /**
            When defined within the \c items, it will affect
            the name of the individual XML elements within the list.
            When defined alongside \c type being \c array (outside the \c items),
            it will affect the wrapping element and only if \c wrapped is \c true.
            If \c wrapped is \c false, it will be ignored.
         */
        *string name;

        #! The URL of the namespace definition. Value SHOULD be in the form of a URL.
        *string ns;

        #! The prefix to be used for the @ref XmlObject::name "name".
        *string prefix;

        #! Declares whether the property definition translates to an attribute instead of an element. Default value is \c false.
        bool attribute = False;

        #! MAY be used only for an array definition. Signifies whether the array is wrapped (for example, \c &lt;books&gt;&lt;book/&gt;&lt;book/&gt;&lt;/books&gt;) or unwrapped (\c &lt;book/&gt;&lt;book/&gt;).
        /**
            Default value is \c false. The definition takes effect only when
            defined alongside \c type being \c array (outside the \c items).
         */
        bool wrapped = False;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing XML model definitions

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "XML";
        optional_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "namespace", NT_STRING, \ns);
        optional_field(objType, oh, "prefix", NT_STRING, \prefix);
        optional_field(objType, oh, "attribute", NT_BOOLEAN, \attribute);
        optional_field(objType, oh, "wrapped", NT_BOOLEAN, \wrapped);
    }
}

#! Allows the definition of a security scheme that can be used by the operations.
/**
    Supported schemes are basic authentication, an API key (either as a header
    or as a query parameter) and OAuth2's common flows (implicit, password,
    application and access code).
 */
public class SecuritySchemeObject inherits ObjectBase {
    public {
        #! Required. The type of the security scheme. Valid values are \c "basic", \c "apiKey" or \c "oauth2".
        string type;

        #! A short description for security scheme.
        *string desc;

        #! The name of the header or query parameter to be used.
        /**
            Required when type is \c "apiKey".
         */
        *string name;

        #! The location of the API key. Valid values are \c "query" or \c "header".
        /**
            Required when type is \c "apiKey".
         */
        *string inLoc;

        #! The flow used by the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            Valid values are \c "implicit", \c "password", \c "application" or \c "accessCode".
         */
        *string flow;

        #! The authorization URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is \c "implicit" or \c "accessCode".
         */
        *string authorizationUrl;

        #! The token URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is one of \c "password", \c "application" or \c "accessCode".
         */
        *string tokenUrl;

        #! The available scopes for the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            A hash in the form of <tt>Scopes Object</tt> mapping scope names to short descriptions of them.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#scopesObject
            Keys are scope names. Values are short string descriptions.
         */
        *ScopesObject scopes;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a security schema that can be used by REST API operations

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FLOW invalid OAuth2 flow value
        @throws INVALID-APIKEY-LOCATION invalid 'in' (location) value
        @throws INVALID-SCHEME-TYPE invalid security scheme type; see @ref SecuritySchemeObject::type "type"
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string objType = "Security Scheme";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (type == "apiKey") {
            required_field(objType, oh, "name", NT_STRING, \name);
            required_field(objType, oh, "in", NT_STRING, \inLoc);
            if (inLoc != "query" && inLoc != "header")
                throw "INVALID-APIKEY-LOCATION", "Security Scheme Object: invalid 'in' (location) value passed: " + inLoc;
        } else if (type == "oauth2") {
            required_field(objType, oh, "flow", NT_STRING, \flow);
            if (flow == "accessCode") {
                required_field(objType, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
                required_field(objType, oh, "tokenUrl", NT_STRING, \tokenUrl);
            } else if (flow == "application" || flow == "password") {
                required_field(objType, oh, "tokenUrl", NT_STRING, \tokenUrl);
            } else if (flow == "implicit") {
                required_field(objType, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
            } else {
                throw "INVALID-FLOW", "Security Scheme Object: invalid OAuth2 flow value passed: " + flow;
            }

            hash scopesObj;
            required_field(objType, oh, "scopes", NT_HASH, \scopesObj);
            scopes = new ScopesObject(scopesObj);
        } else if (type != "basic") {
            throw "INVALID-SCHEME-TYPE", "Security Scheme Object: invalid security scheme type passed: " + type;
        }
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Lists the available scopes for an OAuth2 security scheme.
public class ScopesObject inherits ObjectBase {
    public {
        #! Maps between a name of a scope to a short description of it (as the value of the property).
        /**
            Hash of string values.
         */
        hash<string, string> fields;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the available scopes for an OAuth2 security scheme

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        foreach hash item in (oh.pairIterator()) {
            if (item.key !~ /^x-/) { # if not vendor extension
                if (item.value.typeCode() != NT_STRING)
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Scopes Object: %y field has invalid type %y, instead of 'string'",
                            item.key, item.value.type());
                fields{item.key} = item.value;
            }
        }
    }
}
}

# private namespace for internal definitions
namespace Priv {
    # a set of string values
    const SwaggerListToStringSet = -1;
    # a set of any type that can be converted to a string
    const SwaggerListToAnySet = -2;
    const SwaggerListToHashOfStrings = -3;

    const TypeMap = (
        NT_INT: "int",
        NT_STRING: "string",
        NT_FLOAT: "float",
        NT_LIST: "list",
        NT_HASH: "hash",
        NT_NOTHING: "nothing",
        NT_BOOLEAN: "bool",
        SwaggerListToStringSet: "list<string>",
        SwaggerListToAnySet: "list<auto>",
    );

    #! Check and assign a required field.
    /**
        @param objType type of object (e.g. "External Documentation")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    sub required_field(string objType, hash<auto> oh, string name, int typeCode, reference<auto> target) {
        if (!oh.hasKey(name))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: %y field is missing; fields present: %y", objType, name, keys oh);
        auto val = oh{name};
        check_type_code(objType, name, val, typeCode);
        get_value(objType, name, typeCode, val, \target);
    }

    #! Check and assign a required field.
    /**
        @param objType type of object (e.g. "External Documentation")
        @param oh Object hash
        @param name field name
        @param typeCodes possible field typeCodes
        @param target where to assign the field's value

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    sub required_field(string objType, hash<auto> oh, string name, hash<string, bool> typeCodes, reference<auto> target) {
        if (!oh.hasKey(name))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: %y field is missing; fields present: %y", objType, name, keys oh);
        auto val = oh{name};

        if (!typeCodes{val.typeCode()})
            throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y field has invalid type %y", objType, name, val.type());
        get_value(objType, name, val.typeCode(), val, \target);
    }

    #! Check and assign a field.
    /**
        @param objType type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string objType, hash<auto> oh, string name, int typeCode, reference<auto> target) {
        if (!oh.hasKey(name))
            return False;
        auto val = oh{name};
        check_type_code(objType, name, val, typeCode);
        get_value(objType, name, typeCode, val, \target);
        return True;
    }

    #! Check and assign a field.
    /**
        @param objType type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCodes possible field typeCodes
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string objType, hash<auto> oh, string name, hash<string, bool> typeCodes, reference<auto> target) {
        if (!oh.hasKey(name))
            return False;
        auto val = oh{name};
        if (!typeCodes{val.typeCode()})
            throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y field has invalid type %y", objType, name, val.type());
        get_value(objType, name, val.typeCode(), val, \target);
        return True;
    }

    #! verifies the type of a field
    sub check_type_code(string objType, string name, auto val, int typeCode) {
        int vtc = val.typeCode();
        if ((typeCode == SwaggerListToStringSet || typeCode == SwaggerListToAnySet || typeCode == SwaggerListToHashOfStrings) && vtc == NT_LIST)
            return;
        if (vtc != typeCode)
            throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y field has invalid type %y; expecting %y", objType, name, val.type(), TypeMap{typeCode});
    }

    #! assigns a value to a field
    sub get_value(string objType, string name, int typeCode, auto val, reference<auto> target) {
        if (typeCode == SwaggerListToStringSet) {
            foreach auto v in (val) {
                if (v.typeCode() != NT_STRING)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in list value has type %y; expecting \"string\"", objType, name, $# + 1, val.size(), v.type());
                target{v} = True;
            }
        } else if (typeCode == SwaggerListToAnySet) {
            foreach auto v in (val) {
                if (!v.strp())
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in list value has type %y which cannot be converted to a string; the Swagger module only supports types that can be converted to a string for this field", objType, name, $# + 1, val.size(), v.type());
                target{v} = True;
            }
        } else if (typeCode == SwaggerListToHashOfStrings) {
            foreach auto v in (val) {
                int pos = $# + 1;
                if (v.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has type %y; expecting \"hash\"", objType, name, pos, val.size(), v.type());
                if (v.size() > 1)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has a hash with more than one key: %y; expecting a hash with a single key", objType, name, pos, val.size(), v);
                string key = v.firstKey();
                if (target.hasKey(key))
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d has duplicate key %y", objType, name, pos, val.size(), key);
                foreach auto fv in (v.firstValue()) {
                    if (fv.typeCode() != NT_STRING)
                        throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in %y list value has type %y in position %d/%d; expecting \"string\"", objType, name, pos, val.size(), key, fv.type(), $# + 1, fv.lsize());
                }
                target += v;
            }
        } else
            target = val;
    }

    #! returns the Qore type for the given schema type
    string sub get_qore_type(string name, string type, *string format, *SchemaObject items) {
        switch (type) {
            case "array": return sprintf("list<%s>", get_qore_type(items.name, items.type, items.format, items.items));
            case "integer": return "int";
            case "boolean": return "bool";
            case "number": return format && ValidNumberFormatsHash{format} ? "float" : "number";
            case "string": {
                switch (format) {
                    case "byte":
                    case "binary":
                        return "binary";
                    case "date":
                    case "date-time":
                        return "date";
                }
                return "string";
            }
            case "null": return "nothing";
            case "object": return sprintf("hash<%s>", name);
        }
        return sprintf("unknown<%s = %s>", name, type);
    }
}
