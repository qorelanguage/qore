# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Logger.qm Logger library

/*  Logger.qm Copyright 2018 - 2023 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 1.0

%require-types
%enable-all-warnings
%new-style
%no-debugging

%requires Util

module Logger {
    version = "0.6";
    desc = "user module implementing Log4q logger library";
    author = "Tomas Mandys <tomas.mandys@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Logger Module

    @tableofcontents

    @section loggerintro Introduction to the Logger Module

    The %Logger module (aka <b>Log4q</b>) adopts its primary design from the well known
    <a href="https://logging.apache.org/log4j/2.x">log4j</a> library, therefore it
    implements the following primary base classes:
    - @ref Logger::Logger "Logger"
    - @ref Logger::LoggerAppender "LoggerAppender" (abstract)
    - @ref Logger::LoggerFilter "LoggerFilter"
    - @ref Logger::LoggerLayout "LoggerLayout" (abstract)
    - @ref Logger::LoggerPattern "LoggerPattern" (abstract)

    Abstract base classes must be subclassed to implement the desired functionality.

    @subsection logger_scenarior Scenarios

    @par One Thread

    The user code will log to a @ref Logger object, and the logging is performed to the appender synchronously.

    Example:
    @code{.py}
    Logger l("mylogger", LoggerLevel::getLevelInfo());
    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    l.addAppender(laf);
    laf.open();
    ....
    l.info("hello %s #%d", "world", 1);
    l.error("the %s is not perfect", "world");
    @endcode

    @par Multiple Threads

    The user code will log from multiple threads; the events are pushed to a
    @ref Logger::LoggerAppenderQueue "LoggerAppenderQueue" object. The processing is done in a dedicated thread
    when the events are passed to appenders. The user code logging command is non-blocking as it terminates
    immediately when the event is pushed in the queue.

    Example:
    @code{.py}
    our Logger l("mylogger", LoggerLevel::getLevelInfo());

    sub run() {
        while (!done) {
            ...
            l.info("hello %s #%d", "world", 1);
            l.error("the %s is not perfect", "world");
            ...
        }
    }

    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    laf.setQueue(new LoggerAppenderQueue());
    l.addAppender(laf);
    laf.open();

    for (int i=0; i<10; i++) {
        background run();
    }

    while (True) {
        laf.getQueue().process();
    }
    @endcode

    @par Application Server Running Logging From a Few Sandboxed Program Containers

    In this example, the appserver provides a logger API for a few sandboxed programs. The appserver is
    responsible for the <b>Log4q</b> configuration; i.e. it prepares loggers, appenders, filters, etc.
    according to configuration and provides the @ref Logger instance to the @ref Qore::Program "Program"
    container running the sandboxed code.
    The sandboxed code will log to this instance; the logging events are processed by the appserver in a
    dedicated thread which gets the event from a queue and passes it to appenders.  Multiple loggers may be
    configured in a parent/child hierarchy so that a higher logging level (i.e. more event levels) are logged
    with the logger assigned to the sandbox and fewer (ex: only critical errors) to the global appserver logger.

    Example:
    @code{.py}
    LoggerAppenderQueue laq();
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);

    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    while (True) {
        laq.process(-1);
    }
    @endcode

    @par Application Server Running Many Sandboxed Program Containers

    This example is basically the same as the previous example, but to avoid I/O bottlenecks in logging, the
    appserver processing thread gets the event from a queue and passes it to the appender in another worker
    thread by a submitting the logging action to a @ref Qore::Thread::ThreadPool "ThreadPool". So events targeted
    to a particular thread may by processed in different threads but nevertheless serially.

    Example:
    @code{.py}
    ThreadPool tp();
    LoggerAppenderQueueThreadPool laq(tp, 5);
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);
    code processing() = sub () {
        while (True) {
            laq.process(-1);
        }
    }
    # may run in extra thread
    background processing();
    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    # wait till finished
    @endcode

    @subsection logger_v0_6 v0.6
    - Fixed a bug where file rotate could result in logging exceptions; removed explicit atomic lock operations and
      implemented low-level atomic file handling instead
      (<a href="https://github.com/qorelanguage/qore/issues/4842">issue 4842</a>)

    @subsection logger_v0_5 v0.5
    - added @ref Logger::LoggerInterface "LoggerInterface" and @ref Logger::LoggerWrapper "LoggerWrapper" classes
      (<a href="https://github.com/qorelanguage/qore/issues/4776">issue 4776</a>)

    @subsection logger_v0_4 v0.4
    - added the @ref Logger::StdoutAppender "StdoutAppender" class

    @subsection logger_v0_3 v0.3
    - fixed a race condition handling log file rotation with active logs
      (<a href="https://github.com/qorelanguage/qore/issues/4583">issue 4583</a>)

    @subsection logger_v0_2 v0.2
    - added support for the \c %%h and \c %%P patterns for hostname and PID, respectively
      (<a href="https://github.com/qorelanguage/qore/issues/4179">issue 4179</a>)
    - allow file appenders to be reopened
      (<a href="https://github.com/qorelanguage/qore/issues/4171">issue 4171</a>)
    - enable serialization for @ref Logger::LoggerEvent "LoggerEvent" objects as well as for them to be submitted
      directly to @ref Logger::Logger "Logger" objects
      (<a href="https://github.com/qorelanguage/qore/issues/4164">issue 4164</a>)

    @subsection logger_v0_1_1 v0.1.1
    - added Logger::Logger::logArgs() "Logger::logArgs()"
      (<a href="https://github.com/qorelanguage/qore/issues/3492">issue 3492</a>)

    @subsection logger_v0_1 v0.1
    - the initial version of the Logger module
*/

#! The Logger namespace contains all the definitions in the Logger module
public namespace Logger {
#! Defines the minimum set of levels recognized by the system.
/**
    The set of built-in levels includes \c TRACE, \c DEBUG, \c INFO, \c WARN, \c ERROR and \c FATAL. Log4q also supports
    custom log levels where the \c LoggerLevel class may be subclassed to define a larger level set.
*/
public class LoggerLevel inherits Qore::Serializable {
    public {
        #! The highest logger level
        const OFF = MAXINT;
        #! Logger level for fatal errors
        const FATAL = 50000;
        #! Logger level for (non-fatal) errors
        const ERROR = 40000;
        #! Logger level for warnings
        const WARN = 30000;
        #! Logger level for informational messages
        const INFO = 20000;
        #! Logger level for debugging messages
        const DEBUG = 10000;
        #! Logger level for trace messages
        const TRACE = 5000;
        #! The lowest logger level
        const ALL = MININT;
    }

    private:internal {
        #! Integer level value.
        int levelCode;

        #! String representation of the level.
        string levelStr;

        #! Contains a list of instantiated levels
        static hash<string, LoggerLevel> levelMap;

        #! String to int hash
        const LEVELSTR_TO_LEVEL = {
            'ALL':   ALL,
            'TRACE': TRACE,
            'DEBUG': DEBUG,
            'INFO':  INFO,
            'WARN':  WARN,
            'ERROR': ERROR,
            'FATAL': FATAL,
            'OFF':   OFF,
        };

        #! Int to string hash
        const LEVEL_TO_LEVEL_STR = map {$1.value: $1.key}, LEVELSTR_TO_LEVEL.pairIterator();
    }

    #! Creates a new object
    /**
        @param code integer value
        @param str string representation
    */
    constructor(int code, string str) {
        levelCode = code;
        levelStr = str;
    }

    #! Gets level code value
    public int getValue() {
        return levelCode;
    }

    #! Gets level string
    public string getStr() {
        return levelStr;
    }

    #! Compares logger levels
    /**
        @param other the other level to compares
        @return True if level is greater or equal to the \a other level
    */
    public bool isGreaterOrEqual(LoggerLevel other) {
        return levelCode >= other.getValue();
    }

    #! Compares two logger levels
    /**
        @param other the other level to compares
    */
    public bool isEqual(LoggerLevel other) {
        return levelCode == other.getValue();
    }

    #! Returns an OFF Level
    public static LoggerLevel getLevelOff() {
        return LoggerLevel::getLevel(OFF);
    }

    #! Returns a FATAL Level
    public static LoggerLevel getLevelFatal() {
        return LoggerLevel::getLevel(FATAL);
    }

    #! Returns an ERROR Level
    public static LoggerLevel getLevelError() {
        return LoggerLevel::getLevel(ERROR);
    }

    #! Returns a WARN Level
    public static LoggerLevel getLevelWarn() {
        return LoggerLevel::getLevel(WARN);
    }

    #! Returns an INFO Level
    public static LoggerLevel getLevelInfo() {
        return LoggerLevel::getLevel(INFO);
    }

    #! Returns a DEBUG Level
    public static LoggerLevel getLevelDebug() {
        return LoggerLevel::getLevel(DEBUG);
    }

    #! Returns a TRACE Level
    public static LoggerLevel getLevelTrace() {
        return LoggerLevel::getLevel(TRACE);
    }

    #! Returns an ALL Level
    public static LoggerLevel getLevelAll() {
        return LoggerLevel::getLevel(ALL);
    }

    #! Converts the input argument to a level
    /**
        Return value is either instantiated or used the existing one if there is any.

        @param level the input level
        @param default_level value to return if conversion is not possible.

        @throw LOGGER-ERROR if defaultLevel is nothing and level not found
    */
    public static LoggerLevel getLevel(int level, *LoggerLevel default_level) {
        if (exists LEVEL_TO_LEVEL_STR{level}) {
            if (!exists levelMap{level}) {
                levelMap{level} = new LoggerLevel(level, LEVEL_TO_LEVEL_STR{level});
            }
            return levelMap{level};
        } else {
            if (!exists default_level) {
                throw "LOGGER-ERROR", "Cannot get valid Level";
            }
            return default_level;
        }
    }

    #! Returns closest lower logger level
    /**
        @param level the logger level
        @return \c Loggerlevel or \c NOTHING if there is no lower level

        @throw LOGGER-ERROR if level not found
    */
    public static *LoggerLevel getNextLowerLevel(int level) {
        HashIterator hi(LEVELSTR_TO_LEVEL);
        while (hi.next()) {
            if (level == hi.getValue()) {
                if (hi.prev()) {
                    return LoggerLevel::getLevel(hi.getValue());
                }
                break;
            }
        }
        return NOTHING;
    }

    #! Returns closest higher logger level
    /**
        @param level the logger level
        @return \c Loggerlevel or \c NOTHING if there is no higher level

        @throw LOGGER-ERROR if level not found
    */
    public static *LoggerLevel getNextHigherLevel(int level) {
        HashIterator hi(LEVELSTR_TO_LEVEL);
        while (hi.next()) {
            if (level == hi.getValue()) {
                if (hi.next()) {
                    return LoggerLevel::getLevel(hi.getValue());
                }
                break;
            }
        }
        return NOTHING;
    }

    #! Converts the input argument to a level.
    /**
        Return value is either instantiated or used the existing one if there is any.

        @param level_str the string input level
        @param default_level value to return if conversion is not possible.
        @throw LOGGER-ERROR if default_level is nothing and level_str not found
    */
    public static LoggerLevel getLevel(string level_str, *LoggerLevel default_level) {
        level_str = toupper(level_str);
        if (exists LEVELSTR_TO_LEVEL{level_str}) {
            int level = LEVELSTR_TO_LEVEL{level_str};
            if (!exists levelMap{level}) {
                levelMap{level} = new LoggerLevel(level, level_str);
            }
            return levelMap{level};
        } else {
            if (!exists default_level) {
                throw "LOGGER-ERROR", "Cannot get valid Level";
            }
            return default_level;
        }
    }
}

#! Implements callable parameter which is evaluated in run-time when event is rendered
/**
    It may implement logging for stuff which is time consuming to get and would slow program flow in case
    the logging is actually not performed because of filters or logging levels.

    Example:
@code{.py}
int ping_voyager(int num) {
    try {
        # ping voyager #num
        ...
    } except(hash<ExceptionInfo> ex) {
        return -1;
    }
}
Logger l;
....
l.debug("Voyager 1: ping is %y secs", new LoggerEventParameter(\ping_voyager(), 1));
@endcode
*/
public class LoggerEventParameter {
    private:internal {
        code callable;
        *list<auto> args;
    }
    #! Creates object
    /**
        @param func function to be called with optional arguments followed
    */
    constructor(code func, ...) {
        callable = func;
        args = argv;
    }
    #! Call function with arguments provided
    /**
        In case of user function call consider surpressing exceptions to return value corresponding to expected
        formatting parameter (e.g. "%d").
    */
    public auto call() {
        return call_function_args(callable, args);
    }
}

#! Implements an event to be logged
/**
    The event data consists of format string and parameters. The output string is rendered at time when
    logging decision to target is made. Callable parameters are evaluated at this moment as well. It
    should be considered when callable parameters do not return time persistent value. When callable raises
    an exception then exception instance is passed for formatting. So it should be considered if format string and
    use for example "%y" to get readable data.
*/
public class LoggerEvent {
    private:internal {
        #! origin stamp to calculate relative time
        static date startTime = now_us();

        #! Fully Qualified Class Name of the calling category class.
        string fqcn;

        #! Logger reference
        *Logger logger;

        #! The category (logger) name.
        string categoryName;

        #! Level of the logging event.
        LoggerLevel level;

        #! The application supplied message of logging event (not rendered)
        string messageFmt;

        #! arguments to be rendered
        *list<auto> messageArgs;

        #! The application supplied message rendered through the rendering mechanism.
        *string renderedMessage;

        #! related thread id
        int threadId;

        #! event time stamp
        date timeStamp;

        #! location information where the logging was performed.
        *hash<CallStackInfo> locationInfo;

        #! internal representation of throwable
        *hash<ExceptionInfo> throwableInfo;

        #! unique id
        int uniqueId;

        #! unique id generator
        static Sequence sequence(1);
    }

    #! Instantiates a LoggingEvent from the supplied parameters.
    /**
        The category becomes logger name and fqcn logger class name

        @param logger Instance of the Logger class
        @param level The event level
        @param message The payload as format for @ref Qore::sprintf() "sprintf()"()
        @param args The arguments for formatting
        @param location_info code location related to logging event
        @param thread_id thread related to the event, Default: @ref Qore::gettid() "gettid()"
        @param time_stamp logging event timestamp. Default value is @ref Qore::now_us() "now_us()"
        @param throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with the logging event
    */
    constructor(Logger logger, LoggerLevel level, string message, *list<auto> args,
            *hash<CallStackInfo> location_info, int thread_id = gettid(), date time_stamp = now_us(),
            *hash<ExceptionInfo> throwable) {
        fqcn = get_class_name(logger);
        self.logger = logger;
        categoryName = logger.getName();
        self.level = level;
        messageFmt = message;
        messageArgs = args;
        locationInfo = location_info;
        threadId = thread_id;
        timeStamp = time_stamp;
        if (throwable) {
            throwableInfo = throwable;
        }
    }

    #! Instantiates a LoggingEvent from the supplied parameters.
    /**
        @param fqcn name of the caller class.
        @param category The event category.
        @param level The event level
        @param message The payload as format for @ref Qore::sprintf() "sprintf()"()
        @param args The arguments for formatting
        @param location_info code location related to logging event
        @param thread_id thread related to the event, Default: @ref Qore::gettid() "gettid()"
        @param time_stamp logging event timestamp. Default value is @ref Qore::now_us() "now_us()"
        @param throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with the logging event
    */
    constructor(string fqcn, softstring category, LoggerLevel level, string message, *list<auto> args,
            *hash<CallStackInfo> location_info, int thread_id = gettid(), date time_stamp = now_us(),
            *hash<ExceptionInfo> throwable) {
        self.fqcn = fqcn;
        categoryName = category;
        self.level = level;
        messageFmt = message;
        messageArgs = args;
        locationInfo = location_info;
        threadId = thread_id;
        timeStamp = time_stamp;
        if (throwable) {
            throwableInfo = throwable;
        }
    }

    #! Returns the full qualified classname
    public string getFullQualifiedClassname() {
        return fqcn;
    }

    #! Returns the location information for this logging event
    public *hash<CallStackInfo> getLocationInfo() {
        return locationInfo;
    }

    #! Returns the level of this event
    public LoggerLevel getLevel() {
        return level;
    }

    #! Returns the logger which created the event
    public *Logger getLogger() {
        return logger;
    }

    #! Returns the thread id which is related to event
    public int getThreadId() {
        return threadId;
    }

    #! Returns the category name
    public string getCategoryName() {
        return categoryName;
    }

    #! Returns the string message for the logging event
    /**
        Potential callable references are evaluated.
        Next the message is rendered using @ref Qore::vsprintf() "vsprintf()" and the result is cached, so
        the message is rendered only once.

        @return the rendered message
    */
    public string getMessage() {
        if (!exists renderedMessage) {
            # evaluating of callable parameters (via LoggerEventParameter) may be used to get time consuming stuff
            # i.e. they are evaluated only when logging is performed
            list<auto> args2 = ();
            foreach auto arg in (messageArgs) {
                if (arg.typeCode() == NT_OBJECT && arg instanceof LoggerEventParameter) {
                    try {
                        push args2, cast<LoggerEventParameter>(arg).call();
                    } catch (hash<ExceptionInfo> ex) {
                        push args2, ex;
                    }
                } else {
                    push args2, arg;
                }
            }
            # message is considered as printf() format so we process it this way.
            renderedMessage = vsprintf(messageFmt, args2);
        }
        return renderedMessage;
    }

    #! Returns the time when the application/logger started to calculate relative time
    public static date getStartTime() {
        return LoggerEvent::startTime;
    }

    #! Sets the starting time for relative time
    public static setStartTime(date time) {
        LoggerEvent::startTime = time;
    }

    #! Returns the event timestamp as an @ref absolute_dates "absolute date/time value"
    public date getTimeStamp() {
        return timeStamp;
    }

    #! Returns a relative timestamp for the event
    /**
        Returns a @ref relative_dates "relative date/time value" for the amount of time passed
        from the beginning of execution to the time when the event was constructed.

        @see @ref getStartTime()
    */
    public date getRelativeTime() {
        return timeStamp - LoggerEvent::startTime;
    }

    #! Returns throwable info, if any
    public *hash<ExceptionInfo> getThrowableInfo() {
        return throwableInfo;
    }

    #! Generates a globally unique integer identifier and associates it to the event
    public int getUniqueId() {
        if (!exists uniqueId) {
            uniqueId = sequence.next();
        }
        return uniqueId;
    }
}

#! Implements queue serializing async appender events
/**
    All async events may be processed by one worker thread dedicated to
    one or more appenders so the thread posting logging event remains unblocked.
*/
public class LoggerAppenderQueue {
    private:internal {
        Queue queue();
    }

    #! Adds appender event
    /**
        @param appender a logger appender object
        @param type see \c EVENT_xxx constants
        @param params data prepared by @ref LoggerAppender::serializeImpl()
        @return True if the event was succesfully added to queue
    */
    public bool push(LoggerAppender appender, int type, auto params) {
        try {
            queue.push({"appender": appender, "type": type, "params": params}, -1);
        } catch (hash<ExceptionInfo> ex) {
            return False;
        }
        return True;
    }

    #! Processes queued events
    /**
        This method should typically be called in a dedicated thread

        @param ms a timeout value to wait for data to become available on the queue;
            integers are interpreted as milliseconds; relative date/time values are interpreted
            literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
            the call to time out immediately if the call would otherwise block.
            If a positive timeout argument is passed, and no data is available in the timeout period
            then waits up to timeout value, If a negative timeout value is passed as the argument,
            then the call blocks until data is available on the queue. Default value is 0.
    */
    public process(timeout ms = 0) {
        while (True) {
            *hash<auto> rec = getEvent(ms);
            if (!rec) {
                break;
            }
            rec.appender.processEvent(rec.type, rec.params);
        }
    }

    #! Returns the current number of events waiting in queue
    public int size() {
        return queue.size();
    }

    #! Returns the next event from queue or @ref nothing if there is no event available within the timeout period
    /**
        @param ms a timeout value to wait for data to become available on the queue;
            integers are interpreted as milliseconds; relative date/time values are interpreted
            literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
            the call to time out immediately if the call would otherwise block.
            If a positive timeout argument is passed, and no data is available in the timeout period
            then waits up to timeout value, If a negative timeout value is passed as the argument,
            then the call blocks until data is available on the queue.

        @return the next event from queue or @ref nothing if there is no event available within the timeout period
    */
    private *hash<auto> getEvent(timeout ms) {
        if (queue.size() > 0 || ms != 0) {
            try {
                if (ms == 0) {
                    return queue.get(-1);
                } else if (ms > 0) {
                    return queue.get(ms);
                } else {
                    return queue.get(0);
                }
            } catch (hash<ExceptionInfo> ex) {
                switch (ex.err) {
                    case "QUEUE-TIMEOUT":
                        break;
                    default:
                        rethrow;
                }
            }
        }
    }
}

#! Handles the processing for asynchronous appender events in multiple threads
/**
    Async events are removed from the event queue in a single thread which balances processing
    in multiple worker threads via a @ref Qore::Thread::ThreadPool "ThreadPool". This class groups events by appender
    so that events related to a particular appender are always processed serially in the same thread.
    It is compatible with %Qore's @ref Qore::OutputStream implementation where all data submitted to the
    output stream must be submitted from the same thread.
*/
public class LoggerAppenderQueueThreadPool inherits LoggerAppenderQueue {
    private:internal {
        #! worker thread pool
        ThreadPool threadPool;
        #! number of running worker threads
        Counter runningCounter(0);
        #! max.number of worker threads
        int maxThreads;
        #! events removed from queue but not passed to worker thread
        hash<auto> pendingEvents;
        #! events paseed to worker thread
        hash<auto> processingEvents;
        #! queue of processed events in worker threads
        Queue finishedEvents();
        #! internal unique counter
        Sequence lastId(0);
        #! to protect process()
        Mutex lock();
    }

    #! Implements worker thread code
    /**
        @param id unique identifier generated by internal @ref Qore::Thread::Sequence "Sequence"
        @param appender @ref LoggerAppender instance
        @param events list of events
    */
    private:internal worker(string id, LoggerAppender appender, list<auto> events) {
        #printf("start worker(), id: %y, tid: %d\n", id, gettid());
        #printf("<S:%y, tid: %d> ", id, gettid());
        runningCounter.inc();
        on_exit runningCounter.dec();
        try {
            map appender.processEvent($1.type, $1.params), events;
        } catch (hash<ExceptionInfo> ex) {
            # ignore exceptions
        }
        finishedEvents.push(id);
        #printf("end worker(), id: %y, tid: %d\n", id, gettid());
        #printf("<E:%y, tid: %d> ", id, gettid());
    }

    #! Creates the object
    /**
        @param tp worker @ref Qore::Thread::ThreadPool "ThreadPool" where loggging events are submitted
        @param max_threads max.number of worker threads, default value is \c -1, i.e. unlimited
    */
    constructor(ThreadPool tp, int max_threads = -1) {
        threadPool = tp;
        maxThreads = max_threads;
    }

    destructor() {
        runningCounter.waitForZero();
        threadPool.stopWait();
    }

    #! Returns the assigned @ref Qore::Thread::ThreadPool "ThreadPool"
    public ThreadPool getThreadPool() {
        return threadPool;
    }

    #! Processes queue events
    /**
        Group logging events by appender and submit them to a worker thread to be processed in a thread pool so
        the particular thread will handle corresponding appender instance.

        @param ms a timeout value to wait for data to become available on the queue;
            integers are interpreted as milliseconds; relative date/time values are interpreted
            literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
            the call to time out immediately if the call would otherwise block.
            If a positive timeout argument is passed, and no data is available in the timeout period
            then waits up to timeout value, If a negative timeout value is passed as the argument,
            then the call blocks until data is available on the queue. Default value is 0.
    */
    public process(timeout ms = 0) {
        # normally function is called from one thread and it is not time critical
        AutoLock al(lock);
        # get new events and match with pending
        hash<string, auto> last_match;
        while (True) {
            *hash<auto> e = getEvent(ms);
            if (!e) {
                break;
            }
            if (last_match.appender != e.appender) {
                bool found = False;
                foreach string id in (keys pendingEvents) {
                    if (pendingEvents{id}.appender == e.appender) {
                        last_match.id = id;
                        last_match.appender = e.appender;
                        found = True;
                        break;
                    }
                }
                if (!found) {
                    # look into processing
                    foreach string id in (keys processingEvents) {
                        if (processingEvents{id}.appender == e.appender) {
                            last_match.id = id;
                            found = True;
                            break;
                        }
                    }
                    if (!found) {
                        # add new entry
                        last_match.id = string(lastId.next());
                    }
                    last_match.appender = e.appender;
                    pendingEvents{last_match.id} = {
                        "id": last_match.id,  # to get reason of this value duplicating key see problem description
                                              # above ThreadPool::submit(id, ...) call
                        "appender": e.appender,
                        "events": (),
                    };
                }
            }
            push pendingEvents{last_match.id}.events, e.('type', 'params');
        }

        # remove finished
        while (finishedEvents.size() > 0) {
            string id = finishedEvents.get(-1);
            remove processingEvents{id};
        }

        # now try push pending
        foreach string id in (keys pendingEvents) {
            # remove meanwhile finished if any
            while (finishedEvents.size() > 0) {
                remove processingEvents{finishedEvents.get(-1)};
            }
            # is available a free worker thread ?
            if (maxThreads >= 0 && processingEvents.size() >= maxThreads) {
                return;
            }
            if (exists processingEvents{id}) {
                # we cannot trigger new thread if is being processed
                continue;
            }
            hash<auto> e = remove pendingEvents{id};
            processingEvents{id} = e;
            # When passing "id" then no copy is passed to submit pool queue and worker may get the wrong value
            # so we must pass value in new variable which won't change meanwhile when the value is to be used.
            # It is a feature of the "submit" implementation related to parameter passing
            threadPool.submit(sub() { worker(e.id, e.appender, e.events); });
        }
    }

    #! Gets number of pending events
    public int size() {
        AutoLock al(lock);
        return LoggerAppenderQueue::size() + processingEvents.size() + pendingEvents.size();
    }
}

#! Implements passing @ref LoggerEvent to target destination
/**
    subclasses will implement e.g. logging to file, to stderr, to database etc.
    \c LoggerAppender supports sync and async logging.

    The ability to selectively enable or disable logging requests based on level in @ref Logger is
    extended in the appender via @ref LoggerFilter, which implements filtering on any criteria.

    The appender instance should be closed via @ref close() method explicitely to stop accepting
    logging events which might arrive later than destructing process has started. This process
    cannot start by design before all events has been processed as the @ref LoggerEvent instance holds refeence
    to this appender instance.
*/
public class LoggerAppender {
    public {
        #! open event
        const EVENT_OPEN = 1;
        #! logging event
        const EVENT_LOG = 2;
        #! close event
        const EVENT_CLOSE = 3;
    }

    private {
        #! The lock to ensure proper serialization with concurrent access
        RWLock lock();
    }

    private:internal {
        #! An inactive appender won't accept any logging request
        bool active = False;

        #! filter chain
        list<LoggerFilter> filters;

        #! Appender name
        string name;

        #! async queue
        *LoggerAppenderQueue queue;
    }

    #! Creates the object
    /**
        @param name the appender name
    */
    constructor(*string name) {
        self.name = name ?? "";
    }

    destructor() {
        /*
            Note that we cannot enforce calling the close() method in the destructor potentially generating an
            event, because the related member object instance (e.g. File) might be already destroyed at the time
            the event is processed. So such an appander instance should be closed explicitly in user code.

            In any case due to Qore's deterministic GC, File and other objects are deleted automatically when they
            are no longer referenced
        */
    }

    #! Returns the appender name
    public string getName() {
        return name;
    }

    #! Sets the appender queue.
    /**
        Data are passed to target device synchronously
        unless queue is assigned. In this case data are queued and
        dedicated process will process it asynchronously

        @param queue
        @throw "LOGGER-ERROR" thrown if appender is opened
    */
    public setQueue(*LoggerAppenderQueue queue) {
        AutoWriteLock awl(lock);
        if (active) {
            throw "LOGGER-ERROR", "Appender is opened";
        }
        self.queue = queue;
    }

    #! Returns async queue or @ref nothing when events are processed synchronously
    public *LoggerAppenderQueue getQueue() {
        return queue;
    }

    #! Opens logging resources
    /**
        The appender must be opened to accept any logging events
    */
    public open() {
        AutoWriteLock awl(lock);
        if (!active) {
            pushEvent(EVENT_OPEN, NOTHING);
            active = True;
        }
    }

    #! Releases any resources allocated by the appender and closes it
    public close() {
        AutoWriteLock awl(lock);
        if (active) {
            pushEvent(EVENT_CLOSE, NOTHING);
            active = False;
        }
    }

    #! Returns @ref True if the appender is open and therefore active
    public bool isOpen() {
        return active;
    }

    #! Adds a filter to the chain
    /**
        @param filter the new filter to add
        @param top if @ref True then the filter is added at the start of the filter chain, if @ref False (the default),
        the filter is added at the end of the chain
        @throw "LOGGER-ERROR" thrown if the filter is already in the list
    */
    public addFilter(LoggerFilter filter, bool top = False) {
        AutoWriteLock awl(lock);
        if (!filters) {
            filters = (filter, );
        } else {
            if (filters.contains(filter)) {
                throw "LOGGER-ERROR", "Filter already exists in list";
            }
            if (top) {
                unshift filters, filter;
            } else {
                push filters, filter;
            }
        }
    }

    #! Removes the given filter from the filter chain.
    /**
        @param filter the filter to remove
    */
    public removeFilter(LoggerFilter filter) {
        AutoWriteLock awl(lock);
        foreach LoggerFilter f in (filters) {
            if (f == filter) {
                splice filters, $#, 1;
                break;
            }
        }
    }

    #! Clears the filter chain by removing all filters
    public removeAllFilters() {
        AutoWriteLock awl(lock);
        splice filters, 0;
    }

    #! Returns the filter chain as a list
    /**
        Note that appender filter chain may be modified as internal lock is released when copy of list is returned
    */
    public list<LoggerFilter> getFilters() {
        AutoReadLock awl(lock);
        return filters ?? ();
    }

    #! Serializes the given event to put in the queue or write to the target device
    /**
        The appender implementaion can define any format for serialization. The data are passed
        to @ref processEvent() method in the \c params argument when \c type is \c EVENT_LOG.

        @return the serialized event
    */
    abstract private auto serializeImpl(LoggerEvent event);

    #! Pushes the given event on the queue or calls @ref processEvent() in case of synchronous processing
    /**
        @param type the event type
        @param params parameters for the event according to the event type

        @return @ref True if the event was accepted/processed, @ref False if not

        @see @ref processEvent()
    */
    private bool pushEvent(int type, auto params) {
        if (exists queue) {
            return queue.push(self, type, params);
        } else {
            processEvent(type, params);
            return True;
        }
    }

    #! Posts the given event to the output queue
    /**
        Invokes filters; when the event is accepted then it is posted to the queue in case of
        asynchronous processing, or it is immediately logged by the @ref processEvent() method
        in case of synchronous processing.

        @see @ref processEvent()

        @param event the event to post
        @return True if the event has been posted, @ref False if not (filtered out, appender inactive,
        event not accepted on queue, etc)
    */
    public bool post(LoggerEvent event) {
        if (!active) {
            return False;
        }
        {
            AutoReadLock arl(lock);
            foreach LoggerFilter filter in (filters) {
                int d = filter.eval(event);
                if (d == LoggerFilter::DENY) {
                    return False;
                } else if (d == LoggerFilter::ACCEPT) {
                    break;
                }
            }
        }
        auto serialized = serializeImpl(event);
        if (!exists serialized) {
            return False;
        }
        return pushEvent(EVENT_LOG, serialized);
    }

    #! Processes an event to the physical target
    /**
        @see @ref serializeImpl()

        @param type see \c "EVENT_xxx" constants
        @param params processing parameters
    */
    public processEvent(int type, auto params) {
        # the following call may return a lock holder object that will be released when the local variable goes
        # out of scope
        *object holder = ensureAtomicOperations(type);
        processEventImpl(type, params);
        # to avoid an "unreferenced-variable" warning
        remove holder;
    }

    #! Processes the event to the physical target
    /**
        Must be implemented by non-abstract subclasses

        @see @ref serializeImpl()

        @param type see \c "EVENT_xxx" constants
        @param params processing parameters
    */
    abstract public processEventImpl(int type, auto params);

    #! Returns an object that can be used to ensure atomic operations for appender operations
    private *object ensureAtomicOperations(int type) {
    }
}

#! Implements appender which does nothing
/**
    All events posted to the appender are silently ignored
*/
public class LoggerAppenderNull inherits LoggerAppender {
    constructor(*string name): LoggerAppender(name) {
    }

    private auto serializeImpl(LoggerEvent event) {
    }

    public processEventImpl(int type, auto params) {
    }
}

#! Implements pattern parsing and substitution
/**
    The pattern defines fields to be substituted with real values

    The pattern format is:

    @code
    %[<modifiers>] <word> [{<option>}]
    modifiers := [0-9.-]*
    word := [a-zA-Z]+
    option := [^}]*
    @endcode

    When a word (i.e. longer than one char) key without curly brackets is not found then in the next step is resolved its first char,
    e.g. \c "%parchive" the first step tries to resolve \c "parchive" key and if not resolved the second step \c "p" key.
    To parse in key if single step delimit a word from the next character, use curly brackets, i.e. empty option, e.g. \c "%p{}archive".
    If a key is not resolved then exception is raised.

    The following table covers various modifiers and scenarios:

    | !Format modifier | !left justify | !minimum width | !maximum width | !comment |
    | %20c             | false         | 20             | none           | Left pad with spaces if the category name is less than 20 characters long |
    | %-20c            | true          | 20             | none           | Right pad with spaces if the category name is less than 20 characters long |
    | %.30c            | NA            | none           | 30             | Truncate from the beginning if the category name is longer than 30 characters |
    | %20.30c          | false         | 20             | 30             | Left pad with spaces if the category name is shorter than 20 characters. However, if the category name is longer than 30 characters, then truncate from the beginning |
    | %-20.30c         | true          | 20             | 30             | Right pad with spaces if the category name is shorter than 20 characters. However, if the category name is longer than 30 characters, then truncate from the beginning |
*/
public class LoggerPattern {
    public {
        #! format escape character
        const ESCAPE_CHAR = "%";
    }

    private:internal {
        #! pattern
        string origPattern;
    }

    private {
        #! parsed pattern; list elements may be strings or hashes
        list<auto> parsedPattern;  # subclass may provide value e.g. for unit tests
    }

    #! Creates the object
    /**
        @param pattern the logger pattern
        @throw LOGGER-ERROR when pattern is invalid
    */
    constructor(string pattern) {
        # parse pattern
        setPattern(pattern);
    }

    #! Sets the new pattern
    /**
        @param value the logger pattern
        @throw LOGGER-ERROR when pattern is invalid
    */
    public setPattern(string value) {
        string patt = value;
        # list elements may be strings or hashes
        list<auto> pp = ();
        while (patt != "") {
            int pos = 0;
            do {
                pos = bindex(patt, ESCAPE_CHAR, pos);
                if (pos < 0) {
                    pos = patt.size();
                } else {
                    if (pos >= 0 && patt[pos+1] == ESCAPE_CHAR) {  # %%
                        splice patt, pos, 1;
                        pos++;
                        continue;
                    }
                }
                break;
            } while (True);
            if (pos >= patt.size()) {
                push pp, patt;
                patt = "";
            } else {
                if (pos > 0) {
                    push pp, substr(patt, 0, pos);
                }
                splice patt, 0, pos+1;
                # now the string is token
                *list<*string> l = regex_extract(patt, "^([0-9.-]*)([a-zA-Z]+)({[^}]*})?");
                if (l.size() < 2) {
                    throw "LOGGER-ERROR", sprintf("Wrong pattern starting %%%s", patt);
                }
                *list<*string> opt;
                hash<auto> f;
                if (l[0] != "") {
                    # opt = l[0] =~ x/^([-]?)([^.0-9]*)([.]?)([0-9]+)$/;   does not work in all cases
                    if (opt = (l[0] =~ x/^([-]?)([0-9]+)\.([0-9]+)$/) ) {
                        f.leftJustify = opt[0] == "-";
                        f.minWidth = int(opt[1]);
                        f.maxWidth = int(opt[2]);
                    } else if (opt = (l[0] =~ x/^([-]?)([0-9]+)$/) ) {
                        f.leftJustify = opt[0] == "-";
                        f.minWidth = int(opt[1]);
                    } else if (opt = (l[0] =~ x/^.([0-9]+)$/) ) {
                        f.maxWidth = int(opt[0]);
                    } else {
                        throw "LOGGER-ERROR", sprintf("Wrong pattern option starting %%%s", patt);
                    }
                }
                f.key = l[1];
                if (l.size() == 3) {
                    f.option = (regex_extract(l[2], "^{([^}]*)}$")[0]) ?? "";
                }
                patt = regex_subst(patt, "^[0-9.-]*[a-zA-Z]+({[^}]*})?", "");
                push pp, f;
            }
        }

        origPattern = value;
        parsedPattern = pp;
    }

    #! Returns the current pattern
    public string getPattern() {
        return origPattern;
    }

    #! Formats the event record with the current pattern
    /**
        @param data is passed to @ref resolveField()
        @throw LOGGER-ERROR when a key is not resolved
    */
    public string format(auto data) {
        string res = "";
        foreach auto a in (parsedPattern) {
            if (a.typeCode() == NT_STRING) {
                res += a;
            } else {
                bool fallback = False;
                *string val = resolveField(data, a.key, a.option);
                if (!exists val && a.key.size() > 1 && !exists a.option) {
                    # try one char key if key is longer and has no {}, i.e. fix non intuitive case
                    val = resolveField(data, substr(a.key, 0, 1));
                    fallback = exists val;
                }
                if (!exists val) {
                    throw "LOGGER-ERROR", sprintf("Unknown pattern token %y", a.key);
                }

                if (exists a.maxWidth) {
                    val = substr(val, 0, a.maxWidth);
                }
                if (exists a.minWidth && val.size() < a.minWidth) {
                    if (a.leftJustify) {
                        val += strmul(" ", a.minWidth - val.size());
                    } else {
                        val = strmul(" ", a.minWidth - val.size()) + val;
                    }
                }
                res += val;
                if (fallback) {
                    res += substr(a.key, 1);
                }
            }
        }
        return res;
    }

    #! Returns a formatted string for an input pattern
    /**
        @param data input context reference data
        @param key the format character
        @param option the format option value, if any

        @return the formatted string or nothing if the key is not resolved
    */
    abstract private *string resolveField(auto data, string key, *string option);
}

#! Abstract class that defines the interface for logger layouts
/**
    Event data (@ref LoggerEvent) are formatted before the record is passed to the target.
*/
public class LoggerLayout {
    #! Format event record
    abstract public string format(LoggerEvent event);
}

#! Implements the formatting of @ref LoggerEvent objects with a pattern
/**
    The \c LoggerLayoutPattern lets the user specify the output format according to conversion patterns similar to the @ref Qore::sprintf() "sprintf()"() function.

    The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

    | !Conversion character | !Meaning |
    | \c %%c | Used to output the category of the logging event, i.e. logger name |
    | \c %%C | Used to output the class name of the caller issuing the logging request, i.e. logger class name |
    | \c %%d | Used to output the date of the logging event using @ref Qore::format_date() "format_date()". Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}" |
    | \c %%E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
    | \c %%F | Used to output the file name where the logging request was issued |
    | \c %%h | Used to output the hostname where the logging event was generated |
    | \c %%l | Used to output location information of the caller which generated the logging event, i.e. \c "file:line [function()]" |
    | \c %%L | Used to output the line number from where the logging request was issued, option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
    | \c %%m | Used to output the application supplied message associated with the logging event |
    | \c %%M | Used to output the method name where the logging request was issued |
    | \c %%n | Outputs the platform dependent line separator character or characters |
    | \c %%p | Used to output the priority of the logging event |
    | \c %%P | Used to output the PID where the logging event was generated |
    | \c %%r | Used to output the number of milliseconds elapsed from the construction of the layout until the creation of the logging event, option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
    | \c %%t | Used to output the thread id that generated the logging event, option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
    | \c %%u | Used to output logging event unique id, option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
    | \c %%x | Used to output exception string using @ref Util::get_exception_string() |
    | \c %% | The literal percent sign. \c "%%" will print a \c "%" sign |

    For example, the \c LoggerLayoutPattern with the conversion pattern \c "%r [%t] %-5p %c - %m%n" will output something like:

    @verbatim
        176 [23] INFO  MyLogger - New record created
    @endverbatim
*/
public class LoggerLayoutPattern inherits LoggerLayout, public LoggerPattern {
    public {
        #! default layout pattern
        const DEFAULT_PATTERN = "%r [%t] %p %c - %m%n";
        #! default date format
        const DEFAULT_DATE_FORMAT = "YYYY-MM-DD HH:mm:SS.u";
        #! This hostname
        const HostName = gethostname();
    }

    #! Creates the object
    /**
        @param pattern the logger layout pattern
    */
    constructor(string pattern = DEFAULT_PATTERN): LoggerPattern(pattern) {
    }

    #! Returns the line delimiter used on the current OS
    static public string getLineDelimiter() {
        switch (PlatformOS) {
        case "Windows":
            return "\r\n";
        default:
            return "\n";
        }
    }

    #! Formats an event record
    /** @param event the event to format
        @return a formatted string for the event
    */
    public string format(LoggerEvent event) {
        return LoggerPattern::format(event);
    }

    #! Returns the value corresponding to a particular key
    /**
        @param event (@ref LoggerEvent)
        @param key the single-character formatting code
        @param option optional supporting information for \a key
    */
    private *string resolveField(auto event, string key, *string option) {
        if (!(event instanceof LoggerEvent)) {
            throw "LOGGER-ERROR", "Unsupported event type";
        }
        *string res;
        switch (key) {
            case "c":
                res = event.getCategoryName();
                break;
            case "C":
                res = event.getFullQualifiedClassname();
                break;
            case "d":
                if (option) {
                    res = format_date(option, event.getTimeStamp());
                } else {
                    res = format_date(DEFAULT_DATE_FORMAT, event.getTimeStamp());
                }
                break;
            case "E":
                res = ENV{option};
                break;
            case "F":
                res = event.getLocationInfo().file;
                break;
            case "h":
                res = HostName;
                break;
            case "l":
                hash<CallStackInfo> csi = event.getLocationInfo();
                res = sprintf("%s:%d [%s()]", csi.file, csi.line, csi.function);
                break;
            case "L":
                res = sprintf(option ?? "%d", event.getLocationInfo().line);
                break;
            case "m":
                res = event.getMessage();
                break;
            case "M":
                res = event.getLocationInfo().function;
                break;
            case "n":
                res = getLineDelimiter();
                break;
            case "p":
                res = event.getLevel().getStr();
                break;
            case "P":
                res = getpid().toString();
                break;
            case "r":
                res = sprintf(option ?? "%d", get_duration_milliseconds(event.getTimeStamp() - LoggerEvent::getStartTime()));
                break;
            case "t":
                res = sprintf(option ?? "%d", event.getThreadId());
                break;
            case "u":
                res = sprintf(option ?? "%d", event.getUniqueId());
                break;
            case "x":
                if (event.getThrowableInfo()) {
                    res = get_exception_string(event.getThrowableInfo());
                } else {
                    res = "";
                }
                break;
        }
        return res;
    }
}

#! Implements an appender with a layout
/**
    The layout is responsible for formatting the @ref LoggerEvent according to the user's wishes,
    whereas an appender takes care of sending the formatted output to its destination.

    It is used typically for appenders implementing logging to a file
*/
public class LoggerAppenderWithLayout inherits LoggerAppender {
    private:internal {
        #! assigned layout
        LoggerLayout layout;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
    */
    constructor(*string name, LoggerLayout layout): LoggerAppender(name) {
        self.layout = layout;
    }

    #! Assigns a layout to the appender
    /**
    * @param layout the layout for the appender
    */
    public setLayout(LoggerLayout layout) {
        self.layout = layout;
    }

    #! Returns the layout for the appender
    public LoggerLayout getLayout() {
        return layout;
    }

    #! Returns the value formatted using the layout pattern
    /**
        @param event the event to serialize
    */
    private auto serializeImpl(LoggerEvent event) {
        return layout.format(event);
    }
}

#! implements appender writing to an output stream via @ref Qore::StreamWriter "StreamWriter"
/**
    Qore streams are not designed to accept input from multiple threads simultaneously, so writing must be serialized and processed
    in a dedicated thread
*/
public class LoggerAppenderStream inherits LoggerAppenderWithLayout {
    private:internal {
        #! stream writer
        StreamWriter writer;
        #! closed flag
        bool closed = False;
        #! assign thread for stream
        bool assignThread;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param writer the stream to write to
    */
    constructor(*string name, LoggerLayout layout, StreamWriter writer): LoggerAppenderWithLayout(name, layout) {
        self.writer = writer;
        assignThread = writer.getOutputStream().getThreadId() == -1;
    }

    #! Returns the stream writer object
    public StreamWriter getStreamWriter() {
        return writer;
    }

    #! Returns @ref True if assigning a thread for a stream
    public bool hasAssignThread() {
        return assignThread;
    }

    #! Processes open, log, and close events with the output stream; all other events are ignored
    public processEventImpl(int type, auto params) {
        if (type == EVENT_OPEN) {
            if (closed) {
                # OutputStream does not provide open method
                throw "LOGGER-ERROR", "Cannot reopen stream";
            }
        } else {
            if (assignThread) {
                writer.getOutputStream().reassignThread();
            }
            switch (type) {
                case EVENT_LOG:
                    writer.print(params);
                    break;
                case EVENT_CLOSE:
                    writer.getOutputStream().close();
                    closed = True;
                    break;
            }
            on_exit if (assignThread) {
                writer.getOutputStream().unassignThread();
            }
        }
    }
}

#! Implements appender writing to a file
/**
    No multi-threading protection is implemented in the class; the @ref Qore::File "File" class is reused
*/
public class LoggerAppenderFile inherits LoggerAppenderWithLayout {
    public {
        #! reopen event
        const EVENT_REOPEN = 1001;

        #! Default open flags
        const DEFAULT_OPEN_FLAGS = O_CREAT | O_APPEND | O_WRONLY;
    }

    private {
        File file;
        string fileName;
        *string encoding;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param filename the output filename
        @param encoding the file's output encoding
    */
    constructor(*string name, LoggerLayout layout, string filename, *string encoding)
            : LoggerAppenderWithLayout(name, layout) {
        file = new File(encoding);
        fileName = filename;
        self.encoding = encoding;
    }

    #! Returns the file object for the appender
    public File getFile() {
        return file;
    }

    #! Returns the current filename
    public string getFileName() {
        return fileName;
    }

    #! Processes open, close, and log events with the file and ignores all other events
    /**
        @param type the event type
        @param params parameters for the event
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_OPEN:
                openFile();
                break;
            case EVENT_CLOSE:
                closeFile();
                break;
            case EVENT_REOPEN:
                reopen();
                break;
            case EVENT_LOG:
                file.print(params);
                break;
        }
    }

    openFile() {
        file.open2(fileName, DEFAULT_OPEN_FLAGS);
    }

    closeFile() {
        closeFileStatic(file);
    }

    static closeFileStatic(File file) {
        try {
            file.close();
        } catch (hash<ExceptionInfo> ex) {
            if (ex.err != "ILLEGAL-EXPRESSION") {
                # catch unclosable stdxxx errors
                rethrow;
            }
        }
    }

    reopen() {
        # issue #4842: reopen atomically without closing
        file.open2(fileName, DEFAULT_OPEN_FLAGS);
    }
}

%ifdef HAVE_TERMIOS
#! Implements appender writing to a stdout file
/**
    No multi-threading protection is implemented in the class; the @ref Qore::stdout "stdout" instance is reused.
    Unavailable when @ref Qore::PO_NO_TERMINAL_IO parse option is applied.
*/
public class LoggerAppenderStdOut inherits LoggerAppenderWithLayout {
    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
    */
    constructor(*string name, LoggerLayout layout): LoggerAppenderWithLayout(name, layout) {
    }

    #! Processes log events with the file and ignores all other events including open, close
    /**
        @param type the event type
        @param params parameters for the event
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_LOG:
                stdout.print(params);
                break;
        }
    }
}

#! Implements appender writing to a stderr file
/**
    No multi-threading protection is implemented in the class; the @ref Qore::stderr "stderr" instance is reused.
    Unavailable when @ref Qore::PO_NO_TERMINAL_IO parse option is applied.
*/
public class LoggerAppenderStdErr inherits LoggerAppenderWithLayout {
    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
    */
    constructor(*string name, LoggerLayout layout): LoggerAppenderWithLayout(name, layout) {
    }

    #! Processes log events with the file and ignores all other events including open, close
    /**
        @param type the event type
        @param params parameters for the event
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_LOG:
                stderr.print(params);
                break;
        }
    }
}
%endif

#! Abstract class for file appenders with rotation support
public class AbstractLoggerAppenderFileRotate inherits public LoggerAppenderFile {
    public {
        #! rotate event
        const EVENT_ROTATE = 10001;
        #! default value for rotation chain
        const DEFAULT_ROTATION_COUNT = 10;
    }

    constructor(*string name, LoggerLayout layout, *string encoding)
            : LoggerAppenderFile(name, layout, "", encoding) {}

    #! Pushes rotate event
    /**
        The current log file will be closed and opened. If the file exists, then it is ovewritten

        @throw LOGGER-ERROR if rotation is disabled
    */
    public rotate() {
        if (isOpen()) {
            if (getCount() <= 0) {
                throw "LOGGER-ERROR", "Rotation is disabled";
            }
            pushEvent(EVENT_ROTATE, NOTHING);
        }
    }

    #! Abstract method to get count of rotation objects
    public abstract int getCount();
}

#! Implements appender writing to a file with file rotation support
/**
    The events will be logged to a file until rotation occurs.
    At that moment the current file is closed, archive chain is moved,
    new file is created and logging continues there.
*/
public class LoggerAppenderFileRotate inherits public AbstractLoggerAppenderFileRotate, private LoggerPattern {
    public {
        #! default archive pattern
        const DEFAULT_ARCHIVE_PATTERN = "%p%f.%i";
    }

    private:internal {
        int count;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param filename with pattern support; see below for more information
        @param count number of files in rotation chain, if count is <=0 then no ratation is performed
        @param archive pattern to evaluate archive filename; see below for more information
        @param encoding the encoding of the output file

        The following table explains the characters used in @ref LoggerPattern for both filename and archive parameter

        | !Conversion character | !Meaning |
        | \c %%s | Used to output the OS directory separator, i.e. "\" or "/" |
        | \c %%c | Used to output the appender name |
        | \c %%C | Used to output the appender class name |
        | \c %%E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | \c %% | The literal percent sign. \c "%%" will print a \c "%" sign |

        The following table explains the characters used in @ref LoggerPattern for archive parameter only

        | !Conversion character | !Meaning |
        | \c %%P | Used to output the current logging path with filename |
        | \c %%p | Used to output the current logging path |
        | \c %%f | Used to output the current logging filename |
        | \c %%i | Used to output the current file index from 1 to count. option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
        | \c %%n | Used to output the rotation count. Option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |

        For example, the archive pattern \c "%p%f.%i" rotates log file \c "/var/run/log/MyLogger.log" to:
        \c "/var/run/log/MyLogger.log.1" \c "/var/run/log/MyLogger.log.2" \c "/var/run/log/MyLogger.log.3".
    */
    constructor(*string name, LoggerLayout layout, string filename, int count = DEFAULT_ROTATION_COUNT,
            string archive = DEFAULT_ARCHIVE_PATTERN, *string encoding)
            : AbstractLoggerAppenderFileRotate(name, layout, encoding), LoggerPattern(filename) {
        fileName = format(NOTHING);  # no dynamic vars as timestamp
        self.count = count;
        setPattern(archive);
    }

    #! Returns a string for a format field for a pattern-based filename
    /**
        @param data input context reference data
        @param key the format character
        @param option the format option value, if any

        @return the formatted string
    */
    private *string resolveField(auto data, string key, *string option) {
        *string res;
        switch (key) {
            case "c":
                res = get_class_name(self);
                break;
            case "C":
                res = getName();
                break;
            case "E":
                res = ENV{option};
                break;
            case "s":
                res = DirSep;
                break;
        }
        if (data) {  # archive pattern
            switch (key) {
                case "i":
                    res = sprintf(option ?? "%d", data.index);
                    break;
                case "n":
                    res = sprintf(option ?? "%d", data.count);
                    break;
                case "P":
                    res = data.filename;
                    break;
                case "p": # path
                    res = dirname(data.filename);
                    if (res != DirSep) {
                        res += DirSep;
                    }
                    break;
                case "f": # filename
                    res = basename(data.filename);
                    break;
            }
        }
        return res;
    }

    #! Implements filename rotation; handles the open and rotate events directly
    /** All other events are handled by subclasses

        @param type the event type
        @param params event parameters
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_ROTATE:
                if (count > 0 && is_file(fileName)) {
                    list<string> fn = ();
                    int i = 0;
                    while (True) {
                        push fn, getArchiveFileName(i+1);
                        if (!is_dir(dirname(fn[i]))) {
                            mkdir_ex(dirname(fn[i]), 0777, True);
                        }
                        if (i >= count-1 || !is_file(fn[i])) {
                            # find a gap in chain or stop at the last file
                            break;
                        }
                        i++;
                    }
                    while (i > 0) {
                        # shift files till a gap or last file
                        rename(fn[i-1], fn[i]);
                        i--;
                    }
                    # issue #4842: rotate atomically
                    File f(encoding);
                    # first rename old file
                    rename(fileName, fn[0]);
                    # reopen file atomically
                    file.open2(fileName, O_CREAT | O_APPEND | O_WRONLY | O_TRUNC);
                }
                break;
            default:
                LoggerAppenderFile::processEventImpl(type, params);
        }
    }

    #! Returns the archive filename
    /**
        @param idx the index of file (1..count)
    */
    public string getArchiveFileName(int idx) {
        return format({
            "filename": fileName,
            "count": count,
            "index": idx,
        });
    }

    #! Returns max.number of files in chain
    public int getCount() {
        return count;
    }
}

#! Implemants appender writing to a file with file circular rotation support
/**
    The events will be logged to a file until rotation occurs.
    At that moment the current file is closed, next file is created
    and logging continues to the new file.
*/
public class LoggerAppenderFileRing inherits public AbstractLoggerAppenderFileRotate, private LoggerPattern {
    public {
        #! default date format
        const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
    }

    private:internal {
        hash<auto> patternData;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param pattern to generate the file name; see information below
        @param count number of files in ring, if count is <=0 then no ratation is performed
        @param encoding the encoding of the output file

        The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

        | !Conversion character | !Meaning |
        | i | Used to output the current file index from 0 to count-1. option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
        | n | Used to output the rotation count. Option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
        | c | Used to output the appender name. |
        | C | Used to output the appender class name. |
        | d | Used to output the date of the logging event using @ref Qore::format_date() "format_date()". Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |
        | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | % | The literal percent sign. \c "%%" will print a \c "%" sign |

        For example, the pattern \c "/var/run/log/%c.log.%i{%03d}" creates the following file names:
        \c "/var/run/log/MyLogger.log.000", \c "/var/run/log/MyLogger.log.001" etc.
    */
    constructor(*string name, LoggerLayout layout, string pattern, int count = DEFAULT_ROTATION_COUNT,
            *string encoding): AbstractLoggerAppenderFileRotate(name, layout, encoding), LoggerPattern(pattern) {
        # set a provisional filename, to be updated when file is opened
        patternData.timestamp = now_us();
        patternData.count = count;
        patternData.index = 0;
        fileName = format(patternData);
    }

    #! Returns a string for a format field for a pattern-based filename
    /**
        @param data input context reference data
        @param key the format character
        @param option the format option value, if any

        @return the formatted string
    */
    private *string resolveField(auto data, string key, *string option) {
        *string res;
        switch (key) {
            case "i":
                res = sprintf(option ?? "%d", data.index);
                break;
            case "n":
                res = sprintf(option ?? "%d", data.count);
                break;
            case "c":
                res = get_class_name(self);
                break;
            case "C":
                res = getName();
                break;
            case "d":
                if (option) {
                    res = format_date(option, data.timestamp);
                } else {
                    res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                }
                break;
            case "E":
                res = ENV{option};
                break;
        }
        return res;
    }

    #! Implements filename rotation; handles the open and rotate events directly; passes all other events to the subclass for handling
    /**
        @param type the event type
        @param params event parameters
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_OPEN:
                # find newest file
                patternData.timestamp = now_us();
                int last_idx = 0;
                if (patternData.count > 0) {
                    date last_stamp;
                    hash<auto> pd = patternData;
                    for (int i=0; i < patternData.count; i++) {
                        pd.index = i;
                        string fn = format(pd);
                        *hash<StatInfo> si = hstat(fn);
                        if (si) {
                            if (!last_stamp || si.mtime > last_stamp) {
                                last_stamp = si.mtime;
                                last_idx = i;
                            }
                        }
                    }
                }
                patternData.index = last_idx;
                fileName = format(patternData);
                LoggerAppenderFile::processEventImpl(type, params);
                break;
            case EVENT_ROTATE:
                if (patternData.count > 0) {
                    # issue #4842: rotate atomically
                    patternData.index = (patternData.index + 1) % patternData.count;
                    patternData.timestamp = now_us();
                    fileName = format(patternData);
                    # create new file and reopen atomically
                    file.open2(fileName, O_CREAT | O_APPEND | O_WRONLY | O_TRUNC);
                }
                break;
            default:
                LoggerAppenderFile::processEventImpl(type, params);
        }
    }

    #! Returns number of files in ring
    public int getCount() {
        return patternData.count;
    }

    #! Returns current ring index being used for logging
    public int getCurrentIndex() {
        return patternData.index;
    }
}

#! Implements appender writing to a file with archive support
/**
    The events will be logged to a file until archiving is triggered.
    At that moment the current file is closed, moved to file with name evaluated in runtime
    from the archive pattern set in the object, the new file is created, and logging continues to that file.
    The archive never overwrites any existing file.
*/
public class LoggerAppenderFileArchive inherits public LoggerAppenderFile, private LoggerPattern {
    public {
        #! archive event
        const EVENT_ARCHIVE = 20;
        #! default date format
        const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
        #! default archive pattern
        const DEFAULT_ARCHIVE_PATTERN = "%p%f.%d";
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param filename with pattern support; see below for more information
        @param archive pattern to evaluate archive filename; see below for more information
        @param encoding the output file's encoding

        The following table explains the characters used in @ref LoggerPattern for both filename and archive parameter

        | !Conversion character | !Meaning |
        | \c %%s | Used to output the OS directory separator, i.e. "\" or "/" |
        | \c %%c | Used to output the appender name |
        | \c %%C | Used to output the appender class name |
        | \c %%E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | \c %% | The literal percent sign. \c "%%" will print a \c "%" sign |

        The following table explains the characters used in @ref LoggerPattern for archive parameter only

        | !Conversion character | !Meaning |
        | \c %%P | Used to output the current logging path with filename |
        | \c %%p | Used to output the current logging path |
        | \c %%f | Used to output the current logging filename |
        | \c %%d | Used to output the date of the logging event using @ref Qore::format_date() "format_date()". Option may specify date \
            format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |

        For example, the archive pattern \c "%p/archive/%d/%f" archives log file \c "/var/run/log/MyLogger.log" to:
        \c "/var/run/log/archive/20180120102030/MyLogger.log".
    */
    constructor(*string name, LoggerLayout layout, string filename, string archive = DEFAULT_ARCHIVE_PATTERN,
            *string encoding): LoggerAppenderFile(name, layout, filename, encoding), LoggerPattern(filename) {
        fileName = format(NOTHING);  # no dynamic vars as timestamp
        setPattern(archive);
    }

    #! Returns a string for a format field for a pattern-based filename or archive file name
    /**
        @param data if @ref nothing, then this argument specifies the logging filename, otherwise is specifies the archive pattern
        @param key the format character
        @param option the format option value, if any

        @return the formatted string
    */
    private *string resolveField(auto data, string key, *string option) {
        *string res;
        switch (key) {
            case "c":
                res = get_class_name(self);
                break;
            case "C":
                res = getName();
                break;
            case "E":
                res = ENV{option};
                break;
            case "s":
                res = DirSep;
                break;
        }
        if (data) {  # archive pattern
            switch (key) {
                case "d":
                    if (option) {
                        res = format_date(option, data.timestamp);
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                    }
                    break;
                case "P":
                    res = data.filename;
                    break;
                case "p": # path
                    res = dirname(data.filename);
                    if (res != DirSep) {
                        res += DirSep;
                    }
                    break;
                case "f": # filename
                    res = basename(data.filename);
                    break;
            }
        }
        return res;
    }

    #! Implements archiving, handles the archive event directly, passes all other events to the subclass for handling
    /**
        @param type the event code
        @param params event parameters
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_ARCHIVE:
                mkdir_ex(dirname(params), 0777, True);
                if (isOpen()) {
                    # issue #4842: do not close the file here, allow it to be reopened atomically
                    rename(fileName, params);
                    LoggerAppenderFile::processEventImpl(EVENT_OPEN);
                } else {
                    rename(fileName, params);
                }
                break;
            default:
                LoggerAppenderFile::processEventImpl(type, params);
        }
    }

    #! Posts an archive event
    /**
        rename logging file and open new one
        @return archive file name

        @throw LOGGER-ERROR if target file name is not correct or target file already exists
    */
    public string archive() {
        string afn = getArchiveFileName();
        if (afn == "") {
            throw "LOGGER-ERROR", "Empty target filename";
        }
        if (normalize_dir(afn) == normalize_dir(fileName)) {
            throw "LOGGER-ERROR", "Source and target path are equal";
        }
        if (is_dir(afn)) {
            throw "LOGGER-ERROR", "Target is directory";
        }
        if (is_file(afn)) {
            throw "LOGGER-ERROR", "Target file already exists";
        }
        pushEvent(EVENT_ARCHIVE, afn);
        return afn;
    }

    #! Returns the archive filename
    /**
        The pattern may contain date fields so the result may differ when
        executed multiple times
    */
    public string getArchiveFileName() {
        return format({
            "timestamp": now_us(),
            "filename": fileName,
        });
    }
}

#! Implements a general event filtering class
/**
    Users should extend this class to implement customized logging
    event filtering. The filter consists of a linear chain of
    particular filters evaluating if the event should be immediately accepted, rejected
    or passed to next filter.
*/
public class LoggerFilter {
    public {
        #! The event will be processed
        const ACCEPT = 1;

        #! No decision could be made, further filtering should occur
        const NEUTRAL = 0;

        #! The event should not be processed
        const DENY = -1;
    }

    #! Performs filtering logic on an event and returns the decision for the event
    /**
        The method should be overridden to implement a real rule. The default result is @ref NEUTRAL

        @param event the log event

        @return the result of evaluating the event (the default for this method is @ref NEUTRAL)
    */
    public int eval(LoggerEvent event) {
        return NEUTRAL;
    }
}

#! Implements the filter according event @ref LoggerLevel
/**
    When @ref LoggerEvent::getLevel does not satisfy the filter condition, then
    logging is rejected.

    The min and max levels define the range to be logged (if min <= max.level) or range which won't be logged (if max < min.level)
*/
public class LoggerFilterLevel inherits LoggerFilter {
    private:internal {
        #! min.level
        LoggerLevel minLevel;
        #! max.level
        LoggerLevel maxLevel;
    }

    #! Creates the object
    /**
        @param min_value the minimum logging level
        @param max_value the maximum logging level
    */
    constructor(LoggerLevel min_value = LoggerLevel::getLevelInfo(), LoggerLevel max_value = LoggerLevel::getLevelOff()) {
        setMinLevel(min_value);
        setMaxLevel(max_value);
    }

    #! Creates the object
    /**
        @param min_value the minimum logging level
        @param max_value the maximum logging level
    */
    constructor(int min_value, int max_value = LoggerLevel::OFF) {
        setMinLevel(min_value);
        setMaxLevel(max_value);
    }

    #! Creates the object
    /**
        @param min_value the minimum logging level
        @param max_value the maximum logging level
    */
    constructor(string min_value, string max_value = "OFF") {
        setMinLevel(min_value);
        setMaxLevel(max_value);
    }

    #! Sets the minimum logging level
    /**
        @param value the minimum logging level
    */
    public setMinLevel(LoggerLevel value) {
        minLevel = value;
    }

    #! Sets the minimum logging level
    /**
        @param value the minimum logging level
    */
    public setMinLevel(int value) {
        setMinLevel(LoggerLevel::getLevel(value));
    }

    #! Sets the minimum logging level
    /**
        @param value the minimum logging level
    */
    public setMinLevel(string value) {
        setMinLevel(LoggerLevel::getLevel(value));
    }

    #! Returns the minimum logging level
    public LoggerLevel getMinLevel() {
        return minLevel;
    }

    #! Sets the maximum logging level
    /**
        @param value the maximum logging level
    */
    public setMaxLevel(LoggerLevel value) {
        maxLevel = value;
    }

    #! Sets the maximum logging level
    /**
        @param value the maximum logging level
    */
    public setMaxLevel(int value) {
        setMaxLevel(LoggerLevel::getLevel(value));
    }

    #! Sets the maximum logging level
    /**
        @param value the maximum logging level
    */
    public setMaxLevel(string value) {
        setMaxLevel(LoggerLevel::getLevel(value));
    }

    #! Returns the maximum logging level
    public LoggerLevel getMaxLevel() {
        return maxLevel;
    }

    #! Implements filtering by level
    public int eval(LoggerEvent event) {
        if (maxLevel.isGreaterOrEqual(minLevel)) {
            if (!(event.getLevel().isGreaterOrEqual(minLevel) && maxLevel.isGreaterOrEqual(event.getLevel()))) {
                return DENY;
            }
        } else {
            if (event.getLevel().isGreaterOrEqual(maxLevel) && minLevel.isGreaterOrEqual(event.getLevel())) {
                return DENY;
            }
        }
        return NEUTRAL;
    }
}

#! Implements filtering according to a regular expression on the event message
/**
    The rendered event message is tested using a regular expression, and if it does not match the
    expected result, then logging is rejected
*/
public class LoggerFilterRegex inherits LoggerFilter {
    private:internal {
        #! regular string
        string regexStr;
        #! expected result
        bool regexResult;
    }

    #! Creates the object
    /**
        @param regex_str the regular expression to use
        @param regex_result @ref True for a positive match, @ref False for a negative match
    */
    constructor(string regex_str = "", bool regex_result = True) {
        setRegex(regex_str, regex_result);
    }

    #! Sets the regular expression and the expected result for the filter
    /**
        @param regex_str the regular expression to use
        @param regex_result @ref True for a positive match, @ref False for a negative match
    */
    public setRegex(string regex_str, bool regex_result = True) {
        regexStr = regex_str;
        regexResult = regex_result;
    }

    #! Returns the current regex
    public string getRegex() {
        return regexStr;
    }

    #! Returns the expected result
    public bool getRegexResult() {
        return regexResult;
    }

    #! Evaluates the regex and compares with the expected result
    public int eval(LoggerEvent event) {
        if (event.getMessage().regex(regexStr) != regexResult) {
            return DENY;
        } else {
            return NEUTRAL;
        }
    }
}

#! This abstract class defines the logging interface
public class LoggerInterface inherits Qore::Serializable {
    #! Returns @ref True if the passed logger is the logger used to log, @ref False if not
    bool isLogger(LoggerInterface logger) {
        return logger == self;
    }

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract log(LoggerLevel level, string message, ...);

    #! Logs a message using the provided logging level
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract log(int level, string message, ...);

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract log(string level, string message, ...);

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    abstract logArgs(LoggerLevel level, string message, *softlist<auto> args);

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    abstract logArgs(int level, string message, *softlist<auto> args);

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    abstract logArgs(string level, string message, *softlist<auto> args);

    #! Logs an already prepared logging event object
    /**
        @param event the event to log
    */
    abstract logEvent(LoggerEvent event);

    #! Logs a message object with the TRACE level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract trace(string message, ...);

    #! Logs a message object with the DEBUG level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract debug(string message, ...);

    #! Logs a message object with the INFO level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract info(string message, ...);

    #! Logs a message object with the WARN level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract warn(string message, ...);

    #! Logs a message object with the ERROR level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract error(string message, ...);

    #! Logs a message object with the FATAL level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract fatal(string message, ...);

    #! Performs logging of assertions
    /**
        If the \a assertion parameter is @ref False, then the message is logged
        using the ERROR level.

        @see @ref log()

        @param assertion the boolean assertion value
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract assertLog(bool assertion, string message, ...);

    #! Logs the variable name and value using TRACE level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    abstract traceVar(string var_name, auto value);

    #! Logs the variable name and value using DEBUG level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    abstract debugVar(string var_name, auto value);

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    abstract bool isEnabledFor(LoggerLevel level);

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    abstract bool isEnabledFor(int level);

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    abstract bool isEnabledFor(string level);

    #! Checks whether this Logger is enabled for the TRACE Level
    abstract bool isTraceEnabled();

    #! Checks whether this Logger is enabled for the DEBUG Level
    abstract bool isDebugEnabled();

    #! Checks whether this Logger is enabled for the INFO Level
    abstract bool isInfoEnabled();

    #! Checks whether this Logger is enabled for the WARN Level
    abstract bool isWarnEnabled();

    #! Checks whether this Logger is enabled for the ERROR Level
    abstract bool isErrorEnabled();

    #! Checks whether this Logger is enabled for the FATAL Level
    abstract bool isFatalEnabled();

    #! Sets the logging level
    /**
        @param level if nothing then inherits level from parent
    */
    abstract setLevel(*LoggerLevel level);

    #! Sets the logging level
    /**
        @param level the logging level as a string
    */
    abstract setLevel(string level);

    #! Sets the logging level
    /**
        @param level the logging level to set
    */
    abstract setLevel(int level);

    #! Decrement logger level
    /**
        @return current \c LoggerLevel
    */
    abstract *LoggerLevel decLevel();

    #! Increment logger level
    /**
        @return current \c LoggerLevel
    */
    abstract *LoggerLevel incLevel();

    #! Returns the logging level
    /**
        @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
        @throw LOGGER-ERROR if cannot get effective level from hierarchy
    */
    abstract *LoggerLevel getLevel(bool effective = True);
}

#! Class handling a LoggerInterface object as a member and providing atomic logging through it
public class LoggerWrapper inherits LoggerInterface {
    private {
        #! The logger interface
        transient *LoggerInterface logger;
    }

    #! Creates the object with no logger
    constructor() {
    }

    #! Creates the object with a logger
    constructor(LoggerInterface logger) {
        self.logger = logger;
    }

    #! Returns @ref True if the passed logger is the logger used to log, @ref False if not
    bool isLogger(LoggerInterface logger) {
        return logger == self.logger;
    }

    #! Accepts a LoggerInterface object for logging (or clears it)
    setLogger(*LoggerInterface logger) {
        self.logger = logger;
    }

    #! Logs a message using the provided logging level if a logger is set
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    log(LoggerLevel level, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, argv);
        }
    }

    #! Logs a message using the provided logging level if a logger is set
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    log(int level, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, argv);
        }
    }

    #! Logs a message using the provided logging level if a logger is set
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    log(string level, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, argv);
        }
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /** Logging is only performed if a logger is set

        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    logArgs(LoggerLevel level, string message, *softlist<auto> args) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, args);
        }
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /** Logging is only performed if a logger is set

        @param level the logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    logArgs(int level, string message, *softlist<auto> args) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, args);
        }
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /** Logging is only performed if a logger is set

        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    logArgs(string level, string message, *softlist<auto> args) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, args);
        }
    }

    #! Logs an already prepared logging event object
    /**
        @param event the event to log
    */
    logEvent(LoggerEvent event) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logEvent(event);
        }
    }

    #! Logs a message object with the TRACE level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    trace(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(LoggerLevel::getLevelTrace(), message, argv);
        }
    }

    #! Logs a message object with the DEBUG level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    debug(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(LoggerLevel::getLevelDebug(), message, argv);
        }
    }

    #! Logs a message object with the INFO level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    info(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(LoggerLevel::getLevelInfo(), message, argv);
        }
    }

    #! Logs a message object with the WARN level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    warn(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(LoggerLevel::getLevelWarn(), message, argv);
        }
    }

    #! Logs a message object with the ERROR level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    error(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(LoggerLevel::getLevelError(), message, argv);
        }
    }

    #! Logs a message object with the FATAL level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    fatal(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(LoggerLevel::getLevelFatal(), message, argv);
        }
    }

    #! Performs logging of assertions
    /**
        If the \a assertion parameter is @ref False, then the message is logged
        using the ERROR level.

        @see @ref log()

        @param assertion the boolean assertion value
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    assertLog(bool assertion, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.assertLogArgs(assertion, message, argv);
        }
    }

    #! Logs the variable name and value using TRACE level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    traceVar(string var_name, auto value) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.traceVar(var_name, value);
        }
    }

    #! Logs the variable name and value using DEBUG level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    debugVar(string var_name, auto value) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.debugVar(var_name, value);
        }
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    bool isEnabledFor(LoggerLevel level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isEnabledFor(level);
        }
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    bool isEnabledFor(int level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isEnabledFor(level);
        }
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    bool isEnabledFor(string level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isEnabledFor(level);
        }
    }

    #! Checks whether this Logger is enabled for the TRACE Level
    bool isTraceEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isTraceEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the DEBUG Level
    bool isDebugEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isDebugEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the INFO Level
    bool isInfoEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isInfoEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the WARN Level
    bool isWarnEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isWarnEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the ERROR Level
    bool isErrorEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isErrorEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the FATAL Level
    bool isFatalEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isFatalEnabled();
        }
    }

    #! Sets the logging level
    /**
        @param level if nothing then inherits level from parent
    */
    setLevel(*LoggerLevel level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.setLevel(level);
        }
    }

    #! Sets the logging level
    /**
        @param level the logging level as a string
    */
    setLevel(string level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.setLevel(level);
        }
    }

    #! Sets the logging level
    /**
        @param level the logging level to set
    */
    setLevel(int level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.setLevel(level);
        }
    }

    #! Decrement logger level
    /**
        @return current \c LoggerLevel
    */
    *LoggerLevel decLevel() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.decLevel();
        }
    }

    #! Increment logger level
    /**
        @return current \c LoggerLevel
    */
    *LoggerLevel incLevel() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.incLevel();
        }
    }

    #! Returns the logging level
    /**
        @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
        @throw LOGGER-ERROR if cannot get effective level from hierarchy
    */
    *LoggerLevel getLevel(bool effective = True) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.getLevel(effective);
        }
    }

    #! Returns the logger interface for logging
    private *LoggerInterface getLogger() {
        return self.logger;
    }
}

#! Implements main logger class whose instance will be used by user code when logging
/**
    The Logger object is provided to user code. When a log is triggered, the message, arguments, current code
    position, and time are appended as a @ref LoggerEvent event instance when
    the logging level is enabled. The event is passed to all registered appenders in the given Logger as well as
    in parents in the hierarchy when additivity is enabled.
*/
public class Logger inherits LoggerInterface {
    private:internal {
        #! The lock to protect object manipulation
        transient RWLock lock();

        #! The lock to protect access to parent/child hierarchy
        static RWLock hierarchyLock();

        #! Logger additivity
        /** If set to true then child loggers will inherit the appenders of their ancestors by default
        */
        bool additivity = True;

        #! The assigned Logger level. If @ref nothing, the parent level is used
        *LoggerLevel currentLevel;

        #! The name of this Logger instance.
        string name;

        #! The parent logger. Unassigned if this is the root logger.
        *Logger parent;

        #! A collection of appenders linked to this logger.
        transient list<LoggerAppender> appenders;
    }

    #! Creates the object
    /**
        @param name the name of the object
    */
    constructor(string name = "") {
        self.name = name;
    }

    #! Creates the object
    /**
        @param name the name of the object
        @param level the initial level for the logger
    */
    constructor(string name, LoggerLevel level) {
        self.name = name;
        currentLevel = level;
    }

    #! Creates the object with an empty name and the given initial level
    /**
        @param level the initial level for the logger
    */
    constructor(LoggerLevel level) {
        self.name = "";
        currentLevel = level;
    }

    destructor() {
        setParent(NOTHING);
    }

    #! Returns the logger name
    public string getName() {
        return name;
    }

    #! Returns the parent logger, if any
    public *Logger getParent() {
        return parent;
    }

    #! Sets the parent logger
    /**
        @param value the parent logger
        @throw LOGGER-ERROR in case of circular reference
    */
    public setParent(*Logger value) {
        AutoWriteLock awl(lock);
        if (value) {
            AutoWriteLock awhl(Logger::hierarchyLock);
            *Logger l = self;
            while (exists l) {
                if (l == value) {
                    throw "LOGGER-ERROR", "Circular logger chain";
                }
                l = l.getParent();
            }
        }
        parent = value;
    }

    #! Returns the logging level
    /**
        @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
        @throw LOGGER-ERROR if cannot get effective level from hierarchy
    */
    public *LoggerLevel getLevel(bool effective = True) {
        if (effective) {
            AutoReadLock awhl(Logger::hierarchyLock);
            *Logger l = self;
            *LoggerLevel rv;
            while (!exists (rv = l.getLevel(False))) {
                l = l.getParent();
                if (!exists l) {
                    throw "LOGGER-ERROR", "Cannot get effective level";
                }
            }
            return rv;
        } else {
            return currentLevel;
        }
    }

    #! Sets the logging level
    /**
        @param level if nothing then inherits level from parent
    */
    public setLevel(*LoggerLevel level) {
        currentLevel = level;
    }

    #! Sets the logging level
    /**
        @param level the logging level as a string
    */
    public setLevel(string level) {
        setLevel(LoggerLevel::getLevel(level));
    }

    #! Sets the logging level
    /**
        @param level the logging level to set
    */
    public setLevel(int level) {
        setLevel(LoggerLevel::getLevel(level));
    }

    #! Decrement logger level
    /**
        @return current \c LoggerLevel
    */
    public *LoggerLevel decLevel() {
        if (currentLevel) {
            *LoggerLevel lvl = LoggerLevel::getNextLowerLevel(currentLevel.getValue());
            if (lvl) {
                setLevel(lvl);
            }
        }
        return currentLevel;
    }

    #! Increment logger level
    /**
        @return current \c LoggerLevel
    */
    public *LoggerLevel incLevel() {
        if (currentLevel) {
            *LoggerLevel lvl = LoggerLevel::getNextHigherLevel(currentLevel.getValue());
            if (lvl) {
                setLevel(lvl);
            }
        }
        return currentLevel;
    }

    #! Sets the additivity flag; when additivity is active, events are passed to parent loggers.
    /**
        @param enable the additivity flag; when additivity is active, events are passed to parent loggers
    */
    public setAdditivity(bool enable) {
        additivity = enable;
    }

    #! Returns the additivity flag.
    public bool getAdditivity() {
        return additivity;
    }

    #! Forwards the given logging event to all linked appenders.
    /**
        @param event the event to forward
    */
    public callAppenders(LoggerEvent event) {
        AutoReadLock arl(lock);
        map $1.post(event), appenders;
    }

    #! Returns the call location where the log function was called from
    private hash<CallStackInfo> getLocation() {
        list<hash<CallStackInfo>> loc = get_thread_call_stack();
        return loc[2];   # get location at stack-2
    }

    #! Adds an appender to the appender list
    /**
        @param appender add a new LoggerAppender
        @throw "LOGGER-ERROR" exception if appender is already in list
    */
    public addAppender(LoggerAppender appender) {
        AutoWriteLock awl(lock);
        if (!appenders) {
            appenders = (appender, );
        } else {
            if (appenders.contains(appender)) {
                throw "LOGGER-ERROR", "Appender already exists in list";
            }
            push appenders, appender;
        }
    }

    #! Removes the appender from the list
    /**
        @param appender the appender to remove
    */
    public removeAppender(LoggerAppender appender) {
        AutoWriteLock awl(lock);
        foreach LoggerAppender a in (appenders) {
            if (a == appender) {
                splice appenders, $#, 1;
                break;
            }
        }
    }

    #! Clears the appender list by removing all appenders
    public removeAllAppenders() {
        AutoWriteLock awl(lock);
        splice appenders, 0;
    }

    #! Returns the appender list
    /**
        Note that the appender list may be manipulated in another thread as internal lock is released
        when list is returned
    */
    public list<LoggerAppender> getAppenders() {
        AutoReadLock awl(lock);
        return appenders ?? ();
    }

    private:internal logIntern(LoggerLevel level, string message, *list<auto> args, *hash<CallStackInfo> location,
            bool check_throwable, date time_stamp = now_us()) {
        #printf("lI: level: %y msg: %y args: %y loc: %y c: %y t: %y", level, message, args, location, check_throwable, time_stamp);

        if (isEnabledFor(level)) {
            *hash<ExceptionInfo> throwable;
            if (args.size() && check_throwable) {
                # is the last argument ExceptionInfo ?
                auto a = args[args.size()-1];
                if (a.typeCode() == NT_HASH && a.fullType() == "hash<ExceptionInfo>") {
                    throwable = a;
                }
            }
            callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), time_stamp, throwable));
            {
                AutoReadLock awl(lock);
                if (parent && getAdditivity()) {
                    # Forward the event upstream if additivity is turned on
                    parent.logIntern(level, message, args, location, throwable, time_stamp);
                }
            }
        } else {
            AutoReadLock awl(lock);
            if (parent && getAdditivity()) {
                # Forward the event upstream if additivity is turned on
                parent.logIntern(level, message, args, location, check_throwable, time_stamp);
            }
        }
    }

    private:internal logIntern(LoggerLevel level, string message, *list<auto> args, *hash<CallStackInfo> location,
            *hash<ExceptionInfo> throwable, date time_stamp) {
        if (isEnabledFor(level)) {
            callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), time_stamp, throwable));
        }
        {
            AutoReadLock awl(lock);
            if (parent && getAdditivity()) {
                # Forward the event upstream if additivity is turned on
                parent.logIntern(level, message, args, location, throwable, time_stamp);
            }
        }
    }

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public log(LoggerLevel level, string message, ...) {
        logIntern(level, message, argv, getLocation(), True);
    }

    #! Logs a message using the provided logging level
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public log(int level, string message, ...) {
        logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
    }

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public log(string level, string message, ...) {
        logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    public logArgs(LoggerLevel level, string message, *softlist<auto> args) {
        logIntern(level, message, args, getLocation(), True);
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    public logArgs(int level, string message, *softlist<auto> args) {
        logIntern(LoggerLevel::getLevel(level), message, args, getLocation(), True);
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    public logArgs(string level, string message, *softlist<auto> args) {
        logIntern(LoggerLevel::getLevel(level), message, args, getLocation(), True);
    }

    #! Logs an already prepared logging event object.
    /**
        @param event the event to log
    */
    public logEvent(LoggerEvent event) {
        if (isEnabledFor(event.getLevel())) {
            callAppenders(event);
        }

        {
            AutoReadLock awl(lock);
            # Forward the event upstream if additivity is turned on
            if (parent && getAdditivity()) {
                parent.logEvent(event);
            }
        }
    }

    #! Logs a message object with the TRACE level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public trace(string message, ...) {
        logIntern(LoggerLevel::getLevelTrace(), message, argv, getLocation(), True);
    }

    #! Logs a message object with the DEBUG level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public debug(string message, ...) {
        logIntern(LoggerLevel::getLevelDebug(), message, argv, getLocation(), True);
    }

    #! Logs a message object with the INFO level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public info(string message, ...) {
        logIntern(LoggerLevel::getLevelInfo(), message, argv, getLocation(), True);
    }

    #! Logs a message object with the WARN level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public warn(string message, ...) {
        logIntern(LoggerLevel::getLevelWarn(), message, argv, getLocation(), True);
    }

    #! Logs a message object with the ERROR level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public error(string message, ...) {
        logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
    }

    #! Logs a message object with the FATAL level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public fatal(string message, ...) {
        logIntern(LoggerLevel::getLevelFatal(), message, argv, getLocation(), True);
    }

    #! Performs logging of assertions
    /**
        If the \a assertion parameter is @ref False, then the message is logged
        using the ERROR level.

        @see @ref log()

        @param assertion the boolean assertion value
        @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to
        the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public assertLog(bool assertion, string message, ...) {
        if(!assertion) {
            logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
        }
    }

    #! Logs the variable name and value using TRACE level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    public traceVar(string var_name, auto value) {
        logIntern(LoggerLevel::getLevelTrace(), sprintf("%s: %%y", var_name), (value, ), getLocation(), False);
    }

    #! Logs the variable name and value using DEBUG level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    public debugVar(string var_name, auto value) {
        logIntern(LoggerLevel::getLevelDebug(), sprintf("%s: %%y", var_name), (value, ), getLocation(), False);
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter.
    /**
        @param level the log level to check
    */
    public bool isEnabledFor(LoggerLevel level) {
        return level.isGreaterOrEqual(getLevel());
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter.
    /**
        @param level the log level to check
    */
    public bool isEnabledFor(int level) {
        return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter.
    /**
        @param level the log level to check
    */
    public bool isEnabledFor(string level) {
        return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
    }

    #! Checks whether this Logger is enabled for the TRACE Level.
    public bool isTraceEnabled() {
        return isEnabledFor(LoggerLevel::getLevelTrace());
    }

    #! Checks whether this Logger is enabled for the DEBUG Level.
    public bool isDebugEnabled() {
        return isEnabledFor(LoggerLevel::getLevelDebug());
    }

    #! Checks whether this Logger is enabled for the INFO Level.
    public bool isInfoEnabled() {
        return isEnabledFor(LoggerLevel::getLevelInfo());
    }

    #! Checks whether this Logger is enabled for the WARN Level.
    public bool isWarnEnabled() {
        return isEnabledFor(LoggerLevel::getLevelWarn());
    }

    #! Checks whether this Logger is enabled for the ERROR Level.
    public bool isErrorEnabled() {
        return isEnabledFor(LoggerLevel::getLevelError());
    }

    #! Checks whether this Logger is enabled for the FATAL Level.
    public bool isFatalEnabled() {
        return isEnabledFor(LoggerLevel::getLevelFatal());
    }
}

#! Implements the root class for loggers; does not allow a parent logger to be set
public class LoggerRoot inherits Logger {
    # Creates the object
    /**
        @param level initial log level
    */
    constructor(LoggerLevel level = LoggerLevel::getLevelAll()): Logger('') {
        setLevel(level);
    }

    # Creates the object
    /**
        @param level initial log level
    */
    constructor(int level): Logger('') {
        setLevel(level);
    }

    # Creates the object
    /**
        @param level initial log level
    */
    constructor(string level): Logger('') {
        setLevel(level);
    }

    #! Overrides the level setter to prevent setting the root logger's level to @ref nothing (an exception is thrown in this case).
    /**
        The root logger must always have a level.

        @param value the level to set
        @throw LOGGER-ERROR if level is @ref nothing
    */
    public setLevel(*LoggerLevel value) {
        if (!exists value) {
            throw "LOGGER-ERROR", "Cannot set null level for root";
        }
        Logger::setLevel(value);
    }

    #! Overrides value setter as the root logger cannot have a parent; this method always throws an exception if the argument is a value
    /**
        @throw LOGGER-ERROR if parent exists
    */
    public setParent(*Logger value) {
        if (exists value) {
            throw "LOGGER-ERROR", "Cannot set parent for root";
        }
    }
}

#! Appender for logging to the console
/** Useful for tests and development, for example
*/
public class StdoutAppender inherits LoggerAppenderWithLayout {
    constructor() : LoggerAppenderWithLayout("stdout",
            new LoggerLayoutPattern("%d{YYYY-MM-DD HH:mm:SS.xx} T%t [%p]: %m%n")) {
        open();
    }

    processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_LOG:
                print(params);
                break;
        }
    }
}
}
