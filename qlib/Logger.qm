# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Logger.qm Logger library

/*  Logger.qm Copyright 2018 - 2021 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.9

%require-types
%enable-all-warnings
%new-style
%no-debugging

%requires Util

module Logger {
    version = "0.1.1";
    desc = "user module implementing Log4q logger library";
    author = "Tomas Mandys <tomas.mandys@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Logger Module

    @tableofcontents

    @section loggerintro Introduction to the Logger Module

    The %Logger module (aka <b>Log4q</b>) adopts its primary design from the well known
    <a href="https://logging.apache.org/log4j/2.x">log4j</a> library, therefore it
    implements the following primary base classes:
    - @ref Logger::Logger "Logger"
    - @ref Logger::LoggerAppender "LoggerAppender" (abstract)
    - @ref Logger::LoggerFilter "LoggerFilter"
    - @ref Logger::LoggerLayout "LoggerLayout" (abstract)
    - @ref Logger::LoggerPattern "LoggerPattern" (abstract)

    Abstract base classes must be subclassed to implement the desired functionality.

    @subsection logger_scenarior Scenarios

    @par One Thread

    The user code will log to a @ref Logger object, and the logging is performed to the appender synchronously.

    Example:
    @code{.py}
    Logger l("mylogger", LoggerLevel::getLevelInfo());
    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    l.addAppender(laf);
    laf.open();
    ....
    l.info("hello %s #%d", "world", 1);
    l.error("the %s is not perfect", "world");
    @endcode

    @par Multiple Threads

    The user code will log from multiple threads; the events are pushed to a
    @ref Logger::LoggerAppenderQueue "LoggerAppenderQueue" object. The processing is done in a dedicated thread
    when the events are passed to appenders. The user code logging command is non-blocking as it terminates
    immediately when the event is pushed in the queue.

    Example:
    @code{.py}
    our Logger l("mylogger", LoggerLevel::getLevelInfo());

    sub run() {
        while (!done) {
            ...
            l.info("hello %s #%d", "world", 1);
            l.error("the %s is not perfect", "world");
            ...
        }
    }

    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    laf.setQueue(new LoggerAppenderQueue());
    l.addAppender(laf);
    laf.open();

    for (int i=0; i<10; i++) {
        background run();
    }

    while (True) {
        laf.getQueue().process();
    }
    @endcode

    @par Application Server Running Logging From a Few Sandboxed Program Containers

    In this example, the appserver provides a logger API for a few sandboxed programs. The appserver is
    responsible for the <b>Log4q</b> configuration; i.e. it prepares loggers, appenders, filters, etc.
    according to configuration and provides the @ref Logger instance to the @ref Qore::Program "Program"
    container running the sandboxed code.
    The sandboxed code will log to this instance; the logging events are processed by the appserver in a
    dedicated thread which gets the event from a queue and passes it to appenders.  Multiple loggers may be
    configured in a parent/child hierarchy so that a higher logging level (i.e. more event levels) are logged
    with the logger assigned to the sandbox and fewer (ex: only critical errors) to the global appserver logger.

    Example:
    @code{.py}
    LoggerAppenderQueue laq();
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);

    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    while (True) {
        laq.process(-1);
    }
    @endcode

    @par Application Server Running Many Sandboxed Program Containers

    This example is basically the same as the previous example, but to avoid I/O bottlenecks in logging, the
    appserver processing thread gets the event from a queue and passes it to the appender in another worker
    thread by a submitting the logging action to a @ref Qore::Thread::ThreadPool "ThreadPool". So events targeted
    to a particular thread may by processed in different threads but nevertheless serially.

    Example:
    @code{.py}
    ThreadPool tp();
    LoggerAppenderQueueThreadPool laq(tp, 5);
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);
    code processing() = sub () {
        while (True) {
            laq.process(-1);
        }
    }
    # may run in extra thread
    background processing();
    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    # wait till finished
    @endcode

    @subsection logger_v0_1_1 v0.1.1
    - added Logger::Logger::logArgs() "Logger::logArgs()"
      (<a href="https://github.com/qorelanguage/qore/issues/3492">issue 3492</a>)

    @subsection logger_v0_1 v0.1
    - the initial version of the Logger module
*/

#! The Logger namespace contains all the definitions in the Logger module
public namespace Logger {
    #! Defines the minimum set of levels recognized by the system.
    /**
        The set of built-in levels includes \c TRACE, \c DEBUG, \c INFO, \c WARN, \c ERROR and \c FATAL. Log4q also supports
        custom log levels where the \c LoggerLevel class may be subclassed to define a larger level set.
    */
    public class LoggerLevel {
        public {
            #! built-in logger levels
            const OFF = MAXINT;
            const FATAL = 50000;
            const ERROR = 40000;
            const WARN = 30000;
            const INFO = 20000;
            const DEBUG = 10000;
            const TRACE = 5000;
            const ALL = MININT;
        }

        private:internal {
            #! Integer level value.
            int levelCode;

            #! String representation of the level.
            string levelStr;

            #! Contains a list of instantiated levels
            static hash<string, LoggerLevel> levelMap;

            #! String to int hash
            const LEVELSTR_TO_LEVEL = {
                'ALL':   ALL,
                'TRACE': TRACE,
                'DEBUG': DEBUG,
                'INFO':  INFO,
                'WARN':  WARN,
                'ERROR': ERROR,
                'FATAL': FATAL,
                'OFF':   OFF,
            };

            #! Int to string hash
            const LEVEL_TO_LEVEL_STR = map {$1.value: $1.key}, LEVELSTR_TO_LEVEL.pairIterator();
        }

        #! Creates a new object
        /**
            @param code integer value
            @param str string representation
        */
        constructor(int code, string str) {
            levelCode = code;
            levelStr = str;
        }

        #! Gets level code value
        public int getValue() {
            return levelCode;
        }

        #! Gets level string
        public string getStr() {
            return levelStr;
        }

        #! Compares logger levels
        /**
            @param other the other level to compares
            @return True if level is greater or equal to the \a other level
        */
        public bool isGreaterOrEqual(LoggerLevel other) {
            return levelCode >= other.getValue();
        }

        #! Compares two logger levels
        /**
            @param other the other level to compares
        */
        public bool isEqual(LoggerLevel other) {
            return levelCode == other.getValue();
        }

        #! Returns an OFF Level
        public static LoggerLevel getLevelOff() {
            return LoggerLevel::getLevel(OFF);
        }

        #! Returns a FATAL Level
        public static LoggerLevel getLevelFatal() {
            return LoggerLevel::getLevel(FATAL);
        }

        #! Returns an ERROR Level
        public static LoggerLevel getLevelError() {
            return LoggerLevel::getLevel(ERROR);
        }

        #! Returns a WARN Level
        public static LoggerLevel getLevelWarn() {
            return LoggerLevel::getLevel(WARN);
        }

        #! Returns an INFO Level
        public static LoggerLevel getLevelInfo() {
            return LoggerLevel::getLevel(INFO);
        }

        #! Returns a DEBUG Level
        public static LoggerLevel getLevelDebug() {
            return LoggerLevel::getLevel(DEBUG);
        }

        #! Returns a TRACE Level
        public static LoggerLevel getLevelTrace() {
            return LoggerLevel::getLevel(TRACE);
        }

        #! Returns an ALL Level
        public static LoggerLevel getLevelAll() {
            return LoggerLevel::getLevel(ALL);
        }

        #! Converts the input argument to a level
        /**
            Return value is either instantiated or used the existing one if there is any.

            @param level the input level
            @param default_level value to return if conversion is not possible.

            @throw LOGGER-ERROR if defaultLevel is nothing and level not found
        */
        public static LoggerLevel getLevel(int level, *LoggerLevel default_level) {
            if (exists LEVEL_TO_LEVEL_STR{level}) {
                if (!exists levelMap{level}) {
                    levelMap{level} = new LoggerLevel(level, LEVEL_TO_LEVEL_STR{level});
                }
                return levelMap{level};
            } else {
                if (!exists default_level) {
                    throw "LOGGER-ERROR", "Cannot get valid Level";
                }
                return default_level;
            }
        }

        #! Returns closest lower logger level
        /**
            @param \c Loggerlevel
            @return \c Loggerlevel or \c NOTHING if there is no lower level

            @throw LOGGER-ERROR if level not found
        */
        public static *LoggerLevel getNextLowerLevel(int level) {
            HashIterator hi(LEVELSTR_TO_LEVEL);
            while (hi.next()) {
                if (level == hi.getValue()) {
                    if (hi.prev()) {
                        return LoggerLevel::getLevel(hi.getValue());
                    }
                    break;
                }
            }
            return NOTHING;
        }

        #! Returns closest higher logger level
        /**
            @param \c Loggerlevel
            @return \c Loggerlevel or \c NOTHING if there is no higher level

            @throw LOGGER-ERROR if level not found
        */
        public static *LoggerLevel getNextHigherLevel(int level) {
            HashIterator hi(LEVELSTR_TO_LEVEL);
            while (hi.next()) {
                if (level == hi.getValue()) {
                    if (hi.next()) {
                        return LoggerLevel::getLevel(hi.getValue());
                    }
                    break;
                }
            }
            return NOTHING;
        }

        #! Converts the input argument to a level.
        /**
            Return value is either instantiated or used the existing one if there is any.

            @param level_str the string input level
            @param default_level value to return if conversion is not possible.
            @throw LOGGER-ERROR if default_level is nothing and level_str not found
        */
        public static LoggerLevel getLevel(string level_str, *LoggerLevel default_level) {
            level_str = toupper(level_str);
            if (exists LEVELSTR_TO_LEVEL{level_str}) {
                int level = LEVELSTR_TO_LEVEL{level_str};
                if (!exists levelMap{level}) {
                    levelMap{level} = new LoggerLevel(level, level_str);
                }
                return levelMap{level};
            } else {
                if (!exists default_level) {
                    throw "LOGGER-ERROR", "Cannot get valid Level";
                }
                return default_level;
            }
        }
    }

    #! Implements callable parameter which is evaluated in run-time when event is rendered
    /**
        It may implement logging for stuff which is time consuming to get and would slow program flow in case
        the logging is actually not performed because of filters or logging levels.

        Example:
    @code{.py}
    int ping_voyager(int num) {
        try {
            # ping voyager #num
            ...
        } except(hash<ExceptionInfo> ex) {
            return -1;
        }
    }
    Logger l;
    ....
    l.debug("Voyager 1: ping is %y secs", new LoggerEventParameter(\ping_voyager(), 1));
    @endcode
    */
    public class LoggerEventParameter {
        private:internal {
            code callable;
            *list<auto> args;
        }
        #! Creates object
        /**
            @param func function to be called with optional arguments followed
        */
        constructor(code func) {
            callable = func;
            args = argv;
        }
        #! Call function with arguments provided
        /**
            In case of user function call consider surpressing exceptions to return value corresponding to expected
            formatting parameter (e.g. "%d").
        */
        public auto call() {
            return call_function_args(callable, args);
        }
    }

    #! Implements an event to be logged
    /**
        The event data consists of format string and parameters. The output string is rendered at time when
        logging decision to target is made. Callable parameters are evaluated at this moment as well. It
        should be considered when callable parameters do not return time persistent value. When callable raises
        an exception then exception instance is passed for formatting. So it should be considered if format string and
        use for example "%y" to get readable data.
    */
    public class LoggerEvent {
        private:internal {
            #! origin stamp to calculate relative time
            static date startTime = now_us();

            #! Fully Qualified Class Name of the calling category class.
            string fqcn;

            #! Logger reference
            *Logger logger;

            #! The category (logger) name.
            string categoryName;

            #! Level of the logging event.
            LoggerLevel level;

            #! The application supplied message of logging event (not rendered)
            string messageFmt;

            #! arguments to be rendered
            *list messageArgs;

            #! The application supplied message rendered through the rendering mechanism.
            *string renderedMessage;

            #! related thread id
            int threadId;

            #! event time stamp
            date timeStamp;

            #! location information where the logging was performed.
            *hash<CallStackInfo> locationInfo;

            #! internal representation of throwable
            *hash<ExceptionInfo> throwableInfo;

            #! unique id
            int uniqueId;

            #! unique id generator
            static Sequence sequence(1);
        }

        #! Instantiates a LoggingEvent from the supplied parameters.
        /**
            The category becomes logger name and fqcn logger class name

            @param n_logger Instance of the Logger class
            @param n_level The event level
            @param n_message The payload as format for @ref sprintf()
            @param n_args The arguments for formatting
            @param n_location_info code location related to logging event
            @param n_thread_id thread related to the event, Default: @ref gettid()
            @param n_time_stamp logging event timestamp. Default value is @ref now_us
            @param n_throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with logging event
        */
        constructor(Logger n_logger, LoggerLevel n_level, string n_message, *list n_args, *hash<CallStackInfo> n_location_info,
                    int n_thread_id = gettid(), date n_time_stamp = now_us(), *hash<ExceptionInfo> n_throwable) {
            fqcn = get_class_name(n_logger);
            logger = n_logger;
            categoryName = n_logger.getName();
            level = n_level;
            messageFmt = n_message;
            messageArgs = n_args;
            locationInfo = n_location_info;
            threadId = n_thread_id;
            timeStamp = n_time_stamp;
            if (n_throwable) {
                throwableInfo = n_throwable;
            }
        }

        #! Instantiates a LoggingEvent from the supplied parameters.
        /**
            @param n_fqcn name of the caller class.
            @param n_category The event category.
            @param n_level The event level
            @param n_message The payload as format for @ref sprintf()
            @param n_args The arguments for formatting
            @param n_location_info code location related to logging event
            @param n_thread_id thread related to the event, Default: @ref gettid()
            @param n_time_stamp logging event timestamp. Default value is @ref now_us
            @param n_throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with logging event
        */
        constructor(string n_fqcn, softstring n_category, LoggerLevel n_level, string n_message, *list n_args,
                    *hash<CallStackInfo> n_location_info, int n_thread_id = gettid(), date n_time_stamp = now_us(),
                    *hash<ExceptionInfo> n_throwable) {
            fqcn = n_fqcn;
            categoryName = n_category;
            level = n_level;
            messageFmt = n_message;
            messageArgs = n_args;
            locationInfo = n_location_info;
            threadId = n_thread_id;
            timeStamp = n_time_stamp;
            if (n_throwable) {
                throwableInfo = n_throwable;
            }
        }

        #! Returns the full qualified classname
        public string getFullQualifiedClassname() {
            return fqcn;
        }

        #! Returns the location information for this logging event
        public *hash<CallStackInfo> getLocationInfo() {
            return locationInfo;
        }

        #! Returns the level of this event
        public LoggerLevel getLevel() {
            return level;
        }

        #! Returns the logger which created the event
        public *Logger getLogger() {
            return logger;
        }

        #! Returns the thread id which is related to event
        public int getThreadId() {
            return threadId;
        }

        #! Returns the category name
        public string getCategoryName() {
            return categoryName;
        }

        #! Returns the string message for the logging event
        /**
            Potential callable references are evaluated.
            Next the message is rendered using @ref Qore::vsprintf() "vsprintf()" and the result is cached, so
            the message is rendered only once.

            @return the rendered message
        */
        public string getMessage() {
            if (!exists renderedMessage) {
                # evaluating of callable parameters (via LoggerEventParameter) may be used to get time consuming stuff
                # i.e. they are evaluated only when logging is performed
                list<auto> args2 = ();
                foreach auto arg in (messageArgs) {
                    if (arg.typeCode() == NT_OBJECT && arg instanceof LoggerEventParameter) {
                        try {
                            push args2, cast<LoggerEventParameter>(arg).call();
                        } catch (hash<ExceptionInfo> ex) {
                            push args2, ex;
                        }
                    } else {
                        push args2, arg;
                    }
                }
                # message is considered as printf() format so we process it this way.
                renderedMessage = vsprintf(messageFmt, args2);
            }
            return renderedMessage;
        }

        #! Returns the time when the application/logger started to calculate relative time
        public static date getStartTime() {
            return LoggerEvent::startTime;
        }

        #! Sets the starting time for relative time
        public static setStartTime(date time) {
            LoggerEvent::startTime = time;
        }

        #! Returns the event timestamp as an @ref absolute_dates "absolute date/time value"
        public date getTimeStamp() {
            return timeStamp;
        }

        #! Returns a relative timestamp for the event
        /**
            Returns a @ref relative_dates "relative date/time value" for the amount of time passed
            from the beginning of execution to the time when the event was constructed.

            @see @ref getStartTime()
        */
        public date getRelativeTime() {
            return timeStamp - LoggerEvent::startTime;
        }

        #! Returns throwable info, if any
        public *hash<ExceptionInfo> getThrowableInfo() {
            return throwableInfo;
        }

        #! Generates a globally unique integer identifier and associates it to the event
        public int getUniqueId() {
            if (!exists uniqueId) {
                uniqueId = sequence.next();
            }
            return uniqueId;
        }
    }

    #! Implements queue serializing async appender events
    /**
        All async events may be processed by one worker thread dedicated to
        one or more appenders so the thread posting logging event remains unblocked.
    */
    public class LoggerAppenderQueue {
        private:internal {
            Queue queue();
        }

        #! Adds appender event
        /**
            @param appender a logger appender object
            @param type see \c EVENT_xxx constants
            @param params data prepared by @ref LoggerAppender::serializeImpl()
            @return True if the event was succesfully added to queue
        */
        public bool push(LoggerAppender appender, int type, auto params) {
            try {
                queue.push(("appender": appender, "type": type, "params": params), -1);
            } catch (hash<ExceptionInfo> ex) {
                return False;
            }
            return True;
        }

        #! Processes queued events
        /**
            This method should typically be called in a dedicated thread

            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a negative timeout value is passed as the argument,
                then the call blocks until data is available on the queue. Default value is 0.
        */
        public process(timeout ms = 0) {
            while (True) {
                *hash rec = getEvent(ms);
                if (!rec) {
                    break;
                }
                rec.appender.processEventImpl(rec.type, rec.params);
            }
        }

        #! Returns the current number of events waiting in queue
        public int size() {
            return queue.size();
        }

        #! Returns the next event from queue or @ref nothing if there is no event available within the timeout period
        /**
            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a negative timeout value is passed as the argument,
                then the call blocks until data is available on the queue.

            @return the next event from queue or @ref nothing if there is no event available within the timeout period
        */
        private *hash getEvent(timeout ms) {
            if (queue.size() > 0 || ms != 0) {
                try {
                    if (ms == 0) {
                        return queue.get(-1);
                    } else if (ms > 0) {
                        return queue.get(ms);
                    } else {
                        return queue.get(0);
                    }
                } catch (hash<ExceptionInfo> ex) {
                    switch (ex.err) {
                        case "QUEUE-TIMEOUT":
                            break;
                        default:
                            rethrow;
                    }
                }
            }
        }
    }

    #! Handles the processing for asynchronous appender events in multiple threads
    /**
        Async events are removed from the event queue in a single thread which balances processing
        in multiple worker threads via a @ref Qore::Thread::ThreadPool "ThreadPool". This class groups events by appender
        so that events related to a particular appender are always processed serially in the same thread.
        It is compatible with %Qore's @ref Qore::OutputStream implementation where all data submitted to the
        output stream must be submitted from the same thread.
    */
    public class LoggerAppenderQueueThreadPool inherits LoggerAppenderQueue {
        private:internal {
            #! worker thread pool
            ThreadPool threadPool;
            #! number of running worker threads
            Counter runningCounter(0);
            #! max.number of worker threads
            int maxThreads;
            #! events removed from queue but not passed to worker thread
            hash pendingEvents;
            #! events paseed to worker thread
            hash processingEvents;
            #! queue of processed events in worker threads
            Queue finishedEvents();
            #! internal unique counter
            Sequence lastId(0);
            #! to protect process()
            Mutex lock();
        }

        #! Implements worker thread code
        /**
            @param id unique identifier generated by internal @ref Qore::Thread::Sequence "Sequence"
            @param appender @ref LoggerAppender instance
            @param events list of events
        */
        private:internal worker(string id, LoggerAppender appender, list events) {
            #printf("start worker(), id: %y, tid: %d\n", id, gettid());
            #printf("<S:%y, tid: %d> ", id, gettid());
            runningCounter.inc();
            on_exit runningCounter.dec();
            try {
                map appender.processEventImpl($1.type, $1.params), events;
            } catch (hash<ExceptionInfo> ex) {
            }
            finishedEvents.push(id);
            #printf("end worker(), id: %y, tid: %d\n", id, gettid());
            #printf("<E:%y, tid: %d> ", id, gettid());
        }

        #! Creates the object
        /**
            @param tp worker @ref Qore::Thread::ThreadPool "ThreadPool" where loggging events are submitted
            @param max_threads max.number of worker threads, default value is \c -1, i.e. unlimited
        */
        constructor(ThreadPool tp, int max_threads = -1) {
            threadPool = tp;
            maxThreads = max_threads;
        }

        destructor() {
            runningCounter.waitForZero();
            threadPool.stopWait();
        }

        #! Returns the assigned @ref Qore::Thread::ThreadPool "ThreadPool"
        public ThreadPool getThreadPool() {
            return threadPool;
        }

        #! Processes queue events
        /**
            Group logging events by appender and submit them to a worker thread to be processed in a thread pool so
            the particular thread will handle corresponding appender instance.

            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a negative timeout value is passed as the argument,
                then the call blocks until data is available on the queue. Default value is 0.
        */
        public process(timeout ms = 0) {
            # normally function is called from one thread and it is not time critical
            AutoLock al(lock);
            # get new events and match with pending
            hash last_match;
            while (True) {
                *hash e = getEvent(ms);
                if (!e) {
                    break;
                }
                if (last_match.appender != e.appender) {
                    bool found = False;
                    foreach string id in (keys pendingEvents) {
                        if (pendingEvents{id}.appender == e.appender) {
                            last_match.id = id;
                            last_match.appender = e.appender;
                            found = True;
                            break;
                        }
                    }
                    if (!found) {
                        # look into processing
                        foreach string id in (keys processingEvents) {
                            if (processingEvents{id}.appender == e.appender) {
                                last_match.id = id;
                                found = True;
                                break;
                            }
                        }
                        if (!found) {
                            # add new entry
                            last_match.id = string(lastId.next());
                        }
                        last_match.appender = e.appender;
                        pendingEvents{last_match.id} = {
                            "id": last_match.id,  # to get reason of this value duplicating key see problem description above ThreadPool::submit(id, ...) call
                            "appender": e.appender,
                            "events": (),
                        };
                    }
                }
                push pendingEvents{last_match.id}.events, e.('type', 'params');
            }

            # remove finished
            while (finishedEvents.size() > 0) {
                string id = finishedEvents.get(-1);
                remove processingEvents{id};
            }
            # now try push pending
            foreach string id in (keys pendingEvents) {
                # remove meanwhile finished if any
                while (finishedEvents.size() > 0) {
                    remove processingEvents{finishedEvents.get(-1)};
                }
                # is available a free worker thread ?
                if (maxThreads >= 0 && processingEvents.size() >= maxThreads) {
                    return;
                }
                if (exists processingEvents{id}) {
                    # we cannot trigger new thread if is being processed
                    continue;
                }
                hash e = remove pendingEvents{id};
                processingEvents{id} = e;
                # When passing "id" then no copy is passed to submit pool queue and worker may get wrong value
                # so we must pass value in new variable which won't change meanwhile when the value is to be used.
                # It is feature of submit implementation related to parameter passing.
                threadPool.submit(sub() {call_function(\worker(), e.id, e.appender, e.events); } );
            }
        }

        #! Gets number of pending events
        public int size() {
            AutoLock al(lock);
            return LoggerAppenderQueue::size() + processingEvents.size() + pendingEvents.size();
        }
    }

    #! Implements passing @ref LoggerEvent to target destination
    /**
        subclasses will implement e.g. logging to file, to stderr, to database etc.
        \c LoggerAppender supports sync and async logging.

        The ability to selectively enable or disable logging requests based on level in @ref Logger is
        extended in the appender via @ref LoggerFilter, which implements filtering on any criteria.

        The appender instance should be closed via @ref close() method explicitely to stop accepting
        logging events which might arrive later than destructing process has started. This process
        cannot start by design before all events has been processed as the @ref LoggerEvent instance holds refeence
        to this appender instance.
    */
    public class LoggerAppender {
        public {
            #! open event
            const EVENT_OPEN = 1;
            #! logging event
            const EVENT_LOG = 2;
            #! close event
            const EVENT_CLOSE = 3;
        }

        private:internal {
            #! The lock to ensure proper serialization with concurrent access
            RWLock lock();

            #! An inactive appender won't accept any logging request
            bool active = False;

            #! filter chain
            list<LoggerFilter> filters;

            #! Appender name
            string name;

            #! async queue
            *LoggerAppenderQueue queue;
        }

        #! Creates the object
        /**
            @param n_name the appender name
        */
        constructor(*string n_name) {
            name = n_name ?? "";
        }

        destructor() {
            /*
                Note that we cannot enforce calling close() method in destructor potentially generating an event
                because the related member object instance (e.g. File) might be already destroyed in time when the event is
                being processed. So such an appander instance should be closed explicitly in user code.
            */
            # close();
        }

        #! Returns the appender name
        public string getName() {
            return name;
        }

        #! Sets the appender queue.
        /**
            Data are passed to target device synchronously
            unless queue is assigned. In this case data are queued and
            dedicated process will process it asynchronously

            @param n_queue
            @throw "LOGGER-ERROR" thrown if appender is opened
        */
        public setQueue(*LoggerAppenderQueue n_queue) {
            AutoWriteLock awl(lock);
            if (active) {
                throw "LOGGER-ERROR", "Appender is opened";
            }
            queue = n_queue;
        }

        #! Returns async queue or @ref nothing when events are processed synchronously
        public *LoggerAppenderQueue getQueue() {
            return queue;
        }

        #! Opens logging resources
        /**
            The appender must be opened to accept any logging events
        */
        public open() {
            AutoWriteLock awl(lock);
            if (!active) {
                pushEvent(EVENT_OPEN, NOTHING);
                active = True;
            }
        }

        #! Releases any resources allocated by the appender and closes it
        public close() {
            AutoWriteLock awl(lock);
            if (active) {
                pushEvent(EVENT_CLOSE, NOTHING);
                active = False;
            }
        }

        #! Returns @ref True if the appender is open and therefore active
        public bool isOpen() {
            return active;
        }

        #! Adds a filter to the chain
        /**
            @param filter the new filter to add
            @param top if @ref True then the filter is added at the start of the filter chain, if @ref False (the default),
            the filter is added at the end of the chain
            @throw "LOGGER-ERROR" thrown if the filter is already in the list
        */
        public addFilter(LoggerFilter filter, bool top = False) {
            AutoWriteLock awl(lock);
            if (!filters) {
                filters = (filter, );
            } else {
                if (filters.contains(filter)) {
                    throw "LOGGER-ERROR", "Filter already exists in list";
                }
                if (top) {
                    unshift filters, filter;
                } else {
                    push filters, filter;
                }
            }
        }

        #! Removes the given filter from the filter chain.
        /**
            @param filter the filter to remove
        */
        public removeFilter(LoggerFilter filter) {
            AutoWriteLock awl(lock);
            foreach LoggerFilter f in (filters) {
                if (f == filter) {
                    splice filters, $#, 1;
                    break;
                }
            }
        }

        #! Clears the filter chain by removing all filters
        public removeAllFilters() {
            AutoWriteLock awl(lock);
            splice filters, 0;
        }

        #! Returns the filter chain as a list
        /**
            Note that appender filter chain may be modified as internal lock is released when copy of list is returned
        */
        public list<LoggerFilter> getFilters() {
            AutoReadLock awl(lock);
            return filters ?? ();
        }

        #! Serializes the given event to put in the queue or write to the target device
        /**
            The appender implementaion can define any format for serialization. The data are passed
            to @ref processEventImpl() method in the \c params argument when \c type is \c EVENT_LOG.

            @return the serialized event
        */
        abstract private auto serializeImpl(LoggerEvent event);

        #! Pushes the given event on the queue or calls @ref processEventImpl() in case of synchronous processing
        /**
            @param type the event type
            @param params parameters for the event according to the event type

            @return @ref True if the event was accepted/processed, @ref False if not

            @see @ref processEventImpl()
        */
        private bool pushEvent(int type, auto params) {
            if (exists queue) {
                return queue.push(self, type, params);
            } else {
                processEventImpl(type, params);
                return True;
            }
        }

        #! Posts the given event to the output queue
        /**
            Invokes filters; when the event is accepted then it is posted to the queue in case of
            asynchronous processing, or it is immediately logged by the @ref processEventImpl() method
            in case of synchronous processing.

            @see @ref processEventImpl()

            @param event the event to post
            @return True if the event has been posted, @ref False if not (filtered out, appender inactive,
            event not accepted on queue, etc)
        */
        public bool post(LoggerEvent event) {
            if (!active) {
                return False;
            }
            {
                AutoReadLock arl(lock);
                foreach LoggerFilter filter in (filters) {
                    int d = filter.eval(event);
                    if (d == LoggerFilter::DENY) {
                        return False;
                    } else if (d == LoggerFilter::ACCEPT) {
                        break;
                    }
                }
            }
            auto serialized = serializeImpl(event);
            if (!exists serialized) {
                return False;
            }
            return pushEvent(EVENT_LOG, serialized);
        }

        #! Processes the event to the physical target
        /**
            Must be implemented by non-abstract subclasses

            @see @ref serializeImpl()

            @param type see \c "EVENT_xxx" constants
            @param params processing parameters
        */
        abstract public processEventImpl(int type, auto params);
    }

    #! Implements appender which does nothing
    /**
        All events posted to the appender are silently ignored
    */
    public class LoggerAppenderNull inherits LoggerAppender {
        constructor(*string n_name): LoggerAppender(n_name) {
        }

        private auto serializeImpl(LoggerEvent event) {
        }

        public processEventImpl(int type, auto params) {
        }
    }

    #! Implements pattern parsing and substitution
    /**
        The pattern defines fields to be substituted with real values

        The pattern format is:

        @code
        %[<modifiers>] <word> [{<option>}]
        modifiers := [0-9.-]*
        word := [a-zA-Z]+
        option := [^}]*
        @endcode

        When a word (i.e. longer than one char) key without curly brackets is not found then in the next step is resolved its first char,
        e.g. \c "%parchive" the first step tries to resolve \c "parchive" key and if not resolved the second step \c "p" key.
        To parse in key if single step delimit a word from the next character, use curly brackets, i.e. empty option, e.g. \c "%p{}archive".
        If a key is not resolved then exception is raised.

        The following table covers various modifiers and scenarios:

        | !Format modifier | !left justify | !minimum width | !maximum width | !comment |
        | %20c             | false         | 20             | none           | Left pad with spaces if the category name is less than 20 characters long |
        | %-20c            | true          | 20             | none           | Right pad with spaces if the category name is less than 20 characters long |
        | %.30c            | NA            | none           | 30             | Truncate from the beginning if the category name is longer than 30 characters |
        | %20.30c          | false         | 20             | 30             | Left pad with spaces if the category name is shorter than 20 characters. However, if the category name is longer than 30 characters, then truncate from the beginning |
        | %-20.30c         | true          | 20             | 30             | Right pad with spaces if the category name is shorter than 20 characters. However, if the category name is longer than 30 characters, then truncate from the beginning |
    */
    public class LoggerPattern {
        public {
            #! format escape character
            const ESCAPE_CHAR = "%";
        }

        private:internal {
            #! pattern
            string origPattern;
        }

        private {
            #! parsed pattern
            list parsedPattern;  # subclass may provide value e.g. for unit tests
        }

        #! Creates the object
        /**
            @param pattern the logger pattern
            @throw LOGGER-ERROR when pattern is invalid
        */
        constructor(string pattern) {
            # parse pattern
            setPattern(pattern);
        }

        #! Sets the new pattern
        /**
            @param value the logger pattern
            @throw LOGGER-ERROR when pattern is invalid
        */
        public setPattern(string value) {
            string patt = value;
            list pp = ();
            while (patt != "") {
                int pos = 0;
                do {
                    pos = bindex(patt, ESCAPE_CHAR, pos);
                    if (pos < 0) {
                        pos = patt.size();
                    } else {
                        if (pos >= 0 && patt[pos+1] == ESCAPE_CHAR) {  # %%
                            splice patt, pos, 1;
                            pos++;
                            continue;
                        }
                    }
                    break;
                } while (True);
                if (pos >= patt.size()) {
                    push pp, patt;
                    patt = "";
                } else {
                    if (pos > 0) {
                        push pp, substr(patt, 0, pos);
                    }
                    splice patt, 0, pos+1;
                    # now the string is token
                    *list l = regex_extract(patt, "^([0-9.-]*)([a-zA-Z]+)({[^}]*})?");
                    if (l.size() < 2) {
                        throw "LOGGER-ERROR", sprintf("Wrong pattern starting %%%s", patt);
                    }
                    *list opt;
                    hash f;
                    if (l[0] != "") {
                        # opt = l[0] =~ x/^([-]?)([^.0-9]*)([.]?)([0-9]+)$/;   does not work in all cases
                        if (opt = (l[0] =~ x/^([-]?)([0-9]+)\.([0-9]+)$/) ) {
                            f.leftJustify = opt[0] == "-";
                            f.minWidth = int(opt[1]);
                            f.maxWidth = int(opt[2]);
                        } else if (opt = (l[0] =~ x/^([-]?)([0-9]+)$/) ) {
                            f.leftJustify = opt[0] == "-";
                            f.minWidth = int(opt[1]);
                        } else if (opt = (l[0] =~ x/^.([0-9]+)$/) ) {
                            f.maxWidth = int(opt[0]);
                        } else {
                            throw "LOGGER-ERROR", sprintf("Wrong pattern option starting %%%s", patt);
                        }
                    }
                    f.key = l[1];
                    if (l.size() == 3) {
                        f.option = (regex_extract(l[2], "^{([^}]*)}$")[0]) ?? "";
                    }
                    patt = regex_subst(patt, "^[0-9.-]*[a-zA-Z]+({[^}]*})?", "");
                    push pp, f;
                }
            }

            origPattern = value;
            parsedPattern = pp;
        }

        #! Returns the current pattern
        public string getPattern() {
            return origPattern;
        }

        #! Formats the event record with the current pattern
        /**
            @param data is passed to @ref resolveField()
            @throw LOGGER-ERROR when a key is not resolved
        */
        public string format(auto data) {
            string res = "";
            foreach auto a in (parsedPattern) {
                if (a.typeCode() == NT_STRING) {
                    res += a;
                } else {
                    bool fallback = False;
                    *string val = resolveField(data, a.key, a.option);
                    if (!exists val && a.key.size() > 1 && !exists a.option) {
                        # try one char key if key is longer and has no {}, i.e. fix non intuitive case
                        val = resolveField(data, substr(a.key, 0, 1));
                        fallback = exists val;
                    }
                    if (!exists val) {
                        throw "LOGGER-ERROR", sprintf("Unknown pattern token %y", a.key);
                    }

                    if (exists a.maxWidth) {
                        val = substr(val, 0, a.maxWidth);
                    }
                    if (exists a.minWidth && val.size() < a.minWidth) {
                        if (a.leftJustify) {
                            val += strmul(" ", a.minWidth - val.size());
                        } else {
                            val = strmul(" ", a.minWidth - val.size()) + val;
                        }
                    }
                    res += val;
                    if (fallback) {
                        res += substr(a.key, 1);
                    }
                }
            }
            return res;
        }

        #! Returns a formatted string for an input pattern
        /**
            @param data input context reference data
            @param key the format character
            @param option the format option value, if any

            @return the formatted string or nothing if the key is not resolved
        */
        abstract private *string resolveField(auto data, string key, *string option);
    }

    #! Abstract class that defines the interface for logger layouts
    /**
        Event data (@ref LoggerEvent) are formatted before the record is passed to the target.
    */
    public class LoggerLayout {
        #! Format event record
        abstract public string format(LoggerEvent event);
    }

    #! Implements the formatting of @ref LoggerEvent objects with a pattern
    /**
        The \c LoggerLayoutPattern lets the user specify the output format according to conversion patterns similar to the @ref sprintf() function.

        The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

        | !Conversion character | !Meaning |
        | c | Used to output the category of the logging event, i.e. logger name |
        | C | Used to output the class name of the caller issuing the logging request, i.e. logger class name |
        | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}" |
        | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | F | Used to output the file name where the logging request was issued |
        | l | Used to output location information of the caller which generated the logging event, i.e. \c "file:line [function()]" |
        | L | Used to output the line number from where the logging request was issued, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | m | Used to output the application supplied message associated with the logging event |
        | M | Used to output the method name where the logging request was issued |
        | n | Outputs the platform dependent line separator character or characters |
        | p | Used to output the priority of the logging event |
        | r | Used to output the number of milliseconds elapsed from the construction of the layout until the creation of the logging event, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | t | Used to output the thread id that generated the logging event, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | u | Used to output logging event unique id, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | x | Used to output exception string using @ref Util::get_exception_string() |
        | % | The literal percent sign. \c "%%" will print a \c "%" sign |

        For example, the \c LoggerLayoutPattern with the conversion pattern \c "%r [%t] %-5p %c - %m%n" will output something like:

        @verbatim
            176 [23] INFO  MyLogger - New record created
        @endverbatim
    */
    public class LoggerLayoutPattern inherits LoggerLayout, public LoggerPattern {
        public {
            #! default layout pattern
            const DEFAULT_PATTERN = "%r [%t] %p %c - %m%n";
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYY-MM-DD HH:mm:SS.u";
        }

        #! Creates the object
        /**
            @param n_pattern the logger layout pattern
        */
        constructor(string n_pattern = DEFAULT_PATTERN): LoggerPattern(n_pattern) {
        }

        #! Returns the line delimiter used on the current OS
        static public string getLineDelimiter() {
            switch (PlatformOS) {
            case "Windows":
                return "\r\n";
            default:
                return "\n";
            }
        }

        #! Formats an event record
        /** @param event the event to format
            @return a formatted string for the event
        */
        public string format(LoggerEvent event) {
            return LoggerPattern::format(event);
        }

        #! Returns the value corresponding to a particular key
        /**
            @param event (@ref LoggerEvent)
            @param key the single-character formatting code
            @param option optional supporting information for \a key
        */
        private *string resolveField(auto event, string key, *string option) {
            if (!(event instanceof LoggerEvent)) {
                throw "LOGGER-ERROR", "Unsupported event type";
            }
            *string res;
            switch (key) {
                case "c":
                    res = event.getCategoryName();
                    break;
                case "C":
                    res = event.getFullQualifiedClassname();
                    break;
                case "d":
                    if (option) {
                        res = format_date(option, event.getTimeStamp());
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, event.getTimeStamp());
                    }
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "F":
                    res = event.getLocationInfo().file;
                    break;
                case "l":
                    hash<CallStackInfo> csi = event.getLocationInfo();
                    res = sprintf("%s:%d [%s()]", csi.file, csi.line, csi.function);
                    break;
                case "L":
                    res = sprintf(option ?? "%d", event.getLocationInfo().line);
                    break;
                case "m":
                    res = event.getMessage();
                    break;
                case "M":
                    res = event.getLocationInfo().function;
                    break;
                case "n":
                    res = getLineDelimiter();
                    break;
                case "p":
                    res = event.getLevel().getStr();
                    break;
                case "r":
                    res = sprintf(option ?? "%d", get_duration_milliseconds(event.getTimeStamp() - LoggerEvent::getStartTime()));
                    break;
                case "t":
                    res = sprintf(option ?? "%d", event.getThreadId());
                    break;
                case "u":
                    res = sprintf(option ?? "%d", event.getUniqueId());
                    break;
                case "x":
                    if (event.getThrowableInfo()) {
                        res = get_exception_string(event.getThrowableInfo());
                    } else {
                        res = "";
                    }
                    break;
            }
            return res;
        }
    }

    #! Implements an appender with a layout
    /**
        The layout is responsible for formatting the @ref LoggerEvent according to the user's wishes,
        whereas an appender takes care of sending the formatted output to its destination.

        It is used typically for appenders implementing logging to a file
    */
    public class LoggerAppenderWithLayout inherits LoggerAppender {
        private:internal {
            #! assigned layout
            LoggerLayout layout;
        }

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
        */
        constructor(*string n_name, LoggerLayout n_layout): LoggerAppender(n_name) {
            layout = n_layout;
        }

        #! Assigns a layout to the appender
        /**
        * @param n_layout the layout for the appender
        */
        public setLayout(LoggerLayout n_layout) {
            layout = n_layout;
        }

        #! Returns the layout for the appender
        public LoggerLayout getLayout() {
            return layout;
        }

        #! Returns the value formatted using the layout pattern
        /**
            @param event the event to serialize
        */
        private auto serializeImpl(LoggerEvent event) {
            return layout.format(event);
        }
    }

    #! implements appender writing to an output stream via @ref Qore::StreamWriter "StreamWriter"
    /**
        Qore streams are not designed to accept input from multiple threads simultaneously, so writing must be serialized and processed
        in a dedicated thread
    */
    public class LoggerAppenderStream inherits LoggerAppenderWithLayout {
        private:internal {
            #! stream writer
            StreamWriter writer;
            #! closed flag
            bool closed = False;
            #! assign thread for stream
            bool assignThread;
        }

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
            @param n_writer the stream to write to
        */
        constructor(*string n_name, LoggerLayout n_layout, StreamWriter n_writer): LoggerAppenderWithLayout(n_name, n_layout) {
            writer = n_writer;
            assignThread = writer.getOutputStream().getThreadId() == -1;
        }

        #! Returns the stream writer object
        public StreamWriter getStreamWriter() {
            return writer;
        }

        #! Returns @ref True if assigning a thread for a stream
        public bool hasAssignThread() {
            return assignThread;
        }

        #! Processes open, log, and close events with the output stream; all other events are ignored
        public processEventImpl(int type, auto params) {
            if (type == EVENT_OPEN) {
                if (closed) {
                    # OutputStream does not provide open method
                    throw "LOGGER-ERROR", "Cannot reopen stream";
                }
            } else {
                if (assignThread) {
                    writer.getOutputStream().reassignThread();
                }
                switch (type) {
                    case EVENT_LOG:
                        writer.print(params);
                        break;
                    case EVENT_CLOSE:
                        writer.getOutputStream().close();
                        closed = True;
                        break;
                }
                on_exit if (assignThread) {
                    writer.getOutputStream().unassignThread();
                }
            }
        }
    }

    #! Implements appender writing to a file
    /**
        No multi-threading protection is implemented in the class; the @ref Qore::File "File" class is reused
    */
    public class LoggerAppenderFile inherits LoggerAppenderWithLayout {
        private {
            File file;
            string fileName;
        }

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
            @param n_filename the output filename
            @param n_encoding the file's output encoding
        */
        constructor(*string n_name, LoggerLayout n_layout, string n_filename, *string n_encoding): LoggerAppenderWithLayout(n_name, n_layout) {
            file = new File(n_encoding);
            fileName = n_filename;
        }

        #! Returns the file object for the appender
        public File getFile() {
            return file;
        }

        #! Returns the current filename
        public string getFileName() {
            return fileName;
        }

        #! Processes open, close, and log events with the file and ignores all other events
        /**
            @param type the event type
            @param params parameters for the event
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_OPEN:
                    file.open2(fileName, O_CREAT | O_APPEND | O_WRONLY);
                    break;
                case EVENT_CLOSE:
                    try {
                        file.close();
                    } catch (hash<ExceptionInfo> ex) {
                        if (ex.err != "ILLEGAL-EXPRESSION") {
                            # catch unclosable stdxxx errors, TODO: file.isTTY() does the same job ?
                            rethrow;
                        }
                    }
                    break;
                case EVENT_LOG:
                    file.print(params);
                    break;
            }
        }
    }

%ifdef HAVE_TERMIOS
    #! Implements appender writing to a stdout file
    /**
        No multi-threading protection is implemented in the class; the @ref Qore::stdout "stdout" instance is reused.
        Unavailable when @ref Qore::PO_NO_TERMINAL_IO parse option is applied.
    */
    public class LoggerAppenderStdOut inherits LoggerAppenderWithLayout {

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
        */
        constructor(*string n_name, LoggerLayout n_layout): LoggerAppenderWithLayout(n_name, n_layout) {
        }

        #! Processes log events with the file and ignores all other events including open, close
        /**
            @param type the event type
            @param params parameters for the event
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_LOG:
                    stdout.print(params);
                    break;
            }
        }
    }

    #! Implements appender writing to a stderr file
    /**
        No multi-threading protection is implemented in the class; the @ref Qore::stderr "stderr" instance is reused.
        Unavailable when @ref Qore::PO_NO_TERMINAL_IO parse option is applied.
    */
    public class LoggerAppenderStdErr inherits LoggerAppenderWithLayout {

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
        */
        constructor(*string n_name, LoggerLayout n_layout): LoggerAppenderWithLayout(n_name, n_layout) {
        }

        #! Processes log events with the file and ignores all other events including open, close
        /**
            @param type the event type
            @param params parameters for the event
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_LOG:
                    stderr.print(params);
                    break;
            }
        }
    }
%endif

    #! Abstract class for file appenders with rotation support
    public class AbstractLoggerAppenderFileRotate inherits public LoggerAppenderFile {
        public {
            #! rotate event
            const EVENT_ROTATE = 10001;
            #! default value for rotation chain
            const DEFAULT_ROTATION_COUNT = 10;
        }

        constructor(*string n_name, LoggerLayout n_layout, *string n_encoding): LoggerAppenderFile(n_name, n_layout, "", n_encoding) {}

        #! Pushes rotate event
        /**
            The current log file will be closed and opened. If the file exists, then it is ovewritten

            @throw LOGGER-ERROR if rotation is disabled
        */
        public rotate() {
            if (isOpen()) {
                if (getCount() <= 0) {
                    throw "LOGGER-ERROR", "Rotation is disabled";
                }
                pushEvent(EVENT_ROTATE, NOTHING);
            }
        }

        #! Abstract method to get count of rotation objects
        public abstract int getCount();
    }

    #! Implements appender writing to a file with file rotation support
    /**
        The events will be logged to a file until rotation occurs.
        At that moment the current file is closed, archive chain is moved,
        new file is created and logging continues there.
    */
    public class LoggerAppenderFileRotate inherits public AbstractLoggerAppenderFileRotate, private LoggerPattern {
        public {
            #! default archive pattern
            const DEFAULT_ARCHIVE_PATTERN = "%p%f.%i";
        }

        private:internal {
            int count;
        }

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
            @param n_filename with pattern support; see below for more information
            @param n_count number of files in rotation chain, if count is <=0 then no ratation is performed
            @param n_archive pattern to evaluate archive filename; see below for more information
            @param n_encoding the encoding of the output file

            The following table explains the characters used in @ref LoggerPattern for both filename and archive parameter

            | !Conversion character | !Meaning |
            | s | Used to output the OS directory separator, i.e. "\" or "/" |
            | c | Used to output the appender name |
            | C | Used to output the appender class name |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            The following table explains the characters used in @ref LoggerPattern for archive parameter only

            | !Conversion character | !Meaning |
            | P | Used to output the current logging path with filename |
            | p | Used to output the current logging path |
            | f | Used to output the current logging filename |
            | i | Used to output the current file index from 1 to count. option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | n | Used to output the rotation count. Option may specify @ref sprintf() format, e.g. \c "%.3d" |

            For example, the archive pattern \c "%p%f.%i" rotates log file \c "/var/run/log/MyLogger.log" to:
            \c "/var/run/log/MyLogger.log.1" \c "/var/run/log/MyLogger.log.2" \c "/var/run/log/MyLogger.log.3".
        */
        constructor(*string n_name, LoggerLayout n_layout, string n_filename, int n_count = DEFAULT_ROTATION_COUNT, string n_archive = DEFAULT_ARCHIVE_PATTERN, *string n_encoding): AbstractLoggerAppenderFileRotate(n_name, n_layout, n_encoding), LoggerPattern(n_filename) { # do not split line not to confuse doxygen generator!!!
            fileName = format(NOTHING);  # no dynamic vars as timestamp
            count = n_count;
            setPattern(n_archive);
        }

        #! Returns a string for a format field for a pattern-based filename
        /**
            @param data input context reference data
            @param key the format character
            @param option the format option value, if any

            @return the formatted string
        */
        private *string resolveField(auto data, string key, *string option) {
            *string res;
            switch (key) {
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "s":
                    res = DirSep;
                    break;
            }
            if (data) {  # archive pattern
                switch (key) {
                    case "i":
                        res = sprintf(option ?? "%d", data.index);
                        break;
                    case "n":
                        res = sprintf(option ?? "%d", data.count);
                        break;
                    case "P":
                        res = data.filename;
                        break;
                    case "p": # path
                        res = dirname(data.filename);
                        if (res != DirSep) {
                            res += DirSep;
                        }
                        break;
                    case "f": # filename
                        res = basename(data.filename);
                        break;
                }
            }
            return res;
        }

        #! Implements filename rotation; handles the open and rotate events directly; passes all other events to the subclass for handling
        /**
            @param type the event type
            @param params event parameters
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_ROTATE:
                    if (count > 0 && is_file(fileName)) {
                        list fn = ();
                        int i = 0;
                        while (True) {
                            push fn, getArchiveFileName(i+1);
                            if (!is_dir(dirname(fn[i]))) {
                                mkdir_ex(dirname(fn[i]), 0777, True);
                            }
                            if (i >= count-1 || !is_file(fn[i])) {
                                # find a gap in chain or stop at the last file
                                break;
                            }
                            i++;
                        }
                        while (i > 0) {
                            # shift files till a gap or last file
                            rename(fn[i-1], fn[i]);
                            i--;
                        }
                        file.close();
                        rename(fileName, fn[0]);
                        file.open2(fileName, O_CREAT | O_APPEND | O_WRONLY | O_TRUNC);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! Returns the archive filename
        /**
            @param idx the index of file (1..count)
        */
        public string getArchiveFileName(int idx) {
            hash h;
            h.filename = fileName;
            h.count = count;
            h.index = idx;
            string res = format(h);
            return res;
        }

        #! Returns max.number of files in chain
        public int getCount() {
            return count;
        }
    }


    #! Implemants appender writing to a file with file circular rotation support
    /**
        The events will be logged to a file until rotation occurs.
        At that moment the current file is closed, next file is created
        and logging continues to the new file.
    */
    public class LoggerAppenderFileRing inherits public AbstractLoggerAppenderFileRotate, private LoggerPattern {
        public {
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
        }

        private:internal {
            hash patternData;
        }

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
            @param n_pattern to generate the file name; see information below
            @param n_count number of files in ring, if count is <=0 then no ratation is performed
            @param n_encoding the encoding of the output file

            The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

            | !Conversion character | !Meaning |
            | i | Used to output the current file index from 0 to count-1. option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | n | Used to output the rotation count. Option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | c | Used to output the appender name. |
            | C | Used to output the appender class name. |
            | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            For example, the pattern \c "/var/run/log/%c.log.%i{%03d}" creates the following file names:
            \c "/var/run/log/MyLogger.log.000", \c "/var/run/log/MyLogger.log.001" etc.
        */
        constructor(*string n_name, LoggerLayout n_layout, string n_pattern, int n_count = DEFAULT_ROTATION_COUNT, *string n_encoding): AbstractLoggerAppenderFileRotate(n_name, n_layout, n_encoding), LoggerPattern(n_pattern) {
            # set a provisional filename, to be updated when file is opened
            patternData.timestamp = now_us();
            patternData.count = n_count;
            patternData.index = 0;
            fileName = format(patternData);
        }

        #! Returns a string for a format field for a pattern-based filename
        /**
            @param data input context reference data
            @param key the format character
            @param option the format option value, if any

            @return the formatted string
        */
        private *string resolveField(auto data, string key, *string option) {
            *string res;
            switch (key) {
                case "i":
                    res = sprintf(option ?? "%d", data.index);
                    break;
                case "n":
                    res = sprintf(option ?? "%d", data.count);
                    break;
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "d":
                    if (option) {
                        res = format_date(option, data.timestamp);
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                    }
                    break;
                case "E":
                    res = ENV{option};
                    break;
            }
            return res;
        }

        #! Implements filename rotation; handles the open and rotate events directly; passes all other events to the subclass for handling
        /**
            @param type the event type
            @param params event parameters
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_OPEN:
                    # find newest file
                    patternData.timestamp = now_us();
                    int last_idx = 0;
                    if (patternData.count > 0) {
                        date last_stamp;
                        hash pd = patternData;
                        for (int i=0; i < patternData.count; i++) {
                            pd.index = i;
                            string fn = format(pd);
                            *hash<StatInfo> si = hstat(fn);
                            if (si) {
                                if (!last_stamp || si.mtime > last_stamp) {
                                    last_stamp = si.mtime;
                                    last_idx = i;
                                }
                            }
                        }
                    }
                    patternData.index = last_idx;
                    fileName = format(patternData);
                    LoggerAppenderFile::processEventImpl(type, params);
                    break;
                case EVENT_ROTATE:
                    if (patternData.count > 0) {
                        file.close();
                        patternData.index = (patternData.index + 1) % patternData.count;
                        patternData.timestamp = now_us();
                        fileName = format(patternData);
                        file.open2(fileName, O_CREAT | O_APPEND | O_WRONLY | O_TRUNC);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! Returns number of files in ring
        public int getCount() {
            return patternData.count;
        }

        #! Returns current ring index being used for logging
        public int getCurrentIndex() {
            return patternData.index;
        }
    }

    #! Implements appender writing to a file with archive support
    /**
        The events will be logged to a file until archiving is triggered.
        At that moment the current file is closed, moved to file with name evaluated in runtime
        from the archive pattern set in the object, the new file is created, and logging continues to that file.
        The archive never overwrites any existing file.
    */
    public class LoggerAppenderFileArchive inherits public LoggerAppenderFile, private LoggerPattern {
        public {
            #! archive event
            const EVENT_ARCHIVE = 20;
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
            #! default archive pattern
            const DEFAULT_ARCHIVE_PATTERN = "%p%f.%d";
        }

        #! Creates the object
        /**
            @param n_name the name of the appender
            @param n_layout the layout for the appender
            @param n_filename with pattern support; see below for more information
            @param n_archive pattern to evaluate archive filename; see below for more information
            @param n_encoding the output file's encoding

            The following table explains the characters used in @ref LoggerPattern for both filename and archive parameter

            | !Conversion character | !Meaning |
            | s | Used to output the OS directory separator, i.e. "\" or "/" |
            | c | Used to output the appender name |
            | C | Used to output the appender class name |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            The following table explains the characters used in @ref LoggerPattern for archive parameter only

            | !Conversion character | !Meaning |
            | P | Used to output the current logging path with filename |
            | p | Used to output the current logging path |
            | f | Used to output the current logging filename |
            | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |

            For example, the archive pattern \c "%p/archive/%d/%f" archives log file \c "/var/run/log/MyLogger.log" to:
            \c "/var/run/log/archive/20180120102030/MyLogger.log".
        */
        constructor(*string n_name, LoggerLayout n_layout, string n_filename, string n_archive = DEFAULT_ARCHIVE_PATTERN,
            *string n_encoding): LoggerAppenderFile(n_name, n_layout, n_filename, n_encoding), LoggerPattern(n_filename) {
            fileName = format(NOTHING);  # no dynamic vars as timestamp
            setPattern(n_archive);
        }

        #! Returns a string for a format field for a pattern-based filename or archive file name
        /**
            @param data if @ref nothing, then this argument specifies the logging filename, otherwise is specifies the archive pattern
            @param key the format character
            @param option the format option value, if any

            @return the formatted string
        */
        private *string resolveField(auto data, string key, *string option) {
            *string res;
            switch (key) {
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "s":
                    res = DirSep;
                    break;
            }
            if (data) {  # archive pattern
                switch (key) {
                    case "d":
                        if (option) {
                            res = format_date(option, data.timestamp);
                        } else {
                            res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                        }
                        break;
                    case "P":
                        res = data.filename;
                        break;
                    case "p": # path
                        res = dirname(data.filename);
                        if (res != DirSep) {
                            res += DirSep;
                        }
                        break;
                    case "f": # filename
                        res = basename(data.filename);
                        break;
                }
            }
            return res;
        }

        #! Implements archiving, handles the archive event directly, passes all other events to the subclass for handling
        /**
            @param type the event code
            @param params event parameters
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_ARCHIVE:
                    mkdir_ex(dirname(params), 0777, True);
                    if (isOpen()) {
                        file.close();
                        rename(fileName, params);
                        LoggerAppenderFile::processEventImpl(EVENT_OPEN, NOTHING);
                    } else {
                        rename(fileName, params);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! Posts an archive event
        /**
            rename logging file and open new one
            @return archive file name

            @throw LOGGER-ERROR if target file name is not correct or target file already exists
        */
        public string archive() {
            string afn = getArchiveFileName();
            if (afn == "") {
                throw "LOGGER-ERROR", "Empty target filename";
            }
            if (normalize_dir(afn) == normalize_dir(fileName)) {
                throw "LOGGER-ERROR", "Source and target path are equal";
            }
            if (is_dir(afn)) {
                throw "LOGGER-ERROR", "Target is directory";
            }
            if (is_file(afn)) {
                throw "LOGGER-ERROR", "Target file already exists";
            }
            pushEvent(EVENT_ARCHIVE, afn);
            return afn;
        }

        #! Returns the archive filename
        /**
            The pattern may contain date fields so the result may differ when
            executed multiple times
        */
        public string getArchiveFileName() {
            hash h;
            h.timestamp = now_us();
            h.filename = fileName;
            string res = format(h);
            return res;
        }
    }

    #! Implements a general event filtering class
    /**
        Users should extend this class to implement customized logging
        event filtering. The filter consists of a linear chain of
        particular filters evaluating if the event should be immediately accepted, rejected
        or passed to next filter.
    */
    public class LoggerFilter {
        public {
            #! The event will be processed
            const ACCEPT = 1;

            #! No decision could be made, further filtering should occur
            const NEUTRAL = 0;

            #! The event should not be processed
            const DENY = -1;
        }

        #! Performs filtering logic on an event and returns the decision for the event
        /**
            The method should be overridden to implement a real rule. The default result is @ref NEUTRAL

            @param event the log event

            @return the result of evaluating the event (the default for this method is @ref NEUTRAL)
        */
        public int eval(LoggerEvent event) {
            return NEUTRAL;
        }
    }

    #! Implements the filter according event @ref LoggerLevel
    /**
        When @ref LoggerEvent::getLevel does not satisfy the filter condition, then
        logging is rejected.

        The min and max levels define the range to be logged (if min <= max.level) or range which won't be logged (if max < min.level)
    */
    public class LoggerFilterLevel inherits LoggerFilter {
        private:internal {
            #! min.level
            LoggerLevel minLevel;
            #! max.level
            LoggerLevel maxLevel;
        }

        #! Creates the object
        /**
            @param min_value the minimum logging level
            @param max_value the maximum logging level
        */
        constructor(LoggerLevel min_value = LoggerLevel::getLevelInfo(), LoggerLevel max_value = LoggerLevel::getLevelOff()) {
            setMinLevel(min_value);
            setMaxLevel(max_value);
        }

        #! Creates the object
        /**
            @param min_value the minimum logging level
            @param max_value the maximum logging level
        */
        constructor(int min_value, int max_value = LoggerLevel::OFF) {
            setMinLevel(min_value);
            setMaxLevel(max_value);
        }

        #! Creates the object
        /**
            @param min_value the minimum logging level
            @param max_value the maximum logging level
        */
        constructor(string min_value, string max_value = "OFF") {
            setMinLevel(min_value);
            setMaxLevel(max_value);
        }

        #! Sets the minimum logging level
        /**
            @param value the minimum logging level
        */
        public setMinLevel(LoggerLevel value) {
            minLevel = value;
        }

        #! Sets the minimum logging level
        /**
            @param value the minimum logging level
        */
        public setMinLevel(int value) {
            setMinLevel(LoggerLevel::getLevel(value));
        }

        #! Sets the minimum logging level
        /**
            @param value the minimum logging level
        */
        public setMinLevel(string value) {
            setMinLevel(LoggerLevel::getLevel(value));
        }

        #! Returns the minimum logging level
        public LoggerLevel getMinLevel() {
            return minLevel;
        }

        #! Sets the maximum logging level
        /**
            @param value the maximum logging level
        */
        public setMaxLevel(LoggerLevel value) {
            maxLevel = value;
        }

        #! Sets the maximum logging level
        /**
            @param value the maximum logging level
        */
        public setMaxLevel(int value) {
            setMaxLevel(LoggerLevel::getLevel(value));
        }

        #! Sets the maximum logging level
        /**
            @param value the maximum logging level
        */
        public setMaxLevel(string value) {
            setMaxLevel(LoggerLevel::getLevel(value));
        }

        #! Returns the maximum logging level
        public LoggerLevel getMaxLevel() {
            return maxLevel;
        }

        #! Implements filtering by level
        public int eval(LoggerEvent event) {
            if (maxLevel.isGreaterOrEqual(minLevel)) {
                if (!(event.getLevel().isGreaterOrEqual(minLevel) && maxLevel.isGreaterOrEqual(event.getLevel()))) {
                    return DENY;
                }
            } else {
                if (event.getLevel().isGreaterOrEqual(maxLevel) && minLevel.isGreaterOrEqual(event.getLevel())) {
                    return DENY;
                }
            }
            return NEUTRAL;
        }
    }

    #! Implements filtering according to a regular expression on the event message
    /**
        The rendered event message is tested using a regular expression, and if it does not match the
        expected result, then logging is rejected
    */
    public class LoggerFilterRegex inherits LoggerFilter {
        private:internal {
            #! regular string
            string regexStr;
            #! expected result
            bool regexResult;
        }

        #! Creates the object
        /**
            @param regex_str the regular expression to use
            @param regex_result @ref True for a positive match, @ref False for a negative match
        */
        constructor(string regex_str = "", bool regex_result = True) {
            setRegex(regex_str, regex_result);
        }

        #! Sets the regular expression and the expected result for the filter
        /**
            @param regex_str the regular expression to use
            @param regex_result @ref True for a positive match, @ref False for a negative match
        */
        public setRegex(string regex_str, bool regex_result = True) {
            regexStr = regex_str;
            regexResult = regex_result;
        }

        #! Returns the current regex
        public string getRegex() {
            return regexStr;
        }

        #! Returns the expected result
        public bool getRegexResult() {
            return regexResult;
        }

        #! Evaluates the regex and compares with the expected result
        public int eval(LoggerEvent event) {
            if (event.getMessage().regex(regexStr) != regexResult) {
                return DENY;
            } else {
                return NEUTRAL;
            }
        }
    }

    #! Implements main logger class whose instance will be used by user code when logging
    /**
        The Logger object is provided to user code. When a log is triggered then
        message, arguments, current code position, time are appended into @ref LoggerEvent event instance when
        the logging level is enabled. The event is passed to all registered appenders in the given Logger as well as
        in parents in the hierarchy when additivity is enabled.
    */
    public class Logger {
        private:internal {
            #! The lock to protect object manipulation
            RWLock lock();

            #! The lock to protect access to parent/child hierarchy
            static RWLock hierarchyLock();

            #! Logger additivity. If set to true then child loggers will inherit the appenders of their ancestors by default.
            bool additivity = True;

            #! The assigned Logger level. If @ref nothing, the parent level is used
            *LoggerLevel currentLevel;

            #! The name of this Logger instance.
            string name;

            #! The parent logger. Unassigned if this is the root logger.
            *Logger parent;

            #! A collection of appenders linked to this logger.
            list<LoggerAppender> appenders;
        }

        #! Creates the object
        /**
            @param name the name of the object
        */
        constructor(string name = "") {
            self.name = name;
        }

        #! Creates the object
        /**
            @param name the name of the object
            @param level the initial level for the logger
        */
        constructor(string name, LoggerLevel level) {
            self.name = name;
            currentLevel = level;
        }

        #! Creates the object with an empty name and the given initial level
        /**
            @param level the initial level for the logger
        */
        constructor(LoggerLevel level) {
            self.name = "";
            currentLevel = level;
        }

        destructor() {
            setParent(NOTHING);
        }

        #! Returns the logger name
        public string getName() {
            return name;
        }

        #! Returns the parent logger, if any
        public *Logger getParent() {
            return parent;
        }

        #! Sets the parent logger
        /**
            @param value the parent logger
            @throw LOGGER-ERROR in case of circular reference
        */
        public setParent(*Logger value) {
            AutoWriteLock awl(lock);
            if (value) {
                AutoWriteLock awhl(Logger::hierarchyLock);
                *Logger l = self;
                while (exists l) {
                    if (l == value) {
                        throw "LOGGER-ERROR", "Circular logger chain";
                    }
                    l = l.getParent();
                }
            }
            parent = value;
        }

        #! Returns the logging level
        /**
            @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
            @throw LOGGER-ERROR if cannot get effective level from hierarchy
        */
        public *LoggerLevel getLevel(bool effective = True) {
            if (effective) {
                AutoReadLock awhl(Logger::hierarchyLock);
                *Logger l = self;
                while (!exists l.getLevel(False)) {
                    l = l.getParent();
                    if (!exists l) {
                        throw "LOGGER-ERROR", "Cannot get effective level";
                    }
                }
                return l.getLevel(False);
            } else {
                return currentLevel;
            }
        }

        #! Sets the logging level
        /**
            @param level if nothing then inherits level from parent
        */
        public setLevel(*LoggerLevel level) {
            currentLevel = level;
        }

        #! Sets the logging level
        /**
            @param level the logging level as a string
        */
        public setLevel(string level) {
            setLevel(LoggerLevel::getLevel(level));
        }

        #! Sets the logging level
        /**
            @param level the logging level to set
        */
        public setLevel(int level) {
            setLevel(LoggerLevel::getLevel(level));
        }

        #! Decrement logger level
        /**
            @return current \c LoggerLevel
        */
        public *LoggerLevel decLevel() {
            if (currentLevel) {
                *LoggerLevel lvl = LoggerLevel::getNextLowerLevel(currentLevel.getValue());
                if (lvl) {
                    setLevel(lvl);
                }
            }
            return currentLevel;
        }

        #! Increment logger level
        /**
            @return current \c LoggerLevel
        */
        public *LoggerLevel incLevel() {
            if (currentLevel) {
                *LoggerLevel lvl = LoggerLevel::getNextHigherLevel(currentLevel.getValue());
                if (lvl) {
                    setLevel(lvl);
                }
            }
            return currentLevel;
        }

        #! Sets the additivity flag; when additivity is active, events are passed to parent loggers.
        /**
            @param enable the additivity flag; when additivity is active, events are passed to parent loggers
        */
        public setAdditivity(bool enable) {
            additivity = enable;
        }

        #! Returns the additivity flag.
        public bool getAdditivity() {
            return additivity;
        }

        #! Returns the call location where the log function was called from
        private hash<CallStackInfo> getLocation() {
            list<hash<CallStackInfo>> loc = get_thread_call_stack();
            return loc[2];   # get location at stack-2
        }

        #! Forwards the given logging event to all linked appenders.
        /**
            @param event the event to forward
        */
        private callAppenders(LoggerEvent event) {
            AutoReadLock arl(lock);
            map $1.post(event), appenders;
        }

        #! Adds an appender to the appender list
        /**
            @param appender add a new LoggerAppender
            @throw "LOGGER-ERROR" exception if appender is already in list
        */
        public addAppender(LoggerAppender appender) {
            AutoWriteLock awl(lock);
            if (!appenders) {
                appenders = (appender, );
            } else {
                if (appenders.contains(appender)) {
                    throw "LOGGER-ERROR", "Appender already exists in list";
                }
                push appenders, appender;
            }
        }

        #! Removes the appender from the list
        /**
            @param appender the appender to remove
        */
        public removeAppender(LoggerAppender appender) {
            AutoWriteLock awl(lock);
            foreach LoggerAppender a in (appenders) {
                if (a == appender) {
                    splice appenders, $#, 1;
                    break;
                }
            }
        }

        #! Clears the appender list by removing all appenders
        public removeAllAppenders() {
            AutoWriteLock awl(lock);
            splice appenders, 0;
        }

        #! Returns the appender list
        /**
            Note that the appender list may be manipulated in another thread as internal lock is released
            when list is returned
        */
        public list<LoggerAppender> getAppenders() {
            AutoReadLock awl(lock);
            return appenders ?? ();
        }

        private:internal logIntern(LoggerLevel level, string message, *list<auto> args, *hash<CallStackInfo> location,
                bool check_throwable, date time_stamp = now_us()) {

            #printf("lI: level: %y msg: %y args: %y loc: %y c: %y t: %y", level, message, args, location, check_throwable, time_stamp);

            if (isEnabledFor(level)) {
                *hash<ExceptionInfo> throwable;
                if (args.size() && check_throwable) {
                    # is the last argument ExceptionInfo ?
                    auto a = args[args.size()-1];
                    if (a.typeCode() == NT_HASH && a.fullType() == "hash<ExceptionInfo>") {
                        throwable = a;
                    }
                }
                callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), time_stamp, throwable));
                {
                    AutoReadLock awl(lock);
                    if (parent && getAdditivity()) {
                        # Forward the event upstream if additivity is turned on
                        parent.logIntern(level, message, args, location, throwable, time_stamp);
                    }
                }
            } else {
                AutoReadLock awl(lock);
                if (parent && getAdditivity()) {
                    # Forward the event upstream if additivity is turned on
                    parent.logIntern(level, message, args, location, check_throwable, time_stamp);
                }
            }
        }

        private:internal logIntern(LoggerLevel level, string message, *list<auto> args, *hash<CallStackInfo> location,
                *hash<ExceptionInfo> throwable, date time_stamp) {
            if (isEnabledFor(level)) {
                callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), time_stamp, throwable));
            }
            {
                AutoReadLock awl(lock);
                if (parent && getAdditivity()) {
                    # Forward the event upstream if additivity is turned on
                    parent.logIntern(level, message, args, location, throwable, time_stamp);
                }
            }
        }

        #! Logs a message using the provided logging level.
        /**
            @param level The logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public log(LoggerLevel level, string message) {
            logIntern(level, message, argv, getLocation(), True);
        }

        #! Logs a message using the provided logging level.
        /**
            @param level the logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public log(int level, string message) {
            logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
        }

        #! Logs a message using the provided logging level.
        /**
            @param level The logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public log(string level, string message) {
            logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
        }

        #! Logs a message using the provided logging level and a single argument for any format string arguments.
        /**
            @param level The logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
            @param args any format string arguments to the log message
        */
        public logArgs(LoggerLevel level, string message, *softlist<auto> args) {
            logIntern(level, message, args, getLocation(), True);
        }

        #! Logs a message using the provided logging level and a single argument for any format string arguments.
        /**
            @param level the logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public logArgs(int level, string message, *softlist<auto> args) {
            logIntern(LoggerLevel::getLevel(level), message, args, getLocation(), True);
        }

        #! Logs a message using the provided logging level and a single argument for any format string arguments.
        /**
            @param level The logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public logArgs(string level, string message, *softlist<auto> args) {
            logIntern(LoggerLevel::getLevel(level), message, args, getLocation(), True);
        }

        #! Logs an already prepared logging event object.
        /**
            @param event the event to log
        */
        public logEvent(LoggerEvent event) {
            if (isEnabledFor(event.getLevel())) {
                callAppenders(event);
            }

            {
                AutoReadLock awl(lock);
                # Forward the event upstream if additivity is turned on
                if (parent && getAdditivity()) {
                    parent.logEvent(event);
                }
            }
        }

        #! Logs a message object with the TRACE level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public trace(string message) {
            logIntern(LoggerLevel::getLevelTrace(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the DEBUG level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public debug(string message) {
            logIntern(LoggerLevel::getLevelDebug(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the INFO level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public info(string message) {
            logIntern(LoggerLevel::getLevelInfo(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the WARN level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public warn(string message) {
            logIntern(LoggerLevel::getLevelWarn(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the ERROR level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public error(string message) {
            logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the FATAL level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public fatal(string message) {
            logIntern(LoggerLevel::getLevelFatal(), message, argv, getLocation(), True);
        }

        #! Performs logging of assertions
        /**
            If the \a assertion parameter is @ref False, then the message is logged
            using the ERROR level.

            @see @ref log()

            @param assertion the boolean assertion value
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public assertLog(bool assertion, string message) {
            if(!assertion) {
                logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
            }
        }

         #! Logs the variable name and value using TRACE level
        /**
            @see @ref log()

            @param var_name the variable name
            @param value the value of the variable
        */
        public traceVar(string var_name, auto value) {
            logIntern(LoggerLevel::getLevelTrace(), sprintf("%s: %%y", var_name), (value, ), getLocation(), False);
        }

        #! Logs the variable name and value using DEBUG level
        /**
            @see @ref log()

            @param var_name the variable name
            @param value the value of the variable
        */
        public debugVar(string var_name, auto value) {
            logIntern(LoggerLevel::getLevelDebug(), sprintf("%s: %%y", var_name), (value, ), getLocation(), False);
        }

        #! Checks whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level the log level to check
        */
        public bool isEnabledFor(LoggerLevel level) {
            return level.isGreaterOrEqual(getLevel());
        }

        #! Checks whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level the log level to check
        */
        public bool isEnabledFor(int level) {
            return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
        }

        #! Checks whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level the log level to check
        */
        public bool isEnabledFor(string level) {
            return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
        }

        #! Checks whether this Logger is enabled for the TRACE Level.
        public bool isTraceEnabled() {
            return isEnabledFor(LoggerLevel::getLevelTrace());
        }

        #! Checks whether this Logger is enabled for the DEBUG Level.
        public bool isDebugEnabled() {
            return isEnabledFor(LoggerLevel::getLevelDebug());
        }

        #! Checks whether this Logger is enabled for the INFO Level.
        public bool isInfoEnabled() {
            return isEnabledFor(LoggerLevel::getLevelInfo());
        }

        #! Checks whether this Logger is enabled for the WARN Level.
        public bool isWarnEnabled() {
            return isEnabledFor(LoggerLevel::getLevelWarn());
        }

        #! Checks whether this Logger is enabled for the ERROR Level.
        public bool isErrorEnabled() {
            return isEnabledFor(LoggerLevel::getLevelError());
        }

        #! Checks whether this Logger is enabled for the FATAL Level.
        public bool isFatalEnabled() {
            return isEnabledFor(LoggerLevel::getLevelFatal());
        }
    }

    #! Implements the root class for loggers; does not allow a parent logger to be set
    public class LoggerRoot inherits Logger {
        # Creates the object
        /**
            @param level initial log level
        */
        constructor(LoggerLevel level = LoggerLevel::getLevelAll()): Logger('') {
            setLevel(level);
        }

        # Creates the object
        /**
            @param level initial log level
        */
        constructor(int level): Logger('') {
            setLevel(level);
        }

        # Creates the object
        /**
            @param level initial log level
        */
        constructor(string level): Logger('') {
            setLevel(level);
        }

        #! Overrides the level setter to prevent setting the root logger's level to @ref nothing (an exception is thrown in this case).
        /**
            The root logger must always have a level.

            @param value the level to set
            @throw LOGGER-ERROR if level is @ref nothing
        */
        public setLevel(*LoggerLevel value) {
            if (!exists value) {
                throw "LOGGER-ERROR", "Cannot set null level for root";
            }
            Logger::setLevel(value);
        }

        #! Overrides value setter as the root logger cannot have a parent; this method always throws an exception if the argument is a value
        /**
            @throw LOGGER-ERROR if parent exists
        */
        public setParent(*Logger value) {
            if (exists value) {
                throw "LOGGER-ERROR", "Cannot set parent for root";
            }
        }
    }
}
