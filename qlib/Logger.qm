# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Logger.qm Logger library

/*  Logger.qm Copyright 2013 - 2018 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.9

%require-types
%enable-all-warnings
%new-style
%no-debugging

%requires Util

module Logger {
    version = "0.1";
    desc = "user module implementing Log4q logger library";
    author = "Tomas Mandys <tomas.mandys@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Logger Module

    @tableofcontents

    @section loggerintro Introduction to the Logger Module

    The %Logger module (aka <b>Log4q</b>) adopts its primary design from the well known
    <a href="https://logging.apache.org/log4j/2.x">log4j</a> library, therefore it
    implements the following primary base classes:
    - @ref Logger::Logger "Logger"
    - @ref Logger::LoggerAppender "LoggerAppender" (abstract)
    - @ref Logger::LoggerFilter "LoggerFilter"
    - @ref Logger::LoggerLayout "LoggerLayout" (abstract)
    - @ref Logger::LoggerPattern "LoggerPattern" (abstract)

    Abstract base classes must be subclassed to implement the desired functionality.

    @subsection logger_scenarior Scenarios

    @par One Thread

    The user code will log to a @ref Logger object, and the logging is performed to the appender synchronously.

    Example:
    @code{.py}
    Logger l("mylogger", LoggerLevel::getLevelInfo());
    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    l.addAppender(laf);
    laf.open();
    ....
    l.info("hello %s #%d", "world", 1);
    l.error("the %s is not perfect", "world");
    @endcode

    @par Multiple Threads

    The user code will log from multiple threads; the events are pushed to a
    @ref Logger::LoggerAppenderQueue "LoggerAppenderQueue" object. The processing is done in a dedicated thread
    when the events are passed to appenders. The the user code logging command is non-blocking as it terminates
    immediately when the event is pushed in the queue.

    Example:
    @code{.py}
    our Logger l("mylogger", LoggerLevel::getLevelInfo());

    sub run() {
        while (!done) {
            ...
            l.info("hello %s #%d", "world", 1);
            l.error("the %s is not perfect", "world");
            ...
        }
    }

    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    laf.setQueue(new LoggerAppenderQueue());
    l.addAppender(laf);
    laf.open();

    for (int i=0; i<10; i++) {
        background run();
    }

    while (True) {
        laf.getQueue().process();
    }
    @endcode

    @par Application Server Running Logging From a Few Sandboxed Program Containers

    In this example, the appserver provides a logger API for a few sandboxed programs. The appserver is
    responsible for the <b>Log4q</b> configuration; i.e. it prepares loggers, appenders, filters, etc.
    according to configuration and provides the @ref Logger instance to the @ref Qore::Program "Program"
    container running the sandboxed code.\n
    The sandboxed code will log to this instance; the logging events are processed by the appserver in a
    dedicated thread which gets the event from a queue and passes it to appenders.  Multiple loggers may be
    configured in a parent/child hierarchy so that a higher logging level (i.e. more event levels) are logged
    with the logger assigned to the sandbox and fewer (ex: only critical errors) to the global appserver logger.

    Example:
    @code{.py}
    LoggerAppenderQueue laq();
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);

    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    while (True) {
        laq.process(-1);
    }
    @endcode

    @par Application Server Running Many Sandboxed Program Containers

    This example is basically the same as the previous example, but to avoid I/O bottlenecks in logging, the
    appserver processing thread gets the event from a queue and passes it to the appender in another worker
    thread by a submitting the logging action to a @ref Qore::Thread::ThreadPool "ThreadPool". So events targeted
    to a particular thread may by processed in different threads but nevertheless serially.

    Example:
    @code{.py}
    ThreadPool tp();
    LoggerAppenderQueueThreadPool laq(tp, 5);
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);
    code processing() = sub () {
        while (True) {
            laq.process(-1);
        }
    }
    # may run in extra thread
    background processing();
    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    # wait till finished
    @endcode

    @subsection logger_v0_1 v0.1
    - the initial version of the Logger module
*/

#! the Logger namespace contains all the definitions in the Logger module
public namespace Logger {

    #! Defines the minimum set of levels recognized by the system.
    /**
        The set of built-in levels includes \c TRACE, \c DEBUG, \c INFO, \c WARN, \c ERROR and \c FATAL. Log4q also supports
        custom log levels where the \c LoggerLevel class may be subclassed to define a larger level set.
    */
    public class LoggerLevel {
        public {
            #! built-in logger levels
            const OFF = MAXINT;
            const FATAL = 50000;
            const ERROR = 40000;
            const WARN = 30000;
            const INFO = 20000;
            const DEBUG = 10000;
            const TRACE = 5000;
            const ALL = MININT;
        }

        private:internal {
            #! Integer level value.
            int m_level;

            #! String representation of the level.
            string m_levelStr;

            #! Contains a list of instantiated levels
            static hash<string, LoggerLevel> m_levelMap;

            #! String to int hash
            const LevelStr2Level = (
                'ALL':   ALL,
                'TRACE': TRACE,
                'DEBUG': DEBUG,
                'INFO':  INFO,
                'WARN':  WARN,
                'ERROR': ERROR,
                'FATAL': FATAL,
                'OFF':   OFF,
            );

            #! Int to string hash
            const Level2LevelStr = map {$1.value: $1.key}, LevelStr2Level.pairIterator();
        }

        #! Creates a new object
        /**
            @param level integer value
            @param levelStr string representation
        */
        constructor(int level, string levelStr) {
            m_level = level;
            m_levelStr = levelStr;
        }

        #! get level value
        public int getValue() {
            return m_level;
        }

        #! get level string
        public string getStr() {
            return m_levelStr;
        }

        #! compare logger levels
        /**
            @param other the other level to compares
            @return True if level is greater or equal to the \a other level
        */
        public bool isGreaterOrEqual(LoggerLevel other) {
            return m_level >= other.getValue();
        }

        #! Compares two logger levels
        /**
            @param other the other level to compares
        */
        public bool isEqual(LoggerLevel other) {
            return m_level == other.getValue();
        }

        #! Returns an OFF Level
        public static LoggerLevel getLevelOff() {
            return LoggerLevel::getLevel(OFF);
        }

        #! Returns an FATAL Level
        public static LoggerLevel getLevelFatal() {
            return LoggerLevel::getLevel(FATAL);
        }

        #! Returns an ERROR Level
        public static LoggerLevel getLevelError() {
            return LoggerLevel::getLevel(ERROR);
        }

        #! Returns an WARN Level
        public static LoggerLevel getLevelWarn() {
            return LoggerLevel::getLevel(WARN);
        }

        #! Returns an INFO Level
        public static LoggerLevel getLevelInfo() {
            return LoggerLevel::getLevel(INFO);
        }

        #! Returns an DEBUG Level
        public static LoggerLevel getLevelDebug() {
            return LoggerLevel::getLevel(DEBUG);
        }

        #! Returns an TRACE Level
        public static LoggerLevel getLevelTrace() {
            return LoggerLevel::getLevel(TRACE);
        }

        #! Returns an ALL Level
        public static LoggerLevel getLevelAll() {
            return LoggerLevel::getLevel(ALL);
        }

        #! Converts the input argument to a level
        /**
            @param level the input level
            @param defaultLevel value to return if conversion is not possible.

            @throw LOGGER-ERROR if defaultLevel is nothing and level not found
        */
        public static LoggerLevel getLevel(int level, *LoggerLevel defaultLevel) {
            if (exists Level2LevelStr{level}) {
                if (!exists m_levelMap{level}) {
                    m_levelMap{level} = new LoggerLevel(level, Level2LevelStr{level});
                }
                return m_levelMap{level};
            } else {
                if (!exists defaultLevel) {
                    throw "LOGGER-ERROR", "Cannot get valid Level";
                }
                return defaultLevel;
            }
        }

        #! Converts the input argument to a level.
        /**
            @param levelStr the string input level
            @param defaultLevel value to return if conversion is not possible.
            @throw LOGGER-ERROR if defaultLevel is nothing and levelStr not found
        */
        public static LoggerLevel getLevel(string levelStr, *LoggerLevel defaultLevel) {
            levelStr = toupper(levelStr);
            if (exists LevelStr2Level{levelStr}) {
                int level = LevelStr2Level{levelStr};
                if (!exists m_levelMap{level}) {
                    m_levelMap{level} = new LoggerLevel(level, levelStr);
                }
                return m_levelMap{level};
            } else {
                if (!exists defaultLevel) {
                    throw "LOGGER-ERROR", "Cannot get valid Level";
                }
                return defaultLevel;
            }
        }
    }

    #! Implements an event to be logged
    /**
        The event data consist of format string and parameters. The output string is rendeded once when
        logging decision to target is made. Callable parameters are evaluated at this moment as well.
    */
    public class LoggerEvent {
        private:internal {
            #! origin stamp to calculate relative time
            static date m_startTime = now_us();

            #! Fully Qualified Class Name of the calling category class.
            string m_fqcn;

            #! Logger reference
            *Logger m_logger;

            #! The category (logger) name.
            string m_categoryName;

            #! Level of the logging event.
            LoggerLevel m_level;

            #! The application supplied message of logging event (not rendered)
            string m_message;

            #! arguments to be rendered
            *list m_args;

            #! The application supplied message rendered through the rendering mechanism.
            *string m_renderedMessage;

            #! related thread id
            int m_threadId;

            #! event time stamp
            date m_timeStamp;

            #! location information where the logging was performed.
            *hash<CallStackInfo> m_locationInfo;

            #! internal representation of throwable
            *hash<ExceptionInfo> m_throwableInfo;

            #! unique id
            int m_uniqueId;

            #! unique id generator
            static Sequence m_sequence(1);
        }

        #! Instantiates a LoggingEvent from the supplied parameters.
        /**
            @param logger The category becomes logger name and fqcn logger class name
            @param level The event level
            @param message The payload as format for @ref sprintf()
            @param args The arguments for formatting
            @param locationInfo code location related to logging event
            @param threadId thread related to the event, Default: @ref gettid()
            @param timeStamp logging event timestamp. Default value is @ref now_us
            @param throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with logging event
        */
        constructor(Logger logger, LoggerLevel level, string message, *list args, *hash<CallStackInfo> locationInfo,
                    int threadId = gettid(), date timeStamp = now_us(), *hash<ExceptionInfo> throwable) {
            m_fqcn = get_class_name(logger);
            m_logger = logger;
            m_categoryName = logger.getName();
            m_level = level;
            m_message = message;
            m_args = args;
            m_locationInfo = locationInfo;
            m_threadId = threadId;
            m_timeStamp = timeStamp;
            if (throwable) {
                m_throwableInfo = throwable;
            }
        }

        #! Instantiates a LoggingEvent from the supplied parameters.
        /**
            @param fqcn name of the caller class.
            @param category The event category.
            @param level The event level
            @param message The payload as format for @ref sprintf()
            @param args The arguments for formatting
            @param locationInfo code location related to logging event
            @param threadId thread related to the event, Default: @ref gettid()
            @param timeStamp logging event timestamp. Default value is @ref now_us
            @param throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with logging event
        */
        constructor(string fqcn, softstring category, LoggerLevel level, string message, *list args, *hash<CallStackInfo> locationInfo,
                    int threadId = gettid(), date timeStamp = now_us(), *hash<ExceptionInfo> throwable) {
            m_fqcn = fqcn;
            m_categoryName = category;
            m_level = level;
            m_message = message;
            m_args = args;
            m_locationInfo = locationInfo;
            m_threadId = threadId;
            m_timeStamp = timeStamp;
            if (throwable) {
                m_throwableInfo = throwable;
            }
        }

        #! Returns the full qualified classname
        public string getFullQualifiedClassname() {
            return m_fqcn;
        }

        #! Returns the location information for this logging event
        public *hash<CallStackInfo> getLocationInfo() {
            return m_locationInfo;
        }

        #! Return the level of this event
        public LoggerLevel getLevel() {
            return m_level;
        }

        #! Returns the logger which created the event
        public *Logger getLogger() {
            return m_logger;
        }

        #! Returns the thread id which is related to event
        public int getThreadId() {
            return m_threadId;
        }

        #! Returns the category name
        public string getCategoryName() {
            return m_categoryName;
        }

        #! Returns the string message for the logging event
        /**
            Potential callable references are evaluated.
            Next the message is rendered using @ref Qore::vsprintf() "vsprintf()" and the result is cached, so the message is
            is rendeded only once.

            @return the rendered message
        */
        public string getMessage() {
            if (!exists m_renderedMessage) {
                # evaluate callp which may be used to get time consuming stuff
                # i.e. they are evaluated only when logging is performed
                auto prevCall;
                list args2 = ();
                foreach auto arg in (m_args) {
                    if (exists prevCall) {
                        bool isParam = False;
                        isParam = arg.typeCode() == NT_LIST;
                        try {
                            push args2, call_function_args(prevCall, arg);
                        } catch (hash<ExceptionInfo> ex) {
                            push args2, ex;
                        }
                        delete prevCall;
                        if (isParam) {
                            continue;
                        }
                    }
                    if (arg.callp()) {
                        prevCall = arg;
                    } else {
                        push args2, arg;
                    }
                }
                if (prevCall) {
                    try {
                        push args2, prevCall();
                    } catch (hash<ExceptionInfo> ex) {
                        push args2, ex;
                    }
                }
                # message is considered as printf() format so we process it this way.
                m_renderedMessage = vsprintf(m_message, args2);
            }
            return m_renderedMessage;
        }

        #! Returns the time when the application/logger started
        public static date getStartTime() {
            return LoggerEvent::m_startTime;
        }

        #! Sets the starting time for relative time
        public static setStartTime(date time) {
            LoggerEvent::m_startTime = time;
        }

        #! Returns the event timestamp as an @ref absolute_dates "absolute date/time value"
        public date getTimeStamp() {
            return m_timeStamp;
        }

        #! Returns a relative timestamp for the event
        /**
            Returns a @ref relative_dates "relative date/time value" for the amount of time passed
            from the beginning of execution to the time when the event was constructed.

            @see @ref getStartTime()
        */
        public date getRelativeTime() {
            return m_timeStamp - LoggerEvent::m_startTime;
        }

        #! Returns throwable info, if any
        public *hash<ExceptionInfo> getThrowableInfo() {
            return m_throwableInfo;
        }

        #! generates a globally unique integer identifier and associates it to the event
        public int getUniqueId() {
            if (!exists m_uniqueId) {
                m_uniqueId = m_sequence.next();
            }
            return m_uniqueId;
        }
    }

    #! Queue serializing async appender events
    /**
        All async events may be processed by one worker thread dedicated to
        one or more appenders so the thread posting logging event remains unblocked.
    */
    public class LoggerAppenderQueue {
        private:internal {
            Queue m_queue();
        }

        #! add appender event
        /**
            @param appender a logger appender object
            @param type see \c EVENT_xxx constants
            @param params data prepared by @ref LoggerAppender::serializeImpl()
            @return True if the event was succesfully added to queue
        */
        public bool push(LoggerAppender appender, int type, auto params) {
            try {
                m_queue.push(("appender": appender, "type": type, "params": params), -1);
            } catch (hash<ExceptionInfo> ex) {
                return False;
            }
            return True;
        }

        #! process queued events
        /**
            This method should typically be called in a dedicated thread

            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a negative timeout value is passed as the argument,
                then the call blocks until data is available on the queue. Default value is 0.
        */
        public process(timeout ms = 0) {
            while (True) {
                *hash rec = getEvent(ms);
                if (!rec) {
                    break;
                }
                rec.appender.processEventImpl(rec.type, rec.params);
            }
        }

        #! Returns the current number of events waiting in queue
        public int size() {
            return m_queue.size();
        }

        #! Returns the next event from queue or @ref nothing if there is no event available within the timeout period
        /**
            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a negative timeout value is passed as the argument,
                then the call blocks until data is available on the queue.

            @return the next event from queue or @ref nothing if there is no event available within the timeout period
        */
        private *hash getEvent(timeout ms) {
            if (m_queue.size() > 0 || ms != 0) {
                try {
                    if (ms == 0) {
                        return m_queue.get(-1);
                    } else if (ms > 0) {
                        return m_queue.get(ms);
                    } else {
                        return m_queue.get(0);
                    }
                } catch (hash<ExceptionInfo> ex) {
                    switch (ex.err) {
                        case "QUEUE-TIMEOUT":
                            break;
                        default:
                            rethrow;
                    }
                }
            }
        }
    }

    #! Handles the processing for asynchronous appender events in multiple threads
    /**
        Async events are removed from the event queue in a single thread which balances processing
        in multiple worker threads via a @ref Qore::Thread::ThreadPool "ThreadPool". This class groups events by appender
        so that events related to a particular appender are always processed serially in the same thread.
        It is compatible with %Qore's @ref Qore::OutputStream implementation where all data submitted to the
        output stream must be submitted from the same thread.
    */
    public class LoggerAppenderQueueThreadPool inherits LoggerAppenderQueue {
        private:internal {
            #! worker thread pool
            ThreadPool m_tp;
            #! number of running worker threads
            Counter m_running(0);
            #! max.number of worker threads
            int m_maxThreads;
            #! events removed from queue but not passed to worker thread
            hash m_pending;
            #! events paseed to worker thread
            hash m_processing;
            #! queue of processed events in worker threads
            Queue m_finished();
            #! internal unique counter
            Sequence m_lastId(0);
            #! to protect process()
            Mutex m_lock();
        }

        #! worker thread code
        /**
            @param id unique identifier generated by internal @ref Qore::Thread::Sequence "Sequence"
            @param appender @ref LoggerAppender instance
            @param events list of events
        */
        private:internal worker(string id, LoggerAppender appender, list events) {
            #printf("start worker(), id: %y, tid: %d\n", id, gettid());
            #printf("<S:%y, tid: %d> ", id, gettid());
            m_running.inc();
            on_exit m_running.dec();
            try {
                map appender.processEventImpl($1.type, $1.params), events;
            } catch (hash<ExceptionInfo> ex) {
            }
            m_finished.push(id);
            #printf("end worker(), id: %y, tid: %d\n", id, gettid());
            #printf("<E:%y, tid: %d> ", id, gettid());
        }

        #! Creates the object
        /**
            @param tp worker @ref Qore::Thread::ThreadPool "ThreadPool" where loggging events are submitted
            @param maxThreads max.number of worker threads, default value is \c -1, i.e. unlimited
        */
        constructor(ThreadPool tp, int maxThreads = -1) {
            m_tp = tp;
            m_maxThreads = maxThreads;
        }

        destructor() {
            m_running.waitForZero();
            m_tp.stopWait();
        }

        #! returns the assigned @ref Qore::Thread::ThreadPool "ThreadPool"
        public ThreadPool getThreadPool() {
            return m_tp;
        }

        #! Processes queue events
        /**
            Group logging events by appender and submit them to a worker thread to be processed in a thread pool

            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a negative timeout value is passed as the argument,
                then the call blocks until data is available on the queue. Default value is 0.
        */
        public process(timeout ms = 0) {
            # normally function is called from one thread and it is not time critical
            AutoLock al(m_lock);
            # get new events and match with pending
            hash lastMatch;
            while (True) {
                *hash e = getEvent(ms);
                if (!e) {
                    break;
                }
                if (lastMatch.appender != e.appender) {
                    bool found = False;
                    foreach string id in (keys m_pending) {
                        if (m_pending{id}.appender == e.appender) {
                            lastMatch.id = id;
                            lastMatch.appender = e.appender;
                            found = True;
                            break;
                        }
                    }
                    if (!found) {
                        # look into processing
                        foreach string id in (keys m_processing) {
                            if (m_processing{id}.appender == e.appender) {
                                lastMatch.id = id;
                                found = True;
                                break;
                            }
                        }
                        if (!found) {
                            # add new entry
                            lastMatch.id = string(m_lastId.next());
                        }
                        lastMatch.appender = e.appender;
                        m_pending{lastMatch.id} = (
                            "id": lastMatch.id,  # BUG: see ThreadPool::submit(id, ...) call
                            "appender": e.appender,
                            "events": (),
                        );
                    }
                }
                push m_pending{lastMatch.id}.events, e.('type', 'params');
            }

            # remove finished
            while (m_finished.size() > 0) {
                string id = m_finished.get(-1);
                remove m_processing{id};
            }
            # now try push pending
            foreach string id in (keys m_pending) {
                # remove meanwhile finished if any
                while (m_finished.size() > 0) {
                    remove m_processing{m_finished.get(-1)};
                }
                # is available a free worker thread ?
                if (m_maxThreads >= 0 && m_processing.size() >= m_maxThreads) {
                    return;
                }
                if (exists m_processing{id}) {
                    # we cannot trigger new thread if is being processed
                    continue;
                }
                hash e = remove m_pending{id};
                m_processing{id} = e;
                # When passing "id" then no copy is passed to submit pool queue and worker may get wrong value
                # so we must pass value in new variable which won't change meanwhile when the value is to be used.
                m_tp.submit(sub() {call_function(\worker(), e.id, e.appender, e.events); } );
            }
        }

        #! get number of pending events
        public int size() {
            AutoLock al(m_lock);
            return LoggerAppenderQueue::size() + m_processing.size() + m_pending.size();
        }
    }

    #! Implements passing @ref LoggerEvent to target destination
    /**
        subclasses will implement e.g. logging to file, to stderr, to database etc.
        \c LoggerAppender supports sync and async logging.

        The ability to selectively enable or disable logging requests based on level in @ref Logger is
        extended in the appender via @ref LoggerFilter, which implements filtering on any criteria.
    */
    public class LoggerAppender {
        public {
            #! open event
            const EVENT_OPEN = 1;
            #! logging event
            const EVENT_LOG = 2;
            #! close event
            const EVENT_CLOSE = 3;
        }

        private:internal {
            #! The lock to to ensure proper serialization with concurrent access
            RWLock m_lock();

            #! an inactive appender won't accept any logging request
            bool m_active = False;

            #! filter chain
            list<LoggerFilter> m_filters;

            #! Appender name
            string m_name;

            #! async queue
            *LoggerAppenderQueue m_queue;
        }

        #! Creates the object
        /**
            @param name the appender name
        */
        constructor(string name = "") {
            m_name = name;
        }

        destructor() {
            #close();  # TODO: cannot call as the target object may be already destroyed
        }

        #! Returns the appender name
        public string getName() {
            return m_name;
        }

        #! Sets the appender queue.
        /**
            Data are passed to target device synchronously
            unless queue is assigned. In this case data are queued and
            dedicated process will process it in asynchronously

            @param queue
        */
        public setQueue(*LoggerAppenderQueue queue) {
            if (m_active) {
                throw "LOGGER-ERROR", "Appender is opened";
            }
            m_queue = queue;
        }

        #! Returns async queue or @ref nothing when events are processed synchronously
        public *LoggerAppenderQueue getQueue() {
            return m_queue;
        }

        #! Open logging resources
        /**
            The appender must be opened (active) to accept any logging events
        */
        public open() {
            if (!m_active) {
                pushEvent(EVENT_OPEN, NOTHING);
                m_active = True;
            }
        }

        #! Releases any resources allocated by the appender and closes it
        /**
        */
        public close() {
            if (m_active) {
                pushEvent(EVENT_CLOSE, NOTHING);
                m_active = False;
            }
        }

        #! Returns the value of the \c active flag, i.e. @ref True if the appender is open and therefore active
        public bool isActive() {
            return m_active;
        }

        #! Adds a filter to the chain
        /**
            @param filter the new filter to add
            @param top if @ref True then the filter is added at the start of the filter chain, if @ref False (the default),
            the filter is added at the end of the chain
            @throw "LOGGER-ERROR" thrown if the filter is already in the list
        */
        public addFilter(LoggerFilter filter, bool top = False) {
            AutoWriteLock awl(m_lock);
            if (!m_filters) {
                m_filters = (filter, );
            } else {
                if (m_filters.contains(filter)) {
                    throw "LOGGER-ERROR", "Filter already exists in list";
                }
                if (top) {
                    unshift m_filters, filter;
                } else {
                    push m_filters, filter;
                }
            }
        }

        #! Removes the given filter from the filter chain.
        /**
            @param filter the filter to remove
        */
        public removeFilter(LoggerFilter filter) {
            AutoWriteLock awl(m_lock);
            foreach LoggerFilter f in (m_filters) {
                if (f == filter) {
                    splice m_filters, $#, 1;
                    break;
                }
            }
        }

        #! Clears the filter chain by removing all filters
        public removeAllFilters() {
            AutoWriteLock awl(m_lock);
            splice m_filters, 0;
        }

        #! Returns the filter chain as a list
        /**
            Note that appender filter chain may be modified as internal lock is released when copy of list is returned
        */
        public list<LoggerFilter> getFilters() {
            AutoReadLock awl(m_lock);
            return m_filters ?? ();
        }

        #! Serializes the given event to put in the queue or write to the target device
        /**
            The appender implementaion can define any format for serialization. The data are passed
            to @ref processEventImpl() method in the \c params argument when \c type is \c EVENT_LOG.

            @return the serialized event
        */
        abstract private auto serializeImpl(LoggerEvent event);

        #! Pushes the given event on the queue or calls @ref processEventImpl() in case of synchronous processing
        /**
            @param type the event type
            @param params parameters for the event according to the event type

            @return @ref True if the event was accepted/processed, @ref False if not

            @see @ref processEventImpl()
        */
        private bool pushEvent(int type, auto params) {
            if (exists m_queue) {
                return m_queue.push(self, type, params);
            } else {
                processEventImpl(type, params);
                return True;
            }
        }

        #! Posts the given event to the output queue
        /**
            Invokes filters; when the event is accepted then it is posted to the queue in case of
            asynchronous processing, or it is immediately logged by the @ref processEventImpl() method
            in case of synchronous processing.

            @see @ref processEventImpl()

            @param event the event to post
            @return True if the event has been posted, @ref False if not (filtered out, appender inactive, event not accepted on queue, etc)
        */
        public bool post(LoggerEvent event) {
            if(!m_active) {
                return False;
            }
            {
                AutoReadLock arl(m_lock);
                foreach LoggerFilter filter in (m_filters) {
                    int d = filter.eval(event);
                    if (d == LoggerFilter::DENY) {
                        return False;
                    } else if (d == LoggerFilter::ACCEPT) {
                        break;
                    }
                }
            }
            auto serialized = serializeImpl(event);
            if (!exists serialized) {
                return False;
            }
            return pushEvent(EVENT_LOG, serialized);
        }

        #! Processes the event to the physical target
        /**
            must be implemented by non-abstract subclasses

            @see @ref serializeImpl()

            @param type see \c "EVENT_xxx" constants
            @param params processing parameters
        */
        abstract public processEventImpl(int type, auto params);
    }

    #! Appender which does nothing
    /**
        All events posted to the appender are silently ignored
    */
    public class LoggerAppenderNull inherits LoggerAppender {
        constructor(string name = ""): LoggerAppender(name) {
        }

        private auto serializeImpl(LoggerEvent event) {
        }

        public processEventImpl(int type, auto params) {
        }
    }

    #! Implements pattern parsing and substitution
    /**
        The pattern defines fields to be substituted with real values

        The pattern format is:

        @code
        %[<modifiers>] <word> [{<option>}]
        modifiers := [0-9.-]*
        word := [a-zA-Z]+
        option := [^}]*
        @endcode

        When a word (i.e. longer than one char) key without curly brackets is not found then in the next step is resolved its first char,
        e.g. \c "%parchive" the first step tries to resolve \c "parchive" key and if not resolved the second step \c "p" key.
        To parse in key if single step delimit a word from the next character, use curly brackets, i.e. empty option, e.g. \c "%p{}archive".
        If a key is not resolved then exception is raised.

        The following table covers various modifiers and scenarios:

        | !Format modifier | !left justify | !minimum width | !maximum width | !comment |
        | %20c             | false         | 20             | none           | Left pad with spaces if the category name is less than 20 characters long |
        | %-20c            | true          | 20             | none           | Right pad with spaces if the category name is less than 20 characters long |
        | %.30c            | NA            | none           | 30             | Truncate from the beginning if the category name is longer than 30 characters |
        | %20.30c          | false         | 20             | 30             | Left pad with spaces if the category name is shorter than 20 characters. However, if the category name is longer than 30 characters, then truncate from the beginning |
        | %-20.30c         | true          | 20             | 30             | Right pad with spaces if the category name is shorter than 20 characters. However, if the category name is longer than 30 characters, then truncate from the beginning |
    */
    public class LoggerPattern {
        public {
            #! format escape character
            const ESCAPE_CHAR = "%";
        }

        private:internal {
            #! pattern
            string m_pattern;
        }

        private {
            #! parsed pattern
            list m_parsedPattern;  # subclass may provide value e.g. for unit tests
        }

        #! Creates the object
        /**
            @param pattern the logger pattern
            @throw LOGGER-ERROR when \a pattern is invalid
        */
        constructor(string pattern) {
            # parse pattern
            setPattern(pattern);
        }

        #! Sets the new pattern
        /**
            @param pattern the logger pattern
            @throw LOGGER-ERROR when \a pattern is invalid
        */
        public setPattern(string pattern) {
            string s = pattern;
            list pp = ();
            while (s != "") {
                int i = 0;
                do {
                    i = bindex(s, ESCAPE_CHAR, i);
                    if (i < 0) {
                        i = s.size();
                    } else {
                        if (i >= 0 && s[i+1] == ESCAPE_CHAR) {  # %%
                            splice s, i, 1;
                            i++;
                            continue;
                        }
                    }
                    break;
                } while (True);
                if (i >= s.size()) {
                    push pp, s;
                    s = "";
                } else {
                    if (i > 0) {
                        push pp, substr(s, 0, i);
                    }
                    splice s, 0, i+1;
                    # now the string is token
%ifdef _DUMMY_TO_PAIR_BRACES_IN_EDITOR
    {
%endif
                    *list l = s =~ x/^([0-9.-]*)([a-zA-Z]+)({[^}]*})?/ ;
                    if (l.size() < 2) {
                        throw "LOGGER-ERROR", sprintf("Wrong pattern starting %%%s", s);
                    }
                    *list opt;
                    hash f;
                    if (l[0] != "") {
                        # opt = l[0] =~ x/^([-]?)([^.0-9]*)([.]?)([0-9]+)$/;   does not work in all cases
                        if (opt = (l[0] =~ x/^([-]?)([0-9]+)\.([0-9]+)$/) ) {
                            f.leftJustify = opt[0] == "-";
                            f.minWidth = int(opt[1]);
                            f.maxWidth = int(opt[2]);
                        } else if (opt = (l[0] =~ x/^([-]?)([0-9]+)$/) ) {
                            f.leftJustify = opt[0] == "-";
                            f.minWidth = int(opt[1]);
                        } else if (opt = (l[0] =~ x/^.([0-9]+)$/) ) {
                            f.maxWidth = int(opt[0]);
                        } else {
                            throw "LOGGER-ERROR", sprintf("Wrong pattern option starting %%%s", s);
                        }
                    }
                    f.key = l[1];
                    if (l.size() == 3) {
%ifdef _DUMMY_TO_PAIR_BRACES_IN_EDITOR
    {
%endif
                        f.option = ((l[2] =~ x/^{([^}]*)}$/)[0]) ?? "";
                    }
%ifdef _DUMMY_TO_PAIR_BRACES_IN_EDITOR
    {
%endif
                    s =~ s/^[0-9.-]*[a-zA-Z]+({[^}]*})?//;
                    push pp, f;
                }
            }

            m_pattern = pattern;
            m_parsedPattern = pp;
        }

        #! Returns the current pattern
        public string getPattern() {
            return m_pattern;
        }

        #! Formats the event record with the current pattern
        /**
            @param data is passed to @ref resolveField()
            @throw LOGGER-ERROR when a key is not resolved
        */
        public string format(auto data) {
            string res = "";
            foreach auto a in (m_parsedPattern) {
                if (a.typeCode() == NT_STRING) {
                    res += a;
                } else {
                    bool fallback = False;
                    *string val = resolveField(data, a.key, a.option);
                    if (!exists val && a.key.size() > 1 && !exists a.option) {
                        # try one char key if key is longer and has no {}, i.e. fix non intuitive case
                        val = resolveField(data, substr(a.key, 0, 1));
                        fallback = exists val;
                    }
                    if (!exists val) {
                        throw "LOGGER-ERROR", sprintf("Unknown pattern token %y", a.key);
                    }

                    if (exists a.maxWidth) {
                        val = substr(val, 0, a.maxWidth);
                    }
                    if (exists a.minWidth && val.size() < a.minWidth) {
                        if (a.leftJustify) {
                            val += strmul(" ", a.minWidth - val.size());
                        } else {
                            val = strmul(" ", a.minWidth - val.size()) + val;
                        }
                    }
                    res += val;
                    if (fallback) {
                        res += substr(a.key, 1);
                    }
                }
            }
            return res;
        }

        #! Returns a formatted string for an input pattern
        /**
            @param data input context reference data
            @param key the format character
            @param option the format option value, if any

            @return the formatted string or nothing if the key is not resolved
        */
        abstract private *string resolveField(auto data, string key, *string option);
    }

    #! Abstract class that defines the interface for logger layouts
    /**
        Event data (@ref LoggerEvent) are formatted before the record is passed to the target.
    */
    public class LoggerLayout {
        #! Format event record
        abstract public string format(LoggerEvent event);
    }

    #! Implements the formatting of @ref LoggerEvent objects with a pattern
    /**
        The \c LoggerLayoutPattern lets the user specify the output format according to conversion patterns similar to the @ref sprintf() function.

        The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

        | !Conversion character | !Meaning |
        | c | Used to output the category of the logging event, i.e. logger name |
        | C | Used to output the class name of the caller issuing the logging request, i.e. logger class name |
        | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}" |
        | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | F | Used to output the file name where the logging request was issued |
        | l | Used to output location information of the caller which generated the logging event, i.e. \c "file:line [function()]" |
        | L | Used to output the line number from where the logging request was issued, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | m | Used to output the application supplied message associated with the logging event |
        | M | Used to output the method name where the logging request was issued |
        | n | Outputs the platform dependent line separator character or characters |
        | p | Used to output the priority of the logging event |
        | r | Used to output the number of milliseconds elapsed from the construction of the layout until the creation of the logging event, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | t | Used to output the thread id that generated the logging event, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | u | Used to output logging event unique id, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | x | Used to output exception string using @ref Util::get_exception_string() |
        | % | The literal percent sign. \c "%%" will print a \c "%" sign |

        For example, the \c LoggerLayoutPattern with the conversion pattern \c "%r [%t] %-5p %c - %m%n" will output something like:

        @verbatim
            176 [23] INFO  MyLogger - New record created
        @endverbatim
    */
    public class LoggerLayoutPattern inherits LoggerLayout, public LoggerPattern {
        public {
            #! default layout pattern
            const DEFAULT_PATTERN = "%r [%t] %p %c - %m%n";
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYY-MM-DD HH:mm:SS.u";
        }

        #! Creates the object
        /**
            @param pattern the logger layout pattern
        */
        constructor(string pattern = DEFAULT_PATTERN): LoggerPattern(pattern) {
        }

        #! Returns the line delimiter used on the current OS
        static public string getLineDelimiter() {
            switch (PlatformOS) {
            case "Windows":
                return "\r\n";
            default:
                return "\n";
            }
        }

        #! Formats an event record
        /** @param event the event to format
            @return a formatted string for the event
        */
        public string format(LoggerEvent event) {
            return LoggerPattern::format(event);
        }

        #! Returns the value corresponding to a particular key
        /**
            @param event (@ref LoggerEvent)
            @param key the single-character formatting code
            @param option optional supporting information for \a key
        */
        private *string resolveField(auto event, string key, *string option) {
            if (!(event instanceof LoggerEvent)) {
                throw "LOGGER-ERROR", "Unsupported event type";
            }
            *string res;
            switch (key) {
                case "c":
                    res = event.getCategoryName();
                    break;
                case "C":
                    res = event.getFullQualifiedClassname();
                    break;
                case "d":
                    if (option) {
                        res = format_date(option, event.getTimeStamp());
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, event.getTimeStamp());
                    }
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "F":
                    res = event.getLocationInfo().file;
                    break;
                case "l":
                    hash<CallStackInfo> csi = event.getLocationInfo();
                    res = sprintf("%s:%d [%s()]", csi.file, csi.line, csi.function);
                    break;
                case "L":
                    res = sprintf(option ?? "%d", event.getLocationInfo().line);
                    break;
                case "m":
                    res = event.getMessage();
                    break;
                case "M":
                    res = event.getLocationInfo().function;
                    break;
                case "n":
                    res = getLineDelimiter();
                    break;
                case "p":
                    res = event.getLevel().getStr();
                    break;
                case "r":
                    res = sprintf(option ?? "%d", get_duration_milliseconds(event.getTimeStamp() - LoggerEvent::getStartTime()));
                    break;
                case "t":
                    res = sprintf(option ?? "%d", event.getThreadId());
                    break;
                case "u":
                    res = sprintf(option ?? "%d", event.getUniqueId());
                    break;
                case "x":
                    if (event.getThrowableInfo()) {
                        res = get_exception_string(event.getThrowableInfo());
                    } else {
                        res = "";
                    }
                    break;
                default:
                    #throw "LOGGER-ERROR", sprintf("Unknown pattern token %y", key);
            }
            return res;
        }
    }

    #! Implements an appender with a layout
    /**
        The layout is responsible for formatting the @ref LoggerEvent according to the user's wishes,
        whereas an appender takes care of sending the formatted output to its destination.

        It is used typically for appenders implementing logging to a file
    */
    public class LoggerAppenderWithLayout inherits LoggerAppender {
        private:internal {
            #! assigned layout
            LoggerLayout m_layout;
        }

        #! creates the object
        /**
            @param name the name of the appender
            @param layout the layout for the appender
        */
        constructor(string name, LoggerLayout layout): LoggerAppender(name) {
            m_layout = layout;
        }

        #! Assigns a layout to the appender
        /**
        * @param layout the layout for the appender
        */
        public setLayout(LoggerLayout layout) {
            m_layout = layout;
        }

        #! Returns the layout for the appender
        public LoggerLayout getLayout() {
            return m_layout;
        }

        #! Returns the value formatted using the layout pattern
        /**
            @param event the event to serialize
        */
        private auto serializeImpl(LoggerEvent event) {
            return m_layout.format(event);
        }
    }

    #! Appender writing to an output stream via @ref Qore::StreamWriter "StreamWriter"
    /**
        Qore streams are not designed to accept input from multiple threads simultaneously, so writing must be serialized and processed
        in a dedicated thread
    */
    public class LoggerAppenderStream inherits LoggerAppenderWithLayout {
        private:internal {
            #! stream writer
            StreamWriter m_writer;
            #! closed flag
            bool m_closed = False;
            #! assign thread for stream
            bool m_assignThread;
        }

        #! Creates the object
        /**
            @param name the name of the appender
            @param layout the layout for the appender
            @param writer the stream to write to
        */
        constructor(string name, LoggerLayout layout, StreamWriter writer): LoggerAppenderWithLayout(name, layout) {
            m_writer = writer;
            m_assignThread = m_writer.getOutputStream().getThreadId() == -1;
        }

        #! Returns the stream writer object
        public StreamWriter getStreamWriter() {
            return m_writer;
        }

        #! Returns @ref True if assigning a thread for a stream
        public bool hasAssignThread() {
            return m_assignThread;
        }

        #! Processes open, log, and close events with the output stream; all other events are ignored
        public processEventImpl(int type, auto params) {
            if (type == EVENT_OPEN) {
                if (m_closed) {
                    # OutputStream does not provide open method
                    throw "LOGGER-ERROR", "Cannot reopen stream";
                }
            } else {
                if (m_assignThread) {
                    m_writer.getOutputStream().reassignThread();
                }
                switch (type) {
                    case EVENT_LOG:
                        m_writer.print(params);
                        break;
                    case EVENT_CLOSE:
                        m_writer.getOutputStream().close();
                        m_closed = True;
                        break;
                }
                on_exit if (m_assignThread) {
                    m_writer.getOutputStream().unassignThread();
                }
            }
        }
    }

    #! Appender writing to a file
    /**
        No multi-threading protection is implemented in the class; the @ref Qore::File "File" class is reused
    */
    public class LoggerAppenderFile inherits LoggerAppenderWithLayout {
        private {
            File m_file;
            string m_filename;
        }

        #! Creates the object
        /**
            @param name the name of the appender
            @param layout the layout for the appender
            @param filename the output filename
            @param encoding the file's output encoding
        */
        constructor(string name, LoggerLayout layout, string filename, *string encoding): LoggerAppenderWithLayout(name, layout) {
            m_file = new File(encoding);
            m_filename = filename;
        }

        #! Returns the file object for the appender
        public File getFile() {
            return m_file;
        }

        #! Returns the current filename
        public string getFileName() {
            return m_filename;
        }

        #! Processes open, close, and log events with the file and ignores all other events
        /**
            @param type the event type
            @param params parameters for the event
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_OPEN:
                    if (m_file.open(m_filename, O_APPEND | O_WRONLY) == -1) {
                        if (errno() == Qore::Err::ENOENT) {
                            # No such file or directory
                            m_file.open2(m_filename, O_CREAT | O_WRONLY);
                        } else {
                            throw "FILE-OPEN2-ERROR", sprintf("%s (arg: %d)", strerror(), errno());
                        }
                    }
                    break;
                case EVENT_CLOSE:
                    try {
                        m_file.close();
                    } catch (hash<ExceptionInfo> ex) {
                        if (ex.err != "ILLEGAL-EXPRESSION") {
                            # catch unclosable stdxxx errors, TODO: m_file.isTTY() does the same job ?
                            rethrow;
                        }
                    }
                    break;
                case EVENT_LOG:
                    m_file.print(params);
                    break;
            }
        }
    }

    #! Appender writing to a file with file rotation support
    /**
        The events will be logged to a file until rotation occurs.
        At that moment the current file is closed, archive chain is moved,
        new file is created and logging continues there.
    */
    public class LoggerAppenderFileRotate inherits public LoggerAppenderFile, private LoggerPattern {
        public {
            #! rotate event
            const EVENT_ROTATE = 10;
            #! default archive pattern
            const DEFAULT_ARCHIVE_PATTERN = "%p%f.%i";
        }

        private:internal {
            int m_count;
        }

        #! Creates the object
        /**
            @param name the name of the appender
            @param layout the layout for the appender
            @param filename with pattern support; see below for more information
            @param count number of files in rotation chain, if count is <=0 then no ratation is performed
            @param archive pattern to evaluate archive filename; see below for more information
            @param encoding the encoding of the output file

            The following table explains the characters used in @ref LoggerPattern for both filename and archive parameter

            | !Conversion character | !Meaning |
            | s | Used to output the OS directory separator, i.e. "\" or "/" |
            | c | Used to output the appender name |
            | C | Used to output the appender class name |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            The following table explains the characters used in @ref LoggerPattern for archive parameter only

            | !Conversion character | !Meaning |
            | P | Used to output the current logging path with filename |
            | p | Used to output the current logging path |
            | f | Used to output the current logging filename |
            | i | Used to output the current file index from 1 to count. option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | n | Used to output the rotation count. Option may specify @ref sprintf() format, e.g. \c "%.3d" |

            For example, the archive pattern \c "%p%f.%i" rotates log file \c "/var/run/log/MyLogger.log" to:
            \c "/var/run/log/MyLogger.log.1" \c "/var/run/log/MyLogger.log.2" \c "/var/run/log/MyLogger.log.3".
        */
        constructor(string name, LoggerLayout layout, string filename, int count, string archive = DEFAULT_ARCHIVE_PATTERN, *string encoding): LoggerAppenderFile(name, layout, "", encoding), LoggerPattern(filename) {
            m_filename = format(NOTHING);  # no dynamic vars as timestamp
            m_count = count;
            setPattern(archive);
        }

        #! Returns a string for a format field for a pattern-based filename
        /**
            @param data input context reference data
            @param key the format character
            @param option the format option value, if any

            @return the formatted string
        */
        private *string resolveField(auto data, string key, *string option) {
            *string res;
            switch (key) {
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "s":
                    res = DirSep;
                    break;
            }
            if (data) {  # archive pattern
                switch (key) {
                    case "i":
                        res = sprintf(option ?? "%d", data.index);
                        break;
                    case "n":
                        res = sprintf(option ?? "%d", data.count);
                        break;
                    case "P":
                        res = data.filename;
                        break;
                    case "p": # path
                        res = dirname(data.filename);
                        if (res != DirSep) {
                            res += DirSep;
                        }
                        break;
                    case "f": # filename
                        res = basename(data.filename);
                        break;
                }
            }
            return res;
        }

        #! Implements filename rotation; handles the open and rotate events directly; passes all other events to the subclass for handling
        /**
            @param type the event type
            @param params event parameters
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_ROTATE:
                    if (m_count > 0 && is_file(m_filename)) {
                        list fn = ();
                        int i = 0;
                        while (True) {
                            push fn, getArchiveFileName(i+1);
                            if (!is_dir(dirname(fn[i]))) {
                                mkdir(dirname(fn[i]), 0777, True);
                            }
                            if (i >= m_count-1 || !is_file(fn[i])) {
                                # find a gap in chain or stop at the last file
                                break;
                            }
                            i++;
                        }
                        while (i > 0) {
                            # shift files till a gap or last file
                            rename(fn[i-1], fn[i]);
                            i--;
                        }
                        m_file.close();
                        rename(m_filename, fn[0]);
                        m_file.open2(m_filename, O_CREAT | O_WRONLY);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! Push rotate event
        /**
            The current log file will be closed and opened. If the file exists, then it is ovewritten

            @throw LOGGER-ERROR if rotation is disabled
        */
        public rotate() {
            if (isActive()) {
                if (m_count <= 0) {
                    throw "LOGGER-ERROR", "Rotation is disabled";
                }
                pushEvent(EVENT_ROTATE, NOTHING);
            }
        }

        #! Returns the archive filename
        /**
            @param idx the index of file (1..count)
        */
        public string getArchiveFileName(int idx) {
            hash h;
            h.filename = m_filename;
            h.count = m_count;
            h.index = idx;
            string res = format(h);
            return res;
        }

        #! Returns max.number of files in chain
        /**
        */
        public int getCount() {
            return m_count;
        }
    }


    #! Appender writing to a file with file circular rotation support
    /**
        The events will be logged to a file until rotation occurs.
        At that moment the current file is closed, next file is created
        and logging continues to the new file.
    */
    public class LoggerAppenderFileRing inherits public LoggerAppenderFile, private LoggerPattern {
        public {
            #! rotate event
            const EVENT_ROTATE = 10;
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
        }

        private:internal {
            hash m_patternData;
        }

        #! Creates the object
        /**
            @param name the name of the appender
            @param layout the layout for the appender
            @param pattern to generate the file name; see information below
            @param count number of files in ring, if count is <=0 then no ratation is performed
            @param encoding the encoding of the output file

            The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

            | !Conversion character | !Meaning |
            | i | Used to output the current file index from 0 to count-1. option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | n | Used to output the rotation count. Option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | c | Used to output the appender name. |
            | C | Used to output the appender class name. |
            | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            For example, the pattern \c "/var/run/log/%c.log.%i{%03d}" creates the following file names:
            \c "/var/run/log/MyLogger.log.000", \c "/var/run/log/MyLogger.log.001" etc.
        */
        constructor(string name, LoggerLayout layout, string pattern, int count, *string encoding): LoggerAppenderFile(name, layout, "", encoding), LoggerPattern(pattern) {
            # set a provisional filename, to be updated when file is opened
            m_patternData.timestamp = now_us();
            m_patternData.count = count;
            m_patternData.index = 0;
            m_filename = format(m_patternData);
        }

        #! Returns a string for a format field for a pattern-based filename
        /**
            @param data input context reference data
            @param key the format character
            @param option the format option value, if any

            @return the formatted string
        */
        private *string resolveField(auto data, string key, *string option) {
            *string res;
            switch (key) {
                case "i":
                    res = sprintf(option ?? "%d", data.index);
                    break;
                case "n":
                    res = sprintf(option ?? "%d", data.count);
                    break;
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "d":
                    if (option) {
                        res = format_date(option, data.timestamp);
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                    }
                    break;
                case "E":
                    res = ENV{option};
                    break;
            }
            return res;
        }

        #! Implements filename rotation; handles the open and rotate events directly; passes all other events to the subclass for handling
        /**
            @param type the event type
            @param params event parameters
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_OPEN:
                    # find newest file
                    m_patternData.timestamp = now_us();
                    int lastIdx = 0;
                    if (m_patternData.count > 0) {
                        date lastStamp;
                        hash pd = m_patternData;
                        for (int i=0; i < m_patternData.count; i++) {
                            pd.index = i;
                            string fn = format(pd);
                            *hash<StatInfo> si = hstat(fn);
                            if (si) {
                                if (!lastStamp || si.mtime > lastStamp) {
                                    lastStamp = si.mtime;
                                    lastIdx = i;
                                }
                            }
                        }
                    }
                    m_patternData.index = lastIdx;
                    m_filename = format(m_patternData);
                    LoggerAppenderFile::processEventImpl(type, params);
                    break;
                case EVENT_ROTATE:
                    if (m_patternData.count > 0) {
                        m_file.close();
                        m_patternData.index = (m_patternData.index + 1) % m_patternData.count;
                        m_patternData.timestamp = now_us();
                        m_filename = format(m_patternData);
                        m_file.open2(m_filename, O_CREAT | O_WRONLY);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! Push rotate event
        /**
            The current log file will be closed and opened. If the file exists, then it is ovewritten

            @throw LOGGER-ERROR if rotation is disabled
        */
        public rotate() {
            if (isActive()) {
                if (m_patternData.count <= 0) {
                    throw "LOGGER-ERROR", "Rotation is disabled";
                }
                pushEvent(EVENT_ROTATE, NOTHING);
            }
        }

        #! Returns number of files in ring
        /**
        */
        public int getCount() {
            return m_patternData.count;
        }

        #! Returns current ring index being used for logging
        /**
        */
        public int getCurrentIndex() {
            return m_patternData.index;
        }
    }

    #! Appender writing to a file with archive support
    /**
        The events will be logged to a file until archiving is triggered.
        At that moment the current file is closed, moved to file with name evaluated in runtime
        from the archive pattern set in the object, the new file is created, and logging continues to that file.
        The archive never overwrites any existing file.
    */
    public class LoggerAppenderFileArchive inherits public LoggerAppenderFile, private LoggerPattern {
        public {
            #! archive event
            const EVENT_ARCHIVE = 20;
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
            #! default archive pattern
            const DEFAULT_ARCHIVE_PATTERN = "%p%f.%d";
        }

        #! Creates the object
        /**
            @param name the name of the appender
            @param layout the layout for the appender
            @param filename with pattern support; see below for more information
            @param archive pattern to evaluate archive filename; see below for more information
            @param encoding the output file's encoding

            The following table explains the characters used in @ref LoggerPattern for both filename and archive parameter

            | !Conversion character | !Meaning |
            | s | Used to output the OS directory separator, i.e. "\" or "/" |
            | c | Used to output the appender name |
            | C | Used to output the appender class name |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            The following table explains the characters used in @ref LoggerPattern for archive parameter only

            | !Conversion character | !Meaning |
            | P | Used to output the current logging path with filename |
            | p | Used to output the current logging path |
            | f | Used to output the current logging filename |
            | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |

            For example, the archive pattern \c "%p/archive/%d/%f" archives log file \c "/var/run/log/MyLogger.log" to:
            \c "/var/run/log/archive/20180120102030/MyLogger.log".
        */
        constructor(string name, LoggerLayout layout, string filename, string archive = DEFAULT_ARCHIVE_PATTERN, *string encoding): LoggerAppenderFile(name, layout, filename, encoding), LoggerPattern(filename) {
            m_filename = format(NOTHING);  # no dynamic vars as timestamp
            setPattern(archive);
        }

        #! Returns a string for a format field for a pattern-based filename or archive file name
        /**
            @param data if @ref nothing, then this argument specifies the logging filename, otherwise is specifies the archive pattern
            @param key the format character
            @param option the format option value, if any

            @return the formatted string
        */
        private *string resolveField(auto data, string key, *string option) {
            *string res;
            switch (key) {
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "s":
                    res = DirSep;
                    break;
            }
            if (data) {  # archive pattern
                switch (key) {
                    case "d":
                        if (option) {
                            res = format_date(option, data.timestamp);
                        } else {
                            res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                        }
                        break;
                    case "P":
                        res = data.filename;
                        break;
                    case "p": # path
                        res = dirname(data.filename);
                        if (res != DirSep) {
                            res += DirSep;
                        }
                        break;
                    case "f": # filename
                        res = basename(data.filename);
                        break;
                }
            }
            return res;
        }

        #! Implements archiving, handles the archive event directly, passes all other events to the subclass for handling
        /**
            @param type the event code
            @param params event parameters
        */
        public processEventImpl(int type, auto params) {
            switch (type) {
                case EVENT_ARCHIVE:
                    mkdir(dirname(params), 0777, True);
                    if (isActive()) {
                        m_file.close();
                        rename(m_filename, params);
                        LoggerAppenderFile::processEventImpl(EVENT_OPEN, NOTHING);
                    } else {
                        rename(m_filename, params);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! Post an archive event
        /**
            rename logging file and open new one
            @return archive file name

            @throw LOGGER-ERROR if target file name is not correct or target file already exists
        */
        public string archive() {
            string afn = getArchiveFileName();
            if (afn == "") {
                throw "LOGGER-ERROR", "Empty target filename";
            }
            if (normalize_dir(afn) == normalize_dir(m_filename)) {
                throw "LOGGER-ERROR", "Source and target path are equal";
            }
            if (is_dir(afn)) {
                throw "LOGGER-ERROR", "Target is directory";
            }
            if (is_file(afn)) {
                throw "LOGGER-ERROR", "Target file already exists";
            }
            pushEvent(EVENT_ARCHIVE, afn);
            return afn;
        }

        #! Returns the archive filename
        /**
            The pattern may contain date fields so the result may differ when
            executed multiple times
        */
        public string getArchiveFileName() {
            hash h;
            h.timestamp = now_us();
            h.filename = m_filename;
            string res = format(h);
            return res;
        }
    }

    #! Implements a general event filtering class
    /**
        Users should extend this class to implement customized logging
        event filtering. The filter consists of a linear chain of
        particular filters evaluating if the event should be immediately accepted, rejected
        or passed to next filter.
    */
    public class LoggerFilter {
        public {
            #! The event will be processed
            const ACCEPT = 1;

            #! No decision could be made, further filtering should occur
            const NEUTRAL = 0;

            #! The event should not be processed
            const DENY = -1;
        }

        #! Performs filtering logic on an event and returns the decision for the event
        /**
            The method should be overridden to implement a real rule. The default result is @ref NEUTRAL

            @param event the log event

            @return the result of evaluating the event (the default for this method is @ref NEUTRAL)
        */
        public int eval(LoggerEvent event) {
            return NEUTRAL;
        }
    }

    #! Implements the filter according event @ref LoggerLevel
    /**
        When @ref LoggerEvent::getLevel does not satisfy the filter condition, then
        logging is rejected.

        The min and max levels define the range to be logged (if min <= max.level) or range which won't be logged (if max < min.level)
    */
    public class LoggerFilterLevel inherits LoggerFilter {
        private:internal {
            #! min.level
            LoggerLevel m_minLevel;
            #! max.level
            LoggerLevel m_maxLevel;
        }

        #! Creates the object
        /**
            @param minLevel the minimum logging level
            @param maxLevel the maximum logging level
        */
        constructor(LoggerLevel minLevel = LoggerLevel::getLevelInfo(), LoggerLevel maxLevel = LoggerLevel::getLevelOff()) {
            setMinLevel(minLevel);
            setMaxLevel(maxLevel);
        }

        #! Creates the object
        /**
            @param minLevel the minimum logging level
            @param maxLevel the maximum logging level
        */
        constructor(int minLevel, int maxLevel = LoggerLevel::OFF) {
            setMinLevel(minLevel);
            setMaxLevel(maxLevel);
        }

        #! Creates the object
        /**
            @param minLevel the minimum logging level
            @param maxLevel the maximum logging level
        */
        constructor(string minLevel, string maxLevel = "OFF") {
            setMinLevel(minLevel);
            setMaxLevel(maxLevel);
        }

        #! Sets the minimum logging level
        /**
            @param minLevel the minimum logging level
        */
        public setMinLevel(LoggerLevel minLevel) {
            m_minLevel = minLevel;
        }

        #! Sets the minimum logging level
        /**
            @param minLevel the minimum logging level
        */
        public setMinLevel(int minLevel) {
            setMinLevel(LoggerLevel::getLevel(minLevel));
        }

        #! Sets the minimum logging level
        /**
            @param minLevel the minimum logging level
        */
        public setMinLevel(string minLevel) {
            setMinLevel(LoggerLevel::getLevel(minLevel));
        }

        #! Returns the minimum logging level
        public LoggerLevel getMinLevel() {
            return m_minLevel;
        }

        #! Sets the maximum logging level
        /**
            @param maxLevel the maximum logging level
        */
        public setMaxLevel(LoggerLevel maxLevel) {
            m_maxLevel = maxLevel;
        }

        #! Sets the maximum logging level
        /**
            @param maxLevel the maximum logging level
        */
        public setMaxLevel(int maxLevel) {
            setMaxLevel(LoggerLevel::getLevel(maxLevel));
        }

        #! Sets the maximum logging level
        /**
            @param maxLevel the maximum logging level
        */
        public setMaxLevel(string maxLevel) {
            setMaxLevel(LoggerLevel::getLevel(maxLevel));
        }

        #! Returns the maximum logging level
        public LoggerLevel getMaxLevel() {
            return m_maxLevel;
        }

        #! Implements filtering by level
        public int eval(LoggerEvent event) {
            if (m_maxLevel.isGreaterOrEqual(m_minLevel)) {
                if (!(event.getLevel().isGreaterOrEqual(m_minLevel) && m_maxLevel.isGreaterOrEqual(event.getLevel()))) {
                    return DENY;
                }
            } else {
                if (event.getLevel().isGreaterOrEqual(m_maxLevel) && m_minLevel.isGreaterOrEqual(event.getLevel())) {
                    return DENY;
                }
            }
            return NEUTRAL;
        }
    }

    #! Implements filtering according to a regular expression on the event message
    /**
        The rendered event message is tested using a regular expression, and if it does not match the
        expected result, then logging is rejected
    */
    public class LoggerFilterRegex inherits LoggerFilter {
        private:internal {
            #! regular string
            string m_regexStr;
            #! expected result
            bool m_regexResult;
        }

        #! Creates the object
        /**
            @param regexStr the regular expression to use
            @param regexResult @ref True for a positive match, @ref False for a negative match
        */
        constructor(string regexStr = "", bool regexResult = True) {
            setRegex(regexStr, regexResult);
        }

        #! Set the regular expression and the expected result for the filter
        /**
            @param regexStr the regular expression to use
            @param regexResult @ref True for a positive match, @ref False for a negative match
        */
        public setRegex(string regexStr, bool regexResult = True) {
            m_regexStr = regexStr;
            m_regexResult = regexResult;
        }

        #! Returns the current regex
        public string getRegex() {
            return m_regexStr;
        }

        #! Returns the expected result
        public bool getRegexResult() {
            return m_regexResult;
        }

        #! Evaluates the regex and compares with the expected result
        public int eval(LoggerEvent event) {
            if (event.getMessage().regex(m_regexStr) != m_regexResult) {
                return DENY;
            } else {
                return NEUTRAL;
            }
        }
    }

    #! Main logger class whose instance will be used by user code when logging
    /**
        The Logger object is provided to user code. When a log is triggered then
        message, arguments, current code posotion, time are appended into @ref LoggerEvent event instance when
        the logging level is enabled. The event is passed to all registered appenders in the given Logger as well as
        in parents in the hierarchy when additivity is enabled.
    */
    public class Logger {
        private:internal {
            #! The lock to protect object manipulation
            RWLock m_lock();

            #! Logger additivity. If set to true then child loggers will inherit the appenders of their ancestors by default.
            bool m_additive = True;

            #! The assigned Logger level. If @ref nothing, the parent level is used
            *LoggerLevel m_level;

            #! The name of this Logger instance.
            string m_name;

            #! The parent logger. Unassigned if this is the root logger.
            *Logger m_parent;

            #! A collection of appenders linked to this logger.
            list<LoggerAppender> m_appenders;
        }

        #! Creates the object
        /**
            @param name the name of the object
        */
        constructor(string name) {
            m_name = name;
        }

        destructor() {
            setParent(NOTHING);
        }

        #! Returns the logger name
        public string getName() {
            return m_name;
        }

        #! Returns the parent logger, if any
        public *Logger getParent() {
            return m_parent;
        }

        #! Sets the parent logger
        /**
            @param parent the parent logger
            @throw LOGGER-ERROR in case of circular reference
        */
        public setParent(*Logger parent) {
            if (parent) {
                *Logger l = self;
                while (exists l) {
                    if (l == parent) {
                        throw "LOGGER-ERROR", "Circular logger chain";
                    }
                    l = l.getParent();
                }
            }
            m_parent = parent;
        }

        #! Returns the logging level
        /**
            @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
            @throw LOGGER-ERROR if cannot get effective level from hierarchy
        */
        public *LoggerLevel getLevel(bool effective = True) {
            if (effective) {
                *Logger l = self;
                while (!exists l.getLevel(False)) {
                    l = l.getParent();
                    if (!exists l) {
                        throw "LOGGER-ERROR", "Cannot get effective level";
                    }
                }
                return l.getLevel(False);
            } else {
                return m_level;
            }
        }

        #! Sets the logging level
        /**
            @param level if nothing then inherits level from parent
        */
        public setLevel(*LoggerLevel level) {
            m_level = level;
        }

        #! Sets the logging level
        /**
            @param level the logging level as a string
        */
        public setLevel(string level) {
            setLevel(LoggerLevel::getLevel(level));;
        }

        #! Sets the logging level
        /**
            @param level the logging level to set
        */
        public setLevel(int level) {
            setLevel(LoggerLevel::getLevel(level));;
        }

        #! Sets the additivity flag; when aditivity is active, events are passed to parent loggers.
        /**
            @param additive the additivity flag; when aditivity is active, events are passed to parent loggers
        */
        public setAdditivity(bool additive) {
            m_additive = additive;
        }

        #! Returns the additivity flag.
        public bool getAdditivity() {
            return m_additive;
        }

        #! Returns the call location where the log function was called from
        private hash<CallStackInfo> getLocation() {
            list<hash<CallStackInfo>> loc = get_thread_call_stack();
            return loc[2];   # get location at stack-2
        }

        #! Forwards the given logging event to all linked appenders.
        /**
            @param event the event to forward
        */
        private callAppenders(LoggerEvent event) {
            AutoReadLock arl(m_lock);
            foreach LoggerAppender appender in (m_appenders) {
                appender.post(event);
            }
        }

        #! Adds an appender to the appender list
        /**
            @param appender add a new LoggerAppender
            @throw "LOGGER-ERROR" exception if appender is already in list
        */
        public addAppender(LoggerAppender appender) {
            AutoWriteLock awl(m_lock);
            if (!m_appenders) {
                m_appenders = (appender, );
            } else {
                if (m_appenders.contains(appender)) {
                    throw "LOGGER-ERROR", "Appender already exists in list";
                }
                push m_appenders, appender;
            }
        }

        #! Removes the appender from the list
        /**
            @param appender the appender to remove
        */
        public removeAppender(LoggerAppender appender) {
            AutoWriteLock awl(m_lock);
            foreach LoggerAppender a in (m_appenders) {
                if (a == appender) {
                    splice m_appenders, $#, 1;
                    break;
                }
            }
        }

        #! Clears the appender list by removing all appenders
        public removeAllAppenders() {
            AutoWriteLock awl(m_lock);
            splice m_appenders, 0;
        }

        #! Returns the appender list
        /**
            Note that the appender list may be manipulated in another thread as internal lock is released when list is returned
        */
        public list<LoggerAppender> getAppenders() {
            AutoReadLock awl(m_lock);
            return m_appenders ?? ();
        }

        private:internal logIntern(*LoggerLevel level, string message, *list args, *hash<CallStackInfo> location, bool checkThrowable) {
            if (!exists level || isEnabledFor(level)) {
                *hash<ExceptionInfo> throwable;
                if (args.size() && checkThrowable) {
                    # is the last argument ExceptionInfo ?
                    auto a = args[args.size()-1];
                    if (a.typeCode() == NT_HASH && a.fullType() == "hash<ExceptionInfo>") {
                        throwable = a;
                    }
                }
                callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), now_us(), throwable));
            }
            if (m_parent && getAdditivity()) {
                # Forward the event upstream if additivity is turned on
                m_parent.logIntern(level, message, args, location, checkThrowable);
            }
        }

        #! Logs a message using the provided logging level.
        /**
            @param level The logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public log(LoggerLevel level, string message) {
            logIntern(level, message, argv, getLocation(), True);
        }

        #! Logs a message using the provided logging level.
        /**
            @param level the logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public log(int level, string message) {
            logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
        }

        #! Logs a message using the provided logging level.
        /**
            @param level The logging level.
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public log(string level, string message) {
            logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
        }

        #! Logs an already prepared logging event object.
        /**
            @param event the event to log
        */
        public logEvent(LoggerEvent event) {
            if (isEnabledFor(event.getLevel())) {
                callAppenders(event);
            }

            # Forward the event upstream if additivity is turned on
            if (m_parent && getAdditivity()) {
                m_parent.logEvent(event);
            }
        }

        #! Logs a message object with the TRACE level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public trace(string message) {
            logIntern(LoggerLevel::getLevelTrace(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the DEBUG level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public debug(string message) {
            logIntern(LoggerLevel::getLevelDebug(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the INFO level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public info(string message) {
            logIntern(LoggerLevel::getLevelInfo(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the WARN level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public warn(string message) {
            logIntern(LoggerLevel::getLevelWarn(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the ERROR level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public error(string message) {
            logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
        }

        #! Logs a message object with the FATAL level.
        /**
            @see @ref log()
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public fatal(string message) {
            logIntern(LoggerLevel::getLevelFatal(), message, argv, getLocation(), True);
        }

        #! Performs logging of assertions
        /**
            If the \a assertion parameter is @ref False, then the message is logged
            using the ERROR level.

            @see @ref log()

            @param assertion the boolean assertion value
            @param message a string to log used as a format string for @ref vsprintf(). Optional arguments are passed to the @ref LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash, then it is considered "throwable" information.
        */
        public assertLog(bool assertion, string message) {
            if(!assertion) {
                logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
            }
        }

         #! Logs the variable name and value using TRACE level
        /**
            @see @ref log()

            @param varName the variable name
            @param value the value of the variable
        */
        public traceVar(string varName, auto value) {
            logIntern(LoggerLevel::getLevelTrace(), sprintf("%s: %y", varName), (value, ), getLocation(), False);
        }

        #! Logs the variable name and value using DEBUG level
        /**
            @see @ref log()

            @param varName the variable name
            @param value the value of the variable
        */
        public debugVar(string varName, auto value) {
            logIntern(LoggerLevel::getLevelDebug(), sprintf("%s: %y", varName), (value, ), getLocation(), False);
        }

        #! Checks whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level the log level to check
        */
        public bool isEnabledFor(LoggerLevel level) {
            return level.isGreaterOrEqual(getLevel());
        }

        #! Checks whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level the log level to check
        */
        public bool isEnabledFor(int level) {
            return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
        }

        #! Checks whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level the log level to check
        */
        public bool isEnabledFor(string level) {
            return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
        }

        #! Checks whether this Logger is enabled for the TRACE Level.
        public bool isTraceEnabled() {
            return isEnabledFor(LoggerLevel::getLevelTrace());
        }

        #! Checks whether this Logger is enabled for the DEBUG Level.
        public bool isDebugEnabled() {
            return isEnabledFor(LoggerLevel::getLevelDebug());
        }

        #! Checks whether this Logger is enabled for the INFO Level.
        public bool isInfoEnabled() {
            return isEnabledFor(LoggerLevel::getLevelInfo());
        }

        #! Checks whether this Logger is enabled for the WARN Level.
        public bool isWarnEnabled() {
            return isEnabledFor(LoggerLevel::getLevelWarn());
        }

        #! Checks whether this Logger is enabled for the ERROR Level.
        public bool isErrorEnabled() {
            return isEnabledFor(LoggerLevel::getLevelError());
        }

        #! Checks whether this Logger is enabled for the FATAL Level.
        public bool isFatalEnabled() {
            return isEnabledFor(LoggerLevel::getLevelFatal());
        }
    }

    #! The root class for loggers; does not allow a parent logger to be set
    public class LoggerRoot inherits Logger {
        # Creates the object
        /**
            @param level initial log level
        */
        constructor(LoggerLevel level = LoggerLevel::getLevelAll()): Logger('') {
            setLevel(level);
        }

        # Creates the object
        /**
            @param level initial log level
        */
        constructor(int level): Logger('') {
            setLevel(level);
        }

        # Creates the object
        /**
            @param level initial log level
        */
        constructor(string level): Logger('') {
            setLevel(level);
        }

        #! Overrides the level setter to prevent setting the root logger's level to @ref nothing (an exception is thrown in this case).
        /**
            The root logger must always have a level.

            @param level the level to set
            @throw LOGGER-ERROR if level is @ref nothing
        */
        public setLevel(*LoggerLevel level) {
            if (!exists level) {
                throw "LOGGER-ERROR", "Cannot set null level for root";
            }
            Logger::setLevel(level);
        }

        #! Overrides parent setter as the root logger cannot have a parent; this method always throws an exception if the argument is a value
        /**
            @throw LOGGER-ERROR if parent exists
        */
        public setParent(*Logger parent) {
            if (exists parent) {
                throw "LOGGER-ERROR", "Cannot set parent for root";
            }
        }
    }
}
