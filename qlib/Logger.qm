# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Logger.qm Logger library

/*  Logger.qm Copyright 2018 - 2024 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 1.0

%require-types
%enable-all-warnings
%new-style
%no-debugging

%requires Util

# import native code for logger
%requires(reexport) logger_bin

module Logger {
    version = "1.0";
    desc = "user module implementing Log4q logger library";
    author = "Tomas Mandys <tomas.mandys@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Logger Module

    @tableofcontents

    @section loggerintro Introduction to the Logger Module

    The %Logger module (aka <b>Log4q</b>) adopts its primary design from the well known
    <a href="https://logging.apache.org/log4j/2.x">log4j</a> library, therefore it
    implements the following primary base classes:
    - @ref Logger::Logger "Logger"

    Other classes can be found in the <a href="../../logger/html/index.html">logger</a> module for performance
    reasons, such as:
    - @ref Qore::Logger::LoggerAppender "LoggerAppender" (abstract)
    - @ref Qore::Logger::LoggerAppenderQueue "LoggerAppenderQueue"
    - @ref Qore::Logger::LoggerAppenderWithLayout "LoggerAppenderWithLayout"
    - @ref Qore::Logger::LoggerFilter "LoggerFilter"
    - @ref Qore::Logger::LoggerLayout "LoggerLayout" (abstract)
    - @ref Qore::Logger::LoggerLayoutPattern "LoggerLayoutPattern"
    - @ref Qore::Logger::LoggerLevel "LoggerLevel"
    - @ref Qore::Logger::LoggerPattern "LoggerPattern" (abstract)

    Abstract base classes must be subclassed to implement the desired functionality.

    @subsection logger_scenarios Scenarios

    @par One Thread

    The user code will log to a @ref Logger object, and the logging is performed to the appender synchronously.

    Example:
    @code{.py}
    Logger l("mylogger", LoggerLevel::LevelInfo);
    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    l.addAppender(laf);
    laf.open();
    ....
    l.info("hello %s #%d", "world", 1);
    l.error("the %s is not perfect", "world");
    @endcode

    @par Multiple Threads

    The user code will log from multiple threads; the events are pushed to a
    @ref Qore::Logger::LoggerAppenderQueue "LoggerAppenderQueue" object. The processing is done in a dedicated thread
    when the events are passed to appenders. The user code logging command is non-blocking as it terminates
    immediately when the event is pushed in the queue.

    Example:
    @code{.py}
    our Logger l("mylogger", LoggerLevel::LevelInfo);

    sub run() {
        while (!done) {
            ...
            l.info("hello %s #%d", "world", 1);
            l.error("the %s is not perfect", "world");
            ...
        }
    }

    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    laf.setQueue(new LoggerAppenderQueue());
    l.addAppender(laf);
    laf.open();

    for (int i=0; i<10; i++) {
        background run();
    }

    while (True) {
        laf.getQueue().process();
    }
    @endcode

    @par Application Server Running Logging From a Few Sandboxed Program Containers

    In this example, the appserver provides a logger API for a few sandboxed programs. The appserver is
    responsible for the <b>Log4q</b> configuration; i.e. it prepares loggers, appenders, filters, etc.
    according to configuration and provides the @ref Logger instance to the @ref Qore::Program "Program"
    container running the sandboxed code.
    The sandboxed code will log to this instance; the logging events are processed by the appserver in a
    dedicated thread which gets the event from a queue and passes it to appenders.  Multiple loggers may be
    configured in a parent/child hierarchy so that a higher logging level (i.e. more event levels) are logged
    with the logger assigned to the sandbox and fewer (ex: only critical errors) to the global appserver logger.

    Example:
    @code{.py}
    LoggerAppenderQueue laq();
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);

    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    while (True) {
        laq.process(-1);
    }
    @endcode

    @par Application Server Running Many Sandboxed Program Containers

    This example is basically the same as the previous example, but to avoid I/O bottlenecks in logging, the
    appserver processing thread gets the event from a queue and passes it to the appender in another worker
    thread by a submitting the logging action to a @ref Qore::Thread::ThreadPool "ThreadPool". So events targeted
    to a particular thread may by processed in different threads but nevertheless serially.

    Example:
    @code{.py}
    ThreadPool tp();
    LoggerAppenderQueueThreadPool laq(tp, 5);
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);
    code processing() = sub () {
        while (True) {
            laq.process(-1);
        }
    }
    # may run in extra thread
    background processing();
    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello %s #%d", "world", 1);
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    # wait till finished
    @endcode

    @subsection logger_v1_0 v1.0
    - Split classes into the <a href="../../logger_bin/html/index.html">logger_bin</a> module for performance reasons
      (<a href="https://github.com/qorelanguage/qore/issues/4884">issue 4884</a>)

    @subsection logger_v0_6 v0.6
    - Fixed a bug where file rotate could result in logging exceptions; removed explicit atomic lock operations and
      implemented low-level atomic file handling instead
      (<a href="https://github.com/qorelanguage/qore/issues/4842">issue 4842</a>)

    @subsection logger_v0_5 v0.5
    - added @ref Logger::LoggerInterface "LoggerInterface" and @ref Logger::LoggerWrapper "LoggerWrapper" classes
      (<a href="https://github.com/qorelanguage/qore/issues/4776">issue 4776</a>)

    @subsection logger_v0_4 v0.4
    - added the @ref Logger::StdoutAppender "StdoutAppender" class

    @subsection logger_v0_3 v0.3
    - fixed a race condition handling log file rotation with active logs
      (<a href="https://github.com/qorelanguage/qore/issues/4583">issue 4583</a>)

    @subsection logger_v0_2 v0.2
    - added support for the \c %%h and \c %%P patterns for hostname and PID, respectively
      (<a href="https://github.com/qorelanguage/qore/issues/4179">issue 4179</a>)
    - allow file appenders to be reopened
      (<a href="https://github.com/qorelanguage/qore/issues/4171">issue 4171</a>)
    - enable serialization for LoggerEvent objects as well as for them to be submitted
      directly to @ref Logger::Logger "Logger" objects
      (<a href="https://github.com/qorelanguage/qore/issues/4164">issue 4164</a>)

    @subsection logger_v0_1_1 v0.1.1
    - added Logger::Logger::logArgs() "Logger::logArgs()"
      (<a href="https://github.com/qorelanguage/qore/issues/3492">issue 3492</a>)

    @subsection logger_v0_1 v0.1
    - the initial version of the Logger module
*/

#! The Logger namespace contains all the definitions in the Logger module
public namespace Logger {
#! Implements callable parameter which is evaluated in run-time when event is rendered
/**
    It may implement logging for stuff which is time consuming to get and would slow program flow in case
    the logging is actually not performed because of filters or logging levels.

    Example:
@code{.py}
int ping_voyager(int num) {
    try {
        # ping voyager #num
        ...
    } except(hash<ExceptionInfo> ex) {
        return -1;
    }
}
Logger l;
....
l.debug("Voyager 1: ping is %y secs", new LoggerEventParameter(\ping_voyager(), 1));
@endcode
*/
public class LoggerEventParameter {
    private:internal {
        code callable;
        *list<auto> args;
    }

    #! Creates object
    /**
        @param func function to be called with optional arguments followed
    */
    constructor(code func, ...) {
        callable = func;
        args = argv;
    }

    #! Call function with arguments provided
    /**
        In case of user function call consider surpressing exceptions to return value corresponding to expected
        formatting parameter (e.g. "%d").
    */
    public auto call() {
        return call_function_args(callable, args);
    }
}

#! Handles the processing for asynchronous appender events in multiple threads
/**
    Async events are removed from the event queue in a single thread which balances processing
    in multiple worker threads via a @ref Qore::Thread::ThreadPool "ThreadPool". This class groups events by appender
    so that events related to a particular appender are always processed serially in the same thread.
    It is compatible with %Qore's @ref Qore::OutputStream implementation where all data submitted to the
    output stream must be submitted from the same thread.
*/
public class LoggerAppenderQueueThreadPool inherits LoggerAppenderQueue {
    private:internal {
        #! worker thread pool
        ThreadPool threadPool;
        #! number of running worker threads
        Counter runningCounter(0);
        #! max.number of worker threads
        int maxThreads;
        #! events removed from queue but not passed to worker thread
        hash<auto> pendingEvents;
        #! events paseed to worker thread
        hash<auto> processingEvents;
        #! queue of processed events in worker threads
        Queue finishedEvents();
        #! internal unique counter
        Sequence lastId(0);
        #! to protect process()
        Mutex lock();
    }

    #! Implements worker thread code
    /**
        @param id unique identifier generated by internal @ref Qore::Thread::Sequence "Sequence"
        @param appender @ref Qore::Logger::LoggerAppender "LoggerAppender" instance
        @param events list of events
    */
    private:internal worker(string id, LoggerAppender appender, list<auto> events) {
        #printf("start worker(), id: %y, tid: %d\n", id, gettid());
        #printf("<S:%y, tid: %d> ", id, gettid());
        runningCounter.inc();
        on_exit runningCounter.dec();
        try {
            map appender.processEvent($1.type, $1.params), events;
        } catch (hash<ExceptionInfo> ex) {
            # ignore exceptions
        }
        finishedEvents.push(id);
        #printf("end worker(), id: %y, tid: %d\n", id, gettid());
        #printf("<E:%y, tid: %d> ", id, gettid());
    }

    #! Creates the object
    /**
        @param tp worker @ref Qore::Thread::ThreadPool "ThreadPool" where loggging events are submitted
        @param max_threads max.number of worker threads, default value is \c -1, i.e. unlimited
    */
    constructor(ThreadPool tp, int max_threads = -1) {
        threadPool = tp;
        maxThreads = max_threads;
    }

    destructor() {
        runningCounter.waitForZero();
        threadPool.stopWait();
    }

    #! Returns the assigned @ref Qore::Thread::ThreadPool "ThreadPool"
    public ThreadPool getThreadPool() {
        return threadPool;
    }

    #! Processes queue events
    /**
        Group logging events by appender and submit them to a worker thread to be processed in a thread pool so
        the particular thread will handle corresponding appender instance.

        @param ms a timeout value to wait for data to become available on the queue;
            integers are interpreted as milliseconds; relative date/time values are interpreted
            literally with a maximum resolution of milliseconds. A value that converts to integer 0 causes
            the call to time out immediately if the call would otherwise block.
            If a positive timeout argument is passed, and no data is available in the timeout period
            then waits up to timeout value, If a negative timeout value is passed as the argument,
            then the call blocks until data is available on the queue. Default value is 0.
    */
    public process(timeout ms = 0) {
        # normally function is called from one thread and it is not time critical
        AutoLock al(lock);
        # get new events and match with pending
        hash<string, auto> last_match;
        while (True) {
            *hash<auto> e = getEvent(ms);
            if (!e) {
                break;
            }
            if (last_match.appender != e.appender) {
                bool found = False;
                foreach string id in (keys pendingEvents) {
                    if (pendingEvents{id}.appender == e.appender) {
                        last_match.id = id;
                        last_match.appender = e.appender;
                        found = True;
                        break;
                    }
                }
                if (!found) {
                    # look into processing
                    foreach string id in (keys processingEvents) {
                        if (processingEvents{id}.appender == e.appender) {
                            last_match.id = id;
                            found = True;
                            break;
                        }
                    }
                    if (!found) {
                        # add new entry
                        last_match.id = string(lastId.next());
                    }
                    last_match.appender = e.appender;
                    pendingEvents{last_match.id} = {
                        "id": last_match.id,  # to get reason of this value duplicating key see problem description
                                              # above ThreadPool::submit(id, ...) call
                        "appender": e.appender,
                        "events": (),
                    };
                }
            }
            push pendingEvents{last_match.id}.events, e.('type', 'params');
        }

        # remove finished
        while (finishedEvents.size() > 0) {
            string id = finishedEvents.get(-1);
            remove processingEvents{id};
        }

        # now try push pending
        foreach string id in (keys pendingEvents) {
            # remove meanwhile finished if any
            while (finishedEvents.size() > 0) {
                remove processingEvents{finishedEvents.get(-1)};
            }
            # is available a free worker thread ?
            if (maxThreads >= 0 && processingEvents.size() >= maxThreads) {
                return;
            }
            if (exists processingEvents{id}) {
                # we cannot trigger new thread if is being processed
                continue;
            }
            hash<auto> e = remove pendingEvents{id};
            processingEvents{id} = e;
            # When passing "id" then no copy is passed to submit pool queue and worker may get the wrong value
            # so we must pass value in new variable which won't change meanwhile when the value is to be used.
            # It is a feature of the "submit" implementation related to parameter passing
            threadPool.submit(sub() { worker(e.id, e.appender, e.events); });
        }
    }

    #! Gets number of pending events
    public int size() {
        AutoLock al(lock);
        return LoggerAppenderQueue::size() + processingEvents.size() + pendingEvents.size();
    }
}

#! Implements appender which does nothing
/**
    All events posted to the appender are silently ignored
*/
public class LoggerAppenderNull inherits LoggerAppender {
    constructor(*string name): LoggerAppender(name) {
    }

    private auto serializeImpl(LoggerEvent event) {
    }

    public processEventImpl(int type, auto params) {
    }
}

#! implements appender writing to an output stream via @ref Qore::StreamWriter "StreamWriter"
/**
    Qore streams are not designed to accept input from multiple threads simultaneously, so writing must be serialized and processed
    in a dedicated thread
*/
public class LoggerAppenderStream inherits LoggerAppenderWithLayout {
    private:internal {
        #! stream writer
        StreamWriter writer;
        #! closed flag
        bool closed = False;
        #! assign thread for stream
        bool assignThread;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param writer the stream to write to
    */
    constructor(*string name, LoggerLayout layout, StreamWriter writer): LoggerAppenderWithLayout(name, layout) {
        self.writer = writer;
        assignThread = writer.getOutputStream().getThreadId() == -1;
    }

    #! Returns the stream writer object
    public StreamWriter getStreamWriter() {
        return writer;
    }

    #! Returns @ref True if assigning a thread for a stream
    public bool hasAssignThread() {
        return assignThread;
    }

    #! Processes open, log, and close events with the output stream; all other events are ignored
    public processEventImpl(int type, auto params) {
        if (type == EVENT_OPEN) {
            if (closed) {
                # OutputStream does not provide open method
                throw "LOGGER-ERROR", "Cannot reopen stream";
            }
        } else {
            if (assignThread) {
                writer.getOutputStream().reassignThread();
            }
            switch (type) {
                case EVENT_LOG:
                    writer.print(params);
                    break;
                case EVENT_CLOSE:
                    writer.getOutputStream().close();
                    closed = True;
                    break;
            }
            on_exit if (assignThread) {
                writer.getOutputStream().unassignThread();
            }
        }
    }
}

%ifdef HAVE_TERMIOS
#! Implements appender writing to a stdout file
/**
    No multi-threading protection is implemented in the class; the @ref Qore::stdout "stdout" instance is reused.
    Unavailable when @ref Qore::PO_NO_TERMINAL_IO parse option is applied.
*/
public class LoggerAppenderStdOut inherits LoggerAppenderWithLayout {
    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
    */
    constructor(*string name, LoggerLayout layout): LoggerAppenderWithLayout(name, layout) {
    }

    #! Processes log events with the file and ignores all other events including open, close
    /**
        @param type the event type
        @param params parameters for the event
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_LOG:
                stdout.print(params);
                break;
        }
    }
}

#! Implements appender writing to a stderr file
/**
    No multi-threading protection is implemented in the class; the @ref Qore::stderr "stderr" instance is reused.
    Unavailable when @ref Qore::PO_NO_TERMINAL_IO parse option is applied.
*/
public class LoggerAppenderStdErr inherits LoggerAppenderWithLayout {
    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
    */
    constructor(*string name, LoggerLayout layout): LoggerAppenderWithLayout(name, layout) {
    }

    #! Processes log events with the file and ignores all other events including open, close
    /**
        @param type the event type
        @param params parameters for the event
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_LOG:
                stderr.print(params);
                break;
        }
    }
}
%endif

#! Abstract class for file appenders with rotation support
public class AbstractLoggerAppenderFileRotate inherits public LoggerAppenderFile {
    public {
        #! rotate event
        const EVENT_ROTATE = 10001;
        #! default value for rotation chain
        const DEFAULT_ROTATION_COUNT = 10;
    }

    constructor(*string name, LoggerLayout layout, *string encoding)
            : LoggerAppenderFile(name, layout, "", encoding) {}

    #! Pushes rotate event
    /**
        The current log file will be closed and opened. If the file exists, then it is ovewritten

        @throw LOGGER-ERROR if rotation is disabled
    */
    public rotate() {
        if (isOpen()) {
            if (getCount() <= 0) {
                throw "LOGGER-ERROR", "Rotation is disabled";
            }
            pushEvent(EVENT_ROTATE, NOTHING);
        }
    }

    #! Abstract method to get count of rotation objects
    public abstract int getCount();
}

#! Implements appender writing to a file with file rotation support
/**
    The events will be logged to a file until rotation occurs.
    At that moment the current file is closed, archive chain is moved,
    new file is created and logging continues there.
*/
public class LoggerAppenderFileRotate inherits public AbstractLoggerAppenderFileRotate, private LoggerPattern {
    public {
        #! default archive pattern
        const DEFAULT_ARCHIVE_PATTERN = "%p%f.%i";
    }

    private:internal {
        int count;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param filename with pattern support; see below for more information
        @param count number of files in rotation chain, if count is <=0 then no ratation is performed
        @param archive pattern to evaluate archive filename; see below for more information
        @param encoding the encoding of the output file

        The following table explains the characters used in @ref Qore::Logger::LoggerPattern "LoggerPattern" for both filename and archive parameter

        | !Conversion character | !Meaning |
        | \c %%s | Used to output the OS directory separator, i.e. "\" or "/" |
        | \c %%c | Used to output the appender name |
        | \c %%C | Used to output the appender class name |
        | \c %%E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | \c %% | The literal percent sign. \c "%%" will print a \c "%" sign |

        The following table explains the characters used in @ref Qore::Logger::LoggerPattern "LoggerPattern" for archive parameter only

        | !Conversion character | !Meaning |
        | \c %%P | Used to output the current logging path with filename |
        | \c %%p | Used to output the current logging path |
        | \c %%f | Used to output the current logging filename |
        | \c %%i | Used to output the current file index from 1 to count. option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
        | \c %%n | Used to output the rotation count. Option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |

        For example, the archive pattern \c "%p%f.%i" rotates log file \c "/var/run/log/MyLogger.log" to:
        \c "/var/run/log/MyLogger.log.1" \c "/var/run/log/MyLogger.log.2" \c "/var/run/log/MyLogger.log.3".
    */
    constructor(*string name, LoggerLayout layout, string filename, int count = DEFAULT_ROTATION_COUNT,
            string archive = DEFAULT_ARCHIVE_PATTERN, *string encoding)
            : AbstractLoggerAppenderFileRotate(name, layout, encoding), LoggerPattern(filename) {
        fileName = format(NOTHING);  # no dynamic vars as timestamp
        self.count = count;
        setPattern(archive);
    }

    #! Returns a string for a format field for a pattern-based filename
    /**
        @param data input context reference data
        @param key the format character
        @param option the format option value, if any

        @return the formatted string
    */
    private *string resolveField(auto data, string key, *string option) {
        *string res;
        switch (key) {
            case "c":
                res = get_class_name(self);
                break;
            case "C":
                res = getName();
                break;
            case "E":
                res = ENV{option};
                break;
            case "s":
                res = DirSep;
                break;
        }
        if (data) {  # archive pattern
            switch (key) {
                case "i":
                    res = sprintf(option ?? "%d", data.index);
                    break;
                case "n":
                    res = sprintf(option ?? "%d", data.count);
                    break;
                case "P":
                    res = data.filename;
                    break;
                case "p": # path
                    res = dirname(data.filename);
                    if (res != DirSep) {
                        res += DirSep;
                    }
                    break;
                case "f": # filename
                    res = basename(data.filename);
                    break;
            }
        }
        return res;
    }

    #! Implements filename rotation; handles the open and rotate events directly
    /** All other events are handled by subclasses

        @param type the event type
        @param params event parameters
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_ROTATE:
                if (count > 0 && is_file(fileName)) {
                    list<string> fn = ();
                    int i = 0;
                    while (True) {
                        push fn, getArchiveFileName(i+1);
                        if (!is_dir(dirname(fn[i]))) {
                            mkdir_ex(dirname(fn[i]), 0777, True);
                        }
                        if (i >= count-1 || !is_file(fn[i])) {
                            # find a gap in chain or stop at the last file
                            break;
                        }
                        i++;
                    }
                    while (i > 0) {
                        # shift files till a gap or last file
                        rename(fn[i-1], fn[i]);
                        i--;
                    }
                    # issue #4842: rotate atomically
                    File f(encoding);
                    # first rename old file
                    rename(fileName, fn[0]);
                    # reopen file atomically
                    file.open2(fileName, O_CREAT | O_APPEND | O_WRONLY | O_TRUNC);
                }
                break;
            default:
                LoggerAppenderFile::processEventImpl(type, params);
        }
    }

    #! Returns the archive filename
    /**
        @param idx the index of file (1..count)
    */
    public string getArchiveFileName(int idx) {
        return format({
            "filename": fileName,
            "count": count,
            "index": idx,
        });
    }

    #! Returns max.number of files in chain
    public int getCount() {
        return count;
    }
}

#! Implemants appender writing to a file with file circular rotation support
/**
    The events will be logged to a file until rotation occurs.
    At that moment the current file is closed, next file is created
    and logging continues to the new file.
*/
public class LoggerAppenderFileRing inherits public AbstractLoggerAppenderFileRotate, private LoggerPattern {
    public {
        #! default date format
        const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
    }

    private:internal {
        hash<auto> patternData;
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param pattern to generate the file name; see information below
        @param count number of files in ring, if count is <=0 then no ratation is performed
        @param encoding the encoding of the output file

        The following table explains the characters used in @ref Qore::Logger::LoggerPattern "LoggerPattern" and all other characters that you can use in your custom pattern:

        | !Conversion character | !Meaning |
        | i | Used to output the current file index from 0 to count-1. option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
        | n | Used to output the rotation count. Option may specify @ref Qore::sprintf() "sprintf()"() format, e.g. \c "%.3d" |
        | c | Used to output the appender name. |
        | C | Used to output the appender class name. |
        | d | Used to output the date of the logging event using @ref Qore::format_date() "format_date()". Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |
        | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | % | The literal percent sign. \c "%%" will print a \c "%" sign |

        For example, the pattern \c "/var/run/log/%c.log.%i{%03d}" creates the following file names:
        \c "/var/run/log/MyLogger.log.000", \c "/var/run/log/MyLogger.log.001" etc.
    */
    constructor(*string name, LoggerLayout layout, string pattern, int count = DEFAULT_ROTATION_COUNT,
            *string encoding): AbstractLoggerAppenderFileRotate(name, layout, encoding), LoggerPattern(pattern) {
        # set a provisional filename, to be updated when file is opened
        patternData.timestamp = now_us();
        patternData.count = count;
        patternData.index = 0;
        fileName = format(patternData);
    }

    #! Returns a string for a format field for a pattern-based filename
    /**
        @param data input context reference data
        @param key the format character
        @param option the format option value, if any

        @return the formatted string
    */
    private *string resolveField(auto data, string key, *string option) {
        *string res;
        switch (key) {
            case "i":
                res = sprintf(option ?? "%d", data.index);
                break;
            case "n":
                res = sprintf(option ?? "%d", data.count);
                break;
            case "c":
                res = get_class_name(self);
                break;
            case "C":
                res = getName();
                break;
            case "d":
                if (option) {
                    res = format_date(option, data.timestamp);
                } else {
                    res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                }
                break;
            case "E":
                res = ENV{option};
                break;
        }
        return res;
    }

    #! Implements filename rotation; handles the open and rotate events directly; passes all other events to the subclass for handling
    /**
        @param type the event type
        @param params event parameters
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_OPEN:
                # find newest file
                patternData.timestamp = now_us();
                int last_idx = 0;
                if (patternData.count > 0) {
                    date last_stamp;
                    hash<auto> pd = patternData;
                    for (int i=0; i < patternData.count; i++) {
                        pd.index = i;
                        string fn = format(pd);
                        *hash<StatInfo> si = hstat(fn);
                        if (si) {
                            if (!last_stamp || si.mtime > last_stamp) {
                                last_stamp = si.mtime;
                                last_idx = i;
                            }
                        }
                    }
                }
                patternData.index = last_idx;
                fileName = format(patternData);
                LoggerAppenderFile::processEventImpl(type, params);
                break;
            case EVENT_ROTATE:
                if (patternData.count > 0) {
                    # issue #4842: rotate atomically
                    patternData.index = (patternData.index + 1) % patternData.count;
                    patternData.timestamp = now_us();
                    fileName = format(patternData);
                    # create new file and reopen atomically
                    file.open2(fileName, O_CREAT | O_APPEND | O_WRONLY | O_TRUNC);
                }
                break;
            default:
                LoggerAppenderFile::processEventImpl(type, params);
        }
    }

    #! Returns number of files in ring
    public int getCount() {
        return patternData.count;
    }

    #! Returns current ring index being used for logging
    public int getCurrentIndex() {
        return patternData.index;
    }
}

#! Implements appender writing to a file with archive support
/**
    The events will be logged to a file until archiving is triggered.
    At that moment the current file is closed, moved to file with name evaluated in runtime
    from the archive pattern set in the object, the new file is created, and logging continues to that file.
    The archive never overwrites any existing file.
*/
public class LoggerAppenderFileArchive inherits public LoggerAppenderFile, private LoggerPattern {
    public {
        #! archive event
        const EVENT_ARCHIVE = 20;
        #! default date format
        const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
        #! default archive pattern
        const DEFAULT_ARCHIVE_PATTERN = "%p%f.%d";
    }

    #! Creates the object
    /**
        @param name the name of the appender
        @param layout the layout for the appender
        @param filename with pattern support; see below for more information
        @param archive pattern to evaluate archive filename; see below for more information
        @param encoding the output file's encoding

        The following table explains the characters used in @ref Qore::Logger::LoggerPattern "LoggerPattern" for both filename and archive parameter

        | !Conversion character | !Meaning |
        | \c %%s | Used to output the OS directory separator, i.e. "\" or "/" |
        | \c %%c | Used to output the appender name |
        | \c %%C | Used to output the appender class name |
        | \c %%E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | \c %% | The literal percent sign. \c "%%" will print a \c "%" sign |

        The following table explains the characters used in @ref Qore::Logger::LoggerPattern "LoggerPattern" for archive parameter only

        | !Conversion character | !Meaning |
        | \c %%P | Used to output the current logging path with filename |
        | \c %%p | Used to output the current logging path |
        | \c %%f | Used to output the current logging filename |
        | \c %%d | Used to output the date of the logging event using @ref Qore::format_date() "format_date()". Option may specify date \
            format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |

        For example, the archive pattern \c "%p/archive/%d/%f" archives log file \c "/var/run/log/MyLogger.log" to:
        \c "/var/run/log/archive/20180120102030/MyLogger.log".
    */
    constructor(*string name, LoggerLayout layout, string filename, string archive = DEFAULT_ARCHIVE_PATTERN,
            *string encoding): LoggerAppenderFile(name, layout, filename, encoding), LoggerPattern(filename) {
        fileName = format(NOTHING);  # no dynamic vars as timestamp
        setPattern(archive);
    }

    #! Returns a string for a format field for a pattern-based filename or archive file name
    /**
        @param data if @ref nothing, then this argument specifies the logging filename, otherwise is specifies the archive pattern
        @param key the format character
        @param option the format option value, if any

        @return the formatted string
    */
    private *string resolveField(auto data, string key, *string option) {
        *string res;
        switch (key) {
            case "c":
                res = get_class_name(self);
                break;
            case "C":
                res = getName();
                break;
            case "E":
                res = ENV{option};
                break;
            case "s":
                res = DirSep;
                break;
        }
        if (data) {  # archive pattern
            switch (key) {
                case "d":
                    if (option) {
                        res = format_date(option, data.timestamp);
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                    }
                    break;
                case "P":
                    res = data.filename;
                    break;
                case "p": # path
                    res = dirname(data.filename);
                    if (res != DirSep) {
                        res += DirSep;
                    }
                    break;
                case "f": # filename
                    res = basename(data.filename);
                    break;
            }
        }
        return res;
    }

    #! Implements archiving, handles the archive event directly, passes all other events to the subclass for handling
    /**
        @param type the event code
        @param params event parameters
    */
    public processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_ARCHIVE:
                mkdir_ex(dirname(params), 0777, True);
                if (isOpen()) {
                    # issue #4842: do not close the file here, allow it to be reopened atomically
                    rename(fileName, params);
                    LoggerAppenderFile::processEventImpl(EVENT_OPEN);
                } else {
                    rename(fileName, params);
                }
                break;
            default:
                LoggerAppenderFile::processEventImpl(type, params);
        }
    }

    #! Posts an archive event
    /**
        rename logging file and open new one
        @return archive file name

        @throw LOGGER-ERROR if target file name is not correct or target file already exists
    */
    public string archive() {
        string afn = getArchiveFileName();
        if (afn == "") {
            throw "LOGGER-ERROR", "Empty target filename";
        }
        if (normalize_dir(afn) == normalize_dir(fileName)) {
            throw "LOGGER-ERROR", "Source and target path are equal";
        }
        if (is_dir(afn)) {
            throw "LOGGER-ERROR", "Target is directory";
        }
        if (is_file(afn)) {
            throw "LOGGER-ERROR", "Target file already exists";
        }
        pushEvent(EVENT_ARCHIVE, afn);
        return afn;
    }

    #! Returns the archive filename
    /**
        The pattern may contain date fields so the result may differ when
        executed multiple times
    */
    public string getArchiveFileName() {
        return format({
            "timestamp": now_us(),
            "filename": fileName,
        });
    }
}

#! Implements the filter according event @ref Qore::Logger::LoggerLevel "LoggerLevel"
/**
    When @ref Qore::Logger::LoggerEvent::getLevel does not satisfy the filter condition, then
    logging is rejected.

    The min and max levels define the range to be logged (if min <= max.level) or range which won't be logged (if max < min.level)
*/
public class LoggerFilterLevel inherits LoggerFilter {
    private:internal {
        #! min.level
        Qore::Logger::LoggerLevel minLevel;
        #! max.level
        Qore::Logger::LoggerLevel maxLevel;
    }

    #! Creates the object
    /**
        @param min_value the minimum logging level
        @param max_value the maximum logging level
    */
    constructor(Qore::Logger::LoggerLevel min_value = Qore::Logger::LoggerLevel::LevelInfo,
            Qore::Logger::LoggerLevel max_value = Qore::Logger::LoggerLevel::LevelOff) {
        setMinLevel(min_value);
        setMaxLevel(max_value);
    }

    #! Creates the object
    /**
        @param min_value the minimum logging level
        @param max_value the maximum logging level
    */
    constructor(int min_value, int max_value = Qore::Logger::LoggerLevel::OFF) {
        setMinLevel(min_value);
        setMaxLevel(max_value);
    }

    #! Creates the object
    /**
        @param min_value the minimum logging level
        @param max_value the maximum logging level
    */
    constructor(string min_value, string max_value = "OFF") {
        setMinLevel(min_value);
        setMaxLevel(max_value);
    }

    #! Sets the minimum logging level
    /**
        @param value the minimum logging level
    */
    public setMinLevel(LoggerLevel value) {
        minLevel = value;
    }

    #! Sets the minimum logging level
    /**
        @param value the minimum logging level
    */
    public setMinLevel(int value) {
        setMinLevel(Qore::Logger::LoggerLevel::getLevel(value));
    }

    #! Sets the minimum logging level
    /**
        @param value the minimum logging level
    */
    public setMinLevel(string value) {
        setMinLevel(Qore::Logger::LoggerLevel::getLevel(value));
    }

    #! Returns the minimum logging level
    public LoggerLevel getMinLevel() {
        return minLevel;
    }

    #! Sets the maximum logging level
    /**
        @param value the maximum logging level
    */
    public setMaxLevel(LoggerLevel value) {
        maxLevel = value;
    }

    #! Sets the maximum logging level
    /**
        @param value the maximum logging level
    */
    public setMaxLevel(int value) {
        setMaxLevel(Qore::Logger::LoggerLevel::getLevel(value));
    }

    #! Sets the maximum logging level
    /**
        @param value the maximum logging level
    */
    public setMaxLevel(string value) {
        setMaxLevel(Qore::Logger::LoggerLevel::getLevel(value));
    }

    #! Returns the maximum logging level
    public Qore::Logger::LoggerLevel getMaxLevel() {
        return maxLevel;
    }

    #! Implements filtering by level
    public int eval(LoggerEvent event) {
        if (maxLevel.isGreaterOrEqual(minLevel)) {
            if (!(event.getLevel().isGreaterOrEqual(minLevel) && maxLevel.isGreaterOrEqual(event.getLevel()))) {
                return DENY;
            }
        } else {
            if (event.getLevel().isGreaterOrEqual(maxLevel) && minLevel.isGreaterOrEqual(event.getLevel())) {
                return DENY;
            }
        }
        return NEUTRAL;
    }
}

#! Implements filtering according to a regular expression on the event message
/**
    The rendered event message is tested using a regular expression, and if it does not match the
    expected result, then logging is rejected
*/
public class LoggerFilterRegex inherits LoggerFilter {
    private:internal {
        #! regular string
        string regexStr;
        #! expected result
        bool regexResult;
    }

    #! Creates the object
    /**
        @param regex_str the regular expression to use
        @param regex_result @ref True for a positive match, @ref False for a negative match
    */
    constructor(string regex_str = "", bool regex_result = True) {
        setRegex(regex_str, regex_result);
    }

    #! Sets the regular expression and the expected result for the filter
    /**
        @param regex_str the regular expression to use
        @param regex_result @ref True for a positive match, @ref False for a negative match
    */
    public setRegex(string regex_str, bool regex_result = True) {
        regexStr = regex_str;
        regexResult = regex_result;
    }

    #! Returns the current regex
    public string getRegex() {
        return regexStr;
    }

    #! Returns the expected result
    public bool getRegexResult() {
        return regexResult;
    }

    #! Evaluates the regex and compares with the expected result
    public int eval(LoggerEvent event) {
        if (event.getMessage().regex(regexStr) != regexResult) {
            return DENY;
        } else {
            return NEUTRAL;
        }
    }
}

#! This abstract class defines the logging interface
public class LoggerInterface inherits Qore::Serializable {
    #! Returns @ref True if the passed logger is the logger used to log, @ref False if not
    bool isLogger(LoggerInterface logger) {
        return logger == self;
    }

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract log(Qore::Logger::LoggerLevel level, string message, ...);

    #! Logs a message using the provided logging level
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract log(int level, string message, ...);

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract log(string level, string message, ...);

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    abstract logArgs(Qore::Logger::LoggerLevel level, string message, *softlist<auto> args);

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    abstract logArgs(int level, string message, *softlist<auto> args);

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    abstract logArgs(string level, string message, *softlist<auto> args);

    #! Logs an already prepared logging event object
    /**
        @param event the event to log
    */
    abstract logEvent(LoggerEvent event);

    #! Logs a message object with the TRACE level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract trace(string message, ...);

    #! Logs a message object with the DEBUG level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract debug(string message, ...);

    #! Logs a message object with the INFO level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract info(string message, ...);

    #! Logs a message object with the WARN level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract warn(string message, ...);

    #! Logs a message object with the ERROR level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract error(string message, ...);

    #! Logs a message object with the FATAL level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract fatal(string message, ...);

    #! Performs logging of assertions
    /**
        If the \a assertion parameter is @ref False, then the message is logged
        using the ERROR level.

        @see @ref log()

        @param assertion the boolean assertion value
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    abstract assertLog(bool assertion, string message, ...);

    #! Logs the variable name and value using TRACE level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    abstract traceVar(string var_name, auto value);

    #! Logs the variable name and value using DEBUG level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    abstract debugVar(string var_name, auto value);

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    abstract bool isEnabledFor(Qore::Logger::LoggerLevel level);

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    abstract bool isEnabledFor(int level);

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    abstract bool isEnabledFor(string level);

    #! Checks whether this Logger is enabled for the TRACE Level
    abstract bool isTraceEnabled();

    #! Checks whether this Logger is enabled for the DEBUG Level
    abstract bool isDebugEnabled();

    #! Checks whether this Logger is enabled for the INFO Level
    abstract bool isInfoEnabled();

    #! Checks whether this Logger is enabled for the WARN Level
    abstract bool isWarnEnabled();

    #! Checks whether this Logger is enabled for the ERROR Level
    abstract bool isErrorEnabled();

    #! Checks whether this Logger is enabled for the FATAL Level
    abstract bool isFatalEnabled();

    #! Sets the logging level
    /**
        @param level if nothing then inherits level from parent
    */
    abstract setLevel(*Qore::Logger::LoggerLevel level);

    #! Sets the logging level
    /**
        @param level the logging level as a string
    */
    abstract setLevel(string level);

    #! Sets the logging level
    /**
        @param level the logging level to set
    */
    abstract setLevel(int level);

    #! Decrement logger level
    /**
        @return current @ref Qore::Logger::LoggerLevel "LoggerLevel"
    */
    abstract *Qore::Logger::LoggerLevel decLevel();

    #! Increment logger level
    /**
        @return current @ref Qore::Logger::LoggerLevel "LoggerLevel"
    */
    abstract *Qore::Logger::LoggerLevel incLevel();

    #! Returns the logging level
    /**
        @param effective if False then get current level which can be NOTHING, if True then get level which might be
        inherited from parent, Default: True
        @throw LOGGER-ERROR if cannot get effective level from hierarchy
    */
    abstract *Qore::Logger::LoggerLevel getLevel(bool effective = True);
}

#! Class handling a LoggerInterface object as a member and providing atomic logging through it
public class LoggerWrapper inherits LoggerInterface {
    private {
        #! The logger interface
        transient *LoggerInterface logger;
    }

    #! Creates the object with no logger
    constructor() {
    }

    #! Creates the object with a logger
    constructor(LoggerInterface logger) {
        self.logger = logger;
    }

    #! Returns @ref True if the passed logger is the logger used to log, @ref False if not
    bool isLogger(LoggerInterface logger) {
        return logger == self.logger;
    }

    #! Accepts a LoggerInterface object for logging (or clears it)
    setLogger(*LoggerInterface logger) {
        self.logger = logger;
    }

    #! Logs a message using the provided logging level if a logger is set
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    log(Qore::Logger::LoggerLevel level, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, argv);
        }
    }

    #! Logs a message using the provided logging level if a logger is set
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    log(int level, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, argv);
        }
    }

    #! Logs a message using the provided logging level if a logger is set
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    log(string level, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, argv);
        }
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /** Logging is only performed if a logger is set

        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    logArgs(Qore::Logger::LoggerLevel level, string message, *softlist<auto> args) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, args);
        }
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /** Logging is only performed if a logger is set

        @param level the logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    logArgs(int level, string message, *softlist<auto> args) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, args);
        }
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /** Logging is only performed if a logger is set

        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    logArgs(string level, string message, *softlist<auto> args) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(level, message, args);
        }
    }

    #! Logs an already prepared logging event object
    /**
        @param event the event to log
    */
    logEvent(LoggerEvent event) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logEvent(event);
        }
    }

    #! Logs a message object with the TRACE level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    trace(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(Qore::Logger::LoggerLevel::LevelTrace, message, argv);
        }
    }

    #! Logs a message object with the DEBUG level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    debug(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(Qore::Logger::LoggerLevel::LevelDebug, message, argv);
        }
    }

    #! Logs a message object with the INFO level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    info(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(Qore::Logger::LoggerLevel::LevelInfo, message, argv);
        }
    }

    #! Logs a message object with the WARN level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    warn(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(Qore::Logger::LoggerLevel::LevelWarn, message, argv);
        }
    }

    #! Logs a message object with the ERROR level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    error(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(Qore::Logger::LoggerLevel::LevelError, message, argv);
        }
    }

    #! Logs a message object with the FATAL level
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    fatal(string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.logArgs(Qore::Logger::LoggerLevel::LevelFatal, message, argv);
        }
    }

    #! Performs logging of assertions
    /**
        If the \a assertion parameter is @ref False, then the message is logged
        using the ERROR level.

        @see @ref log()

        @param assertion the boolean assertion value
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    assertLog(bool assertion, string message, ...) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.assertLogArgs(assertion, message, argv);
        }
    }

    #! Logs the variable name and value using TRACE level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    traceVar(string var_name, auto value) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.traceVar(var_name, value);
        }
    }

    #! Logs the variable name and value using DEBUG level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    debugVar(string var_name, auto value) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.debugVar(var_name, value);
        }
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    bool isEnabledFor(LoggerLevel level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isEnabledFor(level);
        }
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    bool isEnabledFor(int level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isEnabledFor(level);
        }
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter
    /**
        @param level the log level to check
    */
    bool isEnabledFor(string level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isEnabledFor(level);
        }
    }

    #! Checks whether this Logger is enabled for the TRACE Level
    bool isTraceEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isTraceEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the DEBUG Level
    bool isDebugEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isDebugEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the INFO Level
    bool isInfoEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isInfoEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the WARN Level
    bool isWarnEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isWarnEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the ERROR Level
    bool isErrorEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isErrorEnabled();
        }
    }

    #! Checks whether this Logger is enabled for the FATAL Level
    bool isFatalEnabled() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.isFatalEnabled();
        }
    }

    #! Sets the logging level
    /**
        @param level if nothing then inherits level from parent
    */
    setLevel(*LoggerLevel level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.setLevel(level);
        }
    }

    #! Sets the logging level
    /**
        @param level the logging level as a string
    */
    setLevel(string level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.setLevel(level);
        }
    }

    #! Sets the logging level
    /**
        @param level the logging level to set
    */
    setLevel(int level) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            logger.setLevel(level);
        }
    }

    #! Decrement logger level
    /**
        @return current \c LoggerLevel
    */
    *LoggerLevel decLevel() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.decLevel();
        }
    }

    #! Increment logger level
    /**
        @return current \c LoggerLevel
    */
    *LoggerLevel incLevel() {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.incLevel();
        }
    }

    #! Returns the logging level
    /**
        @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
        @throw LOGGER-ERROR if cannot get effective level from hierarchy
    */
    *LoggerLevel getLevel(bool effective = True) {
        *LoggerInterface logger = getLogger();
        if (logger) {
            return logger.getLevel(effective);
        }
    }

    #! Returns the logger interface for logging
    private *LoggerInterface getLogger() {
        return self.logger;
    }
}

#! Implements main logger class whose instance will be used by user code when logging
/**
    The Logger object is provided to user code. When a log is triggered, the message, arguments, current code
    position, and time are appended as a @ref Qore::Logger::LoggerEvent event instance when
    the logging level is enabled. The event is passed to all registered appenders in the given Logger as well as
    in parents in the hierarchy when additivity is enabled.
*/
public class Logger inherits LoggerInterface {
    private:internal {
        #! The lock to protect object manipulation
        transient RWLock lock();

        #! The lock to protect access to parent/child hierarchy
        static RWLock hierarchyLock();

        #! Logger additivity
        /** If set to true then child loggers will inherit the appenders of their ancestors by default
        */
        bool additivity = True;

        #! The assigned Logger level. If @ref nothing, the parent level is used
        *LoggerLevel currentLevel;

        #! The name of this Logger instance.
        string name;

        #! The parent logger. Unassigned if this is the root logger.
        *Logger parent;

        #! A collection of appenders linked to this logger.
        transient list<LoggerAppender> appenders;
    }

    #! Creates the object
    /**
        @param name the name of the object
    */
    constructor(string name = "") {
        self.name = name;
    }

    #! Creates the object
    /**
        @param name the name of the object
        @param level the initial level for the logger
    */
    constructor(string name, LoggerLevel level) {
        self.name = name;
        currentLevel = level;
    }

    #! Creates the object
    /**
        @param name the name of the object
        @param level the initial level for the logger
    */
    constructor(string name, string level) {
        self.name = name;
        currentLevel = LoggerLevel::getLevel(level);
    }

    #! Creates the object
    /**
        @param name the name of the object
        @param level the initial level for the logger
    */
    constructor(string name, int level) {
        self.name = name;
        currentLevel = LoggerLevel::getLevel(level);
    }

    #! Creates the object with an empty name and the given initial level
    /**
        @param level the initial level for the logger
    */
    constructor(LoggerLevel level) {
        self.name = "";
        currentLevel = level;
    }

    destructor() {
        setParent(NOTHING);
    }

    #! Returns the logger name
    public string getName() {
        return name;
    }

    #! Returns the parent logger, if any
    public *Logger getParent() {
        return parent;
    }

    #! Sets the parent logger
    /**
        @param value the parent logger
        @throw LOGGER-ERROR in case of circular reference
    */
    public setParent(*Logger value) {
        AutoWriteLock awl(lock);
        if (value) {
            AutoWriteLock awhl(Logger::hierarchyLock);
            *Logger l = self;
            while (exists l) {
                if (l == value) {
                    throw "LOGGER-ERROR", "Circular logger chain";
                }
                l = l.getParent();
            }
        }
        parent = value;
    }

    #! Returns the logging level
    /**
        @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
        @throw LOGGER-ERROR if cannot get effective level from hierarchy
    */
    public *LoggerLevel getLevel(bool effective = True) {
        if (effective) {
            AutoReadLock awhl(Logger::hierarchyLock);
            *Logger l = self;
            *LoggerLevel rv;
            while (!exists (rv = l.getLevel(False))) {
                l = l.getParent();
                if (!exists l) {
                    throw "LOGGER-ERROR", "Cannot get effective level";
                }
            }
            return rv;
        } else {
            return currentLevel;
        }
    }

    #! Sets the logging level
    /**
        @param level if nothing then inherits level from parent
    */
    public setLevel(*LoggerLevel level) {
        currentLevel = level;
    }

    #! Sets the logging level
    /**
        @param level the logging level as a string
    */
    public setLevel(string level) {
        setLevel(Qore::Logger::LoggerLevel::getLevel(level));
    }

    #! Sets the logging level
    /**
        @param level the logging level to set
    */
    public setLevel(int level) {
        setLevel(Qore::Logger::LoggerLevel::getLevel(level));
    }

    #! Decrement logger level
    /**
        @return current \c LoggerLevel
    */
    public *LoggerLevel decLevel() {
        if (currentLevel) {
            *LoggerLevel lvl = LoggerLevel::getNextLowerLevel(currentLevel.getValue());
            if (lvl) {
                setLevel(lvl);
            }
        }
        return currentLevel;
    }

    #! Increment logger level
    /**
        @return current \c LoggerLevel
    */
    public *LoggerLevel incLevel() {
        if (currentLevel) {
            *LoggerLevel lvl = LoggerLevel::getNextHigherLevel(currentLevel.getValue());
            if (lvl) {
                setLevel(lvl);
            }
        }
        return currentLevel;
    }

    #! Sets the additivity flag; when additivity is active, events are passed to parent loggers.
    /**
        @param enable the additivity flag; when additivity is active, events are passed to parent loggers
    */
    public setAdditivity(bool enable) {
        additivity = enable;
    }

    #! Returns the additivity flag.
    public bool getAdditivity() {
        return additivity;
    }

    #! Forwards the given logging event to all linked appenders.
    /**
        @param event the event to forward
    */
    public callAppenders(LoggerEvent event) {
        AutoReadLock arl(lock);
        map $1.post(event), appenders;
    }

    #! Returns the call location where the log function was called from
    private static hash<CallStackInfo> getLocation() {
        return get_parent_caller_location();
    }

    #! Adds an appender to the appender list
    /**
        @param appender add a new LoggerAppender
        @throw "LOGGER-ERROR" exception if appender is already in list
    */
    public addAppender(LoggerAppender appender) {
        AutoWriteLock awl(lock);
        if (!appenders) {
            appenders = (appender, );
        } else {
            if (appenders.contains(appender)) {
                throw "LOGGER-ERROR", "Appender already exists in list";
            }
            push appenders, appender;
        }
    }

    #! Removes the appender from the list
    /**
        @param appender the appender to remove
    */
    public removeAppender(LoggerAppender appender) {
        AutoWriteLock awl(lock);
        foreach LoggerAppender a in (appenders) {
            if (a == appender) {
                splice appenders, $#, 1;
                break;
            }
        }
    }

    #! Clears the appender list by removing all appenders
    public removeAllAppenders() {
        AutoWriteLock awl(lock);
        splice appenders, 0;
    }

    #! Returns the appender list
    /**
        Note that the appender list may be manipulated in another thread as internal lock is released
        when list is returned
    */
    public list<LoggerAppender> getAppenders() {
        AutoReadLock awl(lock);
        return appenders ?? ();
    }

    private:internal logIntern(LoggerLevel level, string message, *list<auto> args, *hash<CallStackInfo> location,
            bool check_throwable, date time_stamp = now_us()) {
        #printf("lI: level: %y msg: %y args: %y loc: %y c: %y t: %y", level, message, args, location, check_throwable, time_stamp);

        if (isEnabledFor(level)) {
            *hash<ExceptionInfo> throwable;
            if (args.size() && check_throwable) {
                # is the last argument ExceptionInfo ?
                auto a = args[args.size()-1];
                if (a.typeCode() == NT_HASH && a.fullType() == "hash<ExceptionInfo>") {
                    throwable = a;
                }
            }
            callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), time_stamp, throwable));
            {
                AutoReadLock awl(lock);
                if (parent && getAdditivity()) {
                    # Forward the event upstream if additivity is turned on
                    parent.logIntern(level, message, args, location, throwable, time_stamp);
                }
            }
        } else {
            AutoReadLock awl(lock);
            if (parent && getAdditivity()) {
                # Forward the event upstream if additivity is turned on
                parent.logIntern(level, message, args, location, check_throwable, time_stamp);
            }
        }
    }

    private:internal logIntern(LoggerLevel level, string message, *list<auto> args, *hash<CallStackInfo> location,
            *hash<ExceptionInfo> throwable, date time_stamp) {
        if (isEnabledFor(level)) {
            callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), time_stamp, throwable));
        }
        {
            AutoReadLock awl(lock);
            if (parent && getAdditivity()) {
                # Forward the event upstream if additivity is turned on
                parent.logIntern(level, message, args, location, throwable, time_stamp);
            }
        }
    }

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public log(LoggerLevel level, string message, ...) {
        logIntern(level, message, argv, getLocation(), True);
    }

    #! Logs a message using the provided logging level
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public log(int level, string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::getLevel(level), message, argv, getLocation(), True);
    }

    #! Logs a message using the provided logging level
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public log(string level, string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::getLevel(level), message, argv, getLocation(), True);
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    public logArgs(Qore::Logger::LoggerLevel level, string message, *softlist<auto> args) {
        logIntern(level, message, args, getLocation(), True);
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /**
        @param level the logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    public logArgs(int level, string message, *softlist<auto> args) {
        logIntern(Qore::Logger::LoggerLevel::getLevel(level), message, args, getLocation(), True);
    }

    #! Logs a message using the provided logging level and a single argument for any format string arguments.
    /**
        @param level The logging level.
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
        @param args any format string arguments to the log message
    */
    public logArgs(string level, string message, *softlist<auto> args) {
        logIntern(Qore::Logger::LoggerLevel::getLevel(level), message, args, getLocation(), True);
    }

    #! Logs an already prepared logging event object.
    /**
        @param event the event to log
    */
    public logEvent(LoggerEvent event) {
        if (isEnabledFor(event.getLevel())) {
            callAppenders(event);
        }

        {
            AutoReadLock awl(lock);
            # Forward the event upstream if additivity is turned on
            if (parent && getAdditivity()) {
                parent.logEvent(event);
            }
        }
    }

    #! Logs a message object with the TRACE level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public trace(string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::getLevelTrace(), message, argv, getLocation(), True);
    }

    #! Logs a message object with the DEBUG level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public debug(string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::getLevelDebug(), message, argv, getLocation(), True);
    }

    #! Logs a message object with the INFO level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public info(string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::LevelInfo, message, argv, getLocation(), True);
    }

    #! Logs a message object with the WARN level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public warn(string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::LevelWarn, message, argv, getLocation(), True);
    }

    #! Logs a message object with the ERROR level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public error(string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::LevelError, message, argv, getLocation(), True);
    }

    #! Logs a message object with the FATAL level.
    /**
        @see @ref log()
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public fatal(string message, ...) {
        logIntern(Qore::Logger::LoggerLevel::LevelFatal, message, argv, getLocation(), True);
    }

    #! Performs logging of assertions
    /**
        If the \a assertion parameter is @ref False, then the message is logged
        using the ERROR level.

        @see @ref log()

        @param assertion the boolean assertion value
        @param message a string to log used as a format string for @ref Qore::vsprintf() "vsprintf()". Optional arguments are passed to
        the @ref Qore::Logger::LoggerEvent object. If the last parameter is an @ref Qore::ExceptionInfo "ExceptionInfo" typed hash,
        then it is considered "throwable" information.
    */
    public assertLog(bool assertion, string message, ...) {
        if(!assertion) {
            logIntern(Qore::Logger::LoggerLevel::LevelError, message, argv, getLocation(), True);
        }
    }

    #! Logs the variable name and value using TRACE level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    public traceVar(string var_name, auto value) {
        logIntern(Qore::Logger::LoggerLevel::getLevelTrace(), sprintf("%s: %%y", var_name), (value, ), getLocation(), False);
    }

    #! Logs the variable name and value using DEBUG level
    /**
        @see @ref log()

        @param var_name the variable name
        @param value the value of the variable
    */
    public debugVar(string var_name, auto value) {
        logIntern(Qore::Logger::LoggerLevel::getLevelDebug(), sprintf("%s: %%y", var_name), (value, ), getLocation(), False);
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter.
    /**
        @param level the log level to check
    */
    public bool isEnabledFor(LoggerLevel level) {
        return level.isGreaterOrEqual(getLevel());
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter.
    /**
        @param level the log level to check
    */
    public bool isEnabledFor(int level) {
        return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
    }

    #! Checks whether this Logger is enabled for a given Level passed as parameter.
    /**
        @param level the log level to check
    */
    public bool isEnabledFor(string level) {
        return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
    }

    #! Checks whether this Logger is enabled for the TRACE Level.
    public bool isTraceEnabled() {
        return isEnabledFor(Qore::Logger::LoggerLevel::getLevelTrace());
    }

    #! Checks whether this Logger is enabled for the DEBUG Level.
    public bool isDebugEnabled() {
        return isEnabledFor(Qore::Logger::LoggerLevel::getLevelDebug());
    }

    #! Checks whether this Logger is enabled for the INFO Level.
    public bool isInfoEnabled() {
        return isEnabledFor(Qore::Logger::LoggerLevel::LevelInfo);
    }

    #! Checks whether this Logger is enabled for the WARN Level.
    public bool isWarnEnabled() {
        return isEnabledFor(Qore::Logger::LoggerLevel::LevelWarn);
    }

    #! Checks whether this Logger is enabled for the ERROR Level.
    public bool isErrorEnabled() {
        return isEnabledFor(Qore::Logger::LoggerLevel::LevelError);
    }

    #! Checks whether this Logger is enabled for the FATAL Level.
    public bool isFatalEnabled() {
        return isEnabledFor(Qore::Logger::LoggerLevel::LevelFatal);
    }
}

#! Implements the root class for loggers; does not allow a parent logger to be set
public class LoggerRoot inherits Logger {
    # Creates the object
    /**
        @param level initial log level
    */
    constructor(LoggerLevel level = LoggerLevel::getLevelAll()): Logger('') {
        setLevel(level);
    }

    # Creates the object
    /**
        @param level initial log level
    */
    constructor(int level): Logger('') {
        setLevel(level);
    }

    # Creates the object
    /**
        @param level initial log level
    */
    constructor(string level): Logger('') {
        setLevel(level);
    }

    #! Overrides the level setter to prevent setting the root logger's level to @ref nothing (an exception is thrown in this case).
    /**
        The root logger must always have a level.

        @param value the level to set
        @throw LOGGER-ERROR if level is @ref nothing
    */
    public setLevel(*LoggerLevel value) {
        if (!exists value) {
            throw "LOGGER-ERROR", "Cannot set null level for root";
        }
        Logger::setLevel(value);
    }

    #! Overrides value setter as the root logger cannot have a parent; this method always throws an exception if the argument is a value
    /**
        @throw LOGGER-ERROR if parent exists
    */
    public setParent(*Logger value) {
        if (exists value) {
            throw "LOGGER-ERROR", "Cannot set parent for root";
        }
    }
}

#! Appender for logging to the console
/** Useful for tests and development, for example
*/
public class StdoutAppender inherits LoggerAppenderWithLayout {
    constructor() : LoggerAppenderWithLayout("stdout",
            new LoggerLayoutPattern("%d{YYYY-MM-DD HH:mm:SS.xx} T%t [%p]: %m%n")) {
        open();
    }

    processEventImpl(int type, auto params) {
        switch (type) {
            case EVENT_LOG:
                print(params);
                break;
        }
    }
}
}
