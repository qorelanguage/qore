# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Logger.qm Logger library

/*  Logger.qm Copyright 2013 - 2018 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.9

%require-types
%enable-all-warnings
%new-style
%no-debugging

%requires Util

module Logger {
    version = "0.1";
    desc = "user module implementing Log4q logger library";
    author = "Tomas Mandys <tomas.mandys@qore.org>";
    url = "http://qore.org";
    license = "MIT";
    init = sub() {
        LoggerLevel::init();
    };
}

/** @mainpage Logger Module

    @tableofcontents

    @section loggerintro Introduction to the Logger Module

    Logger module, which may be alternatively also called <b>Log4q</b>, adopted main design from well known
    <a href="https://logging.apache.org/log4j/2.x">log4j</a> library.
    So it implements main class @ref Logger::Logger "Logger" and @ref Logger::LoggerAppender "LoggerAppender",
    @ref Logger::LoggerFilter "LoggerFilter", @ref Logger::LoggerLayout "LoggerLayout" abstract base classes
    where their descendants will implement real functionality.

    @subsection logger_scenarior Scenarios

    @par One thread

    The user code will log to @ref Logger and the logging is performed to appender in sync way.

    Example:
    @code{.py}
    Logger l("mylogger", LoggerLevel::getLevelInfo());
    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    l.addAppender(laf);
    laf.open();
    ....
    l.info("hello world");
    l.error("world is not perfect");
    @endcode

    @par Multiple threads

    The user code will log in own threads, the events are pushed to a @ref Logger::LoggerAppenderQueue "LoggerAppenderQueue" object. The processing
    is done in dedicated thread when the events are passed to appenders. The the user code logging
    command is unblocking as it terminates immediately when the event is pushed in the queue.

    Example:
    @code{.py}
    our Logger l("mylogger", LoggerLevel::getLevelInfo());

    sub run() {
        while (!done) {
            ...
            l.info("hello world");
            l.error("world is not perfect");
            ...
        }
    }

    LoggerAppenderFile laf("myappender", new LoggerLayoutPattern(), "/var/run/log/mylog.log");
    laf.setQueue(new LoggerAppenderQueue());
    l.addAppender(laf);
    laf.open();

    for (int i=0; i<10; i++) {
        background run();
    }

    while (True) {
        laf.getQueue().process();
    }
    @endcode

    @par Application server running a few programs

    The appserver provides logger API for sandboxed programs. The appserver
    is responsible for <b>Log4q</b> configuration, i.e. prepares loggers, appenders, filters. etc.
    according a configuration and provides @ref Logger instance to @ref Qore::Program "Program" running a user code.
    The user will log to this instance, the logging events are processed by the appserver in dedidated thread
    which get event from queue and passes it to appenders. The more loggers may be configured in a parent/child hierarchy
    that more event levels are logged to logger assigned to sandbox and just critical errors to global appserver logger.

    Example:
    @code{.py}
    LoggerAppenderQueue laq();
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);

    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello world");
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    while (True) {
        laq.process(0);
    }
    @endcode

    @par Application server running plenty of programs

    The same as previous example but to avoid bottle neck then appserver processing thread get the event from
    queue and passes it to the appender in another worker thread via submittig to the @ref Qore::Thread::ThreadPool "ThreadPool". So events
    targeted to particular thread may by processed in different threads but in serial way.

    Example:
    @code{.py}
    ThreadPool tp();
    LoggerAppenderQueueThreadPool laq(tp, 5);
    LoggerRoot lr("ERROR");
    LoggerAppenderFile lar("", new LoggerLayoutPattern(), "/var/run/log/myappserver.log");
    lar.setQueue(laq);
    lar.open();
    lr.addAppender(lar);
    code processing() = sub () {
        while (True) {
            laq.process(0);
        }
    }
    # may run in extra thread
    background processing();
    foreach string pn in ( .... ) {
        Logger l(pn);
        LoggerAppenderFile la(pn, new LoggerLayoutPattern(), "/var/run/log/"+pn+".log");
        la.setQueue(laq);
        la.open();
        l.setParent(lr);
        l.setAdditivity(True);
        l.addAppender(la);
        l.setLevel("DEBUG");
        Program p(PO_NEW_STYLE);
        p.loadModule("Logger");
        p.parse('
            our Logger logger;  # logging API for Program sandbox
            int sub main(string pn) {
                logger.log("INFO", "hello world");
                ...
                return 0;
            }
        ', pn, WARN_DEFAULT);
        p.setGlobalVarValue("logger", l);
        ...
        background p.callFunction("main", pn);
    }
    # wait till finished
    @endcode

    @subsection logger_v0_1 v0.1
    - the initial version of the Logger module
*/

#! the Logger namespace contains all the definitions in the Logger module
public namespace Logger {

    #! Defines the minimum set of levels recognized by the system.
    /**
        The set of built-in levels includes \c TRACE, \c DEBUG, \c INFO, \c WARN, \c ERROR and \c FATAL. Log4q also supports
        custom log levels where the \c LoggerLevel class may be subclassed to define a larger level set.

        Usage of a built-in \c LoggerLevel instantiates corresponding object which is cached for each level.
    */
    public class LoggerLevel {
        public {
            #! built-in logger levels
            const OFF = MAXINT;
            const FATAL = 50000;
            const ERROR = 40000;
            const WARN = 30000;
            const INFO = 20000;
            const DEBUG = 10000;
            const TRACE = 5000;
            const ALL = MININT;
        }

        private {
            #! Integer level value.
            int m_level;

            #! String representation of the level.
            string m_levelStr;

            #! Contains a list of instantiated levels
            static hash<string, LoggerLevel> m_levelMap;

            #! String to int hash
            static hash<string, int> levelStr2level = (
                'ALL':   ALL,
                'TRACE': TRACE,
                'DEBUG': DEBUG,
                'INFO':  INFO,
                'WARN':  WARN,
                'ERROR': ERROR,
                'FATAL': FATAL,
                'OFF':   OFF,
            );

            #! Int to string hash
            static hash<string, string> level2levelStr;
        }

        /**
            Creates new object

            @param level integer value
            @param levelStr string representation
        */
        constructor(int level, string levelStr) {
            m_level = level;
            m_levelStr = levelStr;
        }

        #! static member initialization
        static public init() {
            map level2levelStr{levelStr2level{$1}} = $1, keys levelStr2level;
        }

        #! get level value
        public int getValue() {
            return m_level;
        }

        #! get level string
        public string getStr() {
            return m_levelStr;
        }

        #! compare logger levels
        /**
            @param other
            @return True if level is greater or equal to other level
        */
        public bool isGreaterOrEqual(LoggerLevel other) {
            return m_level >= other.getValue();
        }

        #! Compares two logger levels
        /**
            @param other
        */
        public bool isEqual(LoggerLevel other) {
            return m_level == other.getValue();
        }

        #! Returns an OFF Level
        public static LoggerLevel getLevelOff() {
            return LoggerLevel::getLevel(OFF);
        }

        #! Returns an FATAL Level
        public static LoggerLevel getLevelFatal() {
            return LoggerLevel::getLevel(FATAL);
        }

        #! Returns an ERROR Level
        public static LoggerLevel getLevelError() {
            return LoggerLevel::getLevel(ERROR);
        }

        #! Returns an WARN Level
        public static LoggerLevel getLevelWarn() {
            return LoggerLevel::getLevel(WARN);
        }

        #! Returns an INFO Level
        public static LoggerLevel getLevelInfo() {
            return LoggerLevel::getLevel(INFO);
        }

        #! Returns an DEBUG Level
        public static LoggerLevel getLevelDebug() {
            return LoggerLevel::getLevel(DEBUG);
        }

        #! Returns an TRACE Level
        public static LoggerLevel getLevelTrace() {
            return LoggerLevel::getLevel(TRACE);
        }

        #! Returns an ALL Level
        public static LoggerLevel getLevelAll() {
            return LoggerLevel::getLevel(ALL);
        }

        #! Converts the input argument to a level
        /**
            @param level
            @param defaultLevel value to return if conversion is not possible.
            @throw LOGGER-ERROR if defaultLevel is nothing and level not found
        */
        public static LoggerLevel getLevel(int level, *LoggerLevel defaultLevel = NOTHING) {
            if (exists level2levelStr{level}) {
                if (!exists m_levelMap{level}) {
                    m_levelMap{level} = new LoggerLevel(level, level2levelStr{level});
                }
                return m_levelMap{level};
            } else {
                if (!exists defaultLevel) {
                    throw "LOGGER-ERROR", "Cannot get valid Level";
                }
                return defaultLevel;
            }
        }

        #! Converts the input argument to a level.
        /**
            @param levelStr
            @param defaultLevel value to return if conversion is not possible.
            @throw LOGGER-ERROR if defaultLevel is nothing and levelStr not found
        */
        public static LoggerLevel getLevel(string levelStr, *LoggerLevel defaultLevel = NOTHING) {
            levelStr = toupper(levelStr);
            if (exists levelStr2level{levelStr}) {
                int level = levelStr2level{levelStr};
                if (!exists m_levelMap{level}) {
                    m_levelMap{level} = new LoggerLevel(level, levelStr);
                }
                return m_levelMap{level};
            } else {
                if (!exists defaultLevel) {
                    throw "LOGGER-ERROR", "Cannot get valid Level";
                }
                return defaultLevel;
            }
        }
    }

    #! Implement event to be logged
    /**
        The event data consist of format string and parameters. The output string is rendeded once when
        logging decision to target is made. Callable parameters are evaluated at this moment as well.
    */
    public class LoggerEvent {
        private {
            #! origin stamp to calculate relative time
            static date m_startTime = now_us();

            #! Fully Qualified Class Name of the calling category class.
            string m_fqcn;

            #! Logger reference
            *Logger m_logger;

            #! The category (logger) name.
            string m_categoryName;

            #! Level of the logging event.
            LoggerLevel m_level;

            #! The application supplied message of logging event (not rendered)
            string m_message;

            #! arguments to be rendered
            *list m_args;

            #! The application supplied message rendered through the rendering mechanism.
            *string m_renderedMessage;

            #! related thread id
            int m_threadId;

            #! event time stamp
            date m_timeStamp;

            #! location information where the logging was performed.
            *hash<CallStackInfo> m_locationInfo;

            #! internal representation of throwable
            *hash<ExceptionInfo> m_throwableInfo;

            #! unique id
            int m_uniqueId;

            #! unique id generator
            static Sequence m_sequence(1);

        }
        #! Instantiate a LoggingEvent from the supplied parameters.
        /**
            @param logger The category becomes logger name and fqcn logger class name
            @param level The event level
            @param message The payload as format for @ref sprintf()
            @param args The arguments for formatting
            @param locationInfo code location related to logging event
            @param threadId thread related to the event, Default: @ref gettid()
            @param timeStamp logging event timestamp. Default value is @ref now_us
            @param throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with logging event
        */
        constructor(Logger logger, LoggerLevel level, string message, *list args, *hash<CallStackInfo> locationInfo = NOTHING,
                    int threadId = gettid(), date timeStamp = now_us(), *hash<ExceptionInfo> throwable = NOTHING) {
            m_fqcn = get_class_name(logger);
            m_logger = logger;
            m_categoryName = logger.getName();
            m_level = level;
            m_message = message;
            m_args = args;
            m_locationInfo = locationInfo;
            m_threadId = threadId;
            m_timeStamp = timeStamp;
            if (throwable) {
                m_throwableInfo = throwable;
            }
        }

        #! Instantiate a LoggingEvent from the supplied parameters.
        /**
            @param fqcn name of the caller class.
            @param category The event category.
            @param level The event level
            @param message The payload as format for @ref sprintf()
            @param args The arguments for formatting
            @param locationInfo code location related to logging event
            @param threadId thread related to the event, Default: @ref gettid()
            @param timeStamp logging event timestamp. Default value is @ref now_us
            @param throwable The throwable @ref Qore::ExceptionInfo "ExceptionInfo" associated with logging event
        */
        constructor(string fqcn, softstring category, LoggerLevel level, string message, *list args, *hash<CallStackInfo> locationInfo = NOTHING,
                    int threadId = gettid(), date timeStamp = now_us(), *hash<ExceptionInfo> throwable = NOTHING) {
            m_fqcn = fqcn;
            m_categoryName = category;
            m_level = level;
            m_message = message;
            m_args = args;
            m_locationInfo = locationInfo;
            m_threadId = threadId;
            m_timeStamp = timeStamp;
            if (throwable) {
                m_throwableInfo = throwable;
            }
        }

        #! Returns the full qualified classname
        public string getFullQualifiedClassname() {
            return m_fqcn;
        }

        #! get the location information for this logging event
        public *hash<CallStackInfo> getLocationInfo() {
            return m_locationInfo;
        }

        #! Return the level of this event
        public LoggerLevel getLevel() {
            return m_level;
        }

        #! Returns the logger which created the event
        public *Logger getLogger() {
            return m_logger;
        }

        #! Returns the thread id which is related to event
        public int getThreadId() {
            return m_threadId;
        }

        #! Returns the category name
        public string getCategoryName() {
            return m_categoryName;
        }

        #! Returns the string message for the logging event
        /**
            Potential callable references are evaluated.
            Next the message is rendered using vprintf() and the result is cached, so the message is
            is rendeded only once.

            @return rendered message
        */
        public string getMessage() {
            if (!exists m_renderedMessage) {
                # evaluate callp which may be used to get time consuming stuff
                # i.e. they are evaluated only when logging is performed
                *any prevCall;
                list args2 = ();
                foreach any arg in (m_args) {
                    if (exists prevCall) {
                        bool isParam = False;
                        isParam = arg.typeCode() == NT_LIST;
                        try {
                            push args2, call_function_args(prevCall, arg);
                        } catch (hash<ExceptionInfo> ex) {
                            push args2, ex;
                        }
                        delete prevCall;
                        if (isParam) {
                            continue;
                        }
                    }
                    if (arg.callp()) {
                        prevCall = arg;
                    } else {
                        push args2, arg;
                    }
                }
                if (prevCall) {
                    try {
                        push args2, prevCall();
                    } catch (hash<ExceptionInfo> ex) {
                        push args2, ex;
                    }
                }
                # message is considered as printf() format so we process it this way.
                m_renderedMessage = vsprintf(m_message, args2);
            }
            return m_renderedMessage;
        }

        #! Returns the time when the application/logger started
        public static date getStartTime() {
            return LoggerEvent::m_startTime;
        }

        #! Set origin for relative time
        public static setStartTime(date time) {
            LoggerEvent::m_startTime = time;
        }

        #! Get event timestamp
        public date getTimeStamp() {
            return m_timeStamp;
        }

        #! Get relative timestamp
        /**
            Returns the time in seconds passed from the beginning of execution to
            the time when the event was constructed.

            @see @ref getStartTime()
        */
        public date getRelativeTime() {
            return m_timeStamp - LoggerEvent::m_startTime;
        }

        #! get throwable info
        public *hash<ExceptionInfo> getThrowableInfo() {
            return m_throwableInfo;
        }

        #! generates globally unique integer identifier and associates it to the event
        public int getUniqueId() {
            if (!exists m_uniqueId) {
                m_uniqueId = m_sequence.next();
            }
            return m_uniqueId;
        }

    }

    #! Queue serializing async appender events
    /**
        All async events may be processed by one worker thread dedicated to
        one or more appenders so the thread posting logging event remains unblocked.
    */
    public class LoggerAppenderQueue {
        private:internal {
            Queue m_queue();
        }
        #! add appender event
        /**
            @param appender
            @param type see \c EVENT_xxx constants
            @param params data prepared by @ref LoggerAppender::serializeImpl()
            @return True if event succesfully added to queue
        */
        public bool push(LoggerAppender appender, int type, any params) {
            try {
                m_queue.push(("appender": appender, "type": type, "params": params), -1);
            } catch (hash<ExceptionInfo> ex) {
                return False;
            }
            return True;
        }
        #! process queued events
        /**
            the method should be called typically in dedicated thread

            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A negative timeout value causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a value that converts to integer 0 is passed as the argument,
                then the call blocks until data is available on the queue. Default value is -1.
        */
        public process(timeout ms = -1) {
            while (True) {
                *hash rec = getEvent(ms);
                if (!rec) {
                    break;
                }
                rec.appender.processEventImpl(rec.type, rec.params);
            }
        }

        #! get current number of event waiting in queue
        public int size() {
            return m_queue.size();
        }

        #! get next event from queue
        /**
            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A negative timeout value causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a value that converts to integer 0 is passed as the argument,
                then the call blocks until data is available on the queue.
        */
        /*private:internal*/ *hash getEvent(timeout ms) {
            if (m_queue.size() > 0 || ms >= 0) {
                try {
                    return m_queue.get(ms);
                } catch (hash<ExceptionInfo> ex) {
                    switch (ex.err) {
                        case "QUEUE-TIMEOUT":
                            break;
                        default:
                            rethrow;
                    }
                }
            }
            return NOTHING;
        }
    }

    #! Queue processing async appender events in more threads
    /**
        Async events are removed from queue in one thread which balances processing
        in more worker threads via @ref Qore::Thread::ThreadPool "ThreadPool". The class groups events by appender
        so the processing of event related to particular appender is processed in serial
        way, i.e. at moment always only in one thread. It is compatible with @ref Qore::OutputStream
        implementation without multi-thread support.
    */
    public class LoggerAppenderQueueThreadPool inherits LoggerAppenderQueue {
        private {
            #! worker thread pool
            ThreadPool m_tp;
            #! number of running worker threads
            Counter m_running(0);
            #! max.number of worker threads
            int m_maxThreads;
            #! events removed from queue but not passed to worker thread
            hash m_pending;
            #! events paseed to worker thread
            hash m_processing;
            #! queue of processed events in worker threads
            Queue m_finished();
            #! internal unique counter
            Sequence m_lastId(0);
            #! to protect process()
            Mutex m_lock();
        }
        #! worker thread code
        /**
            @param id unique identifier generated by internal @ref Qore::Thread::Sequence "Sequence"
            @param appender @ref LoggerAppender instance
            @param events list of events
        */
        private worker(string id, LoggerAppender appender, list events) {
            try {
                foreach hash e in (events) {
                    appender.processEventImpl(e.type, e.params);
                }
            } catch (hash<ExceptionInfo> ex) {
            }
            m_finished.push(id);
        }
        #! creates object
        /**
            @param tp worker @ref Qore::Thread::ThreadPool "ThreadPool" where loggging events are submitted
            @param maxThreads max.number of worker threads, default value is \c -1, i.e. unlimited
        */
        constructor (ThreadPool tp, int maxThreads = -1) {
            m_tp = tp;
            m_maxThreads = maxThreads;
        }

        #! returns assigned @ref Qore::Thread::ThreadPool "ThreadPool"
        public ThreadPool getThreadPool() {
            return m_tp;
        }

        #! process queue events
        /**
            Group logging events by appender and submit then to a a worker thread taken from thread pool

            @param ms a timeout value to wait for data to become available on the queue;
                integers are interpreted as milliseconds; relative date/time values are interpreted
                literally with a maximum resolution of milliseconds. A negative timeout value causes
                the call to time out immediately if the call would otherwise block.
                If a positive timeout argument is passed, and no data is available in the timeout period
                then waits up to timeout value, If a value that converts to integer 0 is passed as the argument,
                then the call blocks until data is available on the queue. Default value is \c -1.
        */
        public process(timeout ms = -1) {
            # normally function is called from one thread and it is not time critical
            AutoLock al(m_lock);
            # get new events and match with pending
            hash lastMatch;
            while (True) {
                *hash e = getEvent(ms);
                if (!e) {
                    break;
                }
                if (lastMatch.appender != e.appender) {
                    bool found = False;
                    foreach string id in (keys m_pending) {
                        if (m_pending{id}.appender == e.appender) {
                            lastMatch.id = id;
                            lastMatch.appender = e.appender;
                            found = True;
                            break;
                        }
                    }
                    if (!found) {
                        # look into processing
                        foreach string id in (keys m_processing) {
                            if (m_processing{id}.appender == e.appender) {
                                lastMatch.id = id;
                                found = True;
                                break;
                            }
                        }
                        if (!found) {
                            # add new entry
                            lastMatch.id = string(m_lastId.next());
                        }
                        lastMatch.appender = e.appender;
                        m_pending{lastMatch.id} = (
                            "id": lastMatch.id,  # BUG: see ThreadPool::submit(id, ...) call
                            "appender": e.appender,
                            "events": (),
                        );
                    }
                }
                push m_pending{lastMatch.id}.events, e.('type', 'params');
            }

            # remove finished
            while (m_finished.size() > 0) {
                string id = m_finished.get(-1);
                remove m_processing{id};
            }
            # now try push pending
            foreach string id in (keys m_pending) {
                # remove finished
                #while (m_finished.size() > 0) {
                #    remove m_processing{m_finished.get(-1)};
                #}
                # is available a free worker thread ?
                if (m_maxThreads >= 0 && m_processing.size() >= m_maxThreads) {
                    return;
                }
                if (exists m_processing{id}) {
                    # we cannot trigger new thread if is being processed
                    continue;
                }
                hash e = remove m_pending{id};
                m_processing{id} = e;
                # BUG: when passing "id" then no copy is passed to submit pool queue and worker may get wrong value
                # so we must pass real constant enough value
                m_tp.submit(sub() {call_function(\worker(), e.id, e.appender, e.events); } );
            }
        }

        #! get number of pending events
        public int size() {
            AutoLock al(m_lock);
            return LoggerAppenderQueue::size() + m_processing.size() + m_pending.size();
        }
    }

    #! Implements passing @ref LoggerEvent to target destination
    /**
        Descendent will implement e.g. logging to file, to stderr, to database etc.
        \c LoggerAppender supports sync and async logging.

        The ability to selectively enable or disable logging requests based on level in @ref Logger is
        extended in appender via @ref LoggerFilter, i.e. filtering on any criteria.
    */
    public class LoggerAppender {
        public {
            #! open event
            const EVENT_OPEN = 1;
            #! logging event
            const EVENT_LOG = 2;
            #! close event
            const EVENT_CLOSE = 3;
        }
        private {
            #! The lock to protect object manipulation
            RWLock m_lock();

            #! inactive appender won't accept any logging request
            bool m_active = False;

            #! filter chain
            list<LoggerFilter> m_filters;

            #! Appender name
            string m_name;

            #! async queue
            *LoggerAppenderQueue m_queue;
        }

        #! Creates object
        /**
            @param name appender name
        */
        constructor(string name = "") {
            m_name = name;
        }

        destructor() {
            #close();  # TODO: cannot call as the target object may be already destroyed
        }

        #! get appender name
        public string getName() {
            return m_name;
        }

        #! Set appender queue.
        /**
            Data are passed to target device synchronously
            unless queue is assigned. In this case data are queued and
            dedicated process will process it in asynchronously

            @param queue
        */
        public setQueue(*LoggerAppenderQueue queue) {
            if (m_active) {
                throw "LOGGER-ERROR", "Appender is opened";
            }
            m_queue = queue;
        }

        #! Get async queue or nothing when events are processed in sync way
        public *LoggerAppenderQueue getQueue() {
            return m_queue;
        }

        #! Open logging resources
        /**
            The appender must be opened (active) to accept any logging events
        */
        public open() {
            if (!m_active) {
                pushEvent(EVENT_OPEN, NOTHING);
                m_active = True;
            }
        }

        #! Releases any resources allocated by the appender and close it
        /**
        */
        public close() {
            if (m_active) {
                pushEvent(EVENT_CLOSE, NOTHING);
                m_active = False;
            }
        }

        #! get active value, i.e. True if appender is opened
        public bool isActive() {
            return m_active;
        }

        #! adds a filter to chain
        /**
            @param filter add a new filter
            @param top if True then add filter at first position, if False (default) to the end of chain
            @throw "LOGGER-ERROR" exception if filter is already in list
        */
        public addFilter(LoggerFilter filter, bool top = False) {
            AutoWriteLock awl(m_lock);
            if (!m_filters) {
                m_filters = (filter, );
            } else {
                if (m_filters.contains(filter)) {
                    throw "LOGGER-ERROR", "Filter already exists in list";
                }
                if (top) {
                    unshift m_filters, filter;
                } else {
                    push m_filters, filter;
                }
            }
        }

        #! removes filter from the filter chain.
        /**
            @param filter
        */
        public removeFilter(LoggerFilter filter) {
            AutoWriteLock awl(m_lock);
            foreach LoggerFilter f in (m_filters) {
                if (f == filter) {
                    splice m_filters, $#, 1;
                    break;
                }
            }
        }

        #! Clears the filter chain by removing all the filters in it
        public removeAllFilters() {
            AutoWriteLock awl(m_lock);
            splice m_filters, 0;
        }

        #! returns filter chain
        /**
            Note that appender filter chain may be modified as internal lock is released when copy of list is returned
        */
        public list<LoggerFilter> getFilters() {
            AutoReadLock awl(m_lock);
            return m_filters ?? ();
        }

        #! serializes event to put in the queue or write to target device
        /**
            Appender implementaion can define any serialize format. The data are passed
            to @ref processEventImpl() method as \c params argument when \c type is \c EVENT_LOG.
        */
        abstract private:internal any serializeImpl(LoggerEvent event);

        #! push event in queue or call @ref processEventImpl() in case of sync
        /**
            @param type
            @param params
        */
        /*private:internal*/ bool pushEvent(int type, any params) {
            if (exists m_queue) {
                return m_queue.push(self, type, params);
            } else {
                processEventImpl(type, params);
                return True;
            }
        }

        #! post event to output queue
        /**
            Invokes filters and when event is accepted then is posted to queue in case of
            asynchronous process or is immediately logged in case of synchronous process.
            to the @ref processEventImpl() method.

            @see @ref processEventImpl()

            @param event
            @return True if event has been posted
        */
        public bool post(LoggerEvent event) {
            if(!m_active) {
                return False;
            }
            {
                AutoReadLock arl(m_lock);
                foreach LoggerFilter filter in (m_filters) {
                    int d = filter.eval(event);
                    if (d == LoggerFilter::DENY) {
                        return False;
                    } else if (d == LoggerFilter::ACCEPT) {
                        break;
                    }
                }
            }
            any serialized = serializeImpl(event);
            if (!exists serialized) {
                return False;
            }
            return pushEvent(EVENT_LOG, serialized);
        }

        #! processes event to physical target
        /**
            must be implemented by successor class

            @see @ref serializeImpl()

            @param type see \c "EVENT_xxx" constants
            @param params
        */
        abstract public processEventImpl(int type, any params);

    }

    #! Appender which does nothing
    /**
        Any events posted to the appender are silently ignored
    */
    public class LoggerAppenderNull inherits LoggerAppender {
        constructor(string name = ""): LoggerAppender(name) {
        }

        /*private:internal*/ any serializeImpl(LoggerEvent event) {
            return NOTHING;
        }

        public processEventImpl(int type, any params) {
        }
    }

    #! Implements patern parsing and substitution
    /**
        The pattern defines fields which are substituted with real values

        The pattern format is:

        @code
        %[<modifiers>] <word> [{<option>}]
        modifiers := [0-9.-]*
        word := [a-zA-Z]+
        option := [^}]*
        @endcode

        To delimit word from next character use curly brackets, i.e. empty option, e.g. \c "%p{}archive"

        Following table covers various modifiers scenarios:

        | !Format modifier | !left justify | !minimum width | !maximum width | !comment |
        | %20c             | false         | 20             | none           | Left pad with spaces if the category name is less than 20 characters long |
        | %-20c            | true          | 20             | none           | Right pad with spaces if the category name is less than 20 characters long |
        | %.30c            | NA            | none           | 30             | Truncate from the beginning if the category name is longer than 30 characters |
        | %20.30c          | false         | 20             | 30             | Left pad with spaces if the category name is shorter than 20 characters. However, if the category name is longer than 30 characters, then truncate from the beginning |
        | %-20.30c         | true          | 20             | 30             | Right pad with spaces if the category name is shorter than 20 characters. However, if category name is longer than 30 characters, then truncate from the beginning |

    */
    public class LoggerPattern {
        public {
            #! format escape character
            const ESCAPE_CHAR = "%";
        }
        private {
            #! pattern
            string m_pattern;
            #! parsed pattern
            list m_parsedPattern;
        }
        #! creates object
        /**
            @param pattern
        */
        constructor(string pattern) {
            # parse pattern
            setPattern(pattern);
        }

        #! Set new pattern
        /**
            @param pattern
            @throw LOGGER-ERROR when pattern is invalid
        */
        public setPattern(string pattern) {
            string s = pattern;
            list pp = ();
            while (s != "") {
                int i = 0;
                do {
                    i = bindex(s, ESCAPE_CHAR, i);
                    if (i < 0) {
                        i = s.size();
                    } else {
                        if (i >= 0 && s[i+1] == ESCAPE_CHAR) {  # %%
                            splice s, i, 1;
                            i++;
                            continue;
                        }
                    }
                    break;
                } while (True);
                if (i >= s.size()) {
                    push pp, s;
                    s = "";
                } else {
                    if (i > 0) {
                        push pp, substr(s, 0, i);
                    }
                    splice s, 0, i+1;
                    # now the string is token
%ifdef _DUMMY_TO_PAIR_BRACES_IN_EDITOR
%endif
                    *list l = s =~ x/^([0-9.-]*)([a-zA-Z]+)({[^}]*})?/ ;  # x/^([0-9.-]*)([a-zA-Z]+)({[^}]*})/;
                    if (l.size() < 2) {
                        throw "LOGGER-ERROR", sprintf("Wrong pattern starting %%%s", s);
                    }
                    *list opt;
                    hash f;
                    if (l[0] != "") {
                        # opt = l[0] =~ x/^([-]?)([^.0-9]*)([.]?)([0-9]+)$/;   does not work in all cases
                        if (opt = (l[0] =~ x/^([-]?)([0-9]+)\.([0-9]+)$/) ) {
                            f.leftJustify = opt[0] == "-";
                            f.minWidth = int(opt[1]);
                            f.maxWidth = int(opt[2]);
                        } else if (opt = (l[0] =~ x/^([-]?)([0-9]+)$/) ) {
                            f.leftJustify = opt[0] == "-";
                            f.minWidth = int(opt[1]);
                        } else if (opt = (l[0] =~ x/^.([0-9]+)$/) ) {
                            f.maxWidth = int(opt[0]);
                        } else {
                            throw "LOGGER-ERROR", sprintf("Wrong pattern option starting %%%s", s);
                        }
                    }
                    f.key = l[1];
                    if (l.size() == 3) {
%ifdef _DUMMY_TO_PAIR_BRACES_IN_EDITOR
%endif
                        f.option = (l[2] =~ x/^{([^}]*)}$/)[0];
                    }
%ifdef _DUMMY_TO_PAIR_BRACES_IN_EDITOR
%endif
                    s =~ s/^[0-9.-]*[a-zA-Z]+({[^}]*})?//;
                    push pp, f;
                }
            }

            m_pattern = pattern;
            m_parsedPattern = pp;
        }

        #! returns current pattern
        public string getPattern() {
            return m_pattern;
        }

        #! get parsed pattern
        /** the function is just for internal purpose (e.g. for unit test), the programmer should never call it
        */
        public list getParsedPattern() {
            return m_parsedPattern ?? ();
        }

        #! Format event record with pattern
        /**
            @param data is passed to @ref resolveField()
        */
        public string format(auto data) {
            string res = "";
            foreach any a in (m_parsedPattern) {
                if (a.typeCode() == NT_STRING) {
                    res += a;
                } else {
                    string val = resolveField(data, a.key, a.option);
                    if (exists a.maxWidth) {
                        val = substr(val, 0, a.maxWidth);
                    }
                    if (exists a.minWidth && val.size() < a.minWidth) {
                        if (a.leftJustify) {
                            val += strmul(" ", a.minWidth - val.size());
                        } else {
                            val = strmul(" ", a.minWidth - val.size()) + val;
                        }
                    }
                    res += val;
                }
            }
            return res;
        }

        #! Resolves key value
        /**
            @param data
            @param key
            @param option
        */
        abstract /*private:internal*/ string resolveField(auto data, string key, *string option);

    }

    #! Abstract class to define interface for logger layout
    /**
        The event data (@ref LoggerEvent) are formatted before the record is passed to target.
    */
    public class LoggerLayout {
        #! Format event record
        abstract public string format(LoggerEvent event);
    }

    #! Implements formatting @ref LoggerEvent with a pattern
    /**
        The \c LoggerLayoutPattern lets the user specify the output format according to conversion patterns similar to the @ref sprintf() function.

        The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

        | !Conversion character | !Meaning |
        | c | Used to output the category of the logging event, i.e. logger name |
        | C | Used to output the class name of the caller issuing the logging request, i.e. logger class name |
        | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}" |
        | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
        | F | Used to output the file name where the logging request was issued |
        | l | Used to output location information of the caller which generated the logging event, i.e. \c "file:line [function()]" |
        | L | Used to output the line number from where the logging request was issued, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | m | Used to output the application supplied message associated with the logging event |
        | M | Used to output the method name where the logging request was issued |
        | n | Outputs the platform dependent line separator character or characters |
        | p | Used to output the priority of the logging event |
        | r | Used to output the number of milliseconds elapsed from the construction of the layout until the creation of the logging event, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | t | Used to output the thread id that generated the logging event, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | u | Used to output logging event unique id, option may specify @ref sprintf() format, e.g. \c "%.3d" |
        | x | Used to output exception string using @ref Util::get_exception_string() |
        | % | The literal percent sign. \c "%%" will print a \c "%" sign |


        For example, the \c LoggerLayoutPattern with the conversion pattern \c "%r [%t] %-5p %c - %m%n" will output something as:

        @code
            176 [23] INFO  MyLogger - New record created
        @endcode
    */
    public class LoggerLayoutPattern inherits LoggerLayout, public LoggerPattern {
        public {
            #! default layout pattern
            const DEFAULT_PATTERN = "%r [%t] %p %c - %m%n";
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYY-MM-DD HH:mm:SS.u";
        }

        #! creates object
        /**
            @param pattern
        */
        constructor(string pattern = DEFAULT_PATTERN): LoggerPattern(pattern) {
        }

        #! Get line delimiter used on current OS
        static public string getLineDelimiter() {
            switch (PlatformOS) {
            case "Windows":
                return "\r\n";
            case "Darwin":
                return "\r";
            default:
                return "\n";
            }
        }

        #! Format event record
        public string format(LoggerEvent event) {
            return LoggerPattern::format(event);
        }

        #! get value corresponding to particular key
        /**
            @param event (@ref LoggerEvent)
            @param key
            @param option
        */
        /*private:internal*/ string resolveField(auto event, string key, *string option) {
            if (!(event instanceof LoggerEvent)) {
                throw "LOGGER-ERROR", "Unsupported event type";
            }
            string res;
            switch (key) {
                case "c":
                    res = event.getCategoryName();
                    break;
                case "C":
                    res = event.getFullQualifiedClassname();
                    break;
                case "d":
                    if (option) {
                        res = format_date(option, event.getTimeStamp());
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, event.getTimeStamp());
                    }
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "F":
                    res = event.getLocationInfo().file;
                    break;
                case "l":
                    hash<CallStackInfo> csi = event.getLocationInfo();
                    res = sprintf("%s:%d [%s()]", csi.file, csi.line, csi.function);
                    break;
                case "L":
                    res = sprintf(option ?? "%d", event.getLocationInfo().line);
                    break;
                case "m":
                    res = event.getMessage();
                    break;
                case "M":
                    res = event.getLocationInfo().function;
                    break;
                case "n":
                    res = getLineDelimiter();
                    break;
                case "p":
                    res = event.getLevel().getStr();
                    break;
                case "r":
                    res = sprintf(option ?? "%d", get_duration_milliseconds(event.getTimeStamp() - LoggerEvent::getStartTime()));
                    break;
                case "t":
                    res = sprintf(option ?? "%d", event.getThreadId());
                    break;
                case "u":
                    res = sprintf(option ?? "%d", event.getUniqueId());
                    break;
                case "x":
                    if (event.getThrowableInfo()) {
                        res = get_exception_string(event.getThrowableInfo());
                    } else {
                        res = "";
                    }
                    break;
                default:
                    res = 'N/A';
                    #throw "LOGGER-ERROR", sprintf("Unknown pattern token %y", key);
            }
            return res;
        }
    }

    #! Implements appender with layout
    /**
        The Layout is responsible for formatting the @ref LoggerEvent according to the user's wishes,
        whereas an appender takes care of sending the formatted output to its destination.

        It is used typically for appender implementing logging to a file
    */
    public class LoggerAppenderWithLayout inherits LoggerAppender {
        private {
            #! assigned layout
            LoggerLayout m_layout;
        }

        #! creates object
        /**
            @param name
            @param layout
        */
        constructor(string name, LoggerLayout layout): LoggerAppender(name) {
            m_layout = layout;
        }

        #! Assigns the appender layout
        /**
        * @param layout
        */
        public setLayout(LoggerLayout layout) {
            m_layout = layout;
        }

        #! Returns the appender layout
        public LoggerLayout getLayout() {
            return m_layout;
        }

        #! Returns value formatted using layout pattern
        /**
            @param event
        */
        /*private:internal*/ any serializeImpl(LoggerEvent event) {
            return m_layout.format(event);
        }

    }

    #! Appender writting to output stream via @ref Qore::StreamWriter "StreamWriter"
    /**
        Qore streams are not designed as multi-threaded so writing to thread must be serialized and processed
        in a dedicated thread
    */
    public class LoggerAppenderStream inherits LoggerAppenderWithLayout {
        private {
            #! stream writer
            StreamWriter m_writer;
            #! closed flag
            bool m_closed = False;
            #! assign thread for stream
            bool m_assignThread;
        }

        #! create object
        /**
            @param name
            @param layout
            @param writer
        */
        constructor(string name, LoggerLayout layout, StreamWriter writer): LoggerAppenderWithLayout(name, layout) {
            m_writer = writer;
            m_assignThread = m_writer.getOutputStream().getThreadId() == -1;
        }

        #! get stream writer instance
        public StreamWriter getStreamWriter() {
            return m_writer;
        }

        #! return True if is assigning thread for stream
        public bool hasAssignThread() {
            return m_assignThread;
        }

        #! process event with output stream
        public processEventImpl(int type, any params) {
            if (type == EVENT_OPEN) {
                if (m_closed) {
                    # OutputStream does not provide open method
                    throw "LOGGER-ERROR", "Cannot reopen stream";
                }
            } else {
                if (m_assignThread) {
                    m_writer.getOutputStream().reassignThread();
                }
                switch (type) {
                    case EVENT_LOG:
                        m_writer.print(params);
                        break;
                    case EVENT_CLOSE:
                        m_writer.getOutputStream().close();
                        m_closed = True;
                        break;
                }
                on_exit if (m_assignThread) {
                    m_writer.getOutputStream().unassignThread();
                }
            }
        }
    }

    #! Appender writing to a file
    /**
        No multi-threading protection is implemented in class. @ref Qore::File "File" class is reused
    */
    public class LoggerAppenderFile inherits LoggerAppenderWithLayout {
        /*private:internal*/private:hierarchy {
            File m_file;
            string m_filename;
        }
        #! create object
        /**
            @param name
            @param layout
            @param filename
            @param encoding
        */
        constructor(string name, LoggerLayout layout, string filename, *string encoding): LoggerAppenderWithLayout(name, layout) {
            m_file = new File(encoding);
            m_filename = filename;
        }

        #! get file instance
        public File getFile() {
            return m_file;
        }

        #! get current filename
        public string getFileName() {
            return m_filename;
        }

        #! process event with file
        /**
            @param type
            @param params
        */
        public processEventImpl(int type, any params) {
            switch (type) {
                case EVENT_OPEN:
                    if (m_file.open(m_filename, O_APPEND | O_WRONLY) == -1) {
                        if (errno() == Qore::Err::ENOENT) {
                            # No such file or directory
                            m_file.open2(m_filename, O_CREAT | O_WRONLY);
                        } else {
                            throw "FILE-OPEN2-ERROR", sprintf("%s (arg: %d)", strerror(), errno());
                        }
                    }
                    break;
                case EVENT_CLOSE:
                    try {
                        m_file.close();
                    } catch (hash<ExceptionInfo> ex) {
                        if (ex.err != "ILLEGAL-EXPRESSION") {
                            # catch unclosable stdxxx errors, TODO: m_file.isTTY() does the same job ?
                            rethrow;
                        }
                    }
                    break;
                case EVENT_LOG:
                    m_file.print(params);
                    break;
            }
        }
    }

    #! Appender writing to a file with rotate support
    /**
        The events will be logged to a file till rotation occurs.
        At that moment the current file is closed, next file is created
        and logging continues to that file.
    */
    public class LoggerAppenderFileRotate inherits public LoggerAppenderFile, private LoggerPattern {
        public {
            #! rotate event
            const EVENT_ROTATE = 10;
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
        }
        private {
            hash m_patternData;
        }
        #! create object
        /**
            @param name
            @param layout
            @param pattern to evaluate file name
            @param count number of rotated files, if count is <=0 then no ratation is performed
            @param encoding

            The following table explains the characters used in @ref LoggerPattern and all other characters that you can use in your custom pattern:

            | !Conversion character | !Meaning |
            | i | Used to output the current file index from 0 to count-1. option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | n | Used to output the rotation count. Option may specify @ref sprintf() format, e.g. \c "%.3d" |
            | c | Used to output the appender name. |
            | C | Used to output the appender class name. |
            | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            For example, the rotate pattern \c "/var/run/log/%c.log.%i{%03d}" output to files
            \c "/var/run/log/MyLogger.log.000", \c "/var/run/log/MyLogger.log.001" etc.

        */
        constructor(string name, LoggerLayout layout, string pattern, int count, *string encoding): LoggerAppenderFile(name, layout, "", encoding), LoggerPattern(pattern) {
            # set a provisional filename, to be updated when file is opened
            m_patternData.timestamp = now_us();
            m_patternData.count = count;
            m_patternData.index = 0;
            m_filename = format(m_patternData);
        }

        #! resolve field for filename
        /**
            @param data
            @param key
            @param option
        */
        /*private:internal*/ string resolveField(auto data, string key, *string option) {
            string res;
            switch (key) {
                case "i":
                    res = sprintf(option ?? "%d", data.index);
                    break;
                case "n":
                    res = sprintf(option ?? "%d", data.count);
                    break;
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "d":
                    if (option) {
                        res = format_date(option, data.timestamp);
                    } else {
                        res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                    }
                    break;
                case "E":
                    res = ENV{option};
                    break;
                default:
                    res = "";
            }
            return res;
        }

        #! implements rotation
        /**
            @param type
            @param params
        */
        public processEventImpl(int type, any params) {
            switch (type) {
                case EVENT_OPEN:
                    # find newest file
                    m_patternData.timestamp = now_us();
                    int lastIdx = 0;
                    if (m_patternData.count > 0) {
                        date lastStamp;
                        hash pd = m_patternData;
                        for (int i=0; i < m_patternData.count; i++) {
                            pd.index = i;
                            string fn = format(pd);
                            *hash<StatInfo> si = hstat(fn);
                            if (si) {
                                if (!lastStamp || si.mtime > lastStamp) {
                                    lastStamp = si.mtime;
                                    lastIdx = i;
                                }
                            }
                        }
                    }
                    m_patternData.index = lastIdx;
                    m_filename = format(m_patternData);
                    LoggerAppenderFile::processEventImpl(type, params);
                    break;
                case EVENT_ROTATE:
                    if (m_patternData.count > 0) {
                        m_file.close();
                        m_patternData.index = (m_patternData.index + 1) % m_patternData.count;
                        m_patternData.timestamp = now_us();
                        m_filename = format(m_patternData);
                        m_file.open2(m_filename, O_CREAT | O_WRONLY);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! post rotate event
        /**
            current logging file will be closed and next opened. If the file exists then it is ovewritten

            @throw LOGGER-ERROR if rotation is disabled
        */
        public rotate() {
            if (isActive()) {
                if (m_patternData.count <= 0) {
                    throw "LOGGER-ERROR", "Rotation is disabled";
                }
                pushEvent(EVENT_ROTATE, NOTHING);
            }
        }
    }

    #! Appender writing to a file with archive support
    /**
        The events will be logged to a file till archive occurs.
        At that moment the current file is closed, moved to file with name evaluated in runtime
        from pattern, new file is created and logging continues to that file.
        The archive never overwrites any existing file.
    */
    public class LoggerAppenderFileArchive inherits public LoggerAppenderFile, private LoggerPattern {
        public {
            #! archive event
            const EVENT_ARCHIVE = 20;
            #! default date format
            const DEFAULT_DATE_FORMAT = "YYYYMMDDHHmmSS";
            #! default archive pattern
            const DEFAULT_ARCHIVE_PATTERN = "%p%f.%d";
        }
        #! create object
        /**
            @param name
            @param layout
            @param filename with pattern support
            @param archive pattern to evaluate archive filename
            @param encoding

            The following table explains the characters used in @ref LoggerPattern for both filename and archive parameter

            | !Conversion character | !Meaning |
            | s | Used to output the OS directory separator, i.e. "\" or "/" |
            | c | Used to output the appender name |
            | C | Used to output the appender class name |
            | E | Used to output the environment variable with name given by option, e.g. \c "%E{HOME}" |
            | % | The literal percent sign. \c "%%" will print a \c "%" sign |

            The following table explains the characters used in @ref LoggerPattern for archive parameter only

            | !Conversion character | !Meaning |
            | P | Used to output the current logging path with filename |
            | p | Used to output the current logging path |
            | f | Used to output the current logging filename |
            | d | Used to output the date of the logging event using @ref format_date. Option may specify date format, e.g. \c "%d{DD.MM.YYYY HH:mm:SS}", default value is \c "YYYYMMDDHHmmSS" |

            For example, the rotate pattern \c "%p/archive/%d/%f" archive logging file \c "/var/run/log/MyLogger.log" to file:
            \c "/var/run/log/archive/20180120102030/MyLogger.log".
        */
        constructor(string name, LoggerLayout layout, string filename, string archive = DEFAULT_ARCHIVE_PATTERN, *string encoding): LoggerAppenderFile(name, layout, filename, encoding), LoggerPattern(filename) {
            m_filename = format(NOTHING);  # no dynamic vars as timestamp
            setPattern(archive);
        }

        #! resolve pattern field
        /**
            @param data if nothing then related to logging filename otherwise for archive
            @param key
            @param option
        */
        /*private:internal*/ string resolveField(auto data, string key, *string option) {
            string res = "";
            switch (key) {
                case "c":
                    res = get_class_name(self);
                    break;
                case "C":
                    res = getName();
                    break;
                case "E":
                    res = ENV{option};
                    break;
                case "s":
                    res = DirSep;
                    break;
            }
            if (data) {  # archive pattern
                switch (key) {
                    case "d":
                        if (option) {
                            res = format_date(option, data.timestamp);
                        } else {
                            res = format_date(DEFAULT_DATE_FORMAT, data.timestamp);
                        }
                        break;
                    case "P":
                        res = data.filename;
                        break;
                    case "p": # path
                        res = dirname(data.filename);
                        if (res != DirSep) {
                            res += DirSep;
                        }
                        break;
                    case "f": # filename
                        res = basename(data.filename);
                        break;
                }
            }
            return res;
        }

        #! implements archiving
        /**
            @param type
            @param params
        */
        public processEventImpl(int type, any params) {
            switch (type) {
                case EVENT_ARCHIVE:
                    mkdir(dirname(params), 0777, True);
                    if (isActive()) {
                        m_file.close();
                        rename(m_filename, params);
                        LoggerAppenderFile::processEventImpl(EVENT_OPEN, NOTHING);
                    } else {
                        rename(m_filename, params);
                    }
                    break;
                default:
                    LoggerAppenderFile::processEventImpl(type, params);
            }
        }

        #! post archive event
        /**
            rename logging file and open new one
            @return archive file name

            @throw LOGGER-ERROR if target file name is not correct or target file already exists
        */
        public string archive() {
            string afn = getArchiveFileName();
            if (afn == "") {
                throw "LOGGER-ERROR", "Empty target filename";
            }
            if (normalize_dir(afn) == normalize_dir(m_filename)) {
                throw "LOGGER-ERROR", "Source and target path are equal";
            }
            if (is_dir(afn)) {
                throw "LOGGER-ERROR", "Target is directory";
            }
            if (is_file(afn)) {
                throw "LOGGER-ERROR", "Target file already exists";
            }
            pushEvent(EVENT_ARCHIVE, afn);
            return afn;
        }

        #! get archive filename
        /**
            The pattern may contain date fields so the result may differ when
            executed multiple times
        */
        public string getArchiveFileName() {
            hash h;
            h.timestamp = now_us();
            h.filename = m_filename;
            string res = format(h);
            return res;
        }
    }

    #! Dummy class
    /**
        TODO: Doxygen silently skips next LoggerFilter class without this dummy class with a non empty private {} section
    */
    /*private*/ class LoggerDummyBecauseOfDoxygenIssue {
        private  {
            any m_dummy;
        }
    }

    #! Implements general event filtering class
    /**
        Users should extend this class to implement customized logging
        event filtering. The filter consists of linear chain of
        particular filters evaluating if the event should be immediately accepted, rejected
        or passed to next filter.
    */
    public class LoggerFilter {
        public {
            #! The event will be processed
            const ACCEPT = 1;

            #! No decision could be made, further filtering should occur
            const NEUTRAL = 0;

            #! The event should not be processed
            const DENY = -1;
        }

        #! Do filtering logic and return decision
        /**
            The method should be overriden to implement real rule. Default result is @ref NEUTRAL

            @param event
        */
        public int eval(LoggerEvent event) {
            return NEUTRAL;
        }
    }

    #! Implement filter according event @ref LoggerLevel
    /**
        When @ref LoggerEvent::getLevel does not satisties filter condition then
        logging is rejected.

        Min and max.level defines range to be logged (if min <= max.level) or range which won't be logged (if max < min.level)
    */
    public class LoggerFilterLevel inherits LoggerFilter {
        private {
            #! min.level
            LoggerLevel m_minLevel;
            #! max.level
            LoggerLevel m_maxLevel;
        }
        #! creates object
        /**
            @param minLevel
            @param maxLevel
        */
        constructor(LoggerLevel minLevel = LoggerLevel::getLevelInfo(), LoggerLevel maxLevel = LoggerLevel::getLevelOff()) {
            setMinLevel(minLevel);
            setMaxLevel(maxLevel);
        }

        #! creates object
        /**
            @param minLevel
            @param maxLevel
        */
        constructor(int minLevel, int maxLevel = LoggerLevel::OFF) {
            setMinLevel(minLevel);
            setMaxLevel(maxLevel);
        }

        #! creates object
        /**
            @param minLevel
            @param maxLevel
        */
        constructor(string minLevel, string maxLevel = "OFF") {
            setMinLevel(minLevel);
            setMaxLevel(maxLevel);
        }

        #! set min.level
        /**
            @param minLevel
        */
        public setMinLevel(LoggerLevel minLevel) {
            m_minLevel = minLevel;
        }

        #! set min.level
        /**
            @param minLevel
        */
        public setMinLevel(int minLevel) {
            setMinLevel(LoggerLevel::getLevel(minLevel));
        }

        #! set min.level
        /**
            @param minLevel
        */
        public setMinLevel(string minLevel) {
            setMinLevel(LoggerLevel::getLevel(minLevel));
        }

        #! get min.level
        public LoggerLevel getMinLevel() {
            return m_minLevel;
        }

        #! set max.level
        /**
            @param maxLevel
        */
        public setMaxLevel(LoggerLevel maxLevel) {
            m_maxLevel = maxLevel;
        }

        #! set max.level
        /**
            @param maxLevel
        */
        public setMaxLevel(int maxLevel) {
            setMaxLevel(LoggerLevel::getLevel(maxLevel));
        }

        #! set max.level
        /**
            @param maxLevel
        */
        public setMaxLevel(string maxLevel) {
            setMaxLevel(LoggerLevel::getLevel(maxLevel));
        }

        #! get max.level
        public LoggerLevel getMaxLevel() {
            return m_maxLevel;
        }

        #! implements filtering by level
        public int eval(LoggerEvent event) {
            if (m_maxLevel.isGreaterOrEqual(m_minLevel)) {
                if (!(event.getLevel().isGreaterOrEqual(m_minLevel) && m_maxLevel.isGreaterOrEqual(event.getLevel()))) {
                    return DENY;
                }
            } else {
                if (event.getLevel().isGreaterOrEqual(m_maxLevel) && m_minLevel.isGreaterOrEqual(event.getLevel())) {
                    return DENY;
                }
            }
            return NEUTRAL;
        }
    }

    #! Implements filtering according regular expression on event message
    /**
        Rendered event message is tested using regular exception and when does not match
        expected result then the logging is rejected
    */
    public class LoggerFilterRegex inherits LoggerFilter {
        private {
            #! regular string
            string m_regexStr;
            #! expected result
            bool m_regexResult;
        }
        #! creates object
        /**
            @param regexStr
            @param regexResult
        */
        constructor(string regexStr = "", bool regexResult = True) {
            setRegex(regexStr, regexResult);
        }

        #! set regular expression and expected result
        /**
            @param regexStr
            @param regexResult
        */
        public setRegex(string regexStr, bool regexResult = True) {
            m_regexStr = regexStr;
            m_regexResult = regexResult;
        }

        #! get current regex
        public string getRegex() {
            return m_regexStr;
        }

        #! get expected result
        public bool getRegexResult() {
            return m_regexResult;
        }

        #! evaluates regex and compares with expected result
        public int eval(LoggerEvent event) {
            if (event.getMessage().regex(m_regexStr) != m_regexResult) {
                return DENY;
            } else {
                return NEUTRAL;
            }
        }
    }

    #! Main logger class whose instance will be used by user code when logging
    /**
        Logger instance is provided to user code. When a log is triggered then
        message, arguments, current code posotion, time are appended into @ref LoggerEvent event instance when
        the logging level is switched on. The event is passed to all registered appenders in given Logger as well as
        to parent in parent/child hierarchy when aditivity is switched on.
    */
    public class Logger {
        private {
            #! The lock to protect object manipulation
            RWLock m_lock();

            #! Logger additivity. If set to true then child loggers will inherit the appenders of their ancestors by default.
            bool m_additive = True;

            #! The assigned Logger level. If nothing then use parent level
            *LoggerLevel m_level;

            #! The name of this Logger instance.
            string m_name;

            #! The parent logger. Set to null if this is the root logger.
            *Logger m_parent;

            #! A collection of appenders linked to this logger.
            list<LoggerAppender> m_appenders;

        }

        #! Creates object
        /**
            @param name
        */
        constructor(string name) {
            m_name = name;
        }

        destructor() {
            setParent(NOTHING);
        }

        #! get logger name
        public string getName() {
            return m_name;
        }

        #! get parent logger
        public *Logger getParent() {
            return m_parent;
        }

        #! set parent logger
        /**
            @param parent
            @throw LOGGER-ERROR in case of circular reference
        */
        public setParent(*Logger parent) {
            if (parent) {
                *Logger l = self;
                while (exists l) {
                    if (l == parent) {
                        throw "LOGGER-ERROR", "Circular logger chain";
                    }
                    l = l.getParent();
                }
            }
            m_parent = parent;
        }

        #! Get logging level
        /**
            @param effective if False then get current level which can be NOTHING, if True then get level which might be inherited from parent, Default: True
            @throw LOGGER-ERROR if cannot get effective level from hierarchy
        */
        public *LoggerLevel getLevel(bool effective = True) {
            if (effective) {
                *Logger l = self;
                while (!exists l.getLevel(False)) {
                    l = l.getParent();
                    if (!exists l) {
                        throw "LOGGER-ERROR", "Cannot get effective level";
                    }
                }
                return l.getLevel(False);
            } else {
                return m_level;
            }
        }

        #! Set logging level
        /**
            @param level if nothing then inherits level from parent
        */
        public setLevel(*LoggerLevel level) {
            m_level = level;
        }

        #! Set logging level
        /**
            @param level
        */
        public setLevel(string level) {
            setLevel(LoggerLevel::getLevel(level));;
        }

        #! Set logging level
        /**
            @param level
        */
        public setLevel(int level) {
            setLevel(LoggerLevel::getLevel(level));;
        }

        #! Sets the additivity flag. When aditivity is active then event are passed to parent instance.
        /**
            @param additive
        */
        public setAdditivity(bool additive) {
            m_additive = additive;
        }

        #! Returns the additivity flag.
        public bool getAdditivity() {
            return m_additive;
        }

        #! Get location where is log function called from
        private hash<CallStackInfo> getLocation() {
            list<hash<CallStackInfo>> loc = get_thread_call_stack();
            return loc[2];   # get location at stack-2
        }

        #! Forwards the given logging event to all linked appenders.
        /**
            @param event
        */
        private callAppenders(LoggerEvent event) {
            AutoReadLock arl(m_lock);
            foreach LoggerAppender appender in (m_appenders) {
                appender.post(event);
            }
        }

        #! add a appender to list
        /**
            @param appender add a new LoggerAppender
            @throw "LOGGER-ERROR" exception if appender is already in list
        */
        public addAppender(LoggerAppender appender) {
            AutoWriteLock awl(m_lock);
            if (!m_appenders) {
                m_appenders = (appender, );
            } else {
                if (m_appenders.contains(appender)) {
                    throw "LOGGER-ERROR", "Appender already exists in list";
                }
                push m_appenders, appender;
            }
        }

        #! remove appender from the list
        /**
            @param appender
        */
        public removeAppender(LoggerAppender appender) {
            AutoWriteLock awl(m_lock);
            foreach LoggerAppender a in (m_appenders) {
                if (a == appender) {
                    splice m_appenders, $#, 1;
                    break;
                }
            }
        }

        #! Clears the appender list by removing all the appenders in it
        public removeAllAppenders() {
            AutoWriteLock awl(m_lock);
            splice m_appenders, 0;
        }

        #! Returns appender list
        /**
            Note that appender list may be manipulated in another thread as internal lock is released when list is returned
        */
        public list<LoggerAppender> getAppenders() {
            AutoReadLock awl(m_lock);
            return m_appenders ?? ();
        }

        private:internal logIntern(*LoggerLevel level, string message, *list args, *hash<CallStackInfo> location, bool checkThrowable) {
            if (!exists level || isEnabledFor(level)) {
                *hash<ExceptionInfo> throwable;
                if (args.size() && checkThrowable) {
                    # is the last argument ExceptionInfo ?
                    auto a = args[args.size()-1];
                    if (a.typeCode() == NT_HASH && a.fullType() == "hash<ExceptionInfo>") {
                        throwable = a;
                    }
                }
                callAppenders(new LoggerEvent(self, level, message, args, location, gettid(), now_us(), throwable));
            }
            if (m_parent && getAdditivity()) {
                # Forward the event upstream if additivity is turned on
                m_parent.logIntern(level, message, args, location, checkThrowable);
            }
        }

        #! Log a message using the provided logging level.
        /**
            @param level The logging level.
            @param message to log is used as format for @ref vsprintf(). Optional arguments are passed to @ref LoggerEvent instance. If the last parameter is
                typed hash @ref Qore::ExceptionInfo "ExceptionInfo" then it is considered as throwable information.
        */
        public log(LoggerLevel level, string message) {
            logIntern(level, message, argv, getLocation(), True);
        }

        #! Log a message using the provided logging level.
        /**
            @param level The logging level.
            @param message to log is used as format for @ref vsprintf(). Optional arguments are passed to @ref LoggerEvent instance. If the last parameter is
                typed hash @ref Qore::ExceptionInfo "ExceptionInfo" then it is considered as throwable information.
        */
        public log(int level, string message) {
            logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
        }

        #! Log a message using the provided logging level.
        /**
            @param level The logging level.
            @param message to log is used as format for @ref vsprintf(). Optional arguments are passed to @ref LoggerEvent instance. If the last parameter is
                typed hash @ref Qore::ExceptionInfo "ExceptionInfo" then it is considered as throwable information.
        */
        public log(string level, string message) {
            logIntern(LoggerLevel::getLevel(level), message, argv, getLocation(), True);
        }

        #! Logs an already prepared logging event object.
        /**
            @param event
        */
        public logEvent(LoggerEvent event) {
            if (isEnabledFor(event.getLevel())) {
                callAppenders(event);
            }

            # Forward the event upstream if additivity is turned on
            if (m_parent && getAdditivity()) {
                m_parent.logEvent(event);
            }
        }

        #! Log a message object with the TRACE level.
        /**
            @see @ref log()
            @param message with optional arguments
        */
        public trace(string message) {
            logIntern(LoggerLevel::getLevelTrace(), message, argv, getLocation(), True);
        }

        #! Log a message object with the DEBUG level.
        /**
            @see @ref log()
            @param message with optional arguments
        */
        public debug(string message) {
            logIntern(LoggerLevel::getLevelDebug(), message, argv, getLocation(), True);
        }

        #! Log a message object with the INFO level.
        /**
            @see @ref log()
            @param message with optional arguments
        */
        public info(string message) {
            logIntern(LoggerLevel::getLevelInfo(), message, argv, getLocation(), True);
        }

        #! Log a message object with the WARN level.
        /**
            @see @ref log()
            @param message with optional arguments
        */
        public warn(string message) {
            logIntern(LoggerLevel::getLevelWarn(), message, argv, getLocation(), True);
        }

        #! Log a message object with the ERROR level.
        /**
            @see @ref log()
            @param message with optional arguments
        */
        public error(string message) {
            logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
        }

        #! Log a message object with the FATAL level.
        /**
            @see @ref log()
            @param message with optional arguments
        */
        public fatal(string message) {
            logIntern(LoggerLevel::getLevelFatal(), message, argv, getLocation(), True);
        }

        #! assertion logging
        /**
            If assertion parameter is evaluated as False, then logs the message
            using the ERROR level.

            @see @ref log()

            @param assertion
            @param message with optional arguments
        */
        public assertLog(bool assertion, string message) {
            if(!assertion) {
                logIntern(LoggerLevel::getLevelError(), message, argv, getLocation(), True);
            }
        }

         #! Log variable name and value using TRACE level
        /**
            @see @ref log()

            @param varName
            @param value
        */
        public traceVar(string varName, any value) {
            logIntern(LoggerLevel::getLevelTrace(), sprintf("%s: %y", varName), (value, ), getLocation(), False);
        }

        #! Log variable name and value using DEBUG level
        /**
            @see @ref log()

            @param varName
            @param value
        */
        public debugVar(string varName, any value) {
            logIntern(LoggerLevel::getLevelDebug(), sprintf("%s: %y", varName), (value, ), getLocation(), False);
        }

        #! Check whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level
        */
        public bool isEnabledFor(LoggerLevel level) {
            return level.isGreaterOrEqual(getLevel());
        }

        #! Check whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level
        */
        public bool isEnabledFor(int level) {
            return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
        }

        #! Check whether this Logger is enabled for a given Level passed as parameter.
        /**
            @param level
        */
        public bool isEnabledFor(string level) {
            return LoggerLevel::getLevel(level).isGreaterOrEqual(getLevel());
        }

        #! Check whether this Logger is enabled for the TRACE Level.
        public bool isTraceEnabled() {
            return isEnabledFor(LoggerLevel::getLevelTrace());
        }

        #! Check whether this Logger is enabled for the DEBUG Level.
        public bool isDebugEnabled() {
            return isEnabledFor(LoggerLevel::getLevelDebug());
        }

        #! Check whether this Logger is enabled for the INFO Level.
        public bool isInfoEnabled() {
            return isEnabledFor(LoggerLevel::getLevelInfo());
        }

        #! Check whether this Logger is enabled for the WARN Level.
        public bool isWarnEnabled() {
            return isEnabledFor(LoggerLevel::getLevelWarn());
        }

        #! Check whether this Logger is enabled for the ERROR Level.
        public bool isErrorEnabled() {
            return isEnabledFor(LoggerLevel::getLevelError());
        }

        #! Check whether this Logger is enabled for the FATAL Level.
        public bool isFatalEnabled() {
            return isEnabledFor(LoggerLevel::getLevelFatal());
        }

    }

    #! root class which prevents setting parent
    public class LoggerRoot inherits Logger {
        # creates object
        /**
            @param level initial log level
        */
        constructor(LoggerLevel level = LoggerLevel::getLevelAll()): Logger('') {
            setLevel(level);
        }

        # creates object
        /**
            @param level initial log level
        */
        constructor(int level): Logger('') {
            setLevel(level);
        }

        # creates object
        /**
            @param level initial log level
        */
        constructor(string level): Logger('') {
            setLevel(level);
        }

        #! Override level setter to prevent setting the root logger's level to nothing.
        /**
            Root logger must always have a level.

            @param level
            @throw LOGGER-ERROR if level is null
        */
        public setLevel(*LoggerLevel level) {
            if (!exists level) {
                throw "LOGGER-ERROR", "Cannot set null level for root";
            }
            m_level = level;
        }

        #! Override parent setter. Root logger cannot have a parent.
        /**
            @throw LOGGER-ERROR if parent exists
        */
        public setParent(*Logger parent) {
            if (exists parent) {
                throw "LOGGER-ERROR", "Cannot set parent for root";
            }
        }
    }

}
