# -*- mode: qore; indent-tabs-mode: nil -*-
# @file QUnit.qm Qore user module for automatic testing

%requires qore >= 0.8.12
%new-style

%try-module xml
%define NO_XML
%endtry

%no-child-restrictions
%allow-injection

%requires Util

module QUnit {
    version = "0.1";
    desc = "User module for unit testing with dependency injection support";
    author = "Zdenek Behan <zdenek.behan@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage QUnit Module

    @tableofcontents

    @section qunitintro Introduction to the QUnit Module

    The %QUnit module provides a framework for automated testing.

    It contains base classes for creating test cases and test suites. It also provides a
    dependency injection helper for mocking pre-existing classes without modifying their code.

    It also provides a number of pre-defined testing functions for use in assertions.

    <b>Examples:</b>
    \include test/TestTemplate.qtest
    \include test/TestTemplateInjected.qtest

    @subsection qunit_run Running tests

    Tests are ran by simply executing the test script:
    @verbatim
    qore test.qtest [OPTIONS]
    @endverbatim

    A number of options is available, controlling the behaviour/output of the test
    @subsection unittestformats Supported output formats of test reports

    Currently the module provides the following output formats:
    - plainquiet - human readable quiet format, prints only failures and a short summary at the end, which is also the default
    - plaintext - human readable format, prints one statement per test
    - junit - machine readable format for further processing

    @section unittest_relnotes Release Notes

    @subsection qunit_v0_1 Version 0.1
    - initial version of module
*/

#! the main namespace for all public definitions in the %QUnit module
public namespace QUnit;

#! An abstract class representing test result interface
public class QUnit::AbstractTestResult {
    public {
        string m_type;
        *string m_subType;
        any m_value;
    }
    constructor(string type) {
        m_type = type;
    }
    constructor(string type, string subType) {
        m_type = type;
        m_subType = subType;
    }
    # test
    abstract public bool equals(AbstractTestResult r);
    abstract public string toString();
}

#! Class representing boolean True
public class QUnit::TestResultSuccess inherits QUnit::AbstractTestResult {
    constructor() : AbstractTestResult("True") {
    }

    #! Equality operator
    public bool equals(QUnit::AbstractTestResult r) {
        return r.m_type == "True";
    }

    public string toString() {
        return "Success";
    }
}

#! Class representing test function failure, both unspecific and with detail
public class QUnit::TestResultFailure inherits QUnit::AbstractTestResult {
    private {
        *string m_detail;
    }

    #! Instantiate an unspecific failure, no detail.
    constructor() : AbstractTestResult("False") {
    }

    #! Instantiate an annotated failure, string detail.
    constructor(string s) : AbstractTestResult("False") {
        m_detail = s;
    }

    #! Equality operator
    public bool equals(QUnit::AbstractTestResult r) {
        # All failures are equal. Annotation is just for description. For structured errors, Exceptions should be used.
        return r.m_type == "False";
    }

    public string toString() {
        return "Failure" + (m_detail ? ": " + m_detail : "");
    }
}

#! Class representing any non-boolean value
public class QUnit::TestResultValue inherits QUnit::AbstractTestResult {
    constructor(any value) : AbstractTestResult("Value") {
        # treat NULL as NOTHING
        if (value === NULL)
            return;
        m_value = value;
    }

    #! Equality operator
    public bool equals(QUnit::AbstractTestResult r) {
        return ((r.m_type == "Value") && (r.m_value === m_value));
    }

    public string toString() {
        switch (m_value.typeCode()) {
            case NT_LIST:
            case NT_HASH:
            case NT_BINARY:
                return sprintf("%N", m_value);
        }
        return sprintf("%s: %N", m_value.type(), m_value);
    }
}

#! Class representing a partial match of a hash value. Common keys have to be identical.
public class QUnit::TestResultPartialHashMatch inherits QUnit::AbstractTestResult {
    constructor(hash value) : AbstractTestResult("PartialHashMatch") {
        if (value == NULL)
            return;
        m_value = value;
    }

    public bool equals(QUnit::AbstractTestResult r) {
        # Check type
        if (r.m_type == "Value") {
            # For Value results, only match against hashes. The others make no sense.
            if (r.m_value.typeCode() != NT_HASH) {
                return False;
            }
        } else if (!r.m_type == "PartialHashMatch") {
            return False;
        }
        # All keys from this hash must be present in r and match.
        foreach string key in (m_value.keyIterator()) {
            if (!r.m_value.hasKey(key))
                return False;

            if (r.m_value{key} != m_value{key})
                return False;
        }
        return True;
    }

    public string toString() {
        return sprintf("Partial Hash match: %N", m_value);
    }
}

#! Class representing Exception of a particular type
public class QUnit::TestResultExceptionType inherits QUnit::AbstractTestResult {
    public {
        #! corresponds to the \c "err" key of an @ref exception_hash "exception hash" (the first value of a @ref throw "throw statement")
        string m_exceptionType;
    }

    #! creates the object from the exception arguments
    /** @param exceptionType corresponds to the \c "err" key of an @ref exception_hash "exception hash" (the first value of a @ref throw "throw statement")
    */
    constructor(string exceptionType) : AbstractTestResult("Exception") {
        m_exceptionType = exceptionType;
    }

    #! private constructor for subclasses
    private constructor(string exceptionType, string subType) : AbstractTestResult("Exception", subType) {
        m_exceptionType = exceptionType;
    }

    #! Equality operator
    public bool equals(QUnit::AbstractTestResult r) {
        if (r.m_type != "Exception") {
            return False;
        }
        QUnit::TestResultExceptionType e = r;
        if (e.m_exceptionType != m_exceptionType) {
            return False;
        }
        return True;
    }

    #! returns a string describing the exception type
    public string toString() {
        return sprintf("Exception: %s", m_exceptionType);
    }
}

#! Class representing Exception of a particular type with a particular detail message
public class QUnit::TestResultExceptionDetail inherits QUnit::TestResultExceptionType {
    private {
        string m_exceptionDetail;
    }

    #! creates the object from the exception arguments
    /** @param exceptionType corresponds to the \c "err" key of an @ref exception_hash "exception hash"
        @param exceptionDetail corresponds to the \c "desc" key of an @ref exception_hash "exception hash"
    */
    constructor(string exceptionType, string exceptionDetail) : TestResultExceptionType(exceptionType, "Detail")  {
        m_exceptionDetail = exceptionDetail;
    }

    #! Equality operator
    public bool equals(QUnit::AbstractTestResult r) {
        if (!TestResultExceptionType::equals(r)) {
            return False;
        }
        if (r.m_subType == "Regexp") {
            /* Ensure reflectiveness of regexp == operation.
               Note that this will only work if this == Detail and r == Regexp, otherwise we could get into infinite recursion.
             */
            return r.equals(self);
        }
        if (r.m_subType != "Detail") {
            return False;
        }
        QUnit::TestResultExceptionDetail e = cast<QUnit::TestResultExceptionDetail>(r);
        if (e.m_exceptionDetail != m_exceptionDetail) {
            return False;
        }
        return True;
    }

    public string toString() {
        return sprintf("Exception: %s: Detail '%s'", m_exceptionType, m_exceptionDetail);
    }

    string getDetail() {
        return m_exceptionDetail;
    }
}

#! Class representing Exception of a particular type and matching regexp for detail
public class QUnit::TestResultExceptionRegexp inherits QUnit::TestResultExceptionType {
    private {
        string m_exceptionRegexp;
    }

    constructor(string exceptionType, string exceptionRegexp) : TestResultExceptionType(exceptionType, "Regexp")  {
        m_exceptionRegexp = exceptionRegexp;
    }

    #! Equality operator
    public bool equals(QUnit::AbstractTestResult r) {
        if (!TestResultExceptionType::equals(r)) {
            return False;
        }
        if (r.m_subType != "Detail") {
            return False;
        }
        QUnit::TestResultExceptionDetail e = cast<QUnit::TestResultExceptionDetail>(r);
        if (!e.getDetail().regex(m_exceptionRegexp)) {
            return False;
        }
        return True;
    }

    public string toString() {
        return sprintf("Exception: %s: Regexp '%s'", m_exceptionType, m_exceptionRegexp);
    }
}

#! Class representing Exception of a particular type and substring for detail
public class QUnit::TestResultExceptionSubstring inherits QUnit::TestResultExceptionRegexp {
    constructor(string exceptionType, string exceptionSubstring) : TestResultExceptionRegexp(exceptionType, exceptionSubstring) {
    }

    public string toString() {
        return sprintf("Exception: %s: Substring '%s'", m_exceptionType, m_exceptionRegexp);
    }
}

#! Class containing the configuration for a test case
public class QUnit::TestCase {
    private {
        #! the name of the test case
        string m_name;

        #! the body of the test case
        code m_code;

        #! arguments to the above callable object
        *list m_args;

        #! number of assertions in current test case
        int num_asserts = 0;

        #! number of successful assertions in current test case
        int num_asserts_ok = 0;
    }

    #! creates the TestCase object from the given arguments
    constructor(string name, code code, *softlist args) {
        m_name = name;
        m_code = code;
        m_args = args;
    }

    #! runs the TestCase
    run(QUnit::Test test) {
        # Attempt to run the test function
        try {
            setupThread();
            on_exit restoreThread();
            # User code setup
            test.setUp();
            # User code cleanup
            on_exit test.tearDown();
            # Main test routine
            call_function_args(m_code, m_args);
            # Test success
            test.addTestResult(self, TestReporter::TEST_SUCCESS);
        }
        catch (hash e) {
            checkException(test, e);
        }
    }

    #! handles exceptions raised while running the TestCase
    checkException(QUnit::Test test, hash e) {
        if (e.err =~ /TEST-.*EXCEPTION/) {
            *string assertion_name = e.arg.name;
            *string pos = e.arg.pos;
            if (!pos) {
                pos = get_ex_pos(e);
                if (pos =~ /QUnit\.qm/) {
                    foreach hash callSite in (e.callstack) {
                        if (callSite.file !~ /QUnit\.qm/) {
                            string fn = regex_subst (callSite.file, "<run-time-loaded: (.*)>", "$1");
                            pos = sprintf("%s:%d", fn, callSite.line + callSite.offset);
                            break;
                        }
                    }
                }
            }
            if (e.err == "TEST-SKIPPED-EXCEPTION") {
                string txt = sprintf("Skip %srequested", assertion_name ? sprintf("of %y ", assertion_name) : NOTHING);
                test.addTestResult(self, TestReporter::TEST_SKIPPED, txt, pos, e.desc);
            } else if (e.err == "TEST-EXCEPTION") {
                string txt = sprintf("Assertion %sfailure", assertion_name ? sprintf("%y ", assertion_name) : NOTHING);
                test.addTestResult(self, TestReporter::TEST_FAILURE, txt, pos, e.desc);
            }
        } else {
            # show little higher traceback record in this case
            string pos = get_ex_pos(e);
            string errtxt = sprintf("Unexpected exception: %s", e.err);
            test.addTestResult(self, TestReporter::TEST_ERROR, errtxt, pos, get_exception_string(e));
        }
    }

    #! returns the test case name
    string getName() {
        return m_name;
    }

    incAssertions() {
        ++num_asserts;
    }

    incAssertionsOk() {
        ++num_asserts_ok;
    }

    int getAssertionCount() {
        return num_asserts;
    }

    int getAssertionOkCount() {
        return num_asserts_ok;
    }

    setupThread() {
        save_thread_data("tc", self);
    }

    restoreThread() {
        remove_thread_data("tc");
    }

    #! renames the test case
    rename(string n_name) {
        m_name = n_name;
    }
}

#! Base class for collecting test results and reporting
public class QUnit::TestReporter {
    private {
        const PLAINQUIET = 0;
        const PLAIN = 1;
        const JUNIT = 2;

        const OUT_TYPES = (
            "plainquiet" : PLAINQUIET,
            "plain" : PLAIN,
            "junit" : JUNIT,
        );

        const RESULT_TYPE_DESCRIPTION = (
            TEST_SUCCESS : ("desc": "Success", "junittag" : NOTHING), # Success does not have a junit child tag
            TEST_FAILURE : ("desc": "FAILURE", "junittag" : "failure"),
            TEST_ERROR   : ("desc": "ERROR", "junittag" : "error"),
            TEST_SKIPPED : ("desc": "Skipped", "junittag" : "skipped"),
        );

        #! A map of print methods, categorised into three types: header, summary, testreport
        hash m_printMethods;

        list m_results = ();
        int m_output;
        *string m_comment;

        #! the result of parsing command-line options with @ref Qore::GetOpt::parse2()
        /** @see
            - Opts
            - constructor()
        */
        hash m_options;

        #! test case name
        string m_name;
        #! test case version
        string m_version;

        #! total number of assertions in script
        int num_asserts = 0;

        #! total number of successful assertions in script
        int num_asserts_ok = 0;
    }

    public {
        #! default options for @ref Qore::GetOpt::constructor()
        const Opts = (
            "help"    : "h,help",
            "verbose" : "v,verbose:i+",
            "quiet"   : "q,quiet",
            "format"  : "format=s",
            );

        const TEST_SUCCESS = 0;
        const TEST_FAILURE = 1;
        const TEST_ERROR = 2;
        const TEST_SKIPPED = 3;
    }

    private printOption(string left, string right, int offset) {
        printf(" %s", left);
        int blanks = offset - left.size();
        if (blanks > 0)
            print(strmul(" ", blanks));
        printf("%s\n", right);
    }

    private usageIntern(int offset = 19) {
        printf("usage: %s [options]\n", get_script_name());
        printOption("-h,--help", "this help text", offset);
        printOption("   --format=type", "output format [default: plainquiet]", offset);
        print("        Format descriptions:
           plainquiet  only print failed tests and a summary at the end
           plain       print a status for each test performed
           junit       print a junit xml output\n");
        printOption("-v,--verbose", "shorthand for --format=plain", offset);
        printOption("-q,--quiet", "shorthand for --format=plainquiet", offset);
    }

    private usage() {
        usageIntern();
        exit(1);
    }

    private processOptions(reference p_argv) {
        if (m_options.help)
            usage();

        if (m_options.verbose && m_options.quiet && m_options.format) {
            printf("Please only select one format type\n");
            exit(1);
        }

        if (p_argv) {
            printf("Warning: excess arguments on command-line\n");
        }

        if (m_options.format) {
            if (!exists OUT_TYPES{m_options.format})
                throw "UNIT-TEST-ERROR", sprintf("Unknown output format: %s", m_options.format);
            m_output = OUT_TYPES{m_options.format};
        } else if (m_options.quiet) {
            m_output = PLAINQUIET;
        } else if (m_options.verbose) {
            m_output = PLAIN;
        } else {
            # Default
            m_output = PLAINQUIET;
        }
    }

    #! creates the object from the arguments
    /** @param name the name of the test
        @param version the version of the test
        @param p_argv an optional reference to a list of command-line arguments
        @param opts the option hash to be passed to @ref Qore::GetOpt::constructor()
    */
    constructor(string name, string version, *reference p_argv, hash opts = Opts) {
        m_name = name;
        m_version = version;
        if (!p_argv)
            p_argv = ARGV;
        m_options = new GetOpt(opts).parse2(\p_argv);
        processOptions(\p_argv);

        # A map of print methods, categorised into three types: header, summary, testreport
        m_printMethods = (
            PLAINQUIET: (
                "header" : \self.printPlaintextHeader(),
                "testreport" : \self.printPlaintextOneTest(),
                "summary" : \self.printPlaintextSummary(),
            ),
            PLAIN: (
                "header" : \self.printPlaintextHeader(),
                "testreport" : \self.printPlaintextOneTest(),
                "summary" : \self.printPlaintextSummary(),
            ),
            JUNIT: (
                "summary" : \self.printJunitSummary(),
            )
        );
    }

    private callPrinterFunction(string type, *softlist args) {
        *code c = m_printMethods{m_output}{type};
        if (c) {
            call_function_args(c, args);
        }
    }

    private printHeader() { callPrinterFunction("header"); }
    private printSummary() { callPrinterFunction("summary"); }
    private printTestReport(hash testcase) { callPrinterFunction("testreport", testcase); }

    private printPlaintextHeader() {
        printf("QUnit Test %y v%s\n", m_name, m_version);
    }

    private printPlaintextSummary() {
        int err = errors();
        string serrors = sprintf(", %d error", err, err == 1 ? "" : "s");
        string sskipped = sprintf(", %d skipped", skipped());
        int succeeded = testCount() - errors() - skipped();
        string ssucceeded = sprintf(", %d succeeded", succeeded);
        string assert_str = sprintf(" (%d assertion%s", num_asserts, num_asserts == 1 ? "" : "s");
        if (num_asserts != num_asserts_ok)
            assert_str += sprintf(", %d succeeded", num_asserts_ok);
        assert_str += ")";
        int cnt = testCount();
        printf("Ran %d test case%s%s%s%s%s\n", cnt, cnt == 1 ? "" : "s", succeeded > 0 ? ssucceeded : "", errors() > 0 ? serrors : "", skipped() > 0 ? sskipped : "", assert_str);
    }

    private printPlaintextOneTest(hash testcase) {
        if (m_output == PLAINQUIET && (testcase.result == TEST_SUCCESS)) {
            return;
        }
        string resultType = RESULT_TYPE_DESCRIPTION{testcase.result}{"desc"};

        printf("%s: %s: %d assertion%s", resultType, testcase.testcase.getName(), testcase.testcase.getAssertionCount(), testcase.testcase.getAssertionCount() == 1 ? "" : "s");
        if (testcase.testcase.getAssertionCount() != testcase.testcase.getAssertionOkCount())
            printf(", %d succeeded", testcase.testcase.getAssertionOkCount());
        print("\n");
        if (testcase.result != TEST_SUCCESS) {
            string out = "";
            printf("%s at %s\n", testcase.error, testcase.pos);
            ListIterator errorDescription(testcase.detail.split("\n"));
            while (errorDescription.next()) {
                out += sprintf("\t>> %s\n", errorDescription.getValue());
            }
            printf("-----\n%s-----\n", out);
        }
    }

    private printJunitSummary() {
%ifdef NO_XML
        stderr.printf("No XML module found. Use --format=plain instead.\n");
        exit(1);
%else
        hash junit;
        junit.testsuites."^attributes^" = (
            "name" : m_name,
            "tests"  : testCount(),
            "errors" : errors(),
            "skipped" : skipped(),
        );
        junit.testsuites.testcase = ();

        ListIterator it(m_results);
        while (it.next()) {
            hash testcase;

            testcase."^attributes^".name = it.getValue().testcase.getName();
            string errmsg = sprintf("%s at %s:\n%s", it.getValue().error, it.getValue().pos, it.getValue().detail);

            int status = it.getValue().result;
            testcase."^attributes^"."status" = RESULT_TYPE_DESCRIPTION{status}.desc;

            if (status != TEST_SUCCESS) {
                string tag = RESULT_TYPE_DESCRIPTION{status}.junittag;
                hash result = ("message" : errmsg, "type" : RESULT_TYPE_DESCRIPTION{status}.desc );
                testcase{tag}."^attributes^" = result;
            }
            push junit."testsuites"."testcase", testcase;
        }

        printf("%s\n", make_xml(junit, XGF_ADD_FORMATTING));
%endif
    }

    #! returns the number of errors encountered during test execution
    int errors() {
        int errs = 0;
        ListIterator it(m_results);
        while (it.next()) {
            if (!(TEST_SUCCESS: "", TEST_SKIPPED: "").hasKey(it.getValue(){"result"})) {
                errs++;
            }
        }
        return errs;
    }

    #! returns the number of tests skipped
    int skipped() {
        int errs = 0;
        ListIterator it(m_results);
        while (it.next()) {
            if (!it.getValue(){"result"} == TEST_SKIPPED) {
                errs++;
            }
        }
        return errs;
    }

    #! returns the total number of test results
    int testCount() {
        return m_results.lsize();
    }

    #! adds a test result
    addTestResult(TestCase tc, int success, *string error, *string pos, *string detail) {
        if (!(RESULT_TYPE_DESCRIPTION.hasKey(success))) {
            throw "TESTING-EXCEPTION", "Invalid test result type!";
        }
        hash testcase = ("testcase": tc, "result": success, "error": error, "pos": pos, "detail": detail);

        printTestReport(testcase);

        push m_results, testcase;
    }
}

#! Base class representing a simple test, implements an implicit main() function and all utility functions for testing
public class QUnit::Test inherits QUnit::TestReporter {
    private {
        #! list of test cases
        list testCases = ();

        static QUnit::TestResultSuccess RESULT_SUCCESS = new QUnit::TestResultSuccess();
        static QUnit::TestResultFailure RESULT_FAILURE = new QUnit::TestResultFailure();
    }

    #! creates the object and sets the name of the test
    constructor(string name, string version, *reference p_argv, *hash opts) : QUnit::TestReporter(name, version, \p_argv, opts) {
    }

    #! global setup; will be called once before tests are run
    globalSetUp() {}

    #! global tear down; will be called once after all tests are run
    globalTearDown() {}

    #! Prototype function for setting up test environment. It will be called for each test individually.
    setUp() {}

    #! Prototype function for cleaning up test environemnt. It will be called after each test has executed.
    tearDown() {}

    #! facade for the system environment variables
    *string getEnv(string key, *string def) {
        string ekey = sprintf("QUNIT_%s", key);
        return ENV{ekey} ?? def;
    }

    #! adds a test case to run
    /** @par Example:
        @code
addTestCase("MyTest", \myTest());
        @endcode

        @param name the name of the test case
        @param call the code to call that executes the test case
        @param args any optional arguments to the test case call
    */
    addTestCase(string name, code call, *softlist args) {
        testCases += new TestCase(name, call, args);
    }

    #! adds a test case to run
    /** @par Example:
        @code
addTestCase(obj);
        @endcode

        @param tc the test case object
    */
    addTestCase(QUnit::TestCase tc) {
        testCases += tc;
    }

    #! Helper function for printing out human-readable comparison of two values.
    private string printUnexpectedData(any exp, any act, *bool neg) {
        string expected = sprintf("%N", exp);
        string actual = neg ? "<identical>" : sprintf("%N", act);
        list expectedLines = expected.split("\n");
        list actualLines = actual.split("\n");

        # Distinguish between multiline
        bool multiline = ((expectedLines.size() + actualLines.size()) > 2);

        string result = "";
        if (!multiline) {
            # For some very simple values that fit on one line, just put it on one line. For values that would overflow the standard line size, do two lines.
            bool twoline = length(expected) + length(actual) > 40;
            result += sprintf("Expected%s %s%sActual %s", neg ? " Not Equal" : "", expected, twoline ? "\n" : ", ", actual);
        } else {
            result += sprintf("* Expected%s:", neg ? " Not Equal" : "");
            result += "\n\t--------------------\n";
            map result += sprintf("\t%s\n", $1), expectedLines;
            result += "\t--------------------\n";
            result += "* Actual:";
            result += "\n\t--------------------\n";
            if (neg)
                result += "\t<same as above>\n";
            else
                map result += sprintf("\t%s\n", $1), actualLines;
            result += "\t--------------------\n";
            list details = ();
            if (exp.typeCode() == NT_HASH && act.typeCode() == NT_HASH) {
                compareHashes(exp, act, \details);
            }
            if (exp.typeCode() == NT_LIST && act.typeCode() == NT_LIST) {
                compareLists(exp, act, \details);
            }
            if (details) {
                result += "* Details:";
                result += "\n\t--------------------\n";
                map result += sprintf("\t%s\n", $1), details;
                result += "\t--------------------\n";
            }
        }
        return result;
    }

    private string shorten(any value) {
        string v = sprintf("%N", value);
        return sprintf("%s (%s)", v.split("\n")[0], value.type());
    }

    private compare(any v1, any v2, reference out, string path) {
        if (v1 !== v2) {
            if (v1.typeCode() == NT_HASH && v2.typeCode() == NT_HASH) {
                compareHashes(v1, v2, \out, path);
            } else if (v1.typeCode() == NT_LIST && v2.typeCode() == NT_LIST) {
                compareLists(v1, v2, \out, path);
            } else {
                out += sprintf("The values of %s differ:", path);
                out += sprintf("    expected: %s", shorten(v1));
                out += sprintf("      actual: %s", shorten(v2));
            }
        }
    }

    private compareHashes(hash h1, hash h2, reference out, string path = "") {
        foreach string key in (h1.keyIterator()) {
            if (h2.hasKey(key)) {
                compare(h1{key}, h2{key}, \out, path + "." + key);
            } else {
                out += sprintf("Missing expected key %s.%s (with value %N)", path, key, h1{key});
            }
        }
        foreach string key in (h2.keyIterator()) {
            if (!h1.hasKey(key)) {
                out += sprintf("Unexpected key %s.%s (with value %N)", path, key, h2{key});
            }
        }
    }

    private compareLists(list l1, list l2, reference out, string path = "") {
        int len1 = elements l1;
        int len2 = elements l2;

        if (len1 != len2) {
            out += sprintf("Different lengths of lists %s%s- expected: %d, actual: %s", path, path ? " " : "", len1, len2);
        }

        for (int i = 0; i < min(len1, len2); ++i) {
            compare(l1[i], l2[i], \out, path + "[" + i + "]");
        }
    }

######### Assertions & test control functions

    #! Tests a value for equality to an expected value
    /** @par Example:
        @code
testAssertionValue("date > operator", now() > (now() - 1D), True);
        @endcode

        @param name the name or description of the assertion
        @param value the value generated by the test
        @param expectedValue the expected value

        @return the \a value argument

        @note make sure and use testAssertion() for any calls that could throw an exception
     */
    public any testAssertionValue(string name, any value, any expectedValue) {
        *TestCase tc = get_thread_data("tc");
        # increment assertion count
        tc.incAssertions();
        ++num_asserts;

        if (value !== expectedValue) {
            throw "TEST-EXCEPTION", printUnexpectedData(expectedValue, value), ("name": name, "pos": NOTHING);
        } else {
            tc.incAssertionsOk();
            ++num_asserts_ok;
            if (m_options.verbose > 1)
                printf("+ OK: %y assertion %y\n", m_name, name);
        }
        return value;
    }

    #! Tests a value for equality to an expected value
    /** @par Example:
        @code
assertEq(5, functionThatShouldReturnFive());
        @endcode

        @param expected the expected value
        @param actual the value generated by the test
        @param name the name or description of the assertion
     */
    public assertEq(any expected, any actual, any name = NOTHING) {
        testAssertionValue(name ?? "", actual, expected);
    }

    #! Tests a boolean value
    /** @par Example:
        @code
assertTrue(functionThatShouldReturnTrue());
        @endcode

        @param actual the value generated by the test
        @param name the name or description of the assertion
     */
    public assertTrue(any actual, any name = NOTHING) {
        testAssertionValue(name ?? "", actual, True);
    }

    #! Tests a boolean value
    /** @par Example:
        @code
assertFalse(functionThatShouldReturnFalse());
        @endcode

        @param actual the value generated by the test
        @param name the name or description of the assertion
     */
    public assertFalse(any actual, any name = NOTHING) {
        testAssertionValue(name ?? "", actual, False);
    }

    #! Tests that a piece of code throws an exception with given description
    /** @par Example:
        @code
assertThrows("DIVISION-BY-ZERO", "division by zero found in integer expression", sub(int a) {print(5/a);}, 0);
        @endcode

        @param expectedErr the expected exception type
        @param expectedDesc the expected exception detail (desc field), ignored if NOTHING
        @param theCode the code to execute
        @param args optional arguments to the code
     */
    public assertThrows(string expectedErr, *string expectedDesc, code theCode, *softlist args) {
        *TestCase tc = get_thread_data("tc");
        if (!tc)
            throw "TEST-ERROR", sprintf("cannot test assertion while not executing a test case; testAssertion() can only be called in code executed in a test case (added with %s::addTestCase())", self.className());
        tc.incAssertions();
        ++num_asserts;

        string exp = sprintf("Exception: %s", expectedErr) + (expectedDesc ? sprintf(": Detail '%s'", expectedDesc) : "");
        try {
            call_function_args(theCode, args);
        } catch (e) {
            if (e.err == expectedErr && (expectedDesc == NOTHING || e.desc == expectedDesc)) {
                tc.incAssertionsOk();
                ++num_asserts_ok;
                return;
            }
            throw "TEST-EXCEPTION", printUnexpectedData(exp, get_exception_string(e));
        }
        throw "TEST-EXCEPTION", sprintf("Expected %s was not thrown", exp);
    }

    #! Tests that a piece of code throws an exception
    /** @par Example:
        @code
assertThrows("DIVISION-BY-ZERO", sub(int a) {print(5/a);}, 0);
        @endcode

        @param expectedErr the expected exception type
        @param theCode the code to execute
        @param args optional arguments to the code
     */
    public assertThrows(string expectedErr, code theCode, *softlist args) {
        assertThrows(expectedErr, NOTHING, theCode, args);
    }

    #! Fails the test anconditionally
    /** @par Example:
        @code
fail("Unexpected code executed");
        @endcode

        @param msg the failure message
     */
    public fail(string msg) {
        throw "TEST-EXCEPTION", msg;
    }

    #! Tests for a single assertion for a call returning no value (for example, to ensure that the call does not throw an exception)
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public testNullAssertion(string name, code condition, *softlist args) {
        testAssertion(name, condition, args, new TestResultValue());
    }

    #! Tests for a single assertion for a call returning an integer value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue an integer value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, int expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning a floating-point value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue a floating-point value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, float expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning an arbitrary-precision numeric value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue an arbitrary-precision numeric value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, number expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning a boolean value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue a boolean value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, bool expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning a string value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue a string value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, string expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning a date value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue a date value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, date expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning a binary value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue a binary value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, binary expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning a hash value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue a hash value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, hash expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion for a call returning a list value and returns the value generated
    /**
        @param name the name or description of the assertion
        @param condition A test function whose result we are asserting
        @param args Arguments passed to condition
        @param expectedResultValue a list value

        @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, list expectedResultValue) {
        return testAssertion(name, condition, args, new TestResultValue(expectedResultValue));
    }

    #! Tests for a single assertion and returns the value generated
    /**
     * @param name the name or description of the assertion
     * @param condition A test function whose result we are asserting
     * @param args Arguments passed to condition
     * @param expectedResult A class describing the expected result of condition; the default is QUnit::TestResultSuccess
     *
     * @return the result of the \a condition call, if the immediate value has any further use
     */
    public any testAssertion(string name, code condition, *softlist args, QUnit::AbstractTestResult expectedResult = new QUnit::TestResultSuccess()) {
        *TestCase tc = get_thread_data("tc");
        if (!tc)
            throw "TEST-ERROR", sprintf("cannot test assertion %y while not executing a test case; testAssertion() can only be called in code executed in a test case (added with %s::addTestCase())", name, self.className());
        tc.incAssertions();
        ++num_asserts;

        *string pos;
        AbstractTestResult result;
        any ret;
        try {
            ret = call_function_args(condition, args);
            if (ret.typeCode() == NT_BOOLEAN) {
                if (ret) {
                    result = new QUnit::TestResultSuccess();
                } else {
                    result = new QUnit::TestResultFailure();
                }
            } else {
                result = new QUnit::TestResultValue(ret);
            }
        }
        catch (e) {
            if (e.err == "TEST-FAILED-EXCEPTION") {
                # Since boolean can contain no detail, we abuse Exceptions this way to annotate a simple failure.
                result = new QUnit::TestResultFailure(e.desc);
            } else {
                pos = get_ex_pos(e);
                result = exists e.desc ? new QUnit::TestResultExceptionDetail(e.err, e.desc) : new QUnit::TestResultExceptionType(e.err);
                ret = e;
            }
        }

        return testAssertionIntern(tc, name, result, expectedResult, ret, pos);
    }

    private any testAssertionIntern(TestCase tc, string name, QUnit::AbstractTestResult actualResult, QUnit::AbstractTestResult expectedResult, any ret, *string pos) {
        if (!expectedResult.equals(actualResult)) {
            any exp = expectedResult instanceof TestResultValue ? expectedResult.m_value : expectedResult.toString();
            any act = actualResult instanceof TestResultValue ? actualResult.m_value : actualResult.toString();
            throw "TEST-EXCEPTION", printUnexpectedData (exp, act), ("name": name, "pos": pos);
        }
        else {
            tc.incAssertionsOk();
            ++num_asserts_ok;
            if (m_options.verbose > 1)
                printf("+ OK: %y assertion %y\n", m_name, name);
        }
        return ret;
    }

    #! Skips a given test, eg. because it may be missing some dependencies.
    /**
     * @param reason The reason for the test skip
     */
    public testSkip(string reason) {
        throw "TEST-SKIPPED-EXCEPTION", reason;
    }

######### Test conditions passable to test assertions

    #! Compare two values for equality
    /**
     * @param a Argument 1
     * @param b Argument 2
     *
     * @returns a == b
     */
    bool equals(any a, any b) {
        if (a != b) {
            throw "TEST-FAILED-EXCEPTION", "Value mismatch, " + printUnexpectedData(a, b);
        }
        return True;
    }

    #! Compare two values for inequality
    /**
     * @param a Argument 1
     * @param b Argument 2
     *
     * @returns a != b
     */
    bool notEquals(any a, any b) {
        if (a == b) {
            throw "TEST-FAILED-EXCEPTION", "Value mismatch, " + printUnexpectedData(a, b, True);
        }
        return True;
    }

    #! Compare a string for match against a regexp
    /**
     * @param s String to match
     * @param regexp Regular expression to match against
     *
     * @returns a == b
     */
    bool regexpMatches(string s, string regexp) {
        if (!s.regex(regexp)) {
            throw "TEST-FAILED-EXCEPTION", sprintf("String does not match:\nString: %s\nRegexp: %s\n", s, regexp);
        }
        return True;
    }

    #! Compare two iterables, item by item, for equality of each index
    /**
     * @param a Iterable 1
     * @param b Iterable 2
     *
     * @returns a == b
     */
    bool equalsIterated(AbstractIterator a, AbstractIterator b) {
        int index = 0;
        while (a.next()) {
            if (!b.next()) {
                throw "TEST-FAILED-EXCEPTION", sprintf("Iterated mismatch, index %d:\n", index) + printUnexpectedData(a.getValue(), "Right hand side ran out of data!");
            }
            if (a.getValue() != b.getValue()) {
                throw "TEST-FAILED-EXCEPTION", sprintf("Iterated mismatch, index %d\n", index) + printUnexpectedData(a.getValue(), b.getValue());
            }
            index++;
        }
        if (b.next()) {
            throw "TEST-FAILED-EXCEPTION", sprintf("Iterated mismatch, index %d\n", index) + printUnexpectedData(b.getValue(), "Left hand side ran out of data!");
        }
        return True;
    }

######### Main function and test running helpers

    #! Run the whole suite, report results
    int main() {
        if (!testCases) {
            throw "TESTING-EXCEPTION", sprintf("Please define some tests first by calling %s::addTestCase()", self.className());
        }

        printHeader();

        # create initialization / shutdown test case
        TestCase gtc("globalSetUp", sub () {});
        gtc.setupThread();
        on_exit gtc.restoreThread();

        try {
            globalSetUp();
        }
        catch (hash ex) {
            gtc.checkException(self, ex);
        }

        foreach TestCase tc in (testCases) {
            code tinit = sub () {tc.setupThread();};
            set_thread_init(tinit);

            # run test case
            tc.run(self);
        }

        try {
            gtc.rename("globalTearDown");
            globalTearDown();
        }
        catch (hash ex) {
            gtc.checkException(self, ex);
        }

        printSummary();
        return errors();
    }
}

#! A class representing a test with injected dependencies.
public class QUnit::DependencyInjectedTest inherits QUnit::Test {
    private {
        *string m_testedFile;
        Program m_child;
        *hash m_modules;

        static bool instantiated = False;
    }

    constructor(string name, string version, *reference p_argv, *hash opts) : QUnit::Test(name, version, \p_argv, opts) {
        if (instantiated) {
            throw "TESTING-EXCEPTION", "Only one instance of DependencyInjectedTest per program allowed!";
        }
        instantiated = True;
    }

    #! A helper function. It must be called once for a new instance with get_script_path() as argument.
    setScriptPath(*string testedFile) {
        if (testedFile) {
            m_testedFile = testedFile;
        }
    }

    #! A prototype function
    setUp() { }
    tearDown() { }

    private Program createInjectedProgram() {
        Program p(PO_NO_API|PO_NO_CHILD_PO_RESTRICTIONS|PO_ALLOW_INJECTION);
        p.setScriptPath(m_testedFile);
        # Replace oneself with the test runner
        p.importClass("QUnit::DependencyInjectedTestRunner", "QUnit::DependencyInjectedTest", True);
        performInjections(p);

        # Default classes
        p.importSystemApi();
        return p;
    }

    abstract performInjections(Program p);
    abstract performModuleInjections();

    private injectIntoModule(string module) {
        m_modules{module} = createInjectedProgram();
        m_modules{module}.loadApplyToUserModule(module, True);
    }

    destructor() {
        # Un-inject all injected modules.
        HashKeyIterator it(m_modules);
        while (it.next()) {
            string mn = basename(it.getValue());
            mn =~ s/\..+$//; # Strip suffix, if any
            reload_module(mn);
        }
    }

    int main() {
        if (!m_testedFile) {
            throw "TESTING-EXCEPTION", "You need to set the script path to run DependencyInjectedTest! Please run setScriptPath(get_script_path()) in the program.";
        }

        Program p = createInjectedProgram();

        # Inject the same into all modules
        performModuleInjections();

        # Load self, with replacements
        string file_data = ReadOnlyFile::readTextFile(m_testedFile);
        int eol = file_data.find("\n");
        if (eol) {
            string fl = file_data.substr(0, eol);
            if (fl =~ /(\\|\s)qr\s*$/)
                p.setParseOptions(PO_NEW_STYLE);
        }
        p.parse(file_data, m_testedFile);

        return p.run() ?? 0;
    }
}

public class QUnit::DependencyInjectedTestRunner inherits QUnit::Test {
    public setScriptPath(*string testedFile) {}
    private injectIntoModule(string module) {}

    constructor(string name, string version, *reference p_argv, *hash opts) : QUnit::Test(name, version, \p_argv, opts) {
    }
}
