# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file MysqlSqlUtil.qm Qore user module for working with MySQL SQL data

/*  MysqlSqlUtil.qm Copyright 2013 - 2023 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 1.0

# requires the SqlUtil module
%requires SqlUtil >= 1.5

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module MysqlSqlUtil {
    version = "1.5";
    desc = "user module for working with MySQL SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage MysqlSqlUtil Module

    @tableofcontents

    @section mysqlsqlutilintro MysqlSqlUtil Module Introduction

    The %MysqlSqlUtil module provides a high level API for working with MySQL database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires MysqlSqlUtil" in your code.

    All the public symbols in the module are defined in the MysqlSqlUtil namespace

    @note This module requires the <a href="https://github.com/qorelanguage/module-mysql">mysql</a> binary module for communication with MySQL databases

    @section mysql_schema_management Schema Management on MySQL

    @subsection mysql_type_mapping Type Mapping

    Column types are mapped from %Qore types as follows:

    <b>MySQL Column Type Mappings</b>
    |!Generic Type Name|!MySQL Type Used
    |\c float|\c double
    |\c number|\c decimal
    |\c string|\c varchar
    |\c date|\c datetime
    |\c binary|\c varbinary
    |\c bool|\c tinyint
    |@ref SqlUtil::BLOB|\c mediumblob
    |@ref SqlUtil::CHAR|\c char
    |@ref SqlUtil::CLOB|\c mediumtext
    |@ref SqlUtil::NUMERIC|\c decimal
    |@ref SqlUtil::VARCHAR|\c varchar

    To use other types, use the \c "native_type" @ref SqlUtil::AbstractTable::ColumnDescOptions "column description option" with the
    native MySQL type name instead (under the \c "driver" and \c "mysql" keys for schemas supporting multiple databases).

    @subsection mysql_column_notnull NOT NULL Constraints on MySQL

    MySQL currently does not support firing "before insert" or "before update" triggers before constraints are checked, so in other databases
    where a trigger will set a default value for a column when a NULL is inserted, MySQL will raise an error if there is a NOT NULL
    constraint on the column.

    @section mysql_relnotes Release Notes

    @subsection mysqlsqlutilv15 MysqlSqlUtil v1.5
    - fixed the prepend and append column operators
      (<a href="https://github.com/qorelanguage/qore/issues/4548">issue 4548</a>)
    - implemented support for generating queries based on generic expressions using the DataProvider module's generic
      expression support
      (<a href="https://github.com/qorelanguage/qore/issues/4538">issue 4538</a>)

    @subsection mysqlsqlutilv143 MysqlSqlUtil v1.4.3
    - allow a \c VARCHAR column to be created without a size, assume a default size
      (<a href="https://github.com/qorelanguage/qore/issues/4399">issue 4399</a>)

    @subsection mysqlsqlutilv142 MysqlSqlUtil v1.4.2
    - added APIs to enable duplicate record creation errors to be detected
      (<a href="https://github.com/qorelanguage/qore/issues/4308">issue 4308</a>)

    @subsection mysqlsqlutilv141 MysqlSqlUtil v1.4.1
    - fixed a bug generating literal date/time values for SQL queries
      (<a href="https://github.com/qorelanguage/qore/issues/3948">issue 3948</a>)

    @subsection mysqlsqlutilv14 MysqlSqlUtil v1.4
    - fixed a bug where the table collation and character set (encoding) could not be specified
      (<a href="https://github.com/qorelanguage/qore/issues/3752">issue 3752</a>)
    - fixed quoting reserved words with backticks
      (<a href="https://github.com/qorelanguage/qore/issues/3750">issue 3750</a>)
    - added support for the DataProvider module
      (<a href="https://github.com/qorelanguage/qore/issues/3545">issue 3545</a>)

    @subsection mysqlsqlutilv131 MysqlSqlUtil v1.3.2
    - updated to work also with newer versions of MySQL / MariaDB that support sequences
      (<a href="https://github.com/qorelanguage/qore/issues/3747">issue 3747</a>)
    - fixed a bug where the sequence table name was not respected in
      @ref MysqlSqlUtil::MysqlDatabase::getNextSequenceValueImpl() "MysqlDatabase::getNextSequenceValueImpl()"
      (<a href="https://github.com/qorelanguage/qore/issues/3641">issue 3641</a>)

    @subsection mysqlsqlutilv131 MysqlSqlUtil v1.3.1
    - fixed quoting of reserved words in column names in table alignment
      (<a href="https://github.com/qorelanguage/qore/issues/3400">issue 3400</a>)

    @subsection mysqlsqlutilv13 MysqlSqlUtil v1.3
    - added support for serializing and deserializing @ref SqlUtil::AbstractTable "AbstractTable" objects (<a href="https://github.com/qorelanguage/qore/issues/2663">issue 2663</a>)

    @subsection mysqlsqlutilv121 MysqlSqlUtil v1.2.1
    - implemented support for custom column operators (<a href="https://github.com/qorelanguage/qore/issues/2314">issue 2314</a>)

    @subsection mysqlsqlutilv12 MysqlSqlUtil v1.2
    - added support for complex types

    @subsection mysqlsqlutilv111 MysqlSqlUtil v1.1.1
    - implemented the \a force option (i.e. cascade) for dropping code objects (<a href="https://github.com/qorelanguage/qore/issues/1314">issue 1314</a>)
    - implemented @ref cop_trunc_date() operator (<a href="https://github.com/qorelanguage/qore/issues/2032">issue 2032</a>)

    @subsection mysqlsqlutilv11 MysqlSqlUtil v1.1
    - corrected support for the \c varbinary type (<a href="https://github.com/qorelanguage/qore/issues/403">bug 403</a>)
    - corrected support for the \c binary type (<a href="https://github.com/qorelanguage/qore/issues/524">bug 524</a>)
    - \c schema member incorrectly set by @ref Qore::SQL::AbstractDatasource::getUserName() "AbstractDatasource::getUserName()" instead of @ref Qore::SQL::AbstractDatasource::getDBName() "AbstractDatasource::getDBName()" (<a href="https://github.com/qorelanguage/qore/pull/519">bug 519</a>)
    - corrected support for datatypes \c binary, \c char, \c varbinary, \c varchar
    - added support for \c cop_cast operator (<a href="https://github.com/qorelanguage/qore/issues/535">feature 535</a>)

    @subsection mysqlsqlutilv10 MysqlSqlUtil v1.0
    - initial release
*/

#! the MysqlSqlUtil namespace contains all the objects in the MysqlSqlUtil module
public namespace MysqlSqlUtil {
    #! returns a MysqlTable object corresponding to the arguments
    public MysqlTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
        return new MysqlTable(nds, nname, opts);
    }

    #! returns a MysqlDatabase object corresponding to the arguments
    public MysqlDatabase sub get_database(AbstractDatasource nds, *hash opts) {
        return new MysqlDatabase(nds, opts);
    }

    sub parse_schema_name(string nname, reference<*string> schema, reference<string> name) {
        *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
        if (sstr) {
            schema = sstr;
            splice nname, 0, schema.size() + 1;
            name = nname;
        }
        else {
            schema = NOTHING;
            name = nname;
        }
    }

    #! MySQL savepoint helper
    public class MysqlSavepointHelper inherits AbstractSavepointHelper {
        #! Creates the object
        constructor(AbstractDatasource ds, *string savepoint) : AbstractSavepointHelper(ds, savepoint) {
        }

        #! Creates the savepoint
        private createSavepointImpl() {
            ds.exec("savepoint " + savepoint);
        }

        #! Rolls back to the savepoint
        private rollbackImpl() {
            ds.exec("rollback to " + savepoint);
        }

        #! Deletes the savepoint
        private deleteSavepointImpl() {
            ds.exec("release savepoint " + savepoint);
        }
    }

    #! the data type for DECIMAL columns
    public class MysqlNumberDataType inherits SqlUtil::AbstractNumericDataType {
        #! creates the object
        constructor(string native_type, bool nullable, *hash<auto> options)
                : AbstractNumericDataType(native_type, nullable, options) {
        }
    }

    #! represents a MySQL-specific index
    public class MysqlIndex inherits SqlUtil::AbstractIndex {
        public {
            string type;
        }

        #! creates the object from the arguments
        constructor(string n_name, bool n_unique, hash n_cols, string n_type = "BTREE") : AbstractIndex(n_name, n_unique, n_cols) {
            type = n_type;
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash opt) {
            return sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.getSqlColumnNameIterator()));
        }

        #! returns @ref True "True" if the argument is equal to the current index, @ref False "False" if not
        private bool equalImpl(AbstractIndex ix) {
            return type == cast<MysqlIndex>(ix).type;
        }

        #! returns a string that can be used to rename the index in the database; hwoever mysql does not support renaming indexes, so the index is dropped and recreated :(
        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s drop index %s, add %sindex %s (%s)", table_name, name, unique ? "unique " : "", new_name, (foldl $1 + ", " + $2, columns.getSqlColumnNameIterator()));
        }

        #! returns a string that can be used to drop the index from the table
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop index %s", table_name, name);
        }
    }

    #! represents a MySQL-specific foreign constraint
    public class MysqlForeignConstraint inherits SqlUtil::AbstractForeignConstraint {
        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractForeignConstraint(n, c, t) {
        }

        string getCreateSql(string table_name, *hash opt) {
            return getCreateSql(name, table_name, opt);
        }

        #! returns a string that drops the constraint and re-adds it, since MySQL does not support renaming constraints
        softlist getRenameSql(string table_name, string new_name) {
            return getDropSql(table_name) + ", " + getAddSql(new_name, table_name);
        }

        string getCreateSql(string name, string table_name, *hash opt) {
            return sprintf("alter table %s ", table_name) + getAddSql(name, table_name, opt);
        }

        string getAddSql(string name, string table_name, *hash opt) {
            return sprintf("add constraint %s foreign key (%s) references %s (%s)", name,
                (foldl $1 + ", " + $2, h.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }

        #! returns a string that can be used to drop the foreign constraint from the database
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop foreign key %s", table_name, name);
        }
    }

    #! represents a MySQL-specific column
    public class MysqlColumn inherits SqlUtil::AbstractColumn {
        public {
            #! byte size of the column
            int byte_size;
        }

        #! empty constructor for subclasses
        private constructor() {
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, *softint bs,
                *int scale) : AbstractColumn(n, nt, qt, sz, nul, dv, cm, scale) {
            byte_size = bs ?? 0;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code{.py}
list<auto> l = col.getAddColumnSql(t);
            @endcode

            @param t the AbstractTable object to modify
         */
        softlist<string> getAddColumnSql(AbstractTable t) {
            return sprintf("alter table %s add %s", t.getSqlName(), getCreateSql(t));
        }

        #! returns an sql string that can be used to add the column to a table
        string getCreateSql(AbstractTable t) {
            string sql = AbstractColumn::getCreateSql(t);
            if (comment) {
                sql += " comment " + t.getSqlValue(comment);
            }
            return sql;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition
        /** if the column definitions are identical then an empty list is returned

            @par Example:
            @code{.py}
list<auto> l = col.getModifySql(t, newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param col the new column definition
            @param opt column modification options (none are supported in this class)

            @return a list of sql strings that can be used to modify the column to the new definition; if the column
            definitions are identical then an empty list is returned
         */
        softlist<string> getModifySqlImpl(AbstractTable t, AbstractColumn col, *hash opt) {
            MysqlColumn c = col;

            string ntd = c.getCreateSql(t);
            if (ntd == getCreateSql(t)) {
                return;
            }

            #printf("%y (%d) <=> %y (%d): L: %s\nXXXXXXXXXX\nR: %s\n",
            #    self.className(), size, c.className(), c.size, getCreateSql(t), ntd);

            return sprintf("alter table %s modify %s", t.getSqlName(), ntd);
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code{.py}
string str = col.getRenameSql(t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            string sql = getCreateSql(t);
            int i = sql.find(" ");
            splice sql, 0, i + 1;
            return sprintf("alter table %s change %s %s %s", t.getSqlName(), ddl_name, getDdlName(new_name), sql);
        }

        #! returns the column name with quoting in case the column name is a reserved word
        /** the name returned here will be used when executing DDL
        */
        string getDdlName(string name) {
            return MysqlDatabase::MysqlReservedWords{name.lwr()} ? ("`" + name + "`") : name;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractColumn c) {
            return byte_size == cast<MysqlColumn>(c).byte_size;
        }
    }

    #! represents a MySQL-specific numeric column
    public class MysqlNumericColumn inherits MysqlColumn {
        public {
            bool unsigned;
            bool auto_increment;
            # auto-incrememnt columns must be either "unique" or "primary key" in mysql
            bool pk = False;
        }

        private {
            # AUTO_INCREMENT applies only to integer and floating-point types
            const AUTO_INCREMENT_VALID_TYPES = {
                # int types
                "tinyint": True,
                "smallint": True,
                "mediumint": True,
                "int": True,
                "bigint": True,
                # float types
                "float": True,
                "real": True,
                "double precision": True,
            };
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, softint bs,
                softint scale, bool n_unsigned = False, bool n_auto_increment = False, bool n_pk = False)
                : MysqlColumn(n, nt, qt, sz, nul, dv, cm, bs, scale) {
            unsigned = n_unsigned;
            auto_increment = n_auto_increment;
            pk = n_pk;
            # default precision is 10
            if (!sz) {
                size = 10;
            }

            validateConstructor();
        }

        #! deserializes the hash to a replica of the original object
        private:internal deserializeMembers(hash<auto> members) {
            self += members;
            validateConstructor();
        }

        private validateConstructor() {
            if (auto_increment && !AUTO_INCREMENT_VALID_TYPES.hasKey(native_type)) {
                throw "MYSQL-COLUMN-ERROR",
                      sprintf("AUTO_INCREMENT can be used only with a subset of types. Used: %s, valid types: %y",
                              native_type, keys AUTO_INCREMENT_VALID_TYPES);
            }
        }

        string getNativeTypeString() {
            string str = MysqlColumn::getNativeTypeString();
            if (unsigned) {
                str += " unsigned";
            }
            if (auto_increment) {
                str += " auto_increment " + (pk ? "primary key" : "unique");
            }
            return str;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractColumn c) {
            MysqlNumericColumn nc = c;
            return unsigned = nc.unsigned && auto_increment == nc.auto_increment && pk == nc.pk;
        }
    }

    public class MysqlUniqueConstraintCommon inherits SqlUtil::AbstractUniqueConstraint {
        constructor() {
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        #! adds index options onto the sql creation string
        getIndexSql(reference<string> sql, string name, *hash opts) {
            sql += sprintf("(%s)", (foldl $1 + ", " + $2, getSqlColumnNameIterator()));
        }
    }

    public class MysqlUniqueConstraint inherits SqlUtil::AbstractUniqueConstraint, MysqlUniqueConstraintCommon {
        constructor(string n, hash n_cols) : AbstractUniqueConstraint(n, n_cols) {
        }

        #! returns the MysqlColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        MysqlColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        string getCreateSql(string table_name, *hash opts) {
            return getCreateSql(name, table_name, opts);
        }

        list getRenameSql(string table_name, string new_name) {
            # the following is only valid with MySQL 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            list l += getDropSql(table_name);
            l += getCreateSql(new_name, table_name);
            return l;
        }

        string getCreateSql(string name, string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s unique ", table_name, name);
            getIndexSql(\sql, name, opts);
            return sql;
        }

        #! returns a string that can be used to drop the constraint from the database
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop index %s", table_name, name);
        }
    }

    #! represents a MySQL-specific primary key constraint
    public class MysqlPrimaryKey inherits SqlUtil::AbstractPrimaryKey, MysqlUniqueConstraintCommon {
        constructor() {
        }

        constructor(*hash c) : AbstractPrimaryKey("PRIMARY", c) {
        }

        #! returns the MysqlColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        MysqlColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add primary key", table_name);
            getIndexSql(\sql, name, opts);
            return sql;
        }

        #! primary keys have no name in MySQL so this method returns an empty list
        softlist getRenameSql(string table_name, string new_name) {
            return ();
        }

        #! returns a string that can be used to drop the constraint from the database
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop primary key", table_name);
        }

        #! returns @ref False "False" since primary key constraints in MySQL have no name
        bool supportsName() {
            return False;
        }
    }

    #! represents a MySQL-specific trigger
    public class MysqlTrigger inherits SqlUtil::AbstractTrigger {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractTrigger(n, n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        softlist getCreateSql(string table_name, *hash opt) {
            return sprintf("create trigger %s %s", name, src);
        }

        #! returns a string that can be used to drop the trigger from the database
        softlist getDropSql(string table_name) {
            return sprintf("drop trigger %s", name);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the trigger in the database
        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter trigger %s on %s rename to %s", name, table_name, new_name);
        }
    }

    #! represents a MySQL-specific function
    public class MysqlFunction inherits SqlUtil::AbstractFunction {
        constructor(string n, string n_src) : AbstractFunction(n, "function", n_src) {
        }

        #! returns a string that can be used to create the function in the database
        softlist getCreateSql(*hash opt) {
            return sprintf("create function %s", src);
        }

        #! returns a string that can be used to drop the function from the database
        /** @param opt this argument is ignored
         */
        string getDropSql(*hash opt) {
            return sprintf("drop function %s", name);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        private bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the function in the database
        /** @param new_name the new name of the object
            @param opt this argument is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("alter function %s rename to %s", name, new_name);
        }
    }

    #! class for MySQL sequences based on a sequence table and autonomous transactions
    public class MysqlSequence inherits SqlUtil::AbstractSequence {
        private {
            string table_name;
        }

        #! creates the object from the arguments
        constructor(string n_table_name, string n_name, number n_start = 1, number n_increment = 1, *softnumber n_end) : AbstractSequence(n_name, n_start, n_increment, n_end) {
            if (increment != 1)
                throw "MYSQL-SEQUENCE-ERROR", sprintf("cannot create a MySQL simulated sequence with any increment value other than 1");
            table_name = n_table_name;
        }

        #! returns a string that can be used to create the sequence in the database
        string getCreateSql(*hash opt) {
            return sprintf("insert into %s (name, id) values ('%s', %d)", table_name, name, start);
        }

        #! returns a string that can be used to rename the sequence in the database
        /** @param new_name the new name of the object
            @param opt this argument is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("update %s set name = '%s' where name = '%s'", table_name, new_name, name);
        }

        #! returns a string that can be used to drop the sequence from the database
        /** @param opt this argument is ignored
         */
        string getDropSql(*hash opt) {
            return sprintf("delete from %s where name = '%s'", table_name, name);
        }
    }

    #! represents a MySQL view
    public class MysqlView inherits SqlUtil::AbstractView {
        public {
            #! table catalog value
            *string tablecatalog;
            #! checkoption clause
            *string checkoption;
            #! dafiner clause
            *string definer;
            #! security type value
            *string securitytype;
        }

        #! creates the object from the arguments
        constructor(string n_name, string n_src, *string n_tablecatalog,
                    *string n_schema,
                    *string n_checkoption, *string n_definer,
                    *string n_securitytype, bool n_updatable)
                : AbstractView(n_name, n_src) {
            tablecatalog = n_tablecatalog;
            schema = n_schema;
            checkoption = n_checkoption;
            definer = n_definer;
            securitytype = n_securitytype;
            updatable = n_updatable;
        }

        #! returns a string that can be used to create the view in the database
        string getCreateSql(*hash opt) {
            # TODO/FIXME: check options
            return sprintf("create %sview %s as %s",
                           opt.replace ? "or replace " : "",
                           name,
                           src
                          );
        }

        #! returns a string that can be used to rename the view in the database
        /** @param new_name the new name of the object
            @param opt this argument is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            list ret;
            push ret, getDropSql(opt);
            string origName = name;
            name = new_name;
            push ret, getCreateSql(); # TODO/FIXME: opts
            name = origName;
            return ret;
        }
    }

    #! provides the MySQL-specific implementation of the AbstractDatabase interface
    public class MysqlDatabase inherits SqlUtil::AbstractDatabase {
        public {
            #! MySQL-specific options
            const MysqlOptions = (
                "sequence_table": Type::String,
                "sequence_function": Type::String,
            );

            #! MySQL-specific schema description keys
            const MysqlSchemaDescriptionOptions = AbstractDatabase::SchemaDescriptionOptions + MysqlOptions;

            #! MySQL-specific database options
            const MysqlDatabaseOptions = AbstractDatabase::DatabaseOptions + MysqlOptions;

            #! MySQL sequence emulation table
            const MysqlSequenceTable = (
                "columns": (
                    "name": (
                        "qore_type": SqlUtil::VARCHAR,
                        "size": 40,
                        "notnull": True,
                    ),
                    "id": (
                        "qore_type": Type::Number,
                        "size": 14,
                        "notnull": True,
                    ),
                ),
            );

            #! MySQL sequence function
            const MysqlSequenceFunction = "%s(seq_name varchar(40)) returns decimal(14)
begin
  update %s set id = last_insert_id(id + 1) where name = seq_name;
  return last_insert_id();
end";

            #! Options for computeStatistics()
            const MysqlComputeStatisticsOptions = ComputeStatisticsOptions + (
                "no-binlog"         : Type::Boolean,
            );

            #! Options for reclaimSpace()
            const MysqlReclaimSpaceOptions = ReclaimSpaceOptions + (
                "no-binlog"         : Type::Boolean,
            );

            #! hash of reserved words
            const MysqlReservedWords = (
                "accessible" : True,
                "add" : True,
                "all" : True,
                "alter" : True,
                "analyze" : True,
                "and" : True,
                "as" : True,
                "asc" : True,
                "asensitive" : True,
                "before" : True,
                "between" : True,
                "bigint" : True,
                "binary" : True,
                "blob" : True,
                "both" : True,
                "by" : True,
                "call" : True,
                "cascade" : True,
                "case" : True,
                "change" : True,
                "char" : True,
                "character" : True,
                "check" : True,
                "collate" : True,
                "column" : True,
                "condition" : True,
                "constraint" : True,
                "continue" : True,
                "convert" : True,
                "create" : True,
                "cross" : True,
                "current_date" : True,
                "current_time" : True,
                "current_timestamp" : True,
                "current_user" : True,
                "cursor" : True,
                "database" : True,
                "databases" : True,
                "day_hour" : True,
                "day_microsecond" : True,
                "day_minute" : True,
                "day_second" : True,
                "dec" : True,
                "decimal" : True,
                "declare" : True,
                "default" : True,
                "delayed" : True,
                "delete" : True,
                "desc" : True,
                "describe" : True,
                "deterministic" : True,
                "distinct" : True,
                "distinctrow" : True,
                "div" : True,
                "double" : True,
                "drop" : True,
                "dual" : True,
                "each" : True,
                "else" : True,
                "elseif" : True,
                "enclosed" : True,
                "escaped" : True,
                "exists" : True,
                "exit" : True,
                "explain" : True,
                "false" : True,
                "fetch" : True,
                "float" : True,
                "float4" : True,
                "float8" : True,
                "for" : True,
                "force" : True,
                "foreign" : True,
                "from" : True,
                "fulltext" : True,
                "get" : True,
                "grant" : True,
                "group" : True,
                "having" : True,
                "high_priority" : True,
                "hour_microsecond" : True,
                "hour_minute" : True,
                "hour_second" : True,
                "if" : True,
                "ignore" : True,
                "in" : True,
                "index" : True,
                "infile" : True,
                "inner" : True,
                "inout" : True,
                "insensitive" : True,
                "insert" : True,
                "int" : True,
                "int1" : True,
                "int2" : True,
                "int3" : True,
                "int4" : True,
                "int8" : True,
                "integer" : True,
                "interval" : True,
                "into" : True,
                "io_after_gtids" : True,
                "io_before_gtids" : True,
                "is" : True,
                "iterate" : True,
                "join" : True,
                "key" : True,
                "keys" : True,
                "kill" : True,
                "leading" : True,
                "leave" : True,
                "left" : True,
                "like" : True,
                "limit" : True,
                "linear" : True,
                "lines" : True,
                "load" : True,
                "localtime" : True,
                "localtimestamp" : True,
                "lock" : True,
                "long" : True,
                "longblob" : True,
                "longtext" : True,
                "loop" : True,
                "low_priority" : True,
                "master_bind" : True,
                "master_ssl_verify_server_cert" : True,
                "match" : True,
                "maxvalue" : True,
                "mediumblob" : True,
                "mediumint" : True,
                "mediumtext" : True,
                "middleint" : True,
                "minute_microsecond" : True,
                "minute_second" : True,
                "mod" : True,
                "modifies" : True,
                "natural" : True,
                "not" : True,
                "no_write_to_binlog" : True,
                "null" : True,
                "numeric" : True,
                "on" : True,
                "optimize" : True,
                "option" : True,
                "optionally" : True,
                "or" : True,
                "order" : True,
                "out" : True,
                "outer" : True,
                "outfile" : True,
                "partition" : True,
                "precision" : True,
                "primary" : True,
                "procedure" : True,
                "purge" : True,
                "range" : True,
                "read" : True,
                "reads" : True,
                "read_write" : True,
                "real" : True,
                "references" : True,
                "regexp" : True,
                "release" : True,
                "rename" : True,
                "repeat" : True,
                "replace" : True,
                "require" : True,
                "resignal" : True,
                "restrict" : True,
                "return" : True,
                "revoke" : True,
                "right" : True,
                "rlike" : True,
                "schema" : True,
                "schemas" : True,
                "second_microsecond" : True,
                "select" : True,
                "sensitive" : True,
                "separator" : True,
                "set" : True,
                "show" : True,
                "signal" : True,
                "smallint" : True,
                "spatial" : True,
                "specific" : True,
                "sql" : True,
                "sqlexception" : True,
                "sqlstate" : True,
                "sqlwarning" : True,
                "sql_big_result" : True,
                "sql_calc_found_rows" : True,
                "sql_small_result" : True,
                "ssl" : True,
                "starting" : True,
                "straight_join" : True,
                "table" : True,
                "terminated" : True,
                "then" : True,
                "tinyblob" : True,
                "tinyint" : True,
                "tinytext" : True,
                "to" : True,
                "trailing" : True,
                "trigger" : True,
                "true" : True,
                "undo" : True,
                "union" : True,
                "unique" : True,
                "unlock" : True,
                "unsigned" : True,
                "update" : True,
                "usage" : True,
                "use" : True,
                "using" : True,
                "utc_date" : True,
                "utc_time" : True,
                "utc_timestamp" : True,
                "values" : True,
                "varbinary" : True,
                "varchar" : True,
                "varcharacter" : True,
                "varying" : True,
                "when" : True,
                "where" : True,
                "while" : True,
                "with" : True,
                "write" : True,
                "xor" : True,
                "year_month" : True,
                "zerofill" : True,
            );

            #! Maximum precision
            const MysqlMaxPrecision = 65;
        }

        private {
            string schema;

            #! separate datasource dedicated for our sequence implementation with autonomous transactions
            Datasource seqds;

            string sequence_table = "sqlutil_sequences";
            string sequence_function = "sqlutil_nextval";
        }

        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
            schema = opts.schema ? opts.schema : ds.getDBName();

            if (opts.sequence_table)
                sequence_table = opts.sequence_table;

            if (opts.sequence_function)
                sequence_function = opts.sequence_function;

            seqds = new Datasource(ds.getConfigString());
        }

        #! Returns @ref True if the driver requires a scale to support decimal values in numeric or decimal columns
        /** @return @ref True if the driver requires a scale to support decimal values in numeric or decimal columns

            @since %MysqlSqlUtil 1.4.3
        */
        bool requiresScale() {
            return True;
        }

        #! Returns the maximum precision for numeric or decimal columns
        /** @return -1 means, no maximum

            @since %MysqlSqlUtil 1.4.3
        */
        int getMaximumPrecision() {
            return MysqlMaxPrecision;
        }

        private list<string> featuresImpl() {
            return list(DB_FUNCTIONS, DB_PROCEDURES,
                        DB_TABLES, DB_VIEWS);
        }

        string getSchemaName() {
            return schema;
        }

        private AbstractSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return new MysqlSequence(sequence_table, name, start, increment, end);
        }

        private *AbstractSequence getSequenceImpl(string name) {
            *AbstractTable t = getTable(sequence_table);
            if (!t)
                return;
            *string str = ds.selectRow("select name from %s where name = %v", sequence_table, name).name;
            if (!str)
                return;
            return new MysqlSequence(sequence_table, name);
        }

        private *AbstractView getViewImpl(string name) {
            *string schema;
            parse_schema_name(name, \schema, \name);

            *hash<auto> row = ds.selectRow("select * from information_schema.views where table_schema = %v and table_name = %v", schema, name);
            if (!row)
                return;

            return new MysqlView(name, row.view_definition, row.table_catalog,
                                 row.table_schema, row.check_option, row.definer,
                                 row.security_type, row.is_updatable);
        }

        private MysqlFunction makeFunctionImpl(string name, string src, *hash opts) {
            trim src;
            return new MysqlFunction(name, src);
        }

        private MysqlFunction makeProcedureImpl(string name, string src, *hash opts) {
            return makeFunctionImpl(name, src, opts);
        }

        private *AbstractFunction getFunctionImpl(string name) {
            *string sm = (name =~ x/^(\w+)\.\w+$/[0]);
            if (sm)
                splice name, 0, sm.size() + 1;
            else
                sm = schema;
            *hash qh = ds.selectRow("select * from information_schema.routines where routine_name = %v and routine_schema = %v", name, sm);
            if (!qh)
                return;

            # get arguments
            *list al = ds.selectRows("select * from information_schema.parameters where specific_name = %v and specific_schema = %v order by ordinal_position", name, sm);

            string rt;
            list params = ();
            if (al) {
                rt = MysqlDatabase::makeParameter(shift al);

                map params += MysqlDatabase::makeParameter($1), al;
            }

            string src = sprintf("%s(%s) returns %s\n%s", name, (foldl $1 + ", " + $2, params), rt, qh.routine_definition);
            return new MysqlFunction(name, src);
        }

        private static string makeParameter(hash<auto> row) {
            string str;
            if (row.parameter_name)
                str = row.parameter_name + " ";
            str += row.data_type;
            if (row.character_maximum_length)
                str += sprintf("(%d)", row.character_maximum_length);
            else if (row.numeric_precision) {
                str += sprintf("(%d", row.numeric_precision);
                if (row.numeric_scale)
                    str += sprintf(",%d", row.numeric_scale);
                str += ")";
            }
            return str;
        }

        private AbstractFunction getProcedureImpl(string name) {
            return getFunctionImpl(name);
        }

        private list getDropSchemaSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                return l;
            }

            return l;
        }

        private list getAlignSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                # if there are any sequences, then we need to make sure the sequence table and function exist
                if (schema_hash.sequences) {
                    # first create / align table
                    Table st(ds, MysqlSequenceTable, sequence_table, opt{MysqlTable::MysqlTableCreationOptions.keys()});
                    Table dbst(ds, sequence_table);
                    list tl = dbst.getAlignSql(st.getTable(), opt{MysqlTable::MysqlAlignTableOptions.keys()});
                    if (tl)
                        l += tl;

                    # create / align function
                    string fstr = sprintf(MysqlSequenceFunction, sequence_function, sequence_table);
                    tl = getAlignFunctionSql(new MysqlFunction(sequence_function, fstr), opt{MysqlDatabase::CreationOptions.keys()});
                    if (tl)
                        l += tl;
                }
                return l;
            }

            return l;
        }

        #! returns a list of string table names in the database
        private list<string> listTablesImpl() {
            return ds.select("select table_name from information_schema.tables where table_schema = %v", schema).table_name;
        }

        #! returns a list of string function names in the database
        /** The function names will include arguments in parentheses after the names

            @return a list of string function names in the database
        */
        private list<string> listFunctionsImpl() {
            *hash qh = ds.select("select routine_name from information_schema.routines where routine_schema = %v and routine_type = 'FUNCTION'");
            return qh.routine_name;
        }

        #! returns a list of string procedure names in the database
        /** The procedure names will include arguments in parentheses after the names

            @return a list of string procedure names in the database
        */
        private list<string> listProceduresImpl() {
            *hash qh = ds.select("select routine_name from information_schema.routines where routine_schema = %v and routine_type = 'PROCEDURE'");
            return qh.routine_name;
        }

        private list<string> listSequencesImpl() {
            *AbstractTable t = getTable(sequence_table);
            if (!t)
                return ();
            return ds.select("select name from %s", sequence_table).name;
        }

        private list<string> listViewsImpl() {
            return ds.select("select table_name from information_schema.views where table_schema = %v", schema).table_name;
        }

        private string getCreateSqlImpl(list l) {
            return MysqlDatabase::getCreateSql(l);
        }

        static string getCreateSql(list l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l);
        }

        #! returns driver-specific options to the base abstract class
        private hash getDatabaseOptions() {
            return MysqlDatabaseOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getSchemaDescriptionOptions() {
            return MysqlSchemaDescriptionOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getComputeStatisticsOptions() {
            return MysqlComputeStatisticsOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getReclaimSpaceOptions() {
            return MysqlReclaimSpaceOptions;
        }

        #! returns the next value in the given sequence
        private softint getNextSequenceValueImpl(string name) {
            on_error seqds.rollback();
            on_success seqds.commit();
            return seqds.selectRow("select %s(%v) as my_nextval", sequence_function, name).my_nextval;
        }

        #! returns the last value issued for the given sequence in the current session
        private softint getCurrentSequenceValueImpl(string name) {
            throw "MYSQL-SEQUENCE-ERROR", "currval is not supported for emulated MySQL sequences";
        }

        #! returns @ref True "True" since we have a workaround implementation for sequences in MySQL
        private bool supportsSequencesImpl() {
            return False;
        }

        #! returns @ref True "True" if the database supports named types
        private bool supportsTypesImpl() {
            return False;
        }

        #! returns @ref True "True" if the database supports packages
        private bool supportsPackagesImpl() {
            return False;
        }

        #! rebuild index implementation. See @ref SqlUtil::AbstractDatabase::rebuildIndex()
        private bool rebuildIndexImpl(string name, *hash options) {
            throw "REBUILD-INDEX-ERROR", "MySQL does not support index rebuilding. Use reclaimSpace()";
        }

        #! compute statistics implementation. See @ref SqlUtil::AbstractDatabase::computeStatistics()
        private computeStatisticsImpl(*hash options) {
            string sql = "analyze ";
            sql += options."no-binlog" ? "no_write_to_binlog " : "local ";
            sql += "table ";

            softlist tables = options.tables ? options.tables : listTables();

            sql += sprintf("%s", tables.join(", "));

            ds.select(sql);
        }

        #! reclaim space implementation. See @ref SqlUtil::AbstractDatabase::reclaimSpace()
        private reclaimSpaceImpl(*hash options) {
            string sql = "optimize ";
            sql += options."no-binlog" ? "no_write_to_binlog " : "local ";
            sql += "table ";

            softlist tables = options.tables ? options.tables : listTables();

            sql += sprintf("%s", tables.join(", "));

            ds.select(sql);
        }

        #! @ref SqlUtil::AbstractDatabase.getPhysicalSize()
        private int getPhysicalSizeImpl() {
            *string dbname = ds.getDBName();
            if (!exists dbname) {
                return GET_PHYSICAL_DB_SIZE_NOVAL;
            }
            return ds.selectRow("select sum(data_length + index_length) as val
                                    from information_schema.tables
                                    where table_schema = %v", dbname).val ?? GET_PHYSICAL_DB_SIZE_NOVAL;
        }
    }

    #! provides the MySQL-specific implementation of the AbstractTable interface
    public class MysqlTable inherits SqlUtil::AbstractTable {
        public {
            #! maps mysql type names to type configurations
            const MysqlTypeMap = {
                "decimal": {
                    "qore": Type::Number,
                    "size": SZ_NUM,
                },
                "tinyint": ("qore": Type::Int, "ai": True,),
                "smallint": ("qore": Type::Int, "ai": True,),
                "mediumint": ("qore": Type::Int, "ai": True,),
                "int": ("qore": Type::Int, "ai": True,),
                "bigint": ("qore": Type::Int, "ai": True,),
                "float": ("qore": Type::Float, "ai": True,),
                "double": ("qore": Type::Float, "ai": True,),

                "date": ("qore": Type::Date,),
                "datetime": ("qore": Type::Date,),
                "timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "time": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6), "default_size": 6,),
                "year": ("qore": Type::Int,),

                "char": {
                    "qore": Type::String,
                    "size": SZ_OPT,
                    "size_range": (0, 255),
                },
                "varchar": {
                    "qore": Type::String,
                    "size": SZ_MAND,
                    "size_range": (0, 65535),
                    "default_size": AbstractColumn::DefaultVarcharSize,
                },

                "binary": ("qore": Type::Binary, "size": SZ_OPT, "size_range": (0, 255)),
                "varbinary": {
                    "qore": Type::Binary,
                    "size": SZ_MAND,
                    "size_range": (0, 65535),
                    "default_size": 80,
                },

                "tinytext": ("qore": Type::String,),
                "text": ("qore": Type::String,),
                "mediumtext": ("qore": Type::String,),
                "longtext": ("qore": Type::String,),

                "tinyblob": ("qore": Type::Binary,),
                "blob": ("qore": Type::Binary,),
                "mediumblob": ("qore": Type::Binary,),
                "longblob": ("qore": Type::Binary,),

                "bit": ("qore": Type::Int,),
            };

            #! maps qore type names to MySQL type names
            const QoreTypeMap = (
                "integer": "bigint",
                "float": "double",
                "number": "decimal",
                "string": "varchar",
                "date": "timestamp",
                "binary": "varbinary",
                "bool": "tinyint",
                SqlUtil::CHAR: "char",
                SqlUtil::CLOB: "mediumtext",
                SqlUtil::BLOB: "mediumblob",
            );

            #! extends @ref SqlUtil::AbstractTable::TableDescriptionHashOptions
            /** the following options are added:
                - \c "engine": for the DB engine behind the table (default: \c innodb)
                - \c "collation": for the table collation (if not set, any \c "collation" option set in the datasource
                  is used for the table collation)
                - \c "table_encoding": the "character set" value for "create table" DDL statements (if not set, the
                  DB encoding value used for the datasource will be used)
            */
            const MysqlTableDescriptionHashOptions = AbstractTable::TableDescriptionHashOptions + (
                "engine": Type::String,
                "collation": Type::String,
                "table_encoding": Type::String,
            );

            #! extends @ref SqlUtil::AbstractTable::ColumnDescOptions with MySQL-specific values
            /** the new keys are as follows:
                - \c "unsigned": only valid with numeric/integer/floating-point types
                - \c "auto_increment": only valid with integer/floating-point types
                - \c "pk": only valid with \c "auto_increment"
            */
            const MysqlColumnDescOptions = AbstractTable::ColumnDescOptions + (
                "unsigned": Type::Boolean,
                "auto_increment": Type::Boolean,
                "pk": Type::Boolean,
            );

            const MysqlIndexOptions = AbstractTable::IndexOptions;

            const MysqlConstraintOptions = AbstractTable::ConstraintOptions + MysqlIndexOptions + (
                "index": Type::String,
            );

            const MysqlTableCreationOptions = AbstractTable::TableCreationOptions + MysqlConstraintOptions;

            const MysqlAlignTableOptions = AbstractTable::AlignTableOptions + MysqlTableCreationOptions;

            #! column operator specializations for MySQL
            const MysqlCopMap = (
                COP_CAST: (
                    "code": string sub (string cve, list<auto> args) {
                        string name = QoreTypeMap{args[0]} ?? args[0];
                        if (name == "varchar") name = "char"; # NOTE: due to current MariaSQL issue ("ERROR 1064 (42000)")
                        hash desc = MysqlTypeMap{name};
                        string sql = sprintf ("cast(%s as %s", cve, name);
                        switch (name) {
                            default:
                                if (desc.size == SZ_MAND) {
                                    if (!exists args[1] && !exists desc.size_range)
                                        throw "OPERATOR-ERROR", sprintf ("op_cast operator missing size for type %s", name);
                                    sql += sprintf("(%d)", args[1] ?? desc.size_range[1]);
                                } else if (desc.size == SZ_NUM && exists args[1]) {
                                    sql += sprintf("(%d", args[1]);
                                    sql += exists args[2] ? sprintf(",%d)", args[2]) : ")";
                                } else if (desc.size == SZ_OPT && exists args[1]) {
                                    sql += sprintf("(%d)", args[1]);
                                }
                        }
                        sql += ")";
                        return sql;
                    },
                ),
                COP_PREPEND: (
                    "arg": Type::String,
                    "sqlvalue": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("concat(%s,%s)", arg, cve);
                    },
                ),
                COP_APPEND: (
                    "arg": Type::String,
                    "sqlvalue": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("concat(%s,%s)", cve, arg);
                    },
                ),
                COP_YEAR: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("date_format(%s, '%%Y')", arg1);
                    }
                ),
                COP_YEAR_MONTH: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("date_format(%s, '%%Y-%%m')", arg1);
                    }
                ),
                COP_YEAR_DAY: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("date_format(%s, '%%Y-%%m-%%e')", arg1);
                    }
                ),
                COP_YEAR_HOUR: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("date_format(%s, '%%Y-%%m-%%e %%k')", arg1);
                    }
                ),
                COP_TRUNC_DATE: (
                    "code": string sub(string arg1, auto arg) {
                        if (!MysqlTruncDate.hasKey(arg)) {
                            throw "COP-TRUNC-DATE-ERROR", sprintf("Not allowed format argument: %y: allowed: %y",
                                arg, MysqlTruncDate.keys());
                        }
                        return sprintf("cast(date_format(%s, %s) as datetime)", arg1, MysqlTruncDate{arg});
                    }
                )
            );

            #! MySQL Expression map
            const MysqlExpressionMap = DefaultExpressionMap + {
                COP_CAST: {
                    "exp": <DataProviderExpressionInfo>{
                        "type": DET_Operator,
                        "label": COP_CAST,
                        "name": "cast",
                        "desc": "cast operator",
                        "symbol": "cast",
                        "args": (
                            DataProviderSignatureAnyType,
                            DataProviderSignatureStringValueType,
                            DataProviderSignatureOptionalIntValueType,
                            DataProviderSignatureOptionalIntValueType),
                        "varargs": True,
                        "return_type": AbstractDataProviderTypeMap."any",
                    },
                    "code": string sub (reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."any");
                        string name = QoreTypeMap{args[1]} ?? args[1];
                        *hash<auto> desc = MysqlTypeMap{name};
                        string sql = sprintf ("cast (%s as %s", exp0, name);
                        if (desc.size == SZ_MAND) {
                            if (!exists args[1] && !exists desc.size_range)
                                throw "OPERATOR-ERROR", sprintf ("cast operator missing size for type %s",
                                    name);
                            sql += sprintf("(%d)", args[1] ?? desc.size_range[1]);
                        } else if (desc.size == SZ_NUM && exists args[1]) {
                            sql += sprintf("(%d", args[1]);
                            sql += exists args[2] ? sprintf(",%d)", args[2]) : ")";
                        } else if (desc.size == SZ_OPT && exists args[1]) {
                            sql += sprintf("(%d)", args[1]);
                        }
                        sql += ")";
                        return sql;
                    },
                },
                COP_PREPEND: DefaultExpressionMap{COP_PREPEND} + {
                    "code": string sub (reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."string");
                        string exp1 = info.table.getExpressionArg(\info, role, args[1],
                            AbstractDataProviderTypeMap."string");
                        return sprintf("concat(%s, %s)", exp1, exp0);
                    },
                },
                COP_APPEND: DefaultExpressionMap{COP_APPEND} + {
                    "code": string sub (reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."string");
                        string exp1 = info.table.getExpressionArg(\info, role, args[1],
                            AbstractDataProviderTypeMap."string");
                        return sprintf("concat(%s, %s)", exp0, exp1);
                    },
                },
                COP_YEAR: {
                    "exp": <DataProviderExpressionInfo>{
                        "type": DET_Operator,
                        "label": COP_YEAR,
                        "name": COP_YEAR,
                        "desc": "returns the year component of a date as a string (ex: `2022`)",
                        "symbol": COP_YEAR,
                        "args": (
                            DataProviderSignatureDateType,
                        ),
                        "return_type": AbstractDataProviderTypeMap."string",
                    },
                    "code": string sub (reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."date");
                        return sprintf("date_format(%s, '%%Y')", exp0);
                    }
                },
                COP_YEAR_MONTH: {
                    "exp": <DataProviderExpressionInfo>{
                        "type": DET_Operator,
                        "label": COP_YEAR_MONTH,
                        "name": COP_YEAR_MONTH,
                        "desc": "returns the year and month components of a date as a string (ex: `2022-06`)",
                        "symbol": COP_YEAR_MONTH,
                        "args": (
                            DataProviderSignatureDateType,
                        ),
                        "return_type": AbstractDataProviderTypeMap."string",
                    },
                    "code": string sub (reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."date");
                        return sprintf("date_format(%s, '%%Y-%%m')", exp0);
                    }
                },
                COP_YEAR_DAY: {
                    "exp": <DataProviderExpressionInfo>{
                        "type": DET_Operator,
                        "label": COP_YEAR_DAY,
                        "name": COP_YEAR_DAY,
                        "desc": "returns the year, month, and day components of a date as a string (ex: `2022-06-29`)",
                        "symbol": COP_YEAR_DAY,
                        "args": (
                            DataProviderSignatureDateType,
                        ),
                        "return_type": AbstractDataProviderTypeMap."string",
                    },
                    "code": string sub (reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."date");
                        return sprintf("date_format(%s, '%%Y-%%m-%%e')", exp0);
                    }
                },
                COP_YEAR_HOUR: {
                    "exp": <DataProviderExpressionInfo>{
                        "type": DET_Operator,
                        "label": COP_YEAR_HOUR,
                        "name": COP_YEAR_HOUR,
                        "desc": "returns the year, month, day, and hour components of a date as a string "
                            "(ex: `2022-06-29 15`)",
                        "symbol": COP_YEAR_HOUR,
                        "args": (
                            DataProviderSignatureDateType,
                        ),
                        "return_type": AbstractDataProviderTypeMap."string",
                    },
                    "code": string sub (reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."date");
                        return sprintf("date_format(%s, '%%Y-%%m-%%e %%k')", exp0);
                    }
                },
                COP_TRUNC_DATE: {
                    "exp": <DataProviderExpressionInfo>{
                        "type": DET_Operator,
                        "label": COP_TRUNC_DATE,
                        "name": COP_TRUNC_DATE,
                        "desc": "truncates the given date to the given resolution; args: date, string code: Y: year, "
                            "M: month, D: day, H: hour, m: minute, S: second",
                        "symbol": COP_TRUNC_DATE,
                        "args": (
                            DataProviderSignatureDateType,
                            DataProviderSignatureStringValueType,
                        ),
                        "return_type": AbstractDataProviderTypeMap."date",
                    },
                    "code": string sub(reference<hash<QueryInfo>> info, int role, list<auto> args) {
                        *string str = MysqlTruncDate{args[1]};
                        if (!str) {
                            throw "COP-TRUNC-DATE-ERROR", sprintf("unknown date truncation format argument %y; "
                                "supported date format arguments: %y", args[1], keys MysqlTruncDate);
                        }
                        string exp0 = info.table.getExpressionArg(\info, role, args[0],
                            AbstractDataProviderTypeMap."date");
                        return sprintf("cast(date_format(%s, %s) as datetime)", exp0, str);
                    },
                },
            };

            #! where operator specializations for MySQL
            const MysqlOpMap = DefaultOpMap + {
                COP_PREPEND: {
                    "arg": Type::String,
                    "sqlvalue": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("concat(%s, %s)", arg, cve);
                    },
                },
                COP_APPEND: {
                    "arg": Type::String,
                    "sqlvalue": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("concat(%s, %s)", cve, arg);
                    },
                },
            };

            #! Map @ref SqlUtil::cop_trunc_date() constants for internal masks
            const MysqlTruncDate = {
                DT_YEAR  : "'%Y-01-01 00:00:00'",
                DT_MONTH : "'%Y-%m-01 00:00:00'",
                DT_DAY   : "'%Y-%m-%d 00:00:00'",
                DT_HOUR  : "'%Y-%m-%d %H:00:00'",
                DT_MINUTE: "'%Y-%m-%d %H:%i:00'",
                DT_SECOND: "'%Y-%m-%d %H:%i:%s'",
            };
        }

        private {
            string schema;
            string engine = "innodb";
            string collation;
            string table_encoding;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a schema in the name
            *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
            if (sstr) {
                schema = sstr;
                splice nname, 0, schema.size() + 1;
                name = nname;
            }
            else
                schema = ds.getDBName();

            if (opts.engine) {
                engine = opts.engine;
            }
            if (opts.collation) {
                collation = opts.collation;
            }
            if (opts.table_encoding) {
                table_encoding = opts.table_encoding;
            }
        }

        #! returns the name of the table to be used in SQL (with a possible qualifiers for schema, etc)
        string getSqlName() {
            return schema + "." + name;
        }

        #! Returns the expression map for MySQL
        hash<auto> getExpressionMap() {
            return MysqlExpressionMap;
        }

        #! returns the "where" operator map for MySQL
        hash<auto> getWhereOperatorMap() {
            return MysqlOpMap;
        }

        private hash getTableCreationOptions() {
            return MysqlTableCreationOptions;
        }

        private hash getTableDescriptionHashOptions() {
            return MysqlTableDescriptionHashOptions;
        }

        private hash getColumnDescOptions() {
            return MysqlColumnDescOptions;
        }

        private hash getIndexOptions() {
            return MysqlIndexOptions;
        }

        private hash getConstraintOptions() {
            return MysqlConstraintOptions;
        }

        private hash getAlignTableOptions() {
            return MysqlAlignTableOptions;
        }

        #! returns the column operator map for this object
        private hash getColumnOperatorMapImpl() {
            return MysqlCopMap;
        }

        private bool checkExistenceImpl() {
            *hash qh = ds.selectRow("select * from information_schema.tables where table_name = %v and table_schema = %v", name, schema);
            if (qh)
                return inDb = True;
            return False;
        }

        private Columns describeImpl() {
            # get column descriptions
            *hash qh = ds.select("select * from information_schema.columns where table_name = %v and table_schema = %v order by ordinal_position", name, schema);
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                #printf("%y: %s\n", row.column_name, row.column_type);
                bool unsigned = False;
                if (row.column_type =~ / unsigned$/) {
                    unsigned = True;
                    row.column_type =~ s/ unsigned$//;
                }

                softint size = row.character_maximum_length ?? row.numeric_precision ?? 0;

                if (row.column_type == "year(2)")
                    size = 2;

                # remove size from type name
                row.column_type =~ s/\(.*\)$//;

                *hash th = MysqlTypeMap.(row.column_type);
                switch (row.column_type) {
                    case "tinyint":
                    case "smallint":
                    case "mediumint":
                    case "int":
                    case "bigint":
                    case "double":
                    case "float":
                    case /text$/:
                    case /blob$/: {
                        row.numeric_precision = 0;
                        size = 0;
                        break;
                    }
                }

                MysqlColumn c;
                auto defval = exists row.column_default && row.column_default !== NULL && row.column_default != "NULL"
                    ? row.column_default
                    : NOTHING;
                if (exists defval) {
                    # process default value according to column type
                    switch (th.qore) {
                        case Type::Int: defval = defval.toInt(); break;
                        case Type::Float: defval = defval.toFloat(); break;
                        case Type::Number: defval = defval.toNumber(); break;
                        case Type::Date: {
                            try {
                                defval = date(defval);
                            } catch (hash<ExceptionInfo> ex) {
                                # ignore INVALID-DATE; keep text (ex: "CURRENT_TIMESTAMP")
                                if (ex.err != "INVALID-DATE")
                                    rethrow;
                            }
                        }
                        case Type::String: {
                            if (defval =~ /^'.*'$/) {
                                defval = defval[1..(defval.size() - 2)];
                                defval =~ s/''/'/g;
                            }
                            break;
                        }
                        # don't know what to do with Type::Binary ???
                        default: break;
                    }
                    defval = getSqlValue(defval);
                }
                bool ai = row.extra == "auto_increment";

                if (row.column_comment =~ /^'.*'$/) {
                    row.column_comment = row.column_comment[1..(row.column_comment.size() - 2)];
                    row.column_comment =~ s/''/'/g;
                }

                if (row.numeric_precision || unsigned || ai) {
                    c = new MysqlNumericColumn(row.column_name, row.column_type, th.qore, row.numeric_precision,
                        row.is_nullable == "YES", defval, row.column_comment ? row.column_comment : NOTHING, 0,
                        row.numeric_scale, unsigned, ai, row.column_key == "PRI");
                } else {
                    c = new MysqlColumn(row.column_name, row.column_type, th.qore, exists size ? size : 0,
                        row.is_nullable == "YES", defval, row.column_comment ? row.column_comment : NOTHING,
                        row.character_octet_length);
                }

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private *string getCreatePrimaryKeySqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                return;
            # if we are creating the entire table and there is a column marked "primary key", then skip this
            if (opt.create_table_all) {
                foreach MysqlColumn c in (columns.iterator()) {
                    if (c instanceof MysqlNumericColumn && cast<MysqlNumericColumn>(c).pk) {
                        return;
                    }
                }
            }
            return AbstractDatabase::doCallback(opt, primaryKey.getCreateSql(name, opt), AbstractDatabase::AC_Add, "primary key", primaryKey.getName(), name);
        }

        private MysqlPrimaryKey getPrimaryKeyImpl() {
            hash rv;

            # get primary key description
            *hash qh = ds.select("select column_name from information_schema.key_column_usage k where constraint_name = 'PRIMARY' and table_name = %v and table_schema = %v order by ordinal_position", name, schema);
            if (!qh.column_name)
                return new MysqlPrimaryKey();

            #printf("MysqlTable::getPrimaryKeyImpl(): %s: %N\n", getName(), qh);
            foreach string col in (qh.column_name)
                rv{col} = columns{col};

            return new MysqlPrimaryKey(rv);
        }

        private Indexes getIndexesImpl() {
            hash rv;

            # get index descriptions
            *hash qh = ds.select("select index_name, non_unique, column_name, index_type from information_schema.statistics s where index_name != 'PRIMARY' and table_name = %v and table_schema = %v order by index_name, seq_in_index", name, schema);

            if (qh.index_name) {
                hash<auto> ih;
                foreach hash<auto> row in (qh.contextIterator()) {
                    if (!ih.(row.index_name)) {
                        ih.(row.index_name) = (
                            "unique": !row.non_unique,
                            "type": row.index_type,
                        );
                    }
                    # send "blank" column for function index
                    if (row.column_name =~ /\(.*\)/ || !columns.hasKey(row.column_name))
                        ih.(row.index_name).columns{row.column_name} = {};
                    else
                        ih.(row.index_name).columns{row.column_name} = columns{row.column_name};
                }

                foreach hash<auto> i in (ih.pairIterator()) {
                    rv.(i.key) = new MysqlIndex(i.key, i.value.unique, i.value.columns, i.value.index_type);
                }
            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl(*hash opts) {
            hash rv;
            # get foreign referential constraints
            # FIXME: use schema name
            *hash qh = ds.select("select t.constraint_name, column_name source_column, referenced_table_name target_table, referenced_column_name target_column from information_schema.table_constraints t inner join information_schema.key_column_usage k on (t.constraint_schema = k.constraint_schema and t.table_name = k.table_name and t.table_schema = k.table_schema and t.constraint_name = k.constraint_name) where constraint_type = 'FOREIGN KEY' and t.table_name = %v and t.table_schema = %v order by position_in_unique_constraint", name, schema);
            if (qh.constraint_name) {
                hash ch;
                foreach hash<auto> row in (qh.contextIterator()) {
                    reference<hash> c = \ch.(row.constraint_name);
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                foreach hash c in (ch.pairIterator()) {
                    # get a description of the target table's columns
                    Columns targ_columns = getReferencedTableColumnsUnlocked(c.value.target.table, opts.table_cache);
                    ForeignConstraintTarget fct(c.value.target.table, targ_columns.subset(c.value.target.columns.keys()));
                    rv.(c.key) = new MysqlForeignConstraint(c.key, new Columns(c.value.columns), fct);
                }
            }

            return new ForeignConstraints(rv);
        }

        private Constraints getConstraintsImpl() {
            # mysql does not support check constraints
            hash rv;

            Constraints c = new Constraints(rv);

            # get unique constraints
            *hash<auto> qh = ds.select("select t.constraint_name, column_name from "
                "information_schema.table_constraints t "
                "inner join information_schema.key_column_usage k on (t.constraint_schema = k.constraint_schema and "
                "t.table_name = k.table_name and t.table_schema = k.table_schema and t.constraint_name = "
                "k.constraint_name) where constraint_type = 'UNIQUE' and t.table_name = %v and t.table_schema = %v "
                "order by ordinal_position", name, schema);
            delete rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                reference<MysqlUniqueConstraint> ch = \rv.(row.constraint_name);
                if (!ch)
                    ch = new MysqlUniqueConstraint(row.constraint_name, {});
                ch.add(row.column_name, columns{row.column_name});
            }

            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();

            return c;
        }

        private Triggers getTriggersImpl() {
            hash rv;

            # get trigger description
            *hash<auto> qh = ds.select("select * from information_schema.triggers where event_object_table = %v and "
                "event_object_schema = %v", name, schema);

            foreach hash<auto> row in (qh.contextIterator()) {
                string src = sprintf("%s %s on %s for each %s %s", row.action_timing.lwr(),
                    row.event_manipulation.lwr(), name, row.action_orientation.lwr(), row.action_statement);
                rv{row.trigger_name} = new MysqlTrigger(row.trigger_name, src);
            }

            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(self), columns.iterator());
            sql += sprintf("\n) engine %s", engine);
            {
                *string encoding = self.table_encoding ?? ds.getDBEncoding();
                if (encoding.val()) {
                    sql += sprintf(" character set %s", encoding);
                }
            }
            {
                # get collation option or connection option, if any
                *string collation = self.collation ?? ds.getOption("collation");
                if (collation) {
                    sql += sprintf(" collate %s", collation);
                }
            }

            return sql;
        }

        #! returns @ref False "False" because the mysql driver does not support array binds / bulk DML operations
        bool hasArrayBind() {
            return False;
        }

        private *list getCreateMiscSqlImpl(*hash opt, bool cache) {
        }

        private *list getAlignSqlImpl(AbstractTable table, *hash opt) {
        }

        private string getCreateSqlImpl(list l) {
            return MysqlDatabase::getCreateSql(l);
        }

        private string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash<auto> opt, bool nullable = True) {
            on_error rethrow $1.err, sprintf("%s (table %y column %y: %y)", $1.desc, getSqlName(), cname, opt);
            if (opt.precision || opt.auto_increment || opt.unsigned
                || (MysqlTypeMap{opt.native_type}.type == Type::Number)
                || (opt.qore_type == Type::Number))
                return new MysqlNumericColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable,
                    opt.default_value, opt.comment, 0, opt.scale, opt.unsigned, opt.auto_increment, opt.pk);
            return new MysqlColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value,
                opt.comment, 0);
        }

        private setPrimaryKeyUnlocked(AbstractPrimaryKey pk) {
            AbstractTable::setPrimaryKeyUnlocked(pk);
            if (pk.size() == 1 && columns.hasKey(pk.getName()) && columns{pk.getName()} instanceof MysqlNumericColumn) {
                MysqlNumericColumn c = columns{pk.getName()};
                if (c.auto_increment && !c.pk)
                    c.pk = True;
            }
        }

        private addColumnToTableUnlocked(AbstractColumn c) {
            AbstractTable::addColumnToTableUnlocked(c);
            # see if column has "auto_increment" set and handle unique indexes and primary keys
            if (c instanceof MysqlNumericColumn) {
                MysqlNumericColumn nc = c;
                if (nc.auto_increment) {
                    MysqlIndex ix;
                    # see if a unique index already exists with this name
                    if (indexes.hasKey(c.name)) {
                        ix = indexes{c.name};
                        if (!ix.unique)
                            throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a unique index for the table does not match with the existing index's definition which is not unique; columns: %y", name, c.name, ix.columns.keys());
                        if (ix.columns.size() > 1 || ix.columns.firstKey() != c.name)
                            throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a unique index for the table does not match with the existing index's column definition: %y", name, c.name, ix.columns.keys());
                    }
                    /*
                    else {
                        if (!indexes)
                            indexes = new Indexes();
                        ix = new MysqlIndex(c.name, True, columns.(list(c.name)));
                        indexes.add(c.name, ix);
                    }
                    */

                    AbstractUniqueConstraint uk;
                    if (nc.pk) {
                        # add primary key if not present
                        if (!primaryKey.empty()) {
                            if (primaryKey.size() > 1 || primaryKey.firstKey() != c.name)
                                throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a primary key for the table does not match with the existing primary key column definition: %y", name, c.name, primaryKey.keys());
                        }
                        else
                            primaryKey = new MysqlPrimaryKey(columns.(list(c.name)));
                        uk = primaryKey;
                    } else {
                        # see if a unique constraint already exists with this name
                        if (constraints.hasKey(c.name)) {
                            if (!(constraints{c.name} instanceof AbstractUniqueConstraint))
                                throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a unique constraint for the table does not match with the existing constraint type: %y", name, c.name, constraints{c.name}.className());

                            uk = constraints{c.name};
                            if (uk.size() > 1 || uk.firstKey() != c.name)
                                throw "AUTO-INCREMENT-ERROR", sprintf("column %y.%y which has \"auto-increment\" set and is also flagged as a unique constraint for the table does not match with the existing unique constraint's column definition: %y", name, c.name, uk.keys());
                        } else {
                            if (!constraints)
                                constraints = new Constraints();
                            uk = new MysqlUniqueConstraint(c.name, columns.(list(c.name)));
                            constraints.add(c.name, uk);
                        }
                    }
                    if (ix)
                        uk.setIndexBase(c.name);
                }
            }
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new MysqlPrimaryKey(ch);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new MysqlIndex(iname, enabled, ch, opt.index_type);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new MysqlForeignConstraint(cname, new Columns(ch), fct);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            throw "MYSQL-CHECK-CONSTRAINT-ERROR", sprintf("MySQL does not support check constraints");
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt) {
            return new MysqlUniqueConstraint(cname, ch);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new MysqlTrigger(tname, src);
        }

        private bool tryInsertImpl(string sql, hash<auto> row) {
            try {
                ds.vexec(sql, row.values());
            } catch (hash<ExceptionInfo> ex) {
                if (isDuplicateRowError(ex)) {
                    return False;
                }
                rethrow;
            }
            return True;
        }

        #! Returns True if the exception was raised because of a duplicate row / key error
        /** @since MysqlSqlUtil 1.4.2
        */
        private bool isDuplicateRowErrorImpl(hash<ExceptionInfo> ex) {
            return (ex.desc =~ /^Duplicate entry /);
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return MysqlTypeMap;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(auto v) {
            return MysqlTable::getSqlValueIntern(v);
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private static *string getSqlValueIntern(auto v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toString();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "true" : "false";

                case NT_DATE: {
                    # MySQL does not allow us to specify the UTC offset in the timestamp literal :(
                    TimeZone tz = TimeZone::get();
                    v = tz.date(v);
                    return "timestamp " + v.format("'YYYY-MM-DDTHH:mm:SS.us'");
                }
            }
        }

        #! returns the column name for use in SQL strings; subclasses can return a special string in case the column name is a reserved word
        /** MySQL/MariaDB etc require column names to be enclosed in backticks instead of double quotes
        */
        string getColumnSqlName(string col) {
            return MysqlDatabase::MysqlReservedWords{col.lwr()} ? ("`" + col + "`") : col;
        }

        #! returns a list of column names for use in SQL strings; subclasses can process the argument list in case a column name is a reserved word
        list getColumnSqlNames(softlist cols) {
            return map getColumnSqlName($1), cols;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code{.py}
string str = table.getSqlValue(date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver

            @throw VALUE-ERROR the given value cannot be converted to an SQL string (missing rules for value)
         */
        static *string getSqlValue(auto v) {
           *string str = MysqlTable::getSqlValueIntern(v);
            if (!exists str)
                throw "VALUE-ERROR", sprintf("class MysqlTable cannot convert type %y to an SQL string (value: %y)", v.type(), v);
            return str;
        }

        private bool emptyImpl() {
            return True;
        }

        private preSetupTableImpl(reference<hash> desc, *hash opt) {
            # see if there is an auto-increment column and set the primary key flag if it matches the primary key declaraion
            foreach string k in (desc.columns.keyIterator()) {
                if (desc.columns{k}.auto_increment) {
                    if (!desc.columns{k}.pk) {
                        if (desc.primary_key.columns.lsize() == 1) {
                            softlist cl = desc.primary_key.columns;
                            if (cl[0] == k) {
                                desc.columns{k}.pk = True;
                                # delete the primary key description; it will be added again when the column is added
                                delete desc.primary_key;
                            }
                        }
                    }
                    break;
                }
            }
        }

        private setupTableImpl(hash desc, *hash opt) {
        }

        #! returns @ref True "True" if the database links constraints to indexes (ie dropping the constraint drops the index, etc)
        private bool constraintsLinkedToIndexesImpl() {
            return True;
        }

        #! returns @ref True "True" if the database automatically creates a unique constraint when a unique index is created (ex: mysql)
        private bool uniqueIndexCreatesConstraintImpl() {
            return True;
        }

        #! returns @ref True "True" if the database support tablespaces
        private bool supportsTablespacesImpl() {
            return False;
        }

        #! processes a string for use in SQL select statements when there is a "limit" argument, but no "orderby" or "offset" arguments
        private doSelectLimitOnlyUnlockedImpl(reference<hash<QueryInfo>> info, reference<string> sql) {
           sql += " limit %v";
           info.args += info.query_hash.limit.toInt();
        }

        #! processes a string for use in SQL select statements when there is an "order by" and "offset" argument
        private doSelectOrderByWithOffsetSqlUnlockedImpl(reference<hash<QueryInfo>> info, reference<string> sql,
                list<auto> coll) {
            doSelectOrderBySqlUnlocked(info, \sql, coll);
            if (info.query_hash.limit) {
                sql += " limit %v";
                info.args += info.query_hash.limit.toInt();
            }

            if (info.query_hash.offset) {
                sql += " offset %v";
                info.args += info.query_hash.offset.toInt();
            }
        }

        #! returns @ref True if the database requires a wildcard \c "*" to be prefixed with the table name when it appears with other column arguments in a select statement
        private bool asteriskRequiresPrefix() {
            return True;
        }

        private *hash<auto> doReturningImpl(hash<auto> opt, reference<string> sql, list<auto> args) {
            throw "RETURNING-ERROR", sprintf("table %s: the mysql driver does not support the returning clause in an "
                "insert statement", getSqlName());
        }

        private list<auto> getGroupOrderByListUnlocked(hash<QueryInfo> info, string key, list<auto> coll) {
            list<auto> ce = ();
            foreach auto cv in (info.query_hash{key}) {
                switch (cv.typeCode()) {
                    case NT_STRING: {
                        if (cv.toInt() == cv) {
                            ce += cv;
                        } else {
                            ce += getColumnNameIntern(info, cv);
                        }
                        break;
                    }

                    case NT_HASH: {
                        ce += doColumnOperatorIntern(\info, cv);
                        break;
                    }

                    case NT_INT: {
                        ce += cv.toString();
                        break;
                    }

                    default:
                        throw "SELECT-ERROR", sprintf("%s: don't know how to parse argument type %y (value: %y) in "
                            "%s list, expecting \"string\" or \"hash\"", getDesc(), cv.type(), cv, key);
                }
            }
            return ce;
        }

        #! returns @ref True "True" if the current driver supports the \c "returning" clause in insert statements
        bool hasReturningImpl() {
            return False;
        }

        #! db-specific copy actions
        private copyImpl(AbstractTable old) {
        }

        #! returns the type for number / numeric columns for the database so that data conversions can be handled properly
        private AbstractDataProviderType getNumericTypeImpl(string native_type, bool nullable, *hash<auto> options) {
            return new MysqlNumberDataType(native_type, nullable, options);
        }

        #! get DB-specific savepoint helper
        /** @param savepoint the savepoint string, if not given a unique savepoint string will be generated

            @since SqlUtil 1.6
        */
        private AbstractSavepointHelper getSavepointHelperImpl(*string savepoint) {
            return new MysqlSavepointHelper(ds, savepoint);
        }
    }
}
