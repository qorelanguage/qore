# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file DebugCmdLine.qm Debug common code

/*  DebugCmdLine.qm Copyright 2013 - 2018 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.13
%requires(reexport) DebugUtil
%requires Util
%requires yaml

%require-types
%enable-all-warnings
%new-style
%no-debugging

module DebugCmdLine {
    version = "0.1.2";
    desc = "user module providing common command line debug stuff";
    author = "Tomas Mandys <tomas.mandys@qoretechnologies.org>";
    url = "http://qoretechnologies.org";
    license = "MIT";
}

/** @mainpage DebugCmdLine Module

    @tableofcontents

    @section debugcmdlineintro Introduction to the DebugCmdLine Module

    The %DebugCmdLine module provides common functionality for implementing debugger client utilities

    @subsection dcl_v0_1_2 v0.1.2
    - removed Linenoise stuff to new module
    - options API
    - source API

    @subsection dcl_v0_1_1 v0.1.1
    - fixed a bug parsing call signatures when setting breakpoints (<a href="https://github.com/qorelanguage/qore/issues/2601">issue 2601</a>)
    - improved breakpoint usability (<a href="https://github.com/qorelanguage/qore/issues/2604">issue 2604</a>)

    @subsection dcl_v0_1 v0.1
    - the initial version of the DebugCommandLine module
*/

#! the DebugCmdLine namespace contains all the definitions in the DebugCmdLine module
public namespace DebugCmdLine {

    /**
        When implementing a wrapper which executes program whose name is passed at command line then we can divide
        arguments usually into 3 groups, internal wrapper arguments, target program filename and program arguments.
        The class support argument parsing for such a case.

        Examples:
            (   # GetOpt options
                'help': 'h,help',
                'verbose': 'v,verbose',
                'listen': 'l,listen=s@',
            );
            wrapper-prog -v -l xxx trg -v -l    # trg is the target program name
            wrapper-prog -v -h trg xxx          # trg is the target program name
            wrapper-prog -v --listen=xxx trg    # trg is the target program name
            wrapper-prog -v --listen xxx trg    # trg is the target program name
        **/
    public class WrapperGetOpt inherits GetOpt {
        #! create the object with the given @ref Qore::GetOpt "GetOpt" option hash
        public constructor(hash options) : GetOpt(options) {
        }

        #! Parses input arguments until a standalone argument is found.
        /**
            @param args @ref list of arguments passed to wrapper, typically ARGV
            @param wrp_args returns list of wrapper arguments
            @param pgm_name returns the target program filename; "" is considered a special file name (meaning \c stdin), NOTHING when no name provided
            @param pgm_args return @ref list of target program arguments

            @par Example:
            @code{.py}
            hash opts = (
                'help': 'h,help',
                'verbose': 'v,verbose',
                'listen': 'l,listen=s@',
            );
            WrapperGetOpt g(opts);
            list dargs;
            hash opt;
            *string fileName;
            g.split(ARGV, \dargs, \fileName, \ARGV);

            try {
                opt = g.parse2(\dargs);
            } catch (hash<ExceptionInfo> ex) {
                stderr.printf("%s: %s\n", ex.err, ex.desc);
                help(-1);
            }

            if (exists fileName) {
                stderr.print("No input file\n");
                exit(-1);
            }
            @endcode
        **/
        public split(list<string> args, reference<list<string>> wrp_args, reference<*string> pgm_name, reference<list<string>> pgm_args) {
            pgm_name = NOTHING;
            wrp_args = new list<string>();
            pgm_args = new list<string>();
            while (args) {
                string s = shift args;
                push wrp_args, s;
                if (s !~ /^\-/ ) {
                    list a = wrp_args;
                    parse(\a);
                    if (a) {
                        # last arg is filename
                        pgm_name = s;
                        pop wrp_args;
                        break;
                    }
                } else if (s == '--') {
                    pgm_name = '';
                    pop wrp_args;
                    break;
                }
            }
            pgm_args = args;
        }
    }

    #! debug command line class
    public class DebugCommandLine inherits AbstractDebugControl {
        public {
            hash cx;
            const defaultIndent = "  ";
        }

        private {
            const fcHelp = 0x01;
            const fcExpandUniqueCmd = 0x02;
            const fcValidate = 0x04;
            const fcFallback = 0x08;
            *string historyFileName;

            Qore::Thread::RWLock rwlContext();
        }

        constructor() {
        }

        private hash<auto> getCommands() {
            code fallbackGetSetInt = sub(DebugCommandLine dcl, softlist path, reference args) {
                switch (args[0] ?? '') {
                    case '':
                        unshift args, 'get';
                        break;
                    case /^[0-9]+$/:
                        unshift args, 'set';
                        break;
                }
            };
            code fallbackGetSetString = sub(DebugCommandLine dcl, softlist path, reference args) {
                switch (args[0] ?? '') {
                    case '':
                        unshift args, 'get';
                        break;
                    default:
                        unshift args, 'set';
                        break;
                }
            };
            return (
                '>': (
                    'help': (
                        '**': (
                            'desc': 'help/*',
                            'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                shift path;
                                if (path[0] == 'help') return ();
                                *hash cmd = dcl.findCmd(path + args, fcHelp | fcExpandUniqueCmd);
                                if (!cmd.variants) return ();
                                return keys cmd.variants;
                            },
                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                shift path; # remove help arg
                                int last_param;
                                # get full path list
                                list fl = path + args;
                                *hash cmd = dcl.findCmd(fl, fcHelp | fcExpandUniqueCmd, \last_param);
                                # see if we have an unknown command or option
                                if (last_param < fl.size()) {
                                    if (!last_param)
                                        printfImpl("%s: unknown command; try \"help\"\n", fl[0]);
                                    else {
                                        string ctxt = fl[0..(last_param - 1)].join(' ');
                                        printfImpl("%s: unknown argument %y; try \"help %s\"\n", ctxt, fl[last_param], ctxt);
                                    }
                                    return;
                                }
                                string full_cmd = fl[0..(last_param - 1)].join(" ");
                                #printfImpl("fl: %y lp: %y full_cmd: %N\n", fl, last_param, full_cmd);
                                if (cmd.cmd) {
                                    printfImpl("%s: %s\n", full_cmd, cmd.cmd.desc);
                                }
                                if (cmd.cmd.aliases) {
                                    printfImpl("Aliases of %s: %s\n", cmd.cmd.name, sort(cmd.cmd.aliases).join(', '));
                                }
                                cmd = dcl.findCmd(fl + '', fcHelp);
                                if (cmd.variants.typeCode() == NT_HASH) {
                                    printfImpl("\nSubcommand list: %s\n", dcl.listVariantCmds(cmd.variants));
                                }
                            },
                        ),
                        'desc': 'get help about command',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            shift path; # remove help arg
                            *hash cmd = dcl.findCmd(list('') , fcHelp);
                            printfImpl("Command root list: %s\n", dcl.listVariantCmds(cmd.variants));
                        },
                    ),
                    'version': (
                        'desc': 'get version info. Check "host" key to see if server side is reponding',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash res.client = (
                                'class': dcl.className(),
                            );
                            try {
                                hash data.cmd = 'version';
                                res.host = dcl.doCommand(data, False).result;
                            } catch (hash<ExceptionInfo> ex) {
                            }
                            dcl.printHuman(res);
                        },
                    ),
                    'cmd': (
                        'desc': 'send a command to the server and show the output',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            #printfImpl("path: %y args: %y\n", path, args);
                            hash data;
                            try {
                                foreach string str in (args) {
                                    any v = parse_to_qore_value(str);
                                    if (v.typeCode() == NT_STRING && !data) {
                                        data.cmd = v;
                                        continue;
                                    }
                                    if (v.typeCode() != NT_HASH)
                                        throw "CMD-ARG-ERROR", sprintf("arg must be a hash; got type %y instead", v.type());
                                    data += v;
                                }
                                if (!data)
                                    printfImpl("syntax: cmd <hash>\n");
                                else {
                                    any res = dcl.doCommand(data, False).result;
                                    printfImpl("Result: %y\n", res);
                                }
                            }
                            catch (hash<ExceptionInfo> ex) {
                                printfImpl("ERROR: cmd cannot be parsed: %s: %s\n", ex.err, ex.desc);
                            }
                        },
                    ),
                    'options': (
                        '>': (
                            'verbose': (
                                '>': {
                                    'set': (
                                        'desc': 'set logger verbosity level, args: level',
                                        '*': (
                                            'validate': \DebugCommandLine::validateInt(),
                                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                                logger.verbose = int(pop path);
                                            },
                                        ),
                                    ),
                                    'get': (
                                        'desc': 'get current logger verbosity level',
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            printfImpl("Logging level: %d\n", logger.verbose);
                                        },
                                    ),
                                },
                                'fallback': fallbackGetSetInt,
                                'desc': 'logger verbosity commands',
                            ),

                            'rverbose': (
                                '>': {
                                    'set': (
                                        'desc': 'set remote logger verbosity level, args: level',
                                        '*': (
                                            'validate': \DebugCommandLine::validateInt(),
                                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                                doCommand((
                                                    'cmd': 'options/verbose/set',
                                                    'value': int(pop path),
                                                ), True);
                                            },
                                        ),
                                    ),
                                    'get': (
                                        'desc': 'get current remote logger verbosity level',
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            *hash vh = doCommand((
                                                'cmd': 'options/verbose/get',
                                            ), False);
                                            printfImpl("Remote Logging level: %y\n", vh.result);
                                        },
                                    ),
                                },
                                'fallback': fallbackGetSetInt,
                                'desc': 'remote logger verbosity commands',
                            ),

                            'fullexceptioninfo': (
                                '>': {
                                    'set': (
                                        'desc': 'set full exception info, args: 0|1',
                                        '*': (
                                            'validate': \DebugCommandLine::validateInt(),
                                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                                doCommand((
                                                    'cmd': 'options/fullexceptioninfo/set',
                                                    'value': int(pop path) > 0,
                                                ), True);
                                            },
                                        ),
                                    ),
                                    'get': (
                                        'desc': 'get full exception info',
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            doCommand((
                                                'cmd': 'options/fullexceptioninfo/get',
                                            ), True);
                                        },
                                    ),
                                },
                                'fallback': fallbackGetSetInt,
                                'desc': 'full exception info commands',
                            ),
                            'sourcepath': (
                                '>': {
                                    'set': (
                                        'desc': 'set source file search path, args: colon-delimited-paths',
                                        '*': (
                                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                                doCommand((
                                                    'cmd': 'options/sourcepath/set',
                                                    'value': pop path,
                                                ), True);
                                            },
                                        ),
                                    ),
                                    'get': (
                                        'desc': 'get source file search path',
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            doCommand((
                                                'cmd': 'options/sourcepath/get',
                                            ), True);
                                        },
                                    ),
                                },
                                'fallback': fallbackGetSetString,
                                'desc': 'search path commands',
                            ),
                        ),
                        'desc': 'options related commands',
                    ),
                    'frame': (
                        '>': {
                            'set': (
                                'desc': 'set current stack frame, args: frameId',
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'thread/stack';
                                        data.tid = dcl.checkThreadId();
                                        *hash th = dcl.doCommand(data, False);
                                        return th.result.size() > 1 ? range(0, th.result.size() - 1) : ();   # TODO: is removing bottom item reliable rule ?
                                    },
                                    'validate': \DebugCommandLine::validateInt(),
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data = (
                                            "cmd": "thread/debug/frame/set",
                                            "tid": dcl.checkThreadId(),
                                            "value": pop path,
                                        );
                                        dcl.doCommand(data, True);
                                        printfImpl("frameId set to %y\n", data.value);
                                    },
                                ),
                            ),
                            'get': (
                                'desc': 'get current stack frame',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data = (
                                        "cmd": "thread/debug/frame/get",
                                        "tid": dcl.checkThreadId(),
                                    );
                                    dcl.doCommand(data, True);
                                },
                            ),
                        },
                        'fallback': fallbackGetSetInt,
                        'desc': 'Stack frame related commands',
                    ),
                    'session': (
                        'desc': 'get list of debugged programs, stopped threads and breakpoint stats',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'session/get';
                            *hash sh = dcl.doCommand(data, False).result;
                            if (sh) {
                                foreach hash ph in (sh.pairIterator()) {
                                    string bs = '';
                                    if (ph.value.breakpoints) {
                                        bs = sprintf(", %s (enabled: %d)", plural(ph.value.breakpoints.size(), "breakpoint"), (select ph.value.breakpoints, AbstractDebugControl::boolStrings{$1.enabled}).size());
                                    }
                                    if (ph.value.interrupted) {
                                        printfImpl("+ %y (program %d, %d blocked %s%s)\n", ph.value.scriptName, ph.key, ph.value.interrupted.size(), plural(ph.value.interrupted.size(), "thread"), bs);
                                        printfImpl("  - blocked %s: %s\n", plural(ph.value.interrupted.size(), "TID"), (foldl $1 + ", " + $2, ph.value.interrupted));
                                    }
                                    else
                                        printfImpl("+ %y (program %d, no blocked threads%s)\n", ph.value.scriptName, ph.key, bs);
                                }
                            }
                            else
                                printfImpl("no programs are currently being debugged\n");
                        },
                        '>': (
                            'load': (
                                'desc': 'load session from file, args: filename',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    dcl.loadSession(shift args);
                                },
                            ),
                            'save': (
                                'desc': 'save session to file, args: filename',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    *string fn = shift args;
                                    if (exists fn) {
                                        hash data.cmd = 'session/get';
                                        hash sh.session.programs = dcl.doCommand(data, False).result;
                                        if (sh.session.programs) {
                                            File f();
                                            f.open(fn, O_CREAT | O_TRUNC | O_WRONLY);
                                            f.write(make_yaml(sh));
                                        }
                                    }
                                },
                            ),
                        ),
                    ),
                    'program': (
                        'alias': 'pgm',
                    ),
                    'pgm': (
                        '>': (
                            'load': (
                                'desc': 'load and run script, args: filename [args..]',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program//create';
                                    data.filename = shift args;
                                    if (!exists data.filename)
                                        throw "DEBUG-COMMAND", "Missing file name";
                                    data.args = args;
                                    dcl.doCommand(data, True);
                                },
                            ),
                            'search': (
                                'desc': 'regex search for a program, args: regex',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    if (!args[0].val()) {
                                        printfImpl("usage: pgm search <regex>\n");
                                        return;
                                    }
                                    hash data.cmd = 'program//list';
                                    *hash pgm_info = dcl.doCommand(data, False);
                                    hash rh;
                                    foreach hash h in (pgm_info.result.pairIterator()) {
                                        if (regex(h.value.scriptName ?? "", args[0]))
                                            rh{h.key} = h.value;
                                    }
                                    if (!rh)
                                        printfImpl("no program matching %y found out of %d programs\n", args[0], pgm_info.result.size());
                                    else {
                                        dcl.showPrograms(rh, False);
                                    }
                                },
                            ),
                            'list': (
                                '>': (
                                    'full': (
                                        'desc': 'verbose program listing',
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            hash data.cmd = 'program//list';
                                            data.listFiles = True;
                                            dcl.doCommand(data, True);
                                        },
                                    ),
                                ),
                                'desc': 'list programs, [full] for a verbose listing',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program//list';
                                    *hash pgm_info = dcl.doCommand(data, False);
                                    if (pgm_info.result)
                                        dcl.showPrograms(pgm_info.result, False);
                                    else
                                        printfImpl("no results returned from server\n");
                                },
                            ),
                            'set': (
                                'desc': 'set current program, arg: programId | scriptName',
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        string name = pop path;
                                        if (bindex(name, '/') >= 0) {  # conflict with delimiter
                                            return ();
                                        }
                                        hash data.cmd = 'program/'+name+'/list';
                                        *hash sd = dcl.doCommand(data, False);
                                        if (sd.result) {
                                            if (name =~ /^[0-9]+$/) {
                                                # programIds
                                                return keys sd.result;
                                            } else {
                                                # scriptNames
                                                list l = ();
                                                map l += (sd.result{$1}.scriptName, ), keys sd.result;
                                                return l;
                                            }
                                        } else {
                                            return ();
                                        }
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        string val = pop path;
                                        if (val !~ /^[0-9]+$/ ) {
                                            if (bindex(val, '/') >= 0) {  # conflict with delimiter
                                                throw "DEBUG-COMMAND", "Invalid character '/'";
                                            }
                                            hash data.cmd = 'program/='+val+'/list';
                                            *hash sd = dcl.doCommand(data, False);
                                            if (!sd.result) {
                                                throw "DEBUG-COMMAND", "Cannot resolve program name";
                                            }
                                            if (sd.result.size() > 1) {
                                                throw "DEBUG-COMMAND", sprintf("Ambiguous program name, pgmIds: %y", keys sd.result);
                                            }
                                            val = sd.result.firstKey();
                                        }
                                        dcl.setContextValue('programId', val);
                                        printfImpl("program context set to %y\n", val);
                                    },
                                ),
                            ),
                            'get': (
                                'desc': 'get current program',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    auto v = dcl.getContextValue('programId');
                                    if (!exists v)
                                        printfImpl("no current program set (pgm set <id> to set)\n");
                                    else
                                        dcl.printHuman(v);
                                },
                            ),
                            'add': (
                                'desc': 'add current program for debugging',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/add';
                                    dcl.doCommand(data, True);
                                },
                            ),
                            'remove': (
                                'desc': 'remove current program from debugging',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/remove';
                                    dcl.doCommand(data, True);
                                },
                            ),
                            'stop': (
                                'desc': 'stop current program, args: [threadId] to stop particular thread',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId();
                                    if (exists args[0]) {
                                        data.cmd += '/thread/'+args[0];
                                    }
                                    data.cmd += '/stop';
                                    dcl.doCommand(data, True);
                                },
                            ),
                            'global': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/global/'+pop path+'/list';
                                        *hash sd = dcl.doCommand(data, False);
                                        return sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        string varName = pop path;
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/global/'+varName+'/';
                                        if (args) {
                                            data.cmd += 'set';
                                            data.value = call_function_args(\dcl.parseValue(), args);
                                            dcl.doCommand(data, True);
                                        } else {
                                            data.cmd += 'get';
                                            *hash vh = dcl.doCommand(data, False);
                                            if (!vh) {
                                                printfImpl("there is no global var %y; use \"pgm global\" to list global vars in this program\n", varName);
                                            }
                                            else {
                                                dcl.printVar(varName, vh.result);
                                            }
                                        }
                                    },
                                ),
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/global//list';
                                    *list tl = dcl.doCommand(data, False).result;
                                    printfImpl("global vars: %s\n", (foldl $1 + ", " + $2, tl));
                                },
                                'desc': 'get/set global variable, args: varName [value]',
                            ),
                            'define': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/define/'+pop path+'/list';
                                        *hash sd = dcl.doCommand(data, False);
                                        return keys sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/define/'+pop path+'/get';
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/define//list';
                                    dcl.doCommand(data, True);
                                },
                                'desc': 'get defines, args: [defineName]',
                            ),
                            'options': (
                                'desc': 'list parse options',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/options';
                                    dcl.doCommand(data, True);
                                },
                            ),
                            'label': (
                                '*': (
                                    'desc': 'get source code from label, args: [line_from [line_count]]',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/label/list';
                                        return DebugCommandLine::enumFilter(keys dcl.doCommand(data, False).result, pop path);
                                    },
                                    'validate': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        if (args.size() > 1) {
                                            push path, shift args;
                                            DebugCommandLine::validateInt(dcl, path, args);
                                            if (args[0] != "") {
                                                push path, shift args;
                                                DebugCommandLine::validateInt(dcl, path, args);
                                            }
                                        }
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        dcl.processGetSource('label', path, args);
                                    },
                                ),
                                'desc': 'list source labels',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/label/list';
                                    showFileNames(dcl.doCommand(data, False).result);
                                },
                            ),
                            'file': (
                                '*': (
                                    'desc': 'get source code from file, args: [line_from [line_count]]',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/file/list';
                                        return DebugCommandLine::enumFilter(keys dcl.doCommand(data, False).result, pop path);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        dcl.processGetSource('file', path, args);
                                    },
                                ),
                                'desc': 'list source filenames',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/file/list';
                                    showFileNames(dcl.doCommand(data, False).result);
                                },
                            ),
                            'info': (
                                'desc': 'get info about current program and list threads',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/='+dcl.checkProgramId()+'/list';
                                    dcl.doCommand(data, True);
                                },
                            ),
                        ),
                        'desc': 'program related commands',
                        /* TODO: what is intended enumeration ?
                        'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'program//list';
                            *hash pgm_info = dcl.doCommand(data, False);
                            list rv = ();
                            *string p = shift path;
                            bool id = p =~ /^[0-9]+$/;
                            foreach hash h in (pgm_info.pairIterator()) {
                                if (!p.val())
                                    rv += h.key.toInt();
                                else {
                                    if (id) {
                                        if (regex(h.key, "^" + p))
                                            rv += h.key.toInt();
                                    }
                                    else if (h.value.scriptName.val() && regex(h.value.scriptName, "^" + p))
                                        rv += h.value.scriptName();
                                }
                            }
                            return rv;
                        },
                        */
                        'fallback': sub(DebugCommandLine dcl, softlist path, reference args) {
                            switch (args[0] ?? '') {
                            case '':
                                unshift args, 'info';
                                break;
                            case /^[0-9]+$/:
                                unshift args, 'set';
                                break;
                            }
                        },
                    ),
                    'break': (
                        '>': (
                            'list': (
                                'desc': 'list breakpoints for current program',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint//list';
                                    *hash sd = dcl.doCommand(data, False);
                                    if (sd.result) {
                                        dcl.showBreakpoints(sd.result);
                                    }
                                },
                                '>': (
                                    'all': (
                                        'desc': 'list breakpoints for all programs',
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            hash data.cmd = 'program//breakpoint//list';
                                            *hash sd = dcl.doCommand(data, False);
                                            if (sd.result) {
                                                dcl.showBreakpoints(sd.result);
                                            }
                                        },
                                    ),
                                ),
                            ),
                            'create': (
                                'desc': 'create breakpoint and get breakpointId. Optionally assign to particular statement, i.e. code line, or do it later using "statement assign". args: [function([args, ...])] | [file] lineno | #statementId',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint//create';
                                    if (args) {
                                        data.value = dcl.getStatementValue(args);
                                    }
                                    dcl.doCommand(data, True);
                                },
                            ),
                            'delete': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/delete';
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'delete breakpoint, args: breakpointId',
                            ),
                            'enable': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/enable';
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'enable breakpoint, args: breakpointId',
                            ),
                            'disable': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/disable';
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'disable breakpoint, args: breakpointId',
                            ),
                            'policy': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    '*': (
                                        'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            return DebugCommandLine::enumFilter(keys policyStrings, pop path);
                                        },
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            hash data.cmd = 'program//breakpoint/'+path[path.size()-2]+'/policy/set';
                                            data.value = pop path;
                                            dcl.doCommand(data, True);
                                        },
                                    ),
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/policy/get';
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': sprintf('get/set breakpoint policy, args: breakpointId [%s]', (keys AbstractDebugControl::policyStrings).join('|')),
                            ),
                            'thread': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {

                                        hash data.cmd = 'program//breakpoint/'+pop path+'/thread/';

                                        if (args) {
                                            string a = shift args;
                                            if (a == '+') {
                                                data.cmd += 'add';
                                                data.value = int(shift args);
                                            } else if (a == '-') {
                                                data.cmd += 'remove';
                                                data.value = int(shift args);
                                            } else {
                                                data.value = ();
                                                push data.value, int(a);
                                                map (push data.value, int($1)), args;
                                                data.cmd += 'set';
                                            }
                                        } else {
                                            data.cmd += 'get';
                                        }
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'get/set threads assigned to breakpoint, args: breakpointId ["+"/"-" threadId | threadId ..]',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/thread/get';
                                        dcl.doCommand(data, True);
                                },
                            ),
                            'statement': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/statement/list';
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'get statement list assigned to breakpoint, args: breakpointId',
                            ),
                        ),
                        'desc': 'breakpoint related commands',
                    ),
                    'statement': (
                        'alias': 'stmt',
                    ),
                    'stmt': (
                        '>': (
                            'list': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/statement/list';
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'list statements, args: breakpointId', # duplicate to breakpoint/statement
                            ),
                            'assign': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/statement/assign';
                                        data.value = dcl.getStatementValue(args);
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'assign statement to breakpoint, args: breakpointId [function([args, ...])] | [file] lineno | #statementId',
                            ),
                            'unassign': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program//breakpoint/'+pop path+'/statement/unassign';
                                        data.value = dcl.getStatementValue(args);
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'unassign statement from breakpoint, args: breakpointId [function([args, ...])] | [file] lineno | #statementId',
                            ),
                            'get': (
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/statement/get';
                                    data.value = dcl.getStatementValue(args);
                                    *hash sd = dcl.doCommand(data, False);
                                    if (exists sd.result) {
                                        printfImpl(formatStatement(sd.result));
                                        if (sd.result.breakpoints) {
                                            printfImpl(" Breakpoints:\n");
                                            foreach hash b in (sd.result.breakpoints) {
                                                printfImpl("  "+formatBreakpoint(b));
                                            }
                                        }
                                    }
                                },
                                'desc': 'get statement info and list related breakpoints, args: [function([args, ...])] | [file] lineno | #statementId',
                            ),
                        ),
                        'desc': 'statement related commands',
                    ),

                    'thread': (
                        '>': (
                            'set': (
                                '*': (
                                    'desc': 'set current thread, args: threadId',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/='+dcl.checkProgramId()+'/list';
                                        *hash sd = dcl.doCommand(data, False);
                                        if (sd.result) {
                                            return DebugCommandLine::enumFilter(sd.result{dcl.checkProgramId()}.threads, pop path);
                                        } else {
                                            return ();
                                        }
                                    },
                                    'validate': \DebugCommandLine::validateInt(),
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        softint val = pop path;
                                        dcl.setContextValue('threadId', val);
                                        printfImpl("remote thread context set to TID %y\n", val);
                                    },
                                ),
                            ),
                            'get': (
                                'desc': 'get current thread',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    *softint threadId = dcl.getContextValue('threadId');
                                    if (!exists threadId)
                                        printfImpl("no current thread set; \"pgm info\" to list threads; \"thread set <id>\" to set the current thread\n");
                                    else
                                        printfImpl("TID context: %d\n", threadId);
                                },
                            ),
                            'local': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'thread/local/'+pop path+'/list';
                                        data.tid = dcl.checkThreadId();
                                        *hash sd = dcl.doCommand(data, False);
                                        return sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        string var = pop path;
                                        hash data.cmd = 'thread/local/'+var+'/';
                                        data.tid = dcl.checkThreadId();
                                        if (args) {
                                            data.cmd += 'set';
                                            data.value = call_function_args(\dcl.parseValue(), args);
                                            dcl.doCommand(data, True);
                                            printfImpl("%s: value set to: %y\n", var, data.value);
                                        } else {
                                            data.cmd += 'get';
                                            *hash vh = dcl.doCommand(data, False);
                                            if (!vh) {
                                                printfImpl("there is no local var %y; use \"thread local\" to list local vars in this frame\n", var);
                                            }
                                            else {
                                                dcl.printVar(var, vh.result.value);
                                            }
                                        }
                                    },
                                ),

                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'thread/local//list';
                                    data.tid = dcl.checkThreadId();
                                    *list tl = dcl.doCommand(data, False).result;
                                    if (tl)
                                        printfImpl("local vars in frame: %s\n", (foldl $1 + ", " + $2, tl));
                                    else
                                        printfImpl("no local vars in frame\n");
                                },
                                'desc': 'get/set local variable, args: varName [value]',
                            ),
                            'debug': (
                                '*': (
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'thread/debug/'+pop path+'/list';
                                        data.tid = dcl.checkThreadId();
                                        *hash sd = dcl.doCommand(data, False);
                                        return sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        string varName = pop path;
                                        hash data.cmd = 'thread/debug/'+varName+'/';
                                        data.tid = dcl.checkThreadId();
                                        if (args) {
                                            data.cmd += 'set';
                                            data.value = call_function_args(\dcl.parseValue(), args);
                                        } else {
                                            data.cmd += 'get';
                                            if (varName == 'result') {
                                                *hash vh = dcl.doCommand(data, False);
                                                if (vh.result) {
                                                    dcl.printVar(varName, vh.result);
                                                } else {
                                                    dcl.printData(vh);
                                                }
                                                return;
                                            }
                                        }
                                        dcl.doCommand(data, True);
                                    },
                                ),
                                'desc': 'get/set special debug variable, args: varName [value], use "thread debug list" command result to see value list of varNames',
                            ),
                            'pgmlist': (
                                'desc': 'show threads and related programs, interrupted programs are marked with \"S\"',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program//list';
                                    *hash pgm_info = dcl.doCommand(data, False).result;
                                    if (pgm_info) {
                                        hash tl;
                                        foreach softint pgmId in (keys pgm_info) {
                                            foreach int tid in (pgm_info{pgmId}.threads) {
                                                tl{tid}.programs{pgmId} = pgm_info{pgmId};
                                                if (exists pgm_info{pgmId}.interrupted) {
                                                    if (inlist(tid, pgm_info{pgmId}.interrupted)) {
                                                        tl{tid}.interrupted = pgmId;
                                                    }
                                                }
                                            }
                                        }
                                        foreach softint tid in (sort(keys tl, int sub(softint l, softint h) {return l<=>h; })) {
                                            # do not output a trailing blank line
                                            if ($#) {
                                                printfImpl("\n");
                                            }
                                            printfImpl("TID %d program list:\n", tid);
                                            dcl.showPrograms(tl{tid}.programs, True);
                                        }
                                    }
                                },
                            ),
                            'list': (
                                'desc': 'show list of threads and top level stack position',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'thread/stack';
                                    *hash threads = dcl.doCommand(data, False).result;
                                    if (threads) {
                                        foreach softint tid in (keys threads) {
                                            printfImpl(" %4d : %s\n", tid, dcl.getThreadStackStr(threads{tid}[0]));
                                        }
                                    }
                                },
                            )
                        ),
                        'desc': 'thread related commands',
                        'fallback': fallbackGetSetInt,
                    ),
                    'stack': (
                        'alias': 'bt',
                    ),
                    'backtrace': (
                        'alias': 'bt',
                    ),
                    'bt': (
                        'desc': 'get stack for current thread',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'thread/stack';
                            data.tid = dcl.checkThreadId();
                            *hash th = dcl.doCommand(data, False);
                            if (th) {
                                dcl.showThreadStack(th.tid, th.result);
                            }
                            else
                                printfImpl("server returned no response\n");
                        },
                        '>': (
                            'all': (
                                'desc': 'show call stack for all threads',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'thread/stack';
                                    *hash threads = dcl.doCommand(data, False).result;
                                    if (threads) {
                                        foreach softint tid in (keys threads) {
                                            # do not output a trailing blank line
                                            if ($#) {
                                                printfImpl("\n");
                                            }
                                            dcl.showThreadStack(tid, threads{tid});
                                        }
                                    }
                                },
                            ),
                        ),
                    ),
                    'source': (
                        'desc': 'get source around current program position, args: [lines-before [lines-after]]',
                        'validate': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            if (args.size() > 0) {
                                DebugCommandLine::validateInt(dcl, path, args);
                                if (args[0] != "") {
                                    push path, shift args;
                                    DebugCommandLine::validateInt(dcl, path, args);
                                }
                            }
                        },
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'thread/source';
                            data.tid = dcl.checkThreadId();
                            if (args.size() > 1) {
                                data.linesbefore = int(args[0]);
                                data.linesafter = int(args[1]);
                            } else if (args.size() > 0) {
                                data.linesbefore = int(args[0]);
                                data.linesafter = data.linesbefore;
                            }
                            dcl.printfImpl("%s", dcl.formatSource(dcl.doCommand(data, False).result));
                        },
                    ),
                    'go': (
                        '*': (
                            'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                return DebugCommandLine::enumFilter(keys runStateStrings, pop path);
                            },
                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                hash data.cmd = 'thread/go/'+pop path;
                                data.tid = dcl.checkThreadId();
                                if (args) {
                                    data.value = dcl.getStatementValue(args);
                                }
                                dcl.doCommand(data, True);
                            },
                        ),
                        'desc': sprintf('go thread with specified runstate and optionally to specified statement, arg: %s [ [function([args, ...])] | [file] lineno | #statementId ]', (keys AbstractDebugControl::runStateStrings).join('|')),
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'thread/go';
                            data.tid = dcl.checkThreadId();
                            dcl.doCommand(data, True);
                        },
                    ),
                ),
            );
        }

        # to implement print to terminal
        abstract public printfImpl(string fmt);

        #! To be implemented to execute remote (via websocket) or local command (via @ref DebugProgramControl::DebugProgramControl "DebugProgramControl")
        abstract public *hash doCommandImpl(hash data);

        public *hash doCommand(hash data, bool print) {
            log(DUV_DEBUG, "Cmd: %y", data);
            *hash ret = doCommandImpl(data);
            if (ret) {
                log(DUV_DEBUG, "Response: %y", ret);
                if (ret.type == "error") {
                    throw "DEBUG-COMMAND", sprintf("%s: %s", ret.result.err, ret.result.desc);
                }
                if (print) {
                    printData(ret);
                }
            }
            return ret;
        }

        public showFileNames(*hash fn) {
            foreach string k in (keys fn) {
                printfImpl("%s", k);
                if (fn{k}) {
                    foreach string k2 in (keys fn{k}) {
                        printfImpl("  @%5d %s", fn{k}{k2}, k2);
                    }
                    printfImpl("");
                }
            }
        }

        public showPrograms(hash ph, bool show_interrupted) {
            # get max name width
            int max = 1;
            foreach hash h in (ph.pairIterator()) {
                if (!h.value.scriptName.val()) {
                    #printfImpl("MISSING: %y = %y\n", h.key, h.value);
                    delete ph{h.key};
                    continue;
                }
                int len;
                if (!h.value.scriptName.val())
                    len = (ph{h.key}.scriptName = sprintf("n/a path %y", h.value.scriptPath)).length();
                else
                    len = h.value.scriptName.length();
                if (len > max)
                    max = len;
            }
            string fmt = sprintf("%%s%%4d%%s: %%-%ds thr: %%2d dbg: %%d/%%d\n", max);
            auto pgmId = getContextValue('programId');
            foreach string id in (sort(keys ph, int sub (string l, string r) { return l.toInt() <=> r.toInt(); })) {
                printfImpl(fmt,
                    (show_interrupted && ph{id}.interrupted) ? 'S':' ', id, id == pgmId ? "*" : " ", ph{id}.scriptName, ph{id}.threads.size(), ph{id}.debugging, ph{id}.debugged);
            }
        }

        public string formatBreakpoint(hash b) {
            return sprintf(" id: %-4d  pgmId: %-4d enabled: %-5s policy: %-6s threads: %y\n", b.id, b.programId, b.enabled, b.policy, b.threads);
        }

        public string formatStatement(hash stmt) {
            string res = sprintf(" @ %-5d %s:%d-%d", stmt.id, stmt.file, stmt.start_line + stmt.offset, stmt.end_line + stmt.offset);
            if (stmt.source) {
                res += sprintf(" (%s:%d-%d)", stmt.source, stmt.start_line, stmt.end_line);
            }
            return res+"\n";
        }

        public showBreakpoints(*list bkpts) {
            foreach hash b in (sort(bkpts, int sub (hash l, hash r) { return l.id <=> r.id; })) {
                printfImpl(formatBreakpoint(b));
                if (b.statements) {
                    foreach hash stmt in (b.statements) {
                        printfImpl("  "+formatStatement(stmt));
                    }
                    printfImpl("\n");
                }
            }
        }

        public string getThreadStackStr(hash lh) {
            string str;
            if (lh.function.val())
                str += sprintf("%s()", lh.function);
            else
                str += "<unknown function>";
            str += " (";
            string loc;
            if (lh.source)
                loc += sprintf("%s:%d", lh.source, lh.line + lh.offset);
            else {
                loc += sprintf("%s", lh.file ?? "<unknown>");
                if (lh.line > 0)
                    loc += sprintf(":%d", lh.line);
            }
            if (lh.endline > 0)
                loc += sprintf("-%d", lh.endline + lh.offset);
            if (loc)
                str += loc + " ";
            str += lh.type;
            str += ")";
            if (lh.programid) {
                str += sprintf(" pgm:%d", lh.programid);
            }
            if (lh.statementid) {
                str += sprintf(" stmtid:%d", lh.statementid);
            }
            return str;
        }

        public showThreadStack(softint tid, list stack) {
            printfImpl("TID %d call stack:\n", tid);
            foreach hash lh in (stack) {
                printfImpl(" - %d%s: %s\n", $#, lh.current ? "*":" ", getThreadStackStr(lh));
            }
        }

        # src keys: code, [startLine], [currentLine]
        public *string formatSource(*hash src) {
            if (exists src.code) {
                if (src.startline > 0) {
                    # add line numbers
                    list l = src.code.split("\n");
                    string fmt = sprintf("%%%dd%%s: %%s", int(log10(src.startline + l.size()))+1);
                    foreach string s in (\l) {
                        string mark = "";
                        if (exists src.currentline) {
                            mark = (src.currentline == src.startline+$#) ? "*":" ";
                        }
                        s = sprintf(fmt, src.startline + $#, mark, s);
                    }
                    return l.join("\n");
                } else {
                    return src.code;
                }
            }
        }
        public processGetSource(string type, list path, list args) {
            hash data.cmd = 'program/'+checkProgramId()+'/'+type+'/source';
            data{type} = pop path;
            if (args[0] != "") {
                data.line = int(args[0]);
                if (args[1] != "") {
                    data.count = int(args[1]);
                }
            }
            *hash src = doCommand(data, False).result;
            if (src.checksum) {
                printfImpl("%s: %s", src.checksum.algorithm, src.checksum.cs);
            }
            printfImpl("%s", formatSource(src));
        }

        static public validateInt(DebugCommandLine dcl, softlist path, softlist val) {
            if (val[0] =~ /[^0-9]/) {
                throw "CMD-ARG-ERROR", sprintf("%s: parameter %y is not integer", path.join(' '), val[0]);
            }
        }

        public auto parseValue() {
            return AbstractDebugControl::serialize(parse_to_qore_value(argv.lsize() == 1 ? argv[0] : argv));
        }

        public auto getContextValue(string key) {
            rwlContext.readLock();
            on_exit rwlContext.readUnlock();
            return cx{key};
        }

        public setContextValue(string key, auto value) {
            rwlContext.writeLock();
            on_exit rwlContext.writeUnlock();
            cx{key} = value;
        }

        public hash getStatementValue(list args) {
            if (!args)
                throw "DEBUG-PROGRAM-HELPER", sprintf("Statement description is missing");
            string s;
            s = trim(shift args);
            if (s =~ /^[0-9]+$/) {
                return {'file': '', 'lineno': int(s)};
            }
            *list l = s =~ x/^(.+)\((.*)\)$/;
            if (l) {
                list la = ();
                foreach string s2 in (split(',', l[1])) {
                    s2 = trim(s2);
                    if (s2 != "") {
                        push la, s2;
                    }
                }
                return {'function': l[0], 'args': la};
            }
            l = s =~ x/^#([0-9]+)$/;
            if (l) {
                return {'id': int(l[0])};
            }
            if (args[0] =~ /^[0-9]+$/) {
                return {'file': s, 'lineno': int(args[0])};
            }
            throw "DEBUG-PROGRAM-HELPER", sprintf("Wrong statement identification");
        }

        private hash splitCmd(string line) {
            hash ret = {'args': (), 'pos': ()};
            int i = 0;
            int q = 0;
            string s = '';
            int start = -1;
            while (i < line.size()) {
                if (start < 0 && s == '' && line[i] != ' ') {
                    start = i;
                }
                switch (line[i]) {
                case ' ':
                    if (q == 0) {
                        if (s != '') {
                            push ret.args, s;
                            push ret.pos, {'start': start, 'end': i};
                            s = '';
                        }
                        start = -1;
                    } else {
                        s += line[i];
                    }
                    break;
                case "'":
                    if (q == 0) {
                        q = 1;
                    } else if (q == 1) {
                        q = 0;
                    } else {
                        s += line[i];
                    }
                    break;
                case '"':
                    if (q == 0) {
                        q = 2;
                    } else if (q == 2) {
                        q = 0;
                    } else {
                        s += line[i];
                    }
                    break;
                case '\':
                    i++;
                    switch (line[i]) {
                    case 'n':
                        s += "\n";
                        break;
                    case 'r':
                        s += "\r";
                        break;
                    case 't':
                        s += "\t";
                        break;
                    case '0':
                        s += "\0";
                        break;
                    default:
                        s += line[i];
                    }
                    break;
                default:
                    s += line[i];
                }
                i++;
            }
            if (q != 0)
                throw "DEBUG-PROGRAM-HELPER", sprintf("Unmatched quotes in %y", line);
            if (s != '') {
                push ret.args, s;
                push ret.pos, {'start': start, 'end': i};
            }
            return ret;
        }

        private string escapeArg(softstring s) {
            int i = 0;
            while (i < s.size()) {
                bool addEsc = True;
                switch (s[i]) {
                    case "\n":
                        splice s, i, 1, 'n';
                        break;
                    case "\r":
                        splice s, i, 1, 'r';
                        break;
                    case "\t":
                        splice s, i, 1, 't';
                        break;
                    case "\0":
                        splice s, i, 1, '0';
                        break;
                    case '\':
                    case " ":
                    case '"':
                    case "'":
                        break;
                    default:
                        addEsc = False;
                }
                if (addEsc) {
                    splice s, i, 0, '\';
                    i++;
                }
                i++;
            }
            return s;
        }

        public string listVariantCmds(hash v) {
            list r;
            foreach string k in (sort(keys(v))) {
                if (!exists v{k}.aliasOf) {
                    if (v{k}.aliases) {
                        push r, sprintf("%s (%s)", k, sort(v{k}.aliases).join(', '));
                    } else {
                        push r, k;
                    }
                }
            }
            return r.join(', ');
        }

        public *hash findCmd(list args, int opts = 0, *reference<int> last_param) {  /* public because it is needed from closure */
            hash result;
            result.path = ();
            hash<auto> c = getCommands();
            last_param = 0;
            while (args) {
                bool doBreak = False;
                while (args) {
                    if ((opts & fcHelp) && exists c."*") {
                        # skip
                        c = c."*";
                    } else if (exists c.">") {
                        # static enum
                        # check for partial matches
                        hash aliases;
                        foreach string k in (keys c.">") {
                            if (c.">"{k}.alias) {
                                aliases{c.">"{k}.alias} += (k,);
                            }
                        }
                        if (!c.">"{args[0]}) {
                            list pm;
                            string arg;
                            # scan through the list and see if we have one possible match
                            foreach string k in (keys c.">") {
                                if (k.substr(0, args[0].size()) == args[0]) {
                                    pm += k;
                                    if (!exists arg)
                                        arg = k;
                                    else
                                        # check if the second match is the same as the first through aliases
                                        # and only reset the argument if it is different
                                        if (c.">"{k}.alias != arg && c.">"{arg}.alias != k)
                                            arg = "";
                                }
                            }

                            if (pm) {
                                # if there is only one variant, then use it immediately
                                if (arg.val() && (opts & fcExpandUniqueCmd)) {
                                    args[0] = arg;
                                }
                                if (args.size() == 1) { # only set variants on the last argument
                                    foreach string c2 in (pm) {
                                        if (!exists c.">"{c2}.alias) {
                                            result.variants{c2} = c.">"{c2};
                                            result.variants{c2}.aliases = aliases{c2};
                                        } else {
                                            result.variants{c2} = c.">"{c.">"{c2}.alias};
                                            result.variants{c2}.aliasOf = c.">"{c2}.alias;
                                            result.variants{c2}.aliases = aliases{result.variants{c2}.aliasOf};
                                        }
                                    }
                                }
                            }
                        }
                        if (exists c.">"{args[0]}) {
                            #remove result.cmd.">";
                            # follow aliases
                            if (*string alias = c.">"{args[0]}.alias) {
                                c = c.">"{alias};
                                c.name = alias;
                                push result.path, alias;
                                shift args;
                            }
                            else {
                                c = c.">"{args[0]};
                                c.name = args[0];
                                push result.path, shift args;
                            }
                            if (args[0] != "" && exists c.validate && (opts & fcValidate)) {
                                c.validate(self, result.path, args);
                            }
                            c.aliases = aliases{c.name};
                            result.cmd = c;
                            ++last_param;
                        } else {
                            if (exists c.fallback && (opts & fcFallback)) {
                                list sa = args;
                                c.fallback(self, result.path, \args);
                                if (args != sa) {
                                    continue;  # reprocess
                                }
                            }
                            if (exists result.variants) {
                                push result.path, shift args;
                                ++last_param;
                            }
                            doBreak = True;
                            break;
                        }
                    } else if (exists c."*") {
                        # dynamically enumerated
                        c = c."*";
                        if (args[0] != "" && exists c.validate && (opts & fcValidate)) {
                            c.validate(self, result.path, args);
                        }
                        if (args.size() == 1 && exists c.enum) {
                            result.variants = c.enum;
                        }
                        push result.path, shift args;
                        ++last_param;
                        result.cmd = c;
                    } else if (exists c."**") {
                        c = c."**";
                        if (exists c.enum) {
                            result.variants = c.enum;
                        }
                        push result.path, shift args;
                        ++last_param;
                        result.cmd = c;
                        doBreak = True;
                        break;
                    } else {
                        doBreak = True;
                        break;
                    }
                }
                if (doBreak) {
                    break;
                }
                if (exists c.fallback && (opts & fcFallback)) {
                    # last chance to modify args and continue
                    c.fallback(self, result.path, \args);
                }
            }
            result.args = args;
            return result;
        }

        public list getLineCompletions(string line) {
            hash h = splitCmd(line);
            if (line == '' || (h.pos && h.pos.last().end < line.size())) {
                h.args += '';
            } else {
                if (h.pos) {
                    # strip last args
                    splice line, h.pos.last().start;
                }
            }
            *hash cmd = findCmd(h.args, fcExpandUniqueCmd);
            if (cmd.variants) {
                *list v;
                switch (cmd.variants.typeCode()) {
                case NT_CLOSURE:
                case NT_CALLREF:
                    try {
                        v = cmd.variants(self, cmd.path, cmd.args);
                    } catch (hash<ExceptionInfo> ex) {
                    }
                    break;
                default:
                    v = keys cmd.variants;
                }
                list res = ();
                map (push res, line+escapeArg($1)), sort(v);
                return res;
            } else {
                return ();
            }
        }

        public bool processCmdLine(string line) {
            int last_param;
            list args = splitCmd(line).args;
            *hash cmd = findCmd(args, fcExpandUniqueCmd | fcValidate | fcFallback, \last_param);
            if (cmd.cmd) {
#                    printfImpl("line:%y\n", line);
                if (cmd.cmd.action) {
#                    printfImpl("exec:%y\n", cmd);
                    try {
                        auto rc = cmd.cmd.action(self, cmd.path, cmd.args);
                        if (rc) {
                            return False;
                        }
                    } catch (hash<ExceptionInfo> ex) {
                        showFullException ? printfImpl("%y\n", ex) : printfImpl("%s: %s\n", ex.err, ex.desc);
                    }
                } else {
                    if (cmd.variants.size() > 1) {
                        printfImpl("%y: Ambiguous subcommand, use more characters to specify among (%y)\n", args[0], keys cmd.variants);
                    } else if (last_param < args.size())
                        printfImpl("%y: Unknown parameter %y; use <TAB> or \"help %s\" for more info\n", args[0], args[last_param], (foldl $1 + " " + $2, (map $1, args, $# < last_param)));
                    else {
                        string cmdstr = args.join(" ");
                        printfImpl("%y: missing required parameter; use <TAB> or \"help %s\" for more info\n", cmdstr, cmdstr);
                    }
                }
            } else {
                if (cmd.variants.size() > 1) {
                    printfImpl("%y: Ambiguous commmand, use more characters to specify among (%y)\n", args[0], keys cmd.variants);
                } else {
                    printfImpl("%y: Unknown command, use <TAB> key or \"help\" to get list of commands\n", args[0]);
                }
            }
            return True;
        }
        private bool isOneLineArray(list x) {
            foreach any i in (x) {
                switch (i.typeCode()) {
                    case NT_NUMBER:
                    case NT_FLOAT:
                    case NT_INT:
                        break;
                    default:
                        return False;
                }
            }
            return True;
        }

        public printVar(string name, hash value) {
            printfImpl("%s %s = %y\n", value.type, name, AbstractDebugControl::unserialize(value));
        }

        public printHuman(hash x, string indent = defaultIndent) {
            foreach string k in (keys x) {
                switch (x{k}.typeCode()) {
                    case NT_HASH:
                        printfImpl("%s%s :\n", indent, k);
                        printHuman(x{k}, indent + defaultIndent);
                        break;
                    case NT_LIST:
                        if (isOneLineArray(x{k})) {
                            printfImpl("%s%s : [%s]\n", indent, k, x{k}.join(", "));
                        } else {
                            if (x{k}.size() > 1) {
                                printfImpl("%s%s : [\n", indent, k);
                                printHuman(x{k}, indent + defaultIndent);
                                printfImpl(indent + "]\n");
                            } else {
                                printfImpl("%s%s :\n", indent, k);
                                printHuman(x{k}, defaultIndent + indent);
                            }
                        }
                        break;
                    default:
                        printHuman(x{k}, sprintf("%s%s : ", indent, k));
                }
            }
        }

        public printHuman(list x, string indent = defaultIndent) {
            foreach any i in (x) {
                switch (i.typeCode()) {
                    case NT_HASH:
                        if (x.size() > 1) {
                            printfImpl("%s{\n", indent);
                            printHuman(i, defaultIndent + indent);
                            printfImpl("%s}\n", indent);
                        } else {
                            printHuman(i, indent);
                        }
                        break;
                    case NT_LIST:
                        if (isOneLineArray(i)) {
                            printfImpl("%s[%s]\n", indent, i.join(", "));
                        } else {
                            printfImpl("%s[\n", indent);
                            printHuman(i, indent + defaultIndent);
                            printfImpl("%s]\n", indent);
                        }
                        break;
                    default:
                        printHuman(i, indent);
                }
            }
        }

        public printHuman(string x, string indent = defaultIndent) {
            if (x =~ /^[A-Za-z0-9_]+$/) {
                printfImpl("%s%s\n", indent, x);
            } else {
                printfImpl("%s%y\n", indent, x);
            }
        }
        public printHuman(any x, string indent = defaultIndent) {
            printfImpl("%s%y\n", indent, x);
        }

        public printData(auto data) {
            string outs;
            if (data.typeCode() == NT_HASH) {
                switch (data.type) {
                case 'response':
                    printHuman(data.result);
                    return; # already printed
                case 'event':
                    outs = sprintf("%s: %s", data.stamp.format("YYYY-MM-DD HH:mm:SS.xx"), data.cmd);
                    if (data.cmd == 'run' && exists data.runstate) {
                        outs += "/" + data.runstate;
                    }
                    if (data.func) {
                        outs += "/" + data.func;
                    }
                    if (data.pgmid)
                        outs += sprintf(", pgm: %d", data.pgmid);
                    if (data.tid)
                        outs += sprintf(", tid: %d", data.tid);
                    if (data.bkptid)
                        outs += sprintf(", bkptid: %d", data.bkptid);
                    if (data.file || data.line || data.statementid) {
                        outs += ", (";
                        if (data.line) {
                            if (!data.file.val())
                                data.file = "<unknown>";
                            outs += sprintf("%s:%d", data.file, data.line);
                        }
                        else if (data.file)
                            outs += data.file;
                        if (data.statementid) {
                            if (data.line || data.file.val())
                                outs += ", ";
                            outs += sprintf("stmtid: %d", data.statementid);
                        }
                        outs += ")";
                    }
                    #outs += sprintf(": action %y", data.func);
                    switch (data.cmd) {
                        case 'interrupt': {
                            if (!exists getContextValue('programId')) {
                                setContextValue('programId', data.pgmid);
                                outs += ", [pgm ctx set]";
                            }
                            if (!exists getContextValue('threadId')) {
                                setContextValue('threadId', data.tid);
                                outs += ", [thread ctx set]";
                            }
                            if (exists data.linecode) {
                                outs += "\n";
                                outs += formatSource({
                                    'code': data.linecode,
                                    'startline': data.line,
                                    'currentline': data.line,
                                });
                            }
                        }
                        break;
                    }
                    break;

                case 'error':
                    if (data.result.ex)
                        outs = sprintf("cmd %y server-side error: %s\n", data.cmd, get_exception_string(data.result.ex));
                    else
                        outs = sprintf("cmd %y server-side error: %s: %s\n", data.cmd, data.result.err, data.result.desc);
                    break;

                case 'thread':
                    /*
                    outs = sprintf("%y: thread %d\n", data.cmd, data.tid);
                    if (data.result)
                        outs += sprintf("%N\n", data.result);
                    break;
                    */
                    # no output for "thread" messages
                    return;
                }

                if (!exists outs)
                    outs = sprintf("%N", data);
            } else {
                outs = sprintf("%y", data);
            }
            printfImpl("%s\n", outs);
        }

        public int checkProgramId() {
            *softint pgmId = getContextValue('programId');
            if (!exists pgmId) {
                throw "DEBUG-COMMAND", "Program is not set (try: \"pgm list\", \"pgm search <regex>\", \"pgm set [id]\")";
            }
            return pgmId;
        }

        public int checkThreadId() {
            *softint threadId = getContextValue('threadId');
            if (!exists threadId) {
                throw "DEBUG-COMMAND", "Thread context is not set (try: \"thread set [id]\")";
            }
            return threadId;
        }

        static public softlist enumBreakpointId(DebugCommandLine dcl, softlist path, softlist args) {
            hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/list';
            *hash sd = dcl.doCommand(data, False);
            return map $1.id, sd.result;
        }

        public loadSession(*string fn) {
            if (exists fn) {
                #printfImpl("Load session: %y\n", fn);
                *hash d = parse_yaml(ReadOnlyFile::readTextFile(fn));
                #printfImpl("Load session data: %y\n", d);
                if (d.session.programs) {
                    hash data.cmd = 'session/set';
                    data.value = d.session.programs;
                    *hash ret = doCommand(data, False);
                    if (ret.result) {
                        printData(ret);
                    }
                }
            }
        }

        public init(hash opt) {
        }

    }
}
