# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file SmtpClient.qm SmtpClient module definition

/*  SmtpClient.qm Copyright 2012 - 2023 Qore Technologies, s.r.o.

    Original Authors: Wolfgang Ritzinger, Marian Bonda, Pavol Potoncok

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum qore version
%requires qore >= 2.0

# need mime definitions
%requires Mime >= 1.4

# need MailMessage classes
%requires MailMessage >= 1.3

%requires(reexport) ConnectionProvider >= 1.4
%requires(reexport) DataProvider

# assume local var scope, do not use "$" for vars, members, and method calls
%new-style

module SmtpClient {
    version = "2.0";
    desc = "SMTP client support module";
    author = "Wolfgang Ritzinger <aargon@rat.at>, Marian Bonda <marian_bonda@users.sourceforge.net>, "
        "Pavol Potoncok <ppotancok@gmail.com>";
    url = "http://qore.org";
    license = "MIT";
    init = sub () {
        ConnectionSchemeCache::registerScheme("smtp", SmtpConnection::ConnectionScheme);
        ConnectionSchemeCache::registerScheme("smtps", SmtpConnection::ConnectionScheme);
        ConnectionSchemeCache::registerScheme("smtptls", SmtpConnection::ConnectionScheme);
        ConnectionSchemeCache::registerScheme("esmtp", SmtpConnection::ConnectionScheme);
        ConnectionSchemeCache::registerScheme("esmtps", SmtpConnection::ConnectionScheme);
        ConnectionSchemeCache::registerScheme("esmtptls", SmtpConnection::ConnectionScheme);

        # register the data provider factory
        DataProvider::registerFactory(new SmtpClientDataProviderFactory());

        # register the data provider application
        DataProviderActionCatalog::registerApp(<DataProviderAppInfo>{
            "name": SmtpClient::AppName,
            "display_name": "SMTP Server",
            "short_desc": "Generic SMTP server for sending emails",
            "desc": "Generic SMTP server for sending emails",
            "scheme": "smtp",
            "logo": SmtpLogo,
            "logo_file_name": "generic-smtp-logo.svg",
            "logo_mime_type": MimeTypeSvg,
        });

        # register all supported actions
        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": SmtpClient::AppName,
            "path": "/send-email",
            "action": "send-email",
            "display_name": "Send an Email With SMTP",
            "short_desc": "Send an email through a generic SMTP server",
            "desc": "Send an email through a generic SMTP server",
            "action_code": DPAT_API,
        });
    };
}

/** @mainpage SmtpClient Module

    @tableofcontents

    @section smtpclientintro SmtpClient Introduction

    The %SmtpClient module provides a set of classes that can be used for easy communication with SMTP servers for
    sending emails, with or without TLS/SSL encryption.

    To use this module, use \c "%requires SmtpClient" in your code.  See examples/email.q for an example program using
    this module

    All the public symbols in the module are defined in the SmtpClient namespace

    Classes provided:
    - @ref SmtpClient::SmtpClient "SmtpClient": manages a connection to an SMTP server
    - @ref SmtpClient::SmtpConnection "SmtpConnection": provides a connection object to an SMTP server (based on the
      @ref connectionproviderintro "ConnectionProvider" module)

    The following supporting classes are provided by the MailMessage module:
    - MailMessage::Message: wraps a message to be sent via an @ref SmtpClient::SmtpClient "SmtpClient" object
    - MailMessage::Attachment: used to attach files to a MailMessage::Message object

    Note that the @ref SmtpClient::SmtpClient "SmtpClient" class automatically detects if the SMTP server supports
    ESMTP and a \c "EHLO" command is executed automatically instead of \c "HELO" if so.  Additionally, the class also
    automatically detects if the server supports the \c "STARTTLS" command by parsing the response to the \c "EHLO"
    command when talking to ESMTP servers.

    If the \a tls flag is not set on the @ref SmtpClient::SmtpClient "SmtpClient" object and the server supports
    \c "STARTTLS" (and a transport layer TLS/SSL connection was not already established), then the
    @ref SmtpClient::SmtpClient "SmtpClient" object will automatically execute a \c "STARTTLS" command after
    connecting so that the rest of the SMTP session is performed securely.  This also allows transparent logins and
    communication with ESMTP servers that require secure connections.

    For the above reasons it's normally not required to use the \c "smtptls" or \c "esmtptls" protocols in the
    @ref SmtpClient::SmtpClient::constructor(string, __7_ code, __7_ code) "SmtpClient::constructor(string, *code, *code)"
    RL argument.

    @anchor smtpclient_protocols
    @ref SmtpClient::SmtpClient::constructor(string, __7_ code, __7_ code) "SmtpClient::constructor(string, *code, *code)"
    takes a URL argument, the protocol (scheme) component is handled as in the following table.

    <b>SmtpcClient Protocol Handling</b>
    |!Protocol|!Default Port|!Description
    |\c "smtp"|25|standard SMTP port without encryption; ESMPT and \c "STARTTLS" detection is supported automatically
    |\c "smtps"|465|note that port 465 is currently assigned to source-specific multicast audio/video \
        (<a href="http://www.iana.org/assignments/port-numbers">http://www.iana.org/assignments/port-numbers</a>); \
        its use as a port for secure SMTP listeners (where security is enforced at the transport layer because the \
        server immediately negotiates a TLS/SSL connection before the application protocol communication starts) is \
        deprecated but is included in this module because many SMTP servers still operate this way
    |\c "smtptls"|25|a \c "STARTTLS" command is executed unconditionally after the connection to ensure a secure \
        connection, even if the server does not declare support for this command in the login response.  It's \
        normally not necessary to use this protocol as \c "STARTTLS" is used automatically when logging in to ESMTP \
        servers that declare support for this command in the response to the \c "EHLO" command.
    |\c "esmtp"|587|like \c "smtp" just using port 587
    |\c "esmtps"|465|like \c "smtps"
    |\c "esmtptls"|587|like \c "smtptls" just using port 587

    @par Example:
    @code{.py}
%requires SmtpClient
%requires Mime

Message msg("The Sender <sender@email.com>", "My Subject");
msg.setBody(body);
msg.addTO("My Best Friend <you@friend.com>");
msg.attach(filename, Mime::MimeTypeText, data);

code log = sub (string str) {printf("%y: %s\n", now_us(), str);};
SmtpClient::SmtpClient smtp("esmtptls://user@password:smtp.example.com", log, log);
smtp.sendMessage(msg);@endcode

    @section smtpclient_references SmtpClient References

    Based on:
    - http://james.apache.org/server/rfclist/smtp/rfc0821.txt
    - http://tools.ietf.org/html/rfc821: initial SMTP protocol spec
    - http://tools.ietf.org/html/rfc1521: quoted printable & base 64 transfer encodings
    - http://tools.ietf.org/html/rfc2045: mime headers, content types, etc
    - http://tools.ietf.org/html/rfc2047: "Q" and "B" encoded words (implemented by the Mime module)
    - http://tools.ietf.org/html/rfc2822: message structure, headers, body, etc

    @section smtpclient_relnotes SmtpClient Release Notes

    @subsection smtpclient_v2_1 SmtpClient 2.1
    - added support for the data provider action catalog API
      (<a href="https://github.com/qorelanguage/qore/issues/4808">issue 4808</a>)

    @subsection smtpclient_v2_0 SmtpClient 2.0
    - added support for the DataProvider API
      (<a href="https://github.com/qorelanguage/qore/issues/4564">issue 4564</a>)

    @subsection smtpclient_v1_9_3 SmtpClient 1.9.3
    - fixed message serialization for SMTP handling in case of single \c "." characters on a line in serialized data
      (issue <a href="https://github.com/qorelanguage/qore/issues/3275">issue 3275</a>)

    @subsection smtpclient_v1_9_2 SmtpClient 1.9.2
    - implemented support for a data provider scheme cache and rich option information for connections
      (<a href="https://github.com/qorelanguage/qore/issues/4025">issue 4025</a>)

    @subsection smtpclient_v1_9_1 SmtpClient 1.9.1
    - fixed type errors sending mails
      (<a href="https://github.com/qorelanguage/qore/issues/3813">issue 3813</a>)

    @subsection smtpclient_v1_9 SmtpClient 1.9
    - added the \c "estmps" scheme for completeness
      (<a href="https://github.com/qorelanguage/qore/issues/2833">issue 2833</a>)

    @subsection smtpclient_v1_8 SmtpClient 1.8
    - removed the \c SmtpConnection::getConstructorInfo() and \c SmtpConnection::getConstructorInfoImpl() methods
      (<a href="https://github.com/qorelanguage/qore/issues/3696">issue 3696</a>)
    - added support for socket events
      (<a href="https://github.com/qorelanguage/qore/issues/3425">issue 3425</a>)

    @subsection smtpclient_v1_7 SmtpClient 1.7
    - added the \c SmtpConnection::getConstructorInfo()
      method to allow connections to be created dynamically, potentially in another process from a network
      call (removed in SmtpClient 1.8)
      (<a href="https://github.com/qorelanguage/qore/issues/2628">issue 2628</a>)

    @subsection smtpclient_v1_6 SmtpClient 1.6
    - added the @ref SmtpClient::SmtpConnection "SmtpConnection" class to support the
      <a href="../../ConnectionProvider/html/index.html">ConnectionProvider</a> module
    - updated for complex types

    @subsection smtpclient_v1_5 SmtpClient 1.5
    - converted to @ref new-style "%new-style"

    @subsection smtpclient_v1_4 SmtpClient 1.4
    - fixed missing username and missing password errors

    @subsection smtpclient_v1_3 SmtpClient 1.3
    - added socket instrumention support from Qore 0.8.9
    - optimized connection and login code; HELO/EHLO and authorization are performed when connecting only; not before
      each email

    @subsection smtpclient_v1_2 SmtpClient 1.2
    - added support for parsing a full URL in the SmtpClient::constructor(); added protocol support and setting the
      username / password from the URL
    - use Message::checkSendPossible() to throw a more descriptive exception if the message is incomplete and not
      ready to be sent
    - implemented support for automatically detecting if the server accepts the STARTTLS command and, if so,
      automatically setting the STARTTLS flag if it's not already set

    @subsection smtpclient_v1_1 SmtpClient 1.1
    - removed the Message and Attachment classes to the MailMessage module to be reused in the Pop3Client module

    @subsection smtpclient_v1_10 SmtpClient 1.0
    - updated to a user module, added initial rudimentary ESMTP handling, STARTTLS and quoted-printable encoding
      support + documentation
*/

#! the %SmtpClient namespace holds all public definitions in the %SmtpClient module
/** This includes:
    - SmtpClient: manages a connection to an SMTP server

    Note that the MailMessage module ("required" above) implements the following classes:
    - Message: wraps a message to be sent via an SmtpClient object
    - Attachment: used to attach files to a Message
*/
public namespace SmtpClient {
#! SMTP server app name
public const AppName = "SMTP";

#! 15 second read timeout
public const DefaultReadTimeout = 15s;

#! 30 second connect timeout
public const DefaultConnectTimeout = 30s;

#! internal response hash
public hashdecl SmtpResponseInfo {
    #! The response code
    int code;

    #! The response string
    string desc;
}

#! for backwards-compatibility and convenience
public class Message inherits MailMessage::Message {
    #! creates a Message object from the arguments given
    /** This variant of the constructor is designed to be used to create a Message object for sending with the
        \c SmtpClient class.

        Use the Message::addTo() method to add message recipients

        @param sender the sender's email address; can be in the format \c "Full Display Name <name@example.com>"
        @param subject the subject line for the email; the subject will be encoded with
        <a href="http://tools.ietf.org/html/rfc2047">"Q" encoding</a>

        @throw MESSAGE-CONSTRUCTOR-ERROR the sender's email address is not valid; the subject is empty
    */
    constructor(string sender, string subject) : MailMessage::Message(sender, subject) {
    }
}

#! for backwards-compatibility only
public class Attachment inherits MailMessage::Attachment {
}

#! the class that's used to communicate with an SMTP server and supports optional TLS/SSL encryption
/** This class uses a Mutex lock in each SmtpClient object to ensure thread serialization to the underlying socket and
    its internal configuration, so it is safe to access in a multithreaded context.
*/
public class SmtpClient {
    #! @cond nodoc
    private {
        Socket sock();

        # connect string
        string connect;

        # ensures exclusive access to the object
        Mutex mutex();

        bool nosend = False;

        # optional info log closure
        *code log_info;

        # optional debug log closure
        *code log_debug;

        # tls flag (ie \c "STARTTLS" flag; ie application layer security)
        bool tls = False;

        # ssl flag (for TLS/SSL connections - ie transport layer instead of application layer security)
        bool ssl = False;

        # esmtp flag
        bool esmtp;

        # authentication credentials
        *string user;
        *string pass;

        # logged in flag
        bool logged_in = False;

        # read timeout in milliseconds
        timeout readTimeout = DefaultReadTimeout;

        # connect timeout in milliseconds
        timeout connectTimeout = DefaultConnectTimeout;

        # HELO/EHLO reply
        hash<auto> hello_reply;

        const MaxDebugLine = 2048;
    }
    #! @endcond

    public {
        #! default SMTP port
        const SmtpPort = 25;

        #! default SMTPS port
        /** note that this port is currently assigned to source-specific multicast audio/video
            (http://www.iana.org/assignments/port-numbers); it's use as a port for secure SMTP listeners (where
            security is enforced at the transport layer because the server immediately negotiates a TLS/SSL connection
            before the application protocol communication starts) is deprecated
        */
        const SmtpsPort = 465;

        #! default ESMTP port
        const EsmtpPort = 587;

        #! procotol config
        const Protocols = {
            "smtp": {
                "port": SmtpPort,
                "ssl": False,
                "tls": False,
            },
            "smtps": {
                "port": SmtpsPort,
                "ssl": True,
                "tls": False,
            },
            "smtptls": {
                "port": SmtpsPort,
                "ssl": False,
                "tls": True,
            },
            "esmtp": {
                "port": EsmtpPort,
                "ssl": False,
                "tls": False,
            },
            "esmtps": {
                "port": SmtpsPort,
                "ssl": True,
                "tls": False,
            },
            "esmtptls": {
                "port": EsmtpPort,
                "ssl": False,
                "tls": True,
            },
        };
    }

    #! creates the SmtpClient object
    /** @param host the hostname of the SMTP server (use \c "[hostname]" to explicitly specify an ipv6 connection)
        @param port the port number of the SMTP server
        @param log a closure or call reference for log messages; a single string argument will be passed to this code
        for logging
        @param dbglog a closure for debugging/technical log messages; a single string argument will be passed to this
        code for logging
    */
    constructor(string host, softint port, *code log, *code dbglog) {
        log_info = log;
        log_debug = dbglog;

        connect = sprintf("%s:%d", host, port);
        logDbg("SmtpClient server: %y", connect);
    }

    #! creates the SmtpClient object
    /** @par Example:
        @code{.py}
SmtpClient smtp("smtptls://user@gmail.com:password@smtp.gmail.com", \log(), \log());
        @endcode

        @param url the URL of the SMTP server (use \c "[hostname]" or \c "[address]" for ipv6 connections); if no
        protocol (scheme) and no port is given for non-UNIX sockets, then @ref SmtpPort is used as the default port
        number.  This argument is parsed with parse_url(); see @ref smtpclient_protocols for a description of the
        handling of the protocol (scheme) component of the URL including default ports per protocol (scheme). If an
        unknown protocol (scheme) is given then a \c SMTP-UNKNOWN-PROTOCOL exception is raised
        @param log an optional closure or call reference for log messages; a single string argument will be passed to
        this code for logging
        @param dbglog an optional closure or call reference for debugging/technical log messages; a single string
        argument will be passed to this code for logging

        @throw PARSE-URL-ERROR the \a url argument could not be parsed with parse_url()
        @throw SMTPCLIENT-UNKNOWN-PROTOCOL the protocol (scheme) given is unknown or unsupported
        @throw SMTPCLIENT-INVALID-AUTHENTICATION partial authentication credentials passed; the username or password
        is missing
    */
    constructor(string url, *code log, *code dbglog) {
        log_info = log;
        log_debug = dbglog;

        hash<UrlInfo> uh = parse_url(url, True);

        if (uh.protocol) {
            *hash<auto> ph = Protocols.(uh.protocol);
            if (!ph) {
                throw "SMTPCLIENT-UNKNOWN-PROTOCOL", sprintf("unsupported scheme %y in %y; known schemes: %y",
                    uh.protocol, url, keys Protocols);
            }

            if (!uh.port && uh.host[0] != "/") {
                uh.port = ph.port;
            }

            self += ph.("tls", "ssl");
        } else if (!uh.port && uh.host[0] != "/") {
            uh.port = SmtpPort;
        }

        connect = uh.port ? sprintf("%s:%d", uh.host, uh.port) : uh.host;
        logDbg("SmtpClient server: %y", connect);

        if (uh.username) {
            if (!uh.password)
                throw "SMTPCLIENT-INVALID-AUTHENTICATION", sprintf("username is set but password is missing in URL "
                    "%y", url);
            user = uh.username;
            pass = uh.password;

            logDbg("set authentication credentials to %s/xxx", user);
        } else if (uh.password) {
            throw "SMTPCLIENT-INVALID-AUTHENTICATION", sprintf("password is set but username is missing in URL %y",
                url);
        }
    }

    #! disconnects if connected and destroys the object
    /** if any exceptions occur during the disconnection, they are sent to the debug log closure/call reference
    */
    destructor() {
        try {
            disconnect();
        } catch (hash<ExceptionInfo> ex) {
            logDbg("SmtpClient disconnect: %s: %s", ex.err, ex.desc);
        }
    }

    #! Returns info about the connection
    /** @return info about the connection with the following keys:
        - \c target: the connection target (host:port)
        - \c tls: the tls flag
        - \c ssl: the ssl flag
        - \c user: any username for the connection
        - \c pass: any password for the connection
    */
    hash<auto> getInfo() {
        return {
            "target": connect,
            "tls": tls,
            "ssl": ssl,
            "user": user,
            "pass": pass,
        };
    }

    #! Set info log closure
    setInfoLogClosure(*code log) {
        self.log_info = log;
    }

    #! Set debug  log closure
    setDebugLogClosure(*code log) {
        self.log_debug = log;
    }

    #! Returns the connection target string
    /** @since %SmtpClient 1.7
    */
    string getTarget() {
        return connect;
    }

    #! sets the TLS/SSL flag
    /** @param n_tls if @ref True "True" then use TLS/SSL; if the TLS/SSL flag is set then the client will issue a
        \c "STARTTLS" command after connecting and negotiate a secure TLS/SSL connection to the server; will also in
        this case turn off the SSL connection flag
    */
    tls(bool n_tls) {
        tls = n_tls;
        if (ssl) {
            ssl = False;
        }
    }

    #! returns the TLS/SSL flag
    bool tls() {
        return tls;
    }

    #! sets the SSL connection flag
    /** @param n_ssl if @ref True "True" then connections to the SMTP server will immediately try to negotiate
        transport layer TSL/SSL security; will also in this case turn off the TLS/SSL \c "STARTTLS" application layer
        security flag
    */
    ssl(bool n_ssl) {
        ssl = n_ssl;
        if (tls) {
            tls = False;
        }
    }

    #! returns the SSL connection flag
    bool ssl() {
        return ssl;
    }

    #! sets the username and password for authenticated connections
    /** @param n_user the username to set for authentication
        @param n_pass the password to set for authentication

        @note
        - Currently this class only knows how to do AUTH PLAIN authentication
        - This method is subject to thread serialization
    */
    setUserPass(string n_user, string n_pass) {
        AutoLock am(mutex);
        user = n_user;
        pass = n_pass;
    }

    #! sets or disables test mode; no connections are made in test mode
    test(bool ns) {
        nosend = ns;
    }

    #! returns the test mode flag
    bool test() {
        return nosend;
    }

    #! Connect to the server with the connection parameters set in the @ref constructor()
    /** @note
        - For possible exceptions, see %Qore's @ref Qore::Socket::connect() "Socket::connect()" method
        - This method is subject to thread serialization
    */
    connect() {
        AutoLock am(mutex);
        connectIntern();
    }

    #! return connection status
    bool isConnected() {
        return (nosend || sock.isOpen());
    }

    #! disconnect from the server
    /** @note This method is subject to thread serialization
    */
    disconnect() {
        AutoLock am(mutex);
        disconnectIntern();
    }

    #! sets the read timeout
    setReadTimeout(timeout to) {
        readTimeout = to;
    }

    #! returns the read timeout as an integer giving milliseconds
    int getReadTimeoutMs() {
        return readTimeout;
    }

    #! returns the read timeout as a relative time value
    date getReadTimeoutDate() {
        return milliseconds(readTimeout);
    }

    #! sets the connect timeout
    setConnectTimeout(timeout to) {
        connectTimeout = to;
    }

    #! returns the connect timeout as an integer giving milliseconds
    int getConnectTimeoutMs() {
        return connectTimeout;
    }

    #! returns the connect timeout as a relative time value
    date getConnectTimeoutDate() {
        return milliseconds(connectTimeout);
    }

    #! send a Message to the server
    /** @param message the Message to send

        @return a hash of data returned by the SMTP server (the return structure hashes described below are made up of
        the following keys: \c "code": the return code, \c "desc": the string description):
        - \c HELO or \c EHLO: a hash of the reply received from the \c HELO or \c EHLO command
        - \c RCPT: hash keyed by email address with hash return structures values for the RCPT TO command
        - \c MSGID: return structure after the send; generally contains message id
        - \c QUIT: the server response of the disconnect command

        @note This method is subject to thread serialization

        @throw MESSAGE-ERROR the message is incomplete and cannot be sent
    */
    hash<auto> sendMessage(MailMessage::Message message) {
        # throws a MESSAGE-ERROR exception if the message cannot be sent
        string mstr = message.serialize();

        if (log_debug)
            logDbg("message: %s", message.toLine());

        # lock for sending
        AutoLock am(mutex);

        hash<auto> reply;
        try {
            # send SMTP info for message
            reply = sendMessageInfoIntern(message);

            # send message
            sendData(mstr);

            # end of data
            hash<SmtpResponseInfo> rh = sendCommand(".");
            reply.MSGID = rh;

            # quit
            rh = sendCommand("QUIT");
            logged_in = False;
            reply.QUIT = rh;
        } catch(hash<ExceptionInfo> ex) {
            logDbg("send error: %s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
            forceDisconnectIntern();
            rethrow;
        }
        # close connection
        forceDisconnectIntern();

        return reply;
    }

    #! force disconnect of socket without error
    /** @note This method is subject to thread serialization
    */
    forceDisconnect() {
        AutoLock am(mutex);
        forceDisconnectIntern();
    }

    #! Removes any warning @ref Qore::Thread::Queue "Queue" object from the Socket
    /** @par Example:
        @code{.py}
smtp.clearWarningQueue();
        @endcode

        @see setWarningQueue()

        @since %SmtpClient 1.3
    */
    nothing clearWarningQueue() {
        sock.clearWarningQueue();
    }

    #! Sets a @ref Qore::Thread::Queue "Queue" object to receive socket warnings
    /** @par Example:
        @code{.py}
smtp.setWarningQueue(5000, 5000, queue, "socket-1");
        @endcode

        @param warning_ms the threshold in milliseconds for individual socket actions (send, receive, connect), if
        exceeded, a socket warning is placed on the warning queue with the following keys:
        - \c "type": a string with the constant value \c "SOCKET-OPERATION-WARNING"
        - \c "operation": a string giving the operation that caused the warning (ex: \c "connect")
        - \c "us": an integer giving the number of microseconds for the operation
        - \c "timeout": an integer giving the warning threshold in microseconds
        - \c "arg": if any \c "arg" argument is passed to the @ref setWarningQueue() "SmtpClient::setWarningQueue()"
          method, it will be included in the warning hash here
        @param warning_bs value in bytes per second; if any call has performance below this threshold, a socket
        warning is placed on the warning queue with the following keys:
        - \c "type": a string with the constant value \c "SOCKET-THROUGHPUT-WARNING"
        - \c "dir": either \c "send" or \c "recv" depending on the direction of the data flow
        - \c "bytes": the amount of bytes sent
        - \c "us": an integer giving the number of microseconds for the operation
        - \c "bytes_sec": a float giving the transfer speed in bytes per second
        - \c "threshold": an integer giving the warning threshold in bytes per second
        - \c "arg": if any \c "arg" argument is passed to the @ref setWarningQueue() "SmtpClient::setWarningQueue()"
          method, it will be included in the warning hash here
        @param queue the @ref Qore::Thread::Queue "Queue" object to receive warning events
        @param arg an optional argument to be placed in the \c "arg" key in each warning hash (could be used to
        identify the socket for example)
        @param min_ms the minimum transfer time with a resolution of milliseconds for a transfer to be eligible for
        triggering a warning; transfers that take less than this period of time are not eligible for raising a warning

        @throw QUEUE-ERROR the Queue passed has a maximum size set
        @throw SOCKET-SETWARNINGQUEUE-ERROR at least one of \a warning_ms and \a warning_bs must be > 0

        @see clearWarningQueue()

        @since %SmtpClient 1.3
    */
    nothing setWarningQueue(int warning_ms, int warning_bs, Queue queue, auto arg, timeout min_ms = 1s) {
        sock.setWarningQueue(warning_ms, warning_bs, queue, arg, min_ms);
    }

    #! Returns performance statistics for the socket
    /** @par Example:
        @code{.py}
hash<auto> h = smtp.getUsageInfo();
        @endcode

        @return a hash with the following keys:
        - \c "bytes_sent": an integer giving the total amount of bytes sent
        - \c "bytes_recv": an integer giving the total amount of bytes received
        - \c "us_sent": an integer giving the total number of microseconds spent sending data
        - \c "us_recv": an integer giving the total number of microseconds spent receiving data
        - \c "arg": (only if warning values have been set with @ref setWarningQueue() "SmtpClient::setWarningQueue()")
          the optional argument for warning hashes
        - \c "timeout": (only if warning values have been set with
          @ref setWarningQueue() "SmtpClient::setWarningQueue()") the warning timeout in microseconds
        - \c "min_throughput": (only if warning values have been set with
          @ref setWarningQueue() "SmtpClient::setWarningQueue()") the minimum warning throughput in bytes/sec

        @since %SmtpClient 1.3

        @see clearStats()
    */
    hash<auto> getUsageInfo() {
        return sock.getUsageInfo();
    }

    #! Clears performance statistics
    /** @par Example:
        @code{.py}
smtp.clearStats();
        @endcode

        @since %SmtpClient 1.3

        @see getUsageInfo()
    */
    clearStats() {
        sock.clearStats();
    }

    #! Sets a @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"
    /** @par Example:
        @code{.py}
smtp.setEventQueue(queue);
        @endcode

        @param queue the @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"; note that
        the Queue passed cannot have any maximum size set or a QUEUE-ERROR will be thrown
        @param arg an argument that will be included in each event hash in the \a arg key
        @param with_data if @ref True, then the actual raw data transferred / received is also included in the events

        @throw QUEUE-ERROR the Queue passed has a maximum size set

        @see @ref event_handling for more information

        @since %SmtpClient 1.8
    */
    setEventQueue(Qore::Thread::Queue queue, auto arg, *bool with_data) {
        sock.setEventQueue(queue, arg, with_data);
    }

    #! Removes any @ref Qore::Thread::Queue "Queue" object
    /** After this call, @ref socket_events "socket events" are no longer added to any currently-set
        @ref Qore::Thread::Queue "Queue"

        @par Example:
        @code{.py}
smtp.setEventQueue();
        @endcode

        @see @ref event_handling for more information

        @since %SmtpClient 1.8
    */
    setEventQueue() {
        sock.setEventQueue();
    }

    #! @cond nodoc
    # don't reimplement this method; fix/enhance it in the module
    final private disconnectIntern() {
        if (isConnected()) {
            sock.close();
            sock.shutdown();
        }
    }

    private log(string msg) {
        if (log_info.val())
            call_function(log_info, "SmtpClient: " + trim(vsprintf(msg, argv)));
    }

    private logDbg(string msg) {
        if (log_debug.val())
            call_function(log_debug, "SmtpClient: " + trim(vsprintf(msg, argv)));
    }

    private connectIntern() {
        try {
            sock.connect(connect, connectTimeout);
            if (ssl)
                sock.upgradeClientToSSL(connectTimeout);

            string rep = readLine(readTimeout);
            logDbg("connect reply: %y", trim(rep));
            esmtp = (rep =~ /ESMTP/);

            # send HELO/EHLO string
            string hello = esmtp ? "EHLO" : "HELO";
            hash<SmtpResponseInfo> rh = sendCommand(hello + "  %s", gethostname());
            if (rh.code >= 500)
                throw "SMTP-DATA-EXCEPTION", sprintf("error sending %s command: %y", hello, rh);

            hello_reply{hello} = rh;

            # try to automatically set the tls flag if it's not already set and we are talking to an ESMTP server and
            # we are not already in a secure connection
            if (!tls && esmtp && !ssl && rh.desc =~ /STARTTLS/) {
                logDbg("server supports STARTTLS; automatically setting STARTTLS flag");
                tls = True;
            }

            # issue STARTTLS and upgrade to a TLS connection if the tls flag is set and we are not already secure
            if (tls && !sock.isSecure()) {
                rh = sendCommand("STARTTLS");
                if (rh.code >= 500)
                    throw "SMTP-DATA-EXCEPTION", sprintf("error sending STARTTLS command: %y", rh);

                sock.upgradeClientToSSL(connectTimeout);
                logDbg("upgrade to TLS/SSL connection %s %s", sock.getSSLCipherName(), sock.getSSLCipherVersion());
            }

            # issue login if credentials supplied and we have not already logged in
            if (!logged_in && user)
                loginIntern();
        } catch (hash<ExceptionInfo> ex) {
            sock.close();
            sock.shutdown();
            rethrow;
        }
    }

    private loginIntern() {
        hash<SmtpResponseInfo> rh = sendCommand("AUTH PLAIN %s",
            make_base64_string(binary(user) + <00> + binary(user) + <00> + binary(pass)));
        if (rh.code != 235)
            throw "SMTP-DATA-EXCEPTION", sprintf("login failed: %y", rh);
        logged_in = True;
    }

    # send data over the socket
    private sendDataIntern(data str) {
        if (!isConnected()) {
            logDbg("send: not connected; not sending");
            throw "NOT-CONNECTED", "not connected in sendDataIntern()";
        }

        # send
        sock.send(str);
    }

    # send data and log in the debug log if set
    private sendData(string str) {
        # format additional arguments if necessary
        if (!argv.empty())
            str = vsprintf(str, argv);

        if (log_debug.val()) {
            string lstr = trim(str);
            if (lstr.size() > MaxDebugLine) {
                splice lstr, MaxDebugLine;
                lstr += "...";
            }
            logDbg("data: %y", lstr);
        }

        sendDataIntern(str);
    }

    # send data and log in the debug log if set
    private sendData(binary b) {
        logDbg("binary data: %d bytes", b.size());
        sendDataIntern(b);
    }

    # send a command over the socket and return the response as a hash
    # don't reimplement this method; fix/enhance it in the module
    final private hash<SmtpResponseInfo> sendCommand(string str) {
        # format additional arguments if necessary
        if (!argv.empty())
            str = vsprintf(str, argv);

        trim str;
        logDbg("send %y", str);

        # send data
        sendDataIntern(str + "\r\n");

        # read data
        string rep;

        softint code;
        string desc;

        # process multi-line responses
        while (True) {
            string l = readLine(readTimeout);
            trim l;
            logDbg("reply: %y", l);

            # if a continuation is signaled from the server, then keep reading
            if (l =~ /^[0-9]{3}-/) {
                if (!code)
                    code = int(l);
                # assume it's the same code every time
                if (!desc.empty())
                    desc += "\n";
                desc += extract l, 4;
                continue;
            }  else {
                if (l !~ /^[0-9]{3} /) {
                    log("cannot parse reply: %s\n", l);
                    desc += l;
                    code = -1;
                    break;
                }
                if (!code)
                    code = int(l);
                # assume it's the same code every time
                if (!desc.empty())
                    desc += "\n";
                desc += extract l, 4;
                break;
            }
        }

        return <SmtpResponseInfo>{"code": code, "desc": desc};
    }

    # read a line from the socket (terminated with \n)
    private string readLine(timeout to) {
        string str;
        int c = 0;
        do {
            c = sock.recvu1(to);
            str += chr(c);
        } while (c != 10);

        return str;
    }

    # sends the message header (without body & attachments) to the SMTP server
    # don't reimplement this method; fix/enhance it in the module
    final private hash<auto> sendMessageInfoIntern(MailMessage::Message message) {
        # open connection to server
        if (!isConnected()) {
            connectIntern();
        }

        # issue login if credentials supplied and we have not already logged in
        if (!logged_in && user) {
            loginIntern();
        }

        hash<SmtpResponseInfo> rh;
        hash<auto> reply = hello_reply;

        rh = sendCommand("MAIL FROM: <%s>", message.getFrom());
        if (rh."code" >= 500) {
            throw "SMTP-DATA-EXCEPTION", sprintf("error sending FROM command: %y", rh);
        }

        # send recipient
        foreach string rcpt in (message.getRecipients()) {
            rh = sendCommand("RCPT TO: <%s>", rcpt);
            reply.RCPT{rcpt} = rh;
            if (rh."code" >= 500) {
                throw "SMTP-DATA-EXCEPTION", sprintf("error sending RCPT command: %y", rh);
            }
        }

        # send data
        rh = sendCommand("DATA");
        if (rh."code" != 354) {
            throw "SMTP-DATA-EXCEPTION", sprintf("error sending DATA command (expected code 354): %y", rh);
        }

        return reply;
    }

    private forceDisconnectIntern() {
        if (isConnected()) {
            try {
                disconnectIntern();
            } catch() {
                # ignore
            }
        }
    }
    #! @endcond
}

#! Class for SMTP non-blocking / polling pings
public class SmtpPingPollOperation inherits Qore::AbstractPollOperation {
    public {
        #! Connect state
        const SPS_CONNECT = "connect";

        #! Read hello state
        const SPS_READ_HELLO = "read-hello";

        #! Send hello state
        const SPS_SEND_HELLO = "send-hello";

        #! Read hello reply state
        const SPS_READ_HELLO_REPLY = "read-hello-reply";

        #! Send STARTTLS state
        const SPS_STARTTLS = "starttls";

        #! Read STARTTLS reply
        const SPS_READ_STARTTLS_REPLY = "read-starttls-reply";

        #! Upgrade socket connection to TLS
        const SPS_UPGRADE_TO_TLS = "upgrade-tls";

        #! Login state
        const SPS_LOGIN = "login";

        #! Read login reply
        const SPS_READ_LOGIN_REPLY = "read-login-reply";

        #! Complete state
        const SPS_COMPLETE = "complete";
    }

    private {
        #! Info about the SMTP client
        hash<auto> info;

        #! The Socket for communication with the server
        Socket sock();

        #! The current internal poll operation
        AbstractPollOperation poller;

        #! Lock for atomicity
        Mutex m();

        #! Current state
        string state;

        #! Goal reached flag
        bool goal_reached = False;

        #! ESMTP flag
        bool esmtp = False;

        #! Server's HELO / EHLO reply code
        int hello_reply_code;

        #! Server's HELO / EHLO reply
        string hello_reply;

        #! Server's STARTTLS code
        int starttls_code;

        #! Server's STARTTLS reply
        string starttls_reply;

        #! Server's login code
        int login_code;

        #! Server's login reply
        string login_reply;
    }

    #! Creates the object based on the SmtpClient
    constructor(SmtpClient smtp) {
        info = smtp.getInfo();

        state = SPS_CONNECT;
        poller = info.ssl
            ? sock.startPollConnectSsl(info.target)
            : sock.startPollConnect(info.target);
    }

    #! Returns the goal
    /** @return the goal set in the constructor
    */
    string getGoal() {
        return "ping";
    }

    #! Returns the current state
    /** @return the current state
    */
    string getState() {
        AutoLock al(m);
        if (!poller) {
            return goal_reached ? "complete" : "error";
        }
        return state;
    }

    #! Returns @ref True when the goal as been reached
    /** @return @ref True when the goal as been reached
    */
    bool goalReached() {
        return state == SPS_COMPLETE;
    }

    #! Returns a hash to be used for I/O polling or @ref nothing in case the poll operation is complete
    *hash<SocketPollInfo> continuePoll() {
        AutoLock al(m);
        if (!poller) {
            return;
        }
        while (True) {
            *hash<SocketPollInfo> pinfo = poller.continuePoll();
            if (pinfo) {
                return pinfo;
            }

            if (state == SPS_CONNECT) {
                state = SPS_READ_HELLO;
                poller = sock.startPollRecvUntilBytesString("\n");
                continue;
            }

            if (state == SPS_READ_HELLO) {
                state = SPS_SEND_HELLO;
                string rep = trim(poller.getOutput());
                esmtp = (rep =~ /ESMTP/);
                poller = sock.startPollSend(sprintf("%s %s\r\n", esmtp ? "EHLO" : "HELO", gethostname()));
                continue;
            }

            if (state == SPS_SEND_HELLO) {
                state = SPS_READ_HELLO_REPLY;
                poller = sock.startPollRecvUntilBytesString("\n");
                continue;
            }

            if (state == SPS_READ_HELLO_REPLY) {
                if (!getReply(\hello_reply_code, \hello_reply)) {
                    # continue reading
                    continue;
                }

                if (!info.tls && hello_reply =~ /STARTTLS/) {
                    info.tls = True;
                }

                if (info.tls) {
                    state = SPS_STARTTLS;
                    poller = sock.startPollSend("STARTTLS\r\n");
                    continue;
                }

                if (info.user && info.pass) {
                    startLogin();
                    continue;
                }

                delete poller;
                state = SPS_COMPLETE;
                break;
            }

            if (state == SPS_STARTTLS) {
                state = SPS_READ_STARTTLS_REPLY;
                poller = sock.startPollRecvUntilBytesString("\n");
                continue;
            }

            if (state == SPS_READ_STARTTLS_REPLY) {
                if (!getReply(\starttls_code, \starttls_reply)) {
                    # continue reading
                    continue;
                }

                state = SPS_UPGRADE_TO_TLS;
                poller = sock.startPollUpgradeClientToSSL();
                continue;
            }

            if (state == SPS_UPGRADE_TO_TLS) {
                if (info.user && info.pass) {
                    startLogin();
                    continue;
                }

                delete poller;
                state = SPS_COMPLETE;
                break;
            }

            if (state == SPS_LOGIN) {
                state = SPS_READ_LOGIN_REPLY;
                poller = sock.startPollRecvUntilBytesString("\n");
                continue;
            }

            if (state == SPS_READ_LOGIN_REPLY) {
                if (!getReply(\login_code, \login_reply)) {
                    # continue reading
                    continue;
                }

                if (login_code != 235) {
                    throw "SMTP-POLL-ERROR", sprintf("login failed: %s %s", login_code, login_reply);
                }

                delete poller;
                state = SPS_COMPLETE;
                break;
            }
        }
    }

    #! Starts the polling login state
    private startLogin() {
        state = SPS_LOGIN;
        poller = sock.startPollSend(sprintf("AUTH PLAIN %s\r\n", make_base64_string(binary(info.user) + <00> +
            binary(info.user) + <00> + binary(info.pass))));
    }

    #! Private reads a reply from the SMTP server
    /** @return False to continue reading, True if done
    */
    private bool getReply(reference<int> rcode, reference<string> rmsg) {
        string line = poller.getOutput();
        if (line !~ /^[0-9]{3}[- ]/) {
            throw "SMTP-POLL-ERROR", sprintf("server provided an invalid reply: %s", trim line);
        }
        int tcode = int(line);
        if (!rcode) {
            rcode = tcode;
        } else if (tcode != rcode) {
            throw "SMTP-POLL-ERROR", sprintf("server provided an inconsistent reply; expecting code %d; got "
                "code %d", rcode, tcode);
        }

        bool cont = line[3] == "-";
        if (rmsg) {
            rmsg += "\n";
        }
        rmsg += extract line, 4;

        # continue reading
        if (cont) {
            poller = sock.startPollRecvUntilBytesString("\n");
            return False;
        }

        if (rcode >= 500) {
            throw "SMTP-POLL-ERROR", sprintf("server replied with error code %d: %s", rcode, rmsg);
        }
        return True;
    }
}

#! class for SMTP connections; returns an object of class @ref SmtpClient for sending emails
/** supports the following runtime options in getImpl() for connection logging:
    - \c "log": a closure accepting a single string for logging
    - \c "dbglog": a closure taking a single string for detailed technical connection logging

    @since %SmtpClient 1.6
*/
public class SmtpConnection inherits ConnectionProvider::AbstractConnectionWithInfo {
    public {
        #! Connection entry info
        const ConnectionScheme = <ConnectionSchemeInfo>{
            "display_name": "SMTP Connection",
            "short_desc": "A connection to an SMTP server",
            "desc": "A connection to an SMTP server",
            "cls": Class::forName("SmtpConnection"),
            "schemes": {
                "esmtptls": True,
                "esmtps": True,
                "esmtp": True,
                "smtptls": True,
                "smtps": True,
                "smtp": True,
            },
            "options": HttpConnection::ConnectionScheme.options + {
                "password": <ConnectionOptionInfo>{
                    "display_name": "Password",
                    "short_desc": "The password to use for authentication",
                    "type": "string",
                    "desc": "The password for authentication; only used if no username or password is set in the URL "
                        "and if the `username` option is also used",
                    "sensitive": True,
                },
                "security": <ConnectionOptionInfo>{
                    "display_name": "Security Type",
                    "short_desc": "Sets the type of security to use",
                    "type": "string",
                    "desc": "Sets the security option for the object; note that this option, if set to any value "
                        "other than `default` will override any security implied by the URL scheme",
                    "allowed_values": (
                        <AllowedValueInfo>{
                            "value": "default",
                            "desc": "Security implied only by the protocol scheme",
                        }, <AllowedValueInfo>{
                            "value": "ssl",
                            "desc": "Immediately negotiate an SSL session; fo not use `STARTTLS`",
                        }, <AllowedValueInfo>{
                            "value": "tls",
                            "desc": "Make a standard socket connection and immediately issue a `STARTTLS` command "
                                "for a secure connection",
                        },
                    ),
                },
                "username": <ConnectionOptionInfo>{
                    "display_name": "Username",
                    "short_desc": "The username to use for authentication",
                    "type": "string",
                    "desc": "The username for authentication; only used if no username or password is set in the URL "
                        "and if the `password` option is also used",
                },
            },
        };
    }

    #! creates the SmtpConnection connection object
    /** @param name the name of the connection
        @param description connection description
        @param url connection URL (potentially with password info)
        @param attributes various attributes. See below
        @param options connection options

        See @ref AbstractConnection::constructor() for \c attributes and \c options reference.

        @throw CONNECTION-OPTION-ERROR missing or invalid connection option
    */
    constructor(string name, string description, string url, hash<auto> attributes = {}, hash<auto> options = {})
            : AbstractConnectionWithInfo(name, description, url, attributes, options) {
    }

    #! creates the SmtpConnection connection object
    /** @param config with the following keys:
        - name (required string): the connection name
        - display_name (optional string): the display name
        - short_desc (optional string): a short description in plain text
        - desc (optional string): a long description with markdown formatting
        - url (required string): the connection URL
        - opts (optional hash): connection options
        - logger (optional LoggerInterface object): logger for the connection
        @param attr optional connection attributes
        - monitor (optional bool): should the connection be monitored? Default: True
        - enabled (optional bool): is the connection enabled? Default: True
        - locked (optional bool): is the connection locked? Default: False
        - debug_data (optional bool): debug data? Default: False
        - tags (optional hash): tags for the connection; no default value

        @throw CONNECTION-OPTION-ERROR missing or invalid connection option or attribute
    */
    constructor(hash<auto> config, *hash<auto> attr) : AbstractConnectionWithInfo(config, attr) {
    }

    #! returns \c "smtp"
    string getType() {
        return "smtp";
    }

    #! returns runtime options
    /** @return a hash with the following keys reflecting support for the corresponding runtime options in getImpl() for connection logging:
        - \c "log": a closure accepting a single string for logging
        - \c "dbglog": a closure taking a single string for detailed technical connection logging
    */
    *hash<auto> getRuntimeOptions() {
        return {
            "log": True,
            "dbglog": True,
        };
    }

    #! returns an SmtpClientDataProvider object for this connection
    /** @param constructor_options any additional constructor options for the data provider

        @return an SmtpClientDataProvider object for this connection

        @see hasDataProvider()
    */
    DataProvider::AbstractDataProvider getDataProvider(*hash<auto> constructor_options) {
        return new SmtpClientDataProvider(get());
    }

    #! returns @ref True, as the connection returns a data provider with the @ref getDataProvider() method
    /** @return @ref True, as the connection returns a data provider with the @ref getDataProvider() method

        @see @ref getDataProvider()
    */
    bool hasDataProvider() {
        return True;
    }

    #! returns @ref True, since this connection type supports the %Qore @ref Qore::Socket "Socket-based" polling API
    /** @return @ref True

        @since ConnectionProvider 1.7
    */
    bool supportsPollingApi() {
        return True;
    }

    #! Called to start a non-blocking polling ping operation on the remote SMTP server
    /**
        @return a socket poll operation object that will allow the connection goal to be reached with polling

        @see supportsPollingApi()

        @since SmtpClient 2.0
    */
    Qore::AbstractPollOperation startPollConnect() {
        return new SmtpPingPollOperation(getImpl(False));
    }

    #! Sets child data provider capabilities
    private setChildCapabilities() {
        children_can_support_apis = True;
    }

    #! returns an @ref SmtpClient object
    /** @param connect if @ref True "True", then @ref SmtpClient::SmtpClient::connect() "SmtpClient::connect()" is called
        @param rtopts supports the following runtime options in getImpl() for connection logging:
        - \c "log": a closure accepting a single string for logging
        - \c "dbglog": a closure taking a single string for detailed technical connection logging

        @return an @ref SmtpClient object
    */
    private SmtpClient getImpl(bool connect = True, *hash<auto> rtopts) {
        string url = self.url;
        if (opts.username.val() && opts.password.val() && (!urlh.username.val() || !urlh.password.val())) {
            url = sprintf("%s://%s:%s@%s", urlh.protocol, opts.username, opts.password, urlh.host);
            if (urlh.port) {
                url += sprintf(":%d", urlh.port);
            }
        }
        if (opts.security == "tls") {
            url =~ s/^(e)?[a-z]+:/$1smtptls:/;
        } else if (opts.security == "ssl") {
            url =~ s/^(e)?[a-z]+:/$1smtps:/;
        }
        SmtpClient sc(url, rtopts.log, rtopts.dbglog);
        if (connect) {
            sc.connect();
        }
        return sc;
    }

    #! Returns the ConnectionSchemeInfo hash for this object
    private hash<ConnectionSchemeInfo> getConnectionSchemeInfoImpl() {
        return ConnectionScheme;
    }
}

#! Data provider implementing an API for sending email messages
/**
*/
public class SmtpClientDataProvider inherits DataProvider::AbstractDataProvider {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "SmtpClientDataProvider",
            "supports_children": True,
            "constructor_options": ConstructorOptions,
            "children_can_support_apis": True,
            "children_can_support_records": False,
            "children_can_support_observers": False,
        };

        #! Constructor options
        const ConstructorOptions = {
            "url": <DataProviderOptionInfo>{
                "display_name": "URL",
                "short_desc": "The SMTP URL to connect to",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "A URL for an SMTP server; supported schemes are:\n"
                    "- `esmtp://`\n"
                    "- `esmtps://`\n"
                    "- `esmtptls://`\n"
                    "- `smtp://`\n"
                    "- `smtps://`\n"
                    "- `smtptls://`\n",
                "required": True,
            },
        };
    }

    private {
        #! The SmtpClient object
        SmtpClient smtp;

        const ChildMap = {
            "send-email": Class::forName("SmtpClient::SmtpClientSendEmailDataProvider"),
        };
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) {
        hash<auto> copts = checkOptions("CONSTRUCTOR-ERROR", ConstructorOptions, options);
        code log_info = sub (string msg) {
            if (logger) {
                logger.info("%s", msg);
            }
        };
        code log_debug = sub (string msg) {
            if (logger) {
                logger.debug("%s", msg);
            }
        };

        smtp = new SmtpClient(copts.url, log_info, log_debug);
    }

    #! Creates the object from an SmtpClient object
    constructor(SmtpClient smtp) {
        self.smtp = smtp;
    }

    string getName() {
        return "smtpclient";
    }

    #! Returns the data provider description
    *string getDesc() {
        return "Data provider for SMTP servers; children provide APIs related to sending emails";
    }

    #! Return data provider summary info
    *list<hash<DataProviderSummaryInfo>> getChildProviderSummaryInfo() {
        return map $1.getConstant("ProviderSummaryInfo").getValue(), ChildMap.iterator();
    }

    #! Returns a list of child data provider names, if any
    /** @return a list of child data provider names, if any
    */
    private *list<string> getChildProviderNamesImpl() {
        return keys ChildMap;
    }

    #! Returns the given child provider or @ref nothing if the given child is unknown
    /** @return the given child provider or @ref nothing if the given child is unknown

        @see getChildProviderEx()
    */
    private *AbstractDataProvider getChildProviderImpl(string name) {
        *Class cls = ChildMap{name};
        if (!cls) {
            return;
        }
        return cls.newObject(smtp);
    }

    #! Returns data provider static info
    private hash<DataProviderInfo> getStaticInfoImpl() {
        return ProviderInfo;
    }
}

#! Send email data provider
public class SmtpClientSendEmailDataProvider inherits AbstractDataProvider {
    public {
        #! SMTP connection
        SmtpClient smtp;

        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "name": "send-email",
            "desc": "SMTP send email data provider",
            "type": "SmtpClientSendEmailDataProvider",
            "constructor_options": SmtpClientDataProvider::ConstructorOptions,
            "supports_request": True,
        };

        #! Provider summary info
        const ProviderSummaryInfo = cast<hash<DataProviderSummaryInfo>>(ProviderInfo{
            AbstractDataProvider::DataProviderSummaryInfoKeys
        });

        #! Request type
        const RequestType = new SmtpSendEmailRequestDataType();

        #! Response type
        const ResponseType = new SmtpSendEmailResponseDataType();
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) {
        checkOptions("CONSTRUCTOR-ERROR", SmtpClientDataProvider::ConstructorOptions, options);
        code log_info = sub (string msg) {
            if (logger) {
                logger.info("%s", msg);
            }
        };
        code log_debug = sub (string msg) {
            if (logger) {
                logger.debug("%s", msg);
            }
        };

        smtp = new SmtpClient(options.url, log_info, log_debug);
    }

    #! Creates the object from an SMTP connection
    constructor(SmtpClient smtp) {
        self.smtp = smtp;
        smtp.setInfoLogClosure(sub (string msg) {
            if (logger) {
                logger.info("%s", msg);
            }
        });
        smtp.setDebugLogClosure(sub (string msg) {
            if (logger) {
                logger.debug("%s", msg);
            }
        });
    }

    #! Returns the data provider name
    string getName() {
        return "send-email";
    }

    #! Makes a request and returns the response
    /** @param req the request info
        @param request_options the request options; will be processed by validateRequestOptions()

        @return the response to the request
    */
    private auto doRequestImpl(auto req, *hash<auto> request_options) {
        Message msg(req.sender, req.subject);
        map msg.addTO($1), req.to;
        map msg.addCC($1), req.cc;
        map msg.addBCC($1), req.bcc;
        msg.setBody(req.body, req."body-encoding", req."body-mime-type");
        map msg.attach($1.name, $1."mime-type", $1."data", $1.encoding, $1.hdr), req.attachments;
        return smtp.sendMessage(msg);
    }

    #! Returns the description of a successful request message, if any
    /** @return the request type for this provider
    */
    private *AbstractDataProviderType getRequestTypeImpl() {
        return RequestType;
    }

    #! Returns the description of a response message, if this object represents a response message
    /** @return the response type for this response message
    */
    private *AbstractDataProviderType getResponseTypeImpl() {
        return ResponseType;
    }

    #! Returns data provider static info
    hash<DataProviderInfo> getStaticInfoImpl() {
        return ProviderInfo;
    }
}

#! SMTP attachment type
public class SmtpSendEmailAttachmentDataType inherits HashDataType {
    private {
        #! Field descriptions
        const Fields = {
            "data": {
                "type": DataType,
                "desc": "The data for the attachment",
                "required": True,
            },
            "encoding": {
                "type": StringType,
                "desc": "The encoding to use for the attachment:\n"
                    "- `default`: `quoted-printable` for string data, `base64` for binary data\n"
                    "- `none`: no content encoding (not recommended)\n"
                    "- `quoted-printable`: quoted printable encoding \n"
                    "- `base64`: base64 encoding",
                "default_value": "default",
            },
            "hdr": {
                "type": HashOrNothingType,
                "desc": "Optional headers to send with the attachment",
            },
            "mime-type": {
                "type": StringType,
                "desc": "The MIME type of the attachment",
                "required": True,
            },
            "name": {
                "type": StringType,
                "desc": "The name or filename of the attachment",
                "required": True,
            },
        };
    }

    #! Creates the object
    constructor() {
        map addField(new QoreDataField($1.key, $1.value.desc, $1.value.type, $1.value.default_value)),
            Fields.pairIterator();
    }
}

#! SMTP send email request type
public class SmtpSendEmailRequestDataType inherits HashDataType {
    private {
        #! Field descriptions
        const Fields = {
            "attachments": {
                "type": new SoftListDataType(new SmtpSendEmailAttachmentDataType(), True),
                "desc": "Any attachments for the message",
            },
            "bcc": {
                "type": new SoftListDataType(StringType, True),
                "desc": "One or more `Bcc:` addresses for the email",
            },
            "body": {
                "type": DataType,
                "desc": "The message body",
            },
            "body-encoding": {
                "type": StringType,
                "desc": "The encoding to use for the attachment:\n"
                    "- `default`: `quoted-printable` for string data, `base64` for binary data\n"
                    "- `none`: no content encoding (not recommended)\n"
                    "- `quoted-printable`: quoted printable encoding \n"
                    "- `base64`: base64 encoding",
                "default_value": "default",
            },
            "body-mime-type": {
                "type": StringOrNothingType,
                "desc": "The MIME type of the message body",
            },
            "cc": {
                "type": new SoftListDataType(StringType, True),
                "desc": "One or more `Cc:` addresses for the email",
            },
            "sender": {
                "type": StringType,
                "desc": "The sender address for the email",
                "required": True,
            },
            "subject": {
                "type": StringType,
                "desc": "The subject for the email",
            },
            "to": {
                "type": new SoftListDataType(StringType, True),
                "desc": "One or more `To:` addresses for the email",
            },
        };
    }

    #! Creates the object
    constructor() {
        map addField(new QoreDataField($1.key, $1.value.desc, $1.value.type, $1.value.default_value)),
            Fields.pairIterator();
    }
}

#! SMTP send email response info type
public class SmtpSendEmailResponseInfoDataType inherits HashDataType {
    private {
        #! Field descriptions
        const Fields = {
            "code": {
                "type": IntType,
                "desc": "The return code provided by the SMTP server for the command",
            },
            "desc": {
                "type": StringType,
                "desc": "The string description returned by the server",
            },
        };
    }

    #! Creates the object
    constructor() {
        map addField(new QoreDataField($1.key, $1.value.desc, $1.value.type, $1.value.default_value)),
            Fields.pairIterator();
    }
}

#! SMTP send email response data type
public class SmtpSendEmailResponseDataType inherits HashDataType {
    #! Creates the object
    constructor() {
        setDefaultOtherFieldType(new SmtpSendEmailResponseInfoDataType());
    }
}

#! The SMTP data provider factory
public class SmtpClientDataProviderFactory inherits AbstractDataProviderFactory {
    private {
        #! Data provider type info
        static Class cls = new Class("SmtpClientDataProvider");

        #! Factory info
        const FactoryInfo = <DataProviderFactoryInfo>{
            "name": "smtpclient",
            "desc": "SMTP client data provider factory",
            "children_can_support_apis": True,
        };
    }

    #! Returns static factory information without \a provider_info
    /** @return static factory information without \a provider_info which is provided by @ref getProviderInfo()
    */
    private hash<DataProviderFactoryInfo> getInfoImpl() {
        return FactoryInfo;
    }

    #! Returns static provider information
    /** @note the \c name and \c children attributes are not returned as they are dynamic attributes
    */
    private hash<DataProviderInfo> getProviderInfoImpl() {
        return SmtpClientDataProvider::ProviderInfo;
    }

    #! Returns the class for the data provider object
    private Class getClassImpl() {
        return cls;
    }
}
}

namespace Priv {
const SmtpLogo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->

<svg
   height=\"200\"
   width=\"200\"
   version=\"1.1\"
   id=\"_x32_\"
   viewBox=\"0 0 128 128\"
   xml:space=\"preserve\"
   sodipodi:docname=\"email-icon.svg\"
   inkscape:version=\"1.3 (0e150ed6c4, 2023-07-21)\"
   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"
   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"
   xmlns=\"http://www.w3.org/2000/svg\"
   xmlns:svg=\"http://www.w3.org/2000/svg\"><defs
   id=\"defs1\" /><sodipodi:namedview
   id=\"namedview1\"
   pagecolor=\"#ffffff\"
   bordercolor=\"#000000\"
   borderopacity=\"0.25\"
   inkscape:showpageshadow=\"2\"
   inkscape:pageopacity=\"0.0\"
   inkscape:pagecheckerboard=\"0\"
   inkscape:deskcolor=\"#d1d1d1\"
   inkscape:zoom=\"1.0289025\"
   inkscape:cx=\"114.19935\"
   inkscape:cy=\"270.67676\"
   inkscape:window-width=\"1277\"
   inkscape:window-height=\"820\"
   inkscape:window-x=\"42\"
   inkscape:window-y=\"1\"
   inkscape:window-maximized=\"0\"
   inkscape:current-layer=\"_x32_\" />&#10;<style
   type=\"text/css\"
   id=\"style1\">&#10;	.st0{fill:#000000;}&#10;</style>&#10;<g
   id=\"g1\"
   transform=\"matrix(0.2,0,0,0.2,12.541291,11.63442)\">&#10;	<path
   class=\"st0\"
   d=\"M 510.678,112.275 C 508.37,100.649 503.215,90.01 496.016,81.221 494.498,79.306 492.912,77.591 491.193,75.876 478.438,63.058 460.536,55.062 440.979,55.062 H 71.021 c -19.557,0 -37.395,7.996 -50.21,20.814 -1.715,1.715 -3.301,3.43 -4.823,5.345 C 8.785,90.009 3.63,100.649 1.386,112.275 0.464,116.762 0,121.399 0,126.087 V 385.92 c 0,9.968 2.114,19.55 5.884,28.203 3.497,8.26 8.653,15.734 14.926,22.001 1.59,1.586 3.169,3.044 4.892,4.494 12.286,10.175 28.145,16.32 45.319,16.32 h 369.958 c 17.18,0 33.108,-6.145 45.323,-16.384 1.718,-1.386 3.305,-2.844 4.891,-4.43 6.27,-6.267 11.425,-13.741 14.994,-22.001 v -0.064 c 3.769,-8.653 5.812,-18.171 5.812,-28.138 V 126.087 c 10e-4,-4.688 -0.456,-9.325 -1.321,-13.812 z M 46.509,101.571 C 52.854,95.233 61.375,91.396 71.021,91.396 h 369.958 c 9.646,0 18.242,3.837 24.512,10.175 1.122,1.129 2.179,2.387 3.112,3.637 L 274.696,274.203 c -5.348,4.687 -11.954,7.002 -18.696,7.002 -6.674,0 -13.276,-2.315 -18.695,-7.002 L 43.472,105.136 c 0.858,-1.25 1.915,-2.436 3.037,-3.565 z M 36.334,385.92 V 142.735 L 176.658,265.15 36.405,387.435 c -0.071,-0.464 -0.071,-0.986 -0.071,-1.515 z m 404.645,34.677 H 71.021 c -6.281,0 -12.158,-1.651 -17.174,-4.552 l 147.978,-128.959 13.815,12.018 c 11.561,10.046 26.028,15.134 40.36,15.134 14.406,0 28.872,-5.088 40.432,-15.134 l 13.808,-12.018 147.92,128.959 c -5.023,2.901 -10.9,4.552 -17.181,4.552 z m 34.687,-34.677 c 0,0.529 0,1.051 -0.068,1.515 L 335.346,265.221 475.666,142.8 Z\"
   id=\"path1\" />&#10;</g>&#10;</svg>";
}