# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file SalesforceRestClient.qm Qore user module for calling Salesforce.com REST services

/*  SalesforceRestClient.qm Copyright (C) 2016 - 2023 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum qore version
%requires qore >= 1.0

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

# don't use "$" for vars, members, and methods, assume local variable scope
%new-style

# do not ignore argument errors
%strict-args

%requires(reexport) Mime >= 1.3
%requires(reexport) RestClient >= 1.3.1
%requires(reexport) ConnectionProvider >= 1.4

module SalesforceRestClient {
    version = "1.6";
    desc = "user module for calling Salesforce.com REST services";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
    init = sub () {
        ConnectionSchemeCache::registerScheme("sfrests", SalesforceRestConnection::ConnectionScheme);
    };
}

/** @mainpage SalesforceRestClient Module

    @tableofcontents

    @section salesforcerestclientintro SalesforceRestClient Introduction

    The %SalesforceRestClient module provides an API for calling REST services with Salesforce.com.

    To use this module, use \c "%requires SalesforceRestClient" in your code.

    All the public symbols in the module are defined in the SalesforceRestClient namespace.

    The main classes are:
    - @ref SalesforceRestClient::SalesforceRestClient "SalesforceRestClient": this class provides the REST client API for communuication with Salesforce.com; it also automates authentication and authorization to the target Connected App
    - @ref SalesforceRestClient::SalesforceRestConnection "SalesforceRestConnection": provides a REST connection object to a Salesforce.com server (based on the @ref connectionproviderintro "ConnectionProvider" module)

    @par Example:
    @code{.py}
#!/usr/bin/env qore

%new-style
%strict-args
%require-types
%enable-all-warnings

%requires SalesforceRestClient

hash<auto> opts = (
    "client_id": ENV.SALESFORCE_CONSUMER_KEY,
    "client_secret": ENV.SALESFORCE_CONSUMER_SECRET,
    "username": ENV.SALESFORCE_USER,
    "password": ENV.SALESFORCE_PASS,
);

SalesforceRestClient rest(opts);
hash ans = rest.get("sobjects");
printf("%N\n", ans.body);
    @endcode

    The composite API can be used to work with multiple objects at once as in the following example:

    @par Example:
    @code{.py}
list<string> sub create_accounts(list account_list) {
    # get list of account numbers for return value
    list<string> account_numbers = map $1.AccountNumber, account_list;

    # add reference IDs for composite REST call
    account_list = map $1 + ("attributes": ("type": "Account", "referenceId": $#.toString())), account_list;

    # create accounts
    hash<auto> info;
    on_error printf("ERROR info: %N", info);
    # maximum 200 accounts can be created; if any errors occur, an exception is thrown
    rc.post("composite/tree/Account", ("records": account_list), \info);

    log(LL_INFO, "created accounts: %y", account_numbers);
    return account_numbers;
}
    @endcode

    Requests can also be made with the Salesforce.com Bulk REST API; the following example shows how a list of accounts can be deleted:
    @par Example:
    @code{.py}
#!/usr/bin/env qore

%new-style
%strict-args
%require-types
%enable-all-warnings

%requires SalesforceRestClient
%requires json

hash<auto> opts = {
    "client_id": ENV.SALESFORCE_CONSUMER_KEY,
    "client_secret": ENV.SALESFORCE_CONSUMER_SECRET,
    "username": ENV.SALESFORCE_USER,
    "password": ENV.SALESFORCE_PASS,
};

SalesforceRestClient rest(opts);

# get list of Account IDs to delete with the REST API with an SOQL query
list<hash<auto>> al = map ("Id": $1.Id), rc.get("query?q=select Id, Name from Account where Name like 'Account %%'").body.records;
# create job with the Bulk REST API
hash<auto> h = rc.bulkJobCreate(BulkJobDelete, "Account", BulkJobJson).jobInfo;
printf("created job %y\n", h.id);
# create JSON data
string data = make_json(al);
# add batch to job with the Bulk REST API
rc.bulkJobAddBatch(h.id, data, BulkJobJson, \info);
# close job with the Bulk REST API
rc.bulkJobClose(h.id);
    @endcode

    @see \c "sfrest" in the bin directory for a user-friendly command-line interface to Salesforce.com REST API
    functionality and a more detailed example of code using this module.

    @section salesforcerestclientrelnotes Release Notes

    @subsection salesforcerestclientv1_6 SalesforceRestClient v1.6
    - updated to use the generic OAuth2 support in the RestClient class

    @subsection salesforcerestclientv1_5_1 SalesforceRestClient v1.5.1
    - added support for \c username and \c password connection options for better security handling

    @subsection salesforcerestclientv1_5 SalesforceRestClient v1.5
    - implemented support for a data provider scheme cache and rich option information for connections
      (<a href="https://github.com/qorelanguage/qore/issues/4025">issue 4025</a>)

    @subsection salesforcerestclientv1_4 SalesforceRestClient v1.4
    - removed the \c SalesforceRestConnection::getConstructorInfo() and
      \c SalesforceRestConnection::getConstructorInfoImpl() methods
      (<a href="https://github.com/qorelanguage/qore/issues/3696">issue 3696</a>)
    - added support for the data provider API

    @subsection salesforcerestclientv1_3 SalesforceRestClient v1.3
    - all connection clases have unified constructor

    @subsection salesforcerestclientv1_2 SalesforceRestClient v1.2
    - added the \c SalesforceRestConnection::getConstructorInfo()
      method to allow connections to be created dynamically, potentially in another process from a network
      call (removed in SalesforceRestClient 1.4)
      (<a href="https://github.com/qorelanguage/qore/issues/2628">issue 2628</a>)

    @subsection salesforcerestclientv1_1_1 SalesforceRestClient v1.1.1
    - fixed a bug handling default options including timeouts in
      @ref SalesforceRestClient::SalesforceRestConnection "SalesforceRestConnection"
      (<a href="https://github.com/qorelanguage/qore/issues/3321">issue 3321</a>)

    @subsection salesforcerestclientv1_1 SalesforceRestClient v1.1
    - added the @ref SalesforceRestClient::SalesforceRestConnection "SalesforceRestConnection" class to support the
      <a href="../../ConnectionProvider/html/index.html">ConnectionProvider</a> module
    - updated for complex types

    @subsection salesforcerestclientv1_0 SalesforceRestClient v1.0
    - the initial version of the %SalesforceRestClient module
*/

#! the SalesforceRestClient namespace contains all the objects in the SalesforceRestClient module
public namespace SalesforceRestClient {
/** @defgroup bulkjob_operations Salesforce.com Bulk REST API Job Operations
*/
#/@{
#! Salesforce.com bulk job "query" operation
public const BulkJobQuery = "query";

#! Salesforce.com bulk job "insert" operation
public const BulkJobInsert = "insert";

#! Salesforce.com bulk job "update" operation
public const BulkJobUpdate = "update";

#! Salesforce.com bulk job "upsert" operation
public const BulkJobUpsert = "upsert";

#! Salesforce.com bulk job "delete" operation
public const BulkJobDelete = "delete";
#/@}

#! a hash of Salesforce.com bulk job operations; keys are @ref bulkjob_operations
/** valid operations are:
    - @ref BulkJobQuery (\c "query")
    - @ref BulkJobInsert (\c "insert")
    - @ref BulkJobUpdate (\c "update")
    - @ref BulkJobUpsert (\c "upsert")
    - @ref BulkJobDelete (\c "delete")
*/
public const BulkJobOperations = {
    BulkJobQuery: True,
    BulkJobInsert: True,
    BulkJobUpdate: True,
    BulkJobUpsert: True,
    BulkJobDelete: True,
};

/** @defgroup bulkjob_contenttypes Salesforce.com Bulk REST API Job Content Types
*/
#/@{
#! Salesforce.com bulk job "CSV" content type
public const BulkJobCsv = "CSV";

#! Salesforce.com bulk job "JSON" content type
public const BulkJobJson = "JSON";

#! Salesforce.com bulk job "XML" content type
public const BulkJobXml = "XML";

#! Salesforce.com bulk job "ZIP_CSV" content type
public const BulkJobZipCsv = "ZIP_CSV";

#! Salesforce.com bulk job "ZIP_JSON" content type
public const BulkJobZipJson = "ZIP_JSON";

#! Salesforce.com bulk job "ZIP_XML" content type
public const BulkJobZipXml = "ZIP_XML";
#/@}

#! a hash of Salesforce.com bulk job content types; keys are @ref bulkjob_contenttypes; values are Mime \c Content-Type strings
/** valid content types are:
    - \c BulkJobCsv (\c "CSV")
    - \c BulkJobJson (\c "JSON")
    - \c BulkJobXml (\c "XML")
    - \c BulkJobZipCsv (\c "ZIP_CSV")
    - \c BulkJobZipJson (\c "ZIP_JSON")
    - \c BulkJobZipXml (\c "ZIP_XML")
*/
public const BulkJobContentTypes = {
    BulkJobCsv: MimeTypeCsv,
    BulkJobJson: MimeTypeJson,
    BulkJobXml: MimeTypeXmlApp,
    BulkJobZipCsv: "zip/csv",
    BulkJobZipJson: "zip/json",
    BulkJobZipXml: "zip/xml",
};

#! this class provides the REST client API for communication with Salesforce.com
/** This class requires the following options for Salesforce.com authentication and authorization to the target Connected App:
    - \c client_id: the Salesforce.com "consumer key"
    - \c client_secret: the Salesforce.com "consumer secret"
    - \c username: the Salesforce.com account username
    - \c password: the Salesforce.com account password

    The following options can be overridden; default values are provided as follows:
    - \c api: default value \c "auto" for the Salesforce.com REST API version; \c "auto" means use the latest version available
    - \c oauth_url_auth: default value \c "https://login.salesforce.com/services/oauth2/authorize"
    - \c oauth_url_token: default value \c "https://login.salesforce.com/services/oauth2/token" (used for logging in to Salesforce.com)
    - \c oauth_url_revoke: default value \c "https://login.salesforce.com/services/oauth2/revoke"

    This class also automatically adds support for the \c "PATCH" HTTP method used by Salesforce.com for updates to existing objects,
    as well as the @ref SalesforceRestClient::SalesforceRestClient::patch() "SalesforceRestClient::patch()" method

    The @ref SalesforceRestClient::SalesforceRestClient::doRequest() "SalesforceRestClient::patchdoRequest()" method is overridden in
    this class to provide transparent authentication and authorization to Salesforce.com.  With every REST request, if no token has
    been acquired, first a login token will be acquired, the internal URL set to the target URL provided by the token call, and then
    the requested REST call will be made.

    When logging in to Salesforce.com (see @ref SalesforceRestClient::SalesforceRestClient::login() "SalesforceRestClient::login()"),
    the \c Authorization header is set by default to be included with any future calls made through this object (or with
    @ref RestClient::RestClient "RestClient" methods in the parent class).

    When sending headers to Salesforce.com, any headers with date values are converted to GMT format; for example, the
    \c "If-Modified-Since" and \c "If-Unmodified-Since" headers can be set to date/time values, and this object will
    convert them to date strings in GMT format; ex:
    @code{.py}
SalesforceRestClient rest(opts);
hash ans = rest.get("sobjects", NOTHING, NOTHING, ("If-Modified-Since": 2016-11-25));
    @endcode

    In a request sent from the call above in the \c Europe/Prague time zone, the \c "If-Modified-Since" header would be sent as:
    @verbatim
If-Modified-Since: Thu, 24 Nov 2016 23:00:00 GMT
    @endverbatim

    The following methods support communication with the Salesforce.com Bulk REST API:
    - @ref doBulkRequest()
    - @ref bulkGet()
    - @ref bulkPost()
    - @ref bulkJobCreate()
    - @ref bulkJobAddBatch()
    - @ref bulkJobClose()
*/
public class SalesforceRestClient inherits RestClient::RestClient {
    public {
        #! defaults for direct member values
        const Defaults = {
            "oauth_url_auth": "https://login.salesforce.com/services/oauth2/authorize",
            "oauth_url_token": "https://login.salesforce.com/services/oauth2/token",
            "oauth_url_revoke": "https://login.salesforce.com/services/oauth2/revoke",
            "api": "auto",
        };

        #! default send encoding
        const DefaultSendEncoding = "gzip";

        #! required options
        const RequiredOptions = (
            # the Salesforce.com "consumer key"
            "client_id",
            # the Salesforce.com "consumer secret"
            "client_secret",
            # the Salesforce.com username
            "username",
            # the Salesforce.com password
            "password",
        );

        #! Salesforce.com async dataload namespace
        const AsyncDataloadNs = "http://www.force.com/2009/06/asyncapi/dataload";

        #! Salesforce.com XML jobInfo attributes
        const JobInfoAttributes = {
            "^attributes^": {
                "xmlns": AsyncDataloadNs,
            },
        };
    }

    private {
        #! Salesforce.com OAuth2 Authorization URL
        string oauth_url_auth;

        #! Salesforce.com OAuth2 Get Token URL
        string oauth_url_token;

        #! Salesforce.com OAuth2 Revoke Token URL
        string oauth_url_revoke;

        #! Mutex for token acquisition
        Mutex m();

        #! Salesforce.com "consumer key"
        string client_id;

        #! Salesforce.com "consumer secret"
        string client_secret;

        #! Salesforce.com REST API version to be used (\c "auto" = latest version)
        string api;

        #! Salesforce.com REST API version currently in use
        string api_used;

        #! hash of APIs retrieved from GET /services/data; keyed by API version string; values: \c "label", \c "url"
        hash<string, hash<auto>> api_hash;
    }

    #! creates the object with the given options
    /**
        @par Example:
        @code{.py}
SalesforceRestClient rest({"url": "http://localhost:8001/rest"});
        @endcode

        @param opts valid options are:
        - \c additional_methods: Optional hash with more but not-HTTP-standardized methods to handle. It allows to
          create various HTTP extensions like e.g. WebDAV. The hash takes the method name as a key, and the value is a
          boolean @ref True "True" or @ref False "False": indicating if the method can accept a message body as well.
          Example:
            @code{.py}
# add new HTTP methods for WebDAV. Both of them require body posting to the server
("additional_methods": ("PROPFIND": True, "MKCOL": True ));
            @endcode
        - \c api: the Salesforce.com API to use; use \c "auto" (the default) to use the latest API version
        - \c client_id: (required) the Salesforce.com "consumer key" for the Connected App
        - \c client_secret: (required) the Salesforce.com "consumer secret" for the Connected App
        - \c connect_timeout: The timeout value in milliseconds for establishing a new socket connection (also can be
          a relative date-time value for clarity, ex: \c 20s)
        - \c content_encoding: for possible values, see @ref EncodingSupport; this sets the send encoding (if the
          \c "send_encoding" option is not set) and the requested response encoding (note that the
          @ref RestClient::RestClient "RestClient" class will only compress outgoing message bodies over
          @ref RestClient::RestClient::CompressionThreshold "CompressionThreshold" bytes in size); additionally please
          note that Salesforce.com does not support \c "bzip2" compression
        - \c data: a @ref DataSerializationOptions "data serialization option"; if not present defaults to \c "json"
        - \c default_path: The default path to use for new connections if a path is not otherwise specified in the
          connection URL
        - \c default_port: The default port number to connect to if none is given in the URL
        - \c error_passthru: if @ref True "True" then HTTP status codes indicating errors will not cause a
            \c REST-RESPONSE-ERROR exception to be raised, rather such responses will be passed through to the caller
            like any other response
        - \c headers: an optional hash of headers to send with every request, these can also be overridden in request
          method calls
        - \c http_version: Either '1.0' or '1.1' for the claimed HTTP protocol version compliancy in outgoing message
          headers
        - \c max_redirects: The maximum number of redirects before throwing an exception (the default is 5)
        - \c password: (required) the Salesforce.com account password for the Connected App
        - \c proxy: The proxy URL for connecting through a proxy
        - \c redirect_passthru: if @ref True "True" then redirect responses will be passed to the caller instead of
            processed
        - \c send_encoding: a @ref EncodingSupport "send data encoding option" or the value \c "auto" which means to
          use automatic encoding; if not present defaults to \c "gzip" content encoding on sent message bodies (note
          that the @ref RestClient::RestClient "RestClient" class will only compress outgoing message bodies over
          @ref RestClient::RestClient::CompressionThreshold "CompressionThreshold" bytes in size); additionally please
          note that Salesforce.com does not support \c "bzip2" compression
        - \c timeout: The timeout value in milliseconds (also can be a relative date-time value for clarity, ex:
          \c 30s)
        - \c username: (required) the Salesforce.com account username for the Connected App
        @param do_not_connect if \c False (the default), then a connection will be immediately established to the
        remote server and a token will be received

        The following are mandatory options for Salesforce.com authentication: \c client_id, \c client_secret,
        \c username, \c password

        @throw RESTCLIENT-ERROR invalid option passed to constructor, unsupported data serialization, etc
        @throw SALESFORCERESTCLIENT-ERROR missing or invalid connection option
    */
    constructor(*hash<auto> opts, *softbool do_not_connect) : RestClient(SalesforceRestClient::getOptions(opts), True) {
        # set options
        setSendEncoding(opts.send_encoding ?? DefaultSendEncoding);
        # check required options
        foreach string key in (RequiredOptions) {
            auto v = opts{key};
            if (!exists v || v == "") {
                throw "SALESFORCERESTCLIENT-ERROR", sprintf("missing required option %y in option argument", key);
            }
            if (v.typeCode() != NT_STRING) {
                throw "SALESFORCERESTCLIENT-ERROR", sprintf("required option %y was passed as a %s (%y); expecting "
                    "\"string\"", key, v.type(), v);
            }

            self{key} = v;
        }

        map self{$1} = opts{$1} ?? Defaults{$1}, keys Defaults;

        if (!do_not_connect) {
            loginIntern();
        }
    }

    #! sends an HTTP \c PATCH request to the Salesforce.com REST server and returns the response; performs an implicit login to Salesforce.com if necessary
    /** @par Example:
        @code{.py}
hash<auto> ans = rest.patch("/orders/1", {"action": "cancel"});
        @endcode

        @param path the URI path to add (will be appended to any root path given in the constructor)
        @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized according to the serialization rules set in @ref RestClient::RestClient::constructor() "RestClient::constructor()"
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "PATCH /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return A hash of headers received from the HTTP server with all key names converted to lower-case; if any message body is included in the response, it will be deserialized to %Qore data and assigned to the value of the \c "body" key

        @throw DESERIALIZATION-ERROR the response body could not be deserialized (unknown \c Content-Type or invalid serialization)
        @throw REST-RESPONSE-ERROR if this exception is thrown by the @ref Qore::HTTPClient::send() call in case of an HTTP response code < 100 or >= 300, the message body is still deserialized if possible and the response information can be retrieved in the \a info hash output keys as follows:
        - \c "response-code": the HTTP response code given
        - \c "response-headers": a hash of processed response headers
        - \c "response-headers-raw": a hash of raw unprocessed response headers
        - \c "response-body": the decoded response body
        .
        Note that this exception is not raised for HTTP status codes indicating an error if the \c error_passthru
        option is set to @ref True "True"

        Other exceptions can be thrown by the @ref Qore::HTTPClient::send() call used to make the HTTP request.

        @see
        - @ref RestClient::RestClient::getSerialization() "RestClient::getSerialization()"
        - @ref RestClient::RestClient::setSerialization() "RestClient::setSerialization()"
    */
    hash<auto> patch(string path, auto body, *reference<hash<auto>> info, *hash<auto> hdr) {
        return doRequest("PATCH", path, body, \info, NOTHING, hdr);
    }

    #! sends an HTTP request to the REST server and returns the response; performs an implicit login to Salesforce.com if necessary
    /** @par Example:
        @code{.py}
hash<auto> ans = rest.doRequest("GET", "sobjects");
        @endcode

        @param m the HTTP method to be used; case is ignored (if not a valid method an \c HTTP-CLIENT-METHOD-ERROR exception is raised)
        @param path the URI path to add (will be appended to any root path given in the constructor)
        @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized according to the serialization rules set in @ref RestClient::RestClient::constructor() "RestClient::constructor()"
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values
        @param decode_errors decode the message body with HTTP error responses and throw an exception based on the message body
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return A hash of headers received from the HTTP server with all key names converted to lower-case; if any message body is included in the response, it will be deserialized to %Qore data and assigned to the value of the \c "body" key

        @throw DESERIALIZATION-ERROR the response body could not be deserialized (unknown \c Content-Type or invalid serialization)
        @throw HTTP-CLIENT-METHOD-ERROR invalid HTTP method argument passed
        @throw REST-RESPONSE-ERROR if this exception is thrown by the @ref Qore::HTTPClient::send() call in case of an HTTP response code < 100 or >= 300, the message body is still deserialized if possible and the response information can be retrieved in the \a info hash output keys as follows:
        - \c "response-code": the HTTP response code given
        - \c "response-headers": a hash of processed response headers
        - \c "response-headers-raw": a hash of raw unprocessed response headers
        - \c "response-body": the decoded response body
        .
        Note that this exception is not raised for HTTP status codes indicating an error if the \c error_passthru
        option is set to @ref True "True"

        Other exceptions can be thrown by the @ref Qore::HTTPClient::send() call used to make the HTTP request.

        @see
        - @ref RestClient::RestClient::getSerialization() "RestClient::getSerialization()"
        - @ref RestClient::RestClient::setSerialization() "RestClient::setSerialization()"
    */
    hash<auto> doRequest(string m, string path, auto body, *reference<hash<auto>> info, softbool decode_errors = True,
            *hash<auto> hdr) {
        # convert any dates in headers to GMT format
        map hdr.($1.key) = getGmtDate($1.value), hdr.pairIterator(), $1.value.typeCode() == NT_DATE;

        AutoLock al(self.m);
        return RestClient::doRequest(m, path, body, \info, decode_errors, hdr);
    }

    #! sends a Bulk API REST request to the Salesforce.com server using \c "rawxml" serialization and returns the response; performs an implicit login to Salesforce.com if necessary
    /** @par Example:
        @code{.py}
hash<auto> ans = rest.doBulkRequest("POST", "job", job);
        @endcode

        @param m the HTTP method to be used; case is ignored (if not a valid method an \c HTTP-CLIENT-METHOD-ERROR exception is raised)
        @param path the URI path to add (will be appended to any root path given in the constructor)
        @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized according to the serialization rules set in @ref RestClient::RestClient::constructor() "RestClient::constructor()"
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values
        @param decode_errors decode the message body with HTTP error responses and throw an exception based on the message body
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return A hash of headers received from the HTTP server with all key names converted to lower-case; if any message body is included in the response, it will be deserialized to %Qore data and assigned to the value of the \c "body" key

        @throw DESERIALIZATION-ERROR the response body could not be deserialized (unknown \c Content-Type or invalid serialization)
        @throw HTTP-CLIENT-METHOD-ERROR invalid HTTP method argument passed
        @throw REST-RESPONSE-ERROR if this exception is thrown by the @ref Qore::HTTPClient::send() call in case of an HTTP response code < 100 or >= 300, the message body is still deserialized if possible and the response information can be retrieved in the \a info hash output keys as follows:
        - \c "response-code": the HTTP response code given
        - \c "response-headers": a hash of processed response headers
        - \c "response-headers-raw": a hash of raw unprocessed response headers
        - \c "response-body": the decoded response body
        .
        Note that this exception is not raised for HTTP status codes indicating an error if the \c error_passthru
        option is set to @ref True "True"

        Other exceptions can be thrown by the @ref Qore::HTTPClient::send() call used to make the HTTP request.

        @note authentication and authorization is done transparently as with the standard OAuth2 mechanism used with the non-bulk REST API

        @see
        - @ref RestClient::RestClient::getSerialization() "RestClient::getSerialization()"
        - @ref RestClient::RestClient::setSerialization() "RestClient::setSerialization()"
    */
    hash<auto> doBulkRequest(string m, string path, auto body, *reference<hash<auto>> info,
            softbool decode_errors = True, *hash<auto> hdr) {
        # convert any dates in headers to GMT format
        map hdr.($1.key) = getGmtDate($1.value), hdr.pairIterator(), $1.value.typeCode() == NT_DATE;

        AutoLock al(self.m);

        if (!token) {
            loginIntern(\info);
        }

        # restore the old serialization option on exit
        string old_ds = ds;
        on_exit
            setSerialization(old_ds);

        # set "rawxml" serialization
        setSerialization("rawxml");

        # restore old URL on exit
        string old_url = getURL();
        on_exit
            setURL(old_url);

        # create the async URL
        string url = old_url;
        url =~ s/data/async/;
        url =~ s/\/v([0-9])/\/$1/;
        setURL(url);

        # setup the headers for bulk REST
        hdr += {
            "X-SFDC-Session": token,
            "Authorization": "",
        };

        return RestClient::doRequest(m, path, body, \info, decode_errors, hdr);
    }

    #! sends an HTTP \c GET request to the REST server using the Salesforce.com Bulk REST API and returns the response
    /** @par Example:
        @code{.py}
hash<auto> ans = rest.bulkGet("/orders/1?info=verbose");
        @endcode

        @param path the URI path to add (will be appended to any root path given in the constructor)
        @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized according to the serialization rules set in @ref RestClient::RestClient::constructor() "RestClient::constructor()"
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "GET /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return A hash of headers received from the HTTP server with all key names converted to lower-case; if any message body is included in the response, it will be deserialized to %Qore data and assigned to the value of the \c "body" key

        @throw DESERIALIZATION-ERROR the response body could not be deserialized (unknown \c Content-Type or invalid serialization)
        @throw REST-RESPONSE-ERROR if this exception is thrown by the @ref Qore::HTTPClient::send() call in case of an HTTP response code < 100 or >= 300, the message body is still deserialized if possible and the response information can be retrieved in the \a info hash output keys as follows:
        - \c "response-code": the HTTP response code given
        - \c "response-headers": a hash of processed response headers
        - \c "response-headers-raw": a hash of raw unprocessed response headers
        - \c "response-body": the decoded response body
        .
        Note that this exception is not raised for HTTP status codes indicating an error if the \c error_passthru
        option is set to @ref True "True"

        Other exceptions can be thrown by the @ref Qore::HTTPClient::send() call used to make the HTTP request.

        @note authentication and authorization is done transparently as with the standard OAuth2 mechanism used with the non-bulk REST API

        @see
        - @ref RestClient::RestClient::getSerialization() "RestClient::getSerialization()"
        - @ref RestClient::RestClient::setSerialization() "RestClient::setSerialization()"
    */
    hash<auto> bulkGet(string path, auto body, *reference<hash<auto>> info, *hash<auto> hdr) {
        return doBulkRequest("GET", path, body, \info, NOTHING, hdr);
    }

    #! sends an HTTP \c POST request to the REST server using the Salesforce.com Bulk REST API and returns the response
    /** @par Example:
        @code{.py}
hash<auto> ans = rest.bulkPost("/orders", ("product": "xyz123", "options": 500));
        @endcode

        @param path the URI path to add (will be appended to any root path given in the constructor)
        @param body an optional message body to be included in the request; if a value for this parameter is passed to the method, then the body will be serialized according to the serialization rules set in @ref RestClient::RestClient::constructor() "RestClient::constructor()"
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return A hash of headers received from the HTTP server with all key names converted to lower-case; if any message body is included in the response, it will be deserialized to %Qore data and assigned to the value of the \c "body" key

        @throw DESERIALIZATION-ERROR the response body could not be deserialized (unknown \c Content-Type or invalid serialization)
        @throw REST-RESPONSE-ERROR if this exception is thrown by the @ref Qore::HTTPClient::send() call in case of an HTTP response code < 100 or >= 300, the message body is still deserialized if possible and the response information can be retrieved in the \a info hash output keys as follows:
        - \c "response-code": the HTTP response code given
        - \c "response-headers": a hash of processed response headers
        - \c "response-headers-raw": a hash of raw unprocessed response headers
        - \c "response-body": the decoded response body
        .
        Note that this exception is not raised for HTTP status codes indicating an error if the \c error_passthru
        option is set to @ref True "True"

        Other exceptions can be thrown by the @ref Qore::HTTPClient::send() call used to make the HTTP request.

        @note authentication and authorization is done transparently as with the standard OAuth2 mechanism used with the non-bulk REST API

        @see
        - @ref RestClient::RestClient::getSerialization() "RestClient::getSerialization()"
        - @ref RestClient::RestClient::setSerialization() "RestClient::setSerialization()"
    */
    hash<auto> bulkPost(string path, auto body, *reference<hash<auto>> info, *hash<auto> hdr) {
        return doBulkRequest("POST", path, body, \info, NOTHING, hdr);
    }

    #! creates a Salesforce.com batch job and returns the job information as a hash
    /** @par Example
        @code{.py}
hash<auto> h = sfrest.bulkJobCreate(BulkJobInsert, "Account", BulkJobJson);
printf("job ID created: %y\n", h.jobInfo.id);
        @endcode

        @param operation the operation to create; see @ref bulkjob_operations for valid values
        @param object the API object to operate on
        @param job_content_type the content type of the job; see @ref bulkjob_contenttypes for valid values
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return the deserialized message body returned by Salesforce.com

        @throw INVALID-OPERATION invalid operation passed; see @ref BulkJobContentTypes for valid values
        @throw INVALID-CONTENT-TYPE invalid job content type passed; see @ref BulkJobContentTypes for valid values

        @note authentication and authorization is done transparently as with the standard OAuth2 mechanism used with the non-bulk REST API
    */
    hash<auto> bulkJobCreate(string operation, string object, string job_content_type, *reference<hash<auto>> info,
            *hash<auto> hdr) {
        if (!BulkJobOperations{operation})
            throw "INVALID-OPERATION", sprintf("invalid Salesforce.com Bulk REST API job operation %y; known "
                "operations: %y", operation, keys BulkJobOperations);
        if (!BulkJobContentTypes{job_content_type})
            throw "INVALID-OPERATION", sprintf("invalid Salesforce.com Bulk REST API job content type %y; known "
                "content types: %y", job_content_type, BulkJobContentTypes.keys());

        hash<auto> h = {
            "jobInfo": (
                JobInfoAttributes + {
                    "operation": operation,
                    "object": object,
                    "contentType": job_content_type,
                },
            ),
        };

        return doBulkRequest("POST", "job", h, \info, NOTHING, hdr).body;
    }

    #! add a batch to a job using the Bulk REST API
    /** @par Example:
        @code{.py}
hash<auto> jh = sfrest.bulkJobCreate(BulkJobInsert, "Account", BulkJobCsv).jobInfo;
printf("job ID created: %y\n", jh.id);
hash<auto> h = sfrest.bulkJobAddBatch(jh.id, csv_string, BulkJobCsv).body;
printf("batch ID: %y batch state: %y\n", h.id, h.state);
        @endcode

        @param jobid the job ID to add the batch to
        @param batch_data the data for the job; this data is not serialized but rather sent as-is using the MIME \c Content-Type associated with the job content type value
        @param job_content_type the content type of the job; see @ref bulkjob_contenttypes for valid values
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return the deserialized message body returned by Salesforce.com

        @throw INVALID-CONTENT-TYPE invalid job content type passed; see @ref BulkJobContentTypes for valid values

        @note authentication and authorization is done transparently as with the standard OAuth2 mechanism used with the non-bulk REST API
    */
    hash<auto> bulkJobAddBatch(string jobid, data batch_data, string job_content_type, *reference<hash<auto>> info,
            *hash<auto> hdr) {
        *string ct = BulkJobContentTypes{job_content_type};
        if (!ct)
            throw "INVALID-OPERATION", sprintf("invalid Salesforce.com Bulk REST API job content type %y; known "
                "content types: %y", job_content_type, keys BulkJobContentTypes);

        # convert any dates in headers to GMT format
        map hdr.($1.key) = getGmtDate($1.value), hdr.pairIterator(), $1.value.typeCode() == NT_DATE;

        AutoLock al(m);
        if (!token) {
            loginIntern(\info);
        }

        # restore old URL on exit
        string old_url = getURL();
        on_exit
            setURL(old_url);

        # create the async URL
        string url = old_url;
        url =~ s/data/async/;
        url =~ s/\/v([0-9])/\/$1/;
        setURL(url);

        # setup the headers for bulk REST
        hdr += (
            "X-SFDC-Session": token,
            "Authorization": "",
        );

        hdr = headers + hdr + (
            "Content-Type": ct,
        );

        on_exit {
            info += {
                "request-body": batch_data,
            };
        }

        # prepare path
        string path = sprintf("job/" + jobid + "/batch");
        preparePath(\path);

        return sendAndDecodeResponse(batch_data, "POST", path, hdr, \info, True);
    }

    #! sends a Bulk REST API job close \c POST request to the server and returns the deserialized result message body
    /** @par Example:
        @code{.py}
sfrest.bulkJobClose(jh.id);
        @endcode

        @param jobid the job ID to close
        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values
        @param hdr any headers to be sent with the request; headers here will override default headers for the object as well

        @return the deserialized message body returned by Salesforce.com

        @note authentication and authorization is done transparently as with the standard OAuth2 mechanism used with the non-bulk REST API
    */
    hash<auto> bulkJobClose(string jobid, *reference<hash<auto>> info, *hash<auto> hdr) {
        hash<auto> h = (
            "jobInfo": (
                JobInfoAttributes + (
                    "state": "Closed",
                ),
            ),
        );
        return doBulkRequest("POST", "job/" + jobid, h, \info, NOTHING, hdr).body;
    }

    #! logs in to Salesforce.com with the credentials provided in the constructor()
    /** @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values

        @note this call is made implicitly before each REST call and should not need to be called manually
    */
    login(*reference<hash<auto>> info) {
        AutoLock al(m);
        loginIntern(\info);
    }

    #! logs out of Salesforce.com by revoking the access token
    /** @par Example:
        @code{.py}
sfrest.logout();
        @endcode

        if not logged in then this method returns immediately

        @param info an optional reference to a hash that will be used as an output variable giving a hash of request headers and other information about the HTTP request; if present the hash will contain the following keys:
        - \c headers: a hash of outgoing HTTP request headers
        - \c request-uri: the request URI string sent (ex: \c "POST /services/async/38.0/job HTTP/1.1")
        - \c body-content-type: the outgoing message body Mime \c Content-Type value
        - \c response-headers: a hash of processed incoming HTTP headers in the response with keys converted to
            lower case and additional information added
        - \c response-headers-raw: a hash of raw unprocessed incoming HTTP headers
        - \c chunked: set to @ref True "True" if the response was received with chunked transfer encoding
        - \c response-code: the HTTP response code
        - \c response-body: the raw message body in the response (after any content decoding)
        - \c response-serialization: the type of message serialization in the response; see @ref DataSerializationOptions for possible values
        - \c request-body: the raw message body in the request (before any content encoding)
        - \c request-serialization: the type of message serialization in the request; see @ref DataSerializationOptions for possible values (for this method, always \c "url")
    */
    logout(*reference<hash<auto>> info) {
        AutoLock al(m);

        # if we are not logged in, then do nothing
        if (!token)
            return;

        # use the Salesforce.com OAuth2 revocation URL to log out
        setURL(oauth_url_revoke);

        # use URL form encoding for the message body
        setSerialization("url");

        # create message body hash
        hash<auto> lh.token = token;

        # make the revoke call
        RestClient::doRequest("POST", "", lh, \info);

        delete token;
    }

    #! returns the Salesforce.com REST API version currently in use
    *string getApi() {
        return api_used;
    }

    #! Return available APIs as a hash
    *hash<string, hash<auto>> getApis() {
        return api_hash;
    }

    #! verifies that the options passed match the configured options
    /** @throw SALESFORCE-REST-OPTION-ERROR one or more options does not match
    */
    checkClientOptions(hash<auto> opts) {
        foreach hash<auto> i in (opts.pairIterator()) {
            if (i.value != self{i.key}) {
                throw "SALESFORCE-REST-OPTION-ERROR", sprintf("SalesforceRestClient has %y = %y; expected: %y", i.key,
                    self{i.key}, i.value);
            }
        }
    }

    #! returns a date string for use with Salesforce.com Bulk REST API requests
    /** @param d the date to return as a formatted string using \c "YYYY-MM-DDTHH:mm:SSZ"

        @return the string corresponding to the date

        @see @ref date_formatting "Date Formatting Strings"
    */
    static string getBulkDate(date d) {
        return d.format("YYYY-MM-DDTHH:mm:SSZ");
    }

    #! returns a date string in GMT for use in Salesforce.com requests
    static string getGmtDate(date d) {
        return gmtime(d).format("Dy, DD Mon YYYY HH:mm:SS") + " GMT";
    }

    #! returns options for the @ref RestClient::RestClient::constructor() "RestClient::constructor()"
    private static hash getOptions(*hash<auto> opts) {
        # data "auto" == "json"
        if (opts."data" == "auto") {
            delete opts."data";
        }
        return {
            "additional_methods": {"PATCH": False} + opts.additional_methods,
            "data": "json",

            "oauth2_token_url": opts.oauth_url_token ?? Defaults.oauth_url_token,
            "oauth2_grant_type": "password",
            "oauth2_client_id": opts.client_id,
            "oauth2_client_secret": opts.client_secret,

            "url": opts.oauth_url_auth ?? Defaults.oauth_url_auth,
        } + Defaults + opts;
    }

    #! performs authentication and authorization with Salesforce.com using the OAuth2 authorization URL
    private hash<auto> loginIntern(*reference<hash> info) {
        # ensure that if json serialization is set, that we do not claim to understand XML responses
        # (which Salesforce.com will prefer otherwise, and then no type information will be transmitted)
        if (ds == "json") {
            addDefaultHeaders({"Accept": MimeTypeJson + "," + MimeTypeFormUrlEncoded});
        } else {
            delete headers.Accept;
        }

        # save send encoding and retore on error
        *hash<auto> old_seh = seh;
        # turn off compression for the login request (is not currently supported in Salesforce.com)
        setSendEncoding("identity");
        # restore the encoding on exit
        on_exit seh = old_seh;

        hash<auto> h = gotOAuth2LoginInfo(RestClient::loginIntern(\info));
        # set the URL to the Salesforce.com URL for REST API calls
        setURL(h.instance_url);
        processApis(RestClient::doRequest("GET", "services/data").body);
        setVerifyApi(h);
        return h;
    }

    #! Process the API response from Salesforce and set / verify the client's API level
    processApis(*list<auto> apis) {
        # get as hash of supported APIs
        on_error printf("APIs: %y\n", apis);
        api_hash = cast<hash<string, hash<auto>>>(map {$1.version: $1 - "version"}, apis);
    }

    #! Sets / verifies the api level and sets the application URL accordingly
    setVerifyApi(hash<auto> h) {
        hash<auto> ah;
        if (api == "auto") {
            api = api_used = api_hash.lastKey();
            ah = api_hash.lastValue();
        } else {
            *hash<auto> aah = api_hash{api};
            if (!aah) {
                throw "SALESFORCE-API-ERROR", sprintf("Salesforce.com REST API %y was requested but is not "
                    "supported; supported Salesforce.com APIs: %y", api, keys api_hash);
            }
            api_used = api;
            ah = aah;
        }

        # set the URL to the Salesforce.com URL for REST API calls
        setURL(h.instance_url + ah.url);
    }
}

#! class for Salesforce.com REST connections; returns @ref SalesforceRestClient::SalesforceRestClient objects
/** In addition to all options supported by @ref RestClient::RestClientConnection "RestClientConnection", this
    connection class supports the following options:
    - \c api: the Salesforce.com API to use; use \c "auto" (the default) to use the latest API version
    - \c client_id: (required) the Salesforce.com "consumer key" for the Connected App
    - \c client_secret: (required) the Salesforce.com "consumer secret" for the Connected App
    - \c oauth_url_auth: default value \c "https://login.salesforce.com/services/oauth2/authorize"
    - \c oauth_url_token: default value \c "https://login.salesforce.com/services/oauth2/token" (used for logging in
      to Salesforce.com)
    - \c oauth_url_revoke: default value \c "https://login.salesforce.com/services/oauth2/revoke"

    @see @ref SalesforceRestClient::SalesforceRestClient::constructor() "SalesforceRestClient::constructor()" for more
    information on the above options

    @since %SalesforceRestConnection 1.1
*/
public class SalesforceRestConnection inherits RestClient::RestConnection {
    public {
        #! Connection entry info
        const ConnectionScheme = <ConnectionSchemeInfo>{
            "cls": Class::forName("SalesforceRestConnection"),
            "options": RestConnection::ConnectionScheme.options + {
                "api": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the Salesforce.com API to use; use `auto` (the default) to use the latest API version",
                    "default_value": SalesforceRestClient::Defaults.api,
                },
                "client_id": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the Salesforce.com \"consumer key\" for the Connected App",
                },
                "client_secret": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the Salesforce.com \"consumer secret\" for the Connected App",
                    "sensitive": True,
                },
                "data": RestConnection::ConnectionScheme.options."data" + <ConnectionOptionInfo>{
                    "default_value": "json",
                },
                "oauth_url_auth": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the OAuth authorization URL",
                    "default_value": SalesforceRestClient::Defaults.oauth_url_auth,
                },
                "oauth_url_token": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the OAuth token URL",
                    "default_value": SalesforceRestClient::Defaults.oauth_url_token,
                },
                "oauth_url_revoke": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the OAuth logout / revoke token URL",
                    "default_value": SalesforceRestClient::Defaults.oauth_url_revoke,
                },
                "password": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the Salesforce.com password (will override any password in the URL)",
                    "sensitive": True,
                },
                "ping_method": RestConnection::ConnectionScheme.options."ping_method" + <ConnectionOptionInfo>{
                    "default_value": "GET",
                },
                "ping_path": RestConnection::ConnectionScheme.options."ping_path" + <ConnectionOptionInfo>{
                    "default_value": "/services/data",
                },
                "username": <ConnectionOptionInfo>{
                    "type": "string",
                    "desc": "the Salesforce.com username (will override any username in the URL)",
                    "sensitive": False,
                },
            },
            # FIXME: username and password are currently optional for backwards compatibility with URL auth options
            "required_options": "client_id,client_secret",
        };
    }

    #! creates the SalesforceRestConnection connection object
    /** @param name the name of the connection
        @param description connection description
        @param url connection URL (potentially with password info)
        @param attributes various attributes. See below
        @param options connection options

        See @ref AbstractConnection::constructor() for \c attributes and \c options reference.
    */
    constructor(string name, string description, string url, hash<auto> attributes = {}, hash<auto> options = {})
        : RestConnection(name, description, url, attributes, options) {
        real_opts = ("url": real_url) + urlh.("username", "password") + opts;
    }

    #! returns \c "sfrests"
    string getType() {
        return "sfrests";
    }

    #! returns @ref True as this connection returns a data provider with the @ref getDataProvider() method
    /** @return @ref True as this connection returns a data provider with the @ref getDataProvider() method

        @see @ref getDataProvider()
    */
    bool hasDataProvider() {
        return True;
    }

    #! returns a data provider object for this connection
    /** @return a data provider object for this connection

        @throw DATA-PROVIDER-ERROR this object does not support the data provider API
    */
    DataProvider::AbstractDataProvider getDataProvider() {
        # to avoid circular dependencies, this object loads the SalesforceRestDataProvider and creates the data provider
        # object dynamically
        load_module("SalesforceRestDataProvider");
        return create_object("SalesforceRestDataProvider", get());
    }

    #! Sets child data provider capabilities
    private setChildCapabilities() {
        children_can_support_records = True;
    }

    #! returns a @ref SalesforceRestClient::SalesforceRestClient object
    /** @param connect if @ref True "True", then the connection is returned already connected
        @param rtopts this connection type does not accept any runtime options, so this parameter is ignored

        @return a @ref SalesforceRestClient::SalesforceRestClient "SalesforceRestClient" object
    */
    private SalesforceRestClient getImpl(bool connect = True, *hash<auto> rtopts) {
        return new SalesforceRestClient(real_opts + {
            "logger": logger,
            "update_options": update_options,
        }, !connect);
    }

    #! Returns the ConnectionSchemeInfo hash for this object
    private hash<ConnectionSchemeInfo> getConnectionSchemeInfoImpl() {
        return ConnectionScheme;
    }

    #! Called to start a non-blocking polling ping operation on the remote REST server
    /**
        @return a socket poll operation object that will allow the connection goal to be reached with polling

        @see supportsPollingApi()
    */
    Qore::AbstractPollOperation startPollConnect() {
        if (!opts.ping_method || !exists opts.ping_path) {
            return HttpBasedConnection::startPollConnect();
        }

        # returns a RestClient option without connecting and without retrieving any external schemas with I/O
        return new SalesforceRestPingPollOperation(getPollImpl(), real_opts);
    }
}

#! REST ping polling I/O class with OAuth2 authentication
/** Ensures a 200 response to the polling send/receive operation
*/
public class SalesforceRestPingPollOperation inherits RestClient::RestPingPollOperation {
    private {
        #! Get available APIs
        const SPS_GET_APIS = "get-apis";
    }

    constructor(RestClient rc, hash<auto> real_opts) : RestPingPollOperation(rc, real_opts) {
    }

    private checkOtherStates() {
        if (state == SPS_GET_APIS) {
            hash<auto> resp = poller.getOutput();
            if ((resp."code" / 100) == 2) {
                AbstractRestSchemaValidator validator = rc.getValidator();
                on_error rethrow $1.err, sprintf("%s: info: %y", $1.desc, resp.info{"request-uri",
                    "response-uri"});
                string body = resp."response-body"
                    ? resp."response-body".toString(resp.info.charset ?? "ISO-8859-1")
                    : "";
                hash<RestResponseClientInfo> info = validator.parseResponse(method, path, resp."code", body,
                    resp.info."response-headers" + {"content-type": resp.info."body-content-type"});
                cast<SalesforceRestClient>(rc).processApis(info.body);
                doStartPing();
                return;
            }

            throw "REST-PING-ERROR", sprintf("failed to retrieve Salesforce APIs: %y returned from %y; response "
                "body: %y", resp.info."response-uri", resp.info."request-uri", body);
        }

        RestPingPollOperation::checkOtherStates();
    }

    private gotOAuth2LoginInfo(hash<auto> h) {
        SalesforceRestClient src = cast<SalesforceRestClient>(rc);
        src.gotOAuth2LoginInfo(h);
        # set the URL to the Salesforce.com URL for REST API calls
        src.setURL(h.instance_url);
        # get APIs if necessary
        if (!src.getApis()) {
            doStartGetApis();
        } else {
            # verify API
            src.setVerifyApi(h);
            # start ping
            doStartPing();
        }
    }

    private doStartGetApis() {
        string path = "/services/data";
        auto body;
        hash<auto> headers = {
            "Accept": MimeTypeJson,
        };
        # first prepare message for ping from any validator
        rc.prepareToSend("GET", \path, \body, \headers);

        state = SPS_GET_APIS;
        poller = rc.startPollSendRecv("GET", path, NOTHING, headers);
    }
}
}
