# -*- mode: qore; indent-tabs-mode: nil -*-
# @file CsvUtil.qm Qore user module for working with CSV files

/*  CsvUtil.qm Copyright 2012 - 2016 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.12

# assume local var scope, do not use "$" for vars, members, and method calls
%new-style

module CsvUtil {
    version = "1.6";
    desc = "user module for working with CSV files";
    author = "Petr Vanek <petr@yarpen.cz>, David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/* see release notes below for version history
*/

/** @mainpage CsvUtil Module

    @tableofcontents

    @section csvutilintro Introduction to the CsvUtil Module

    The %CsvUtil module provides functionality for parsing CSV-like files.

    To use this module, use \c "%requires CsvUtil" in your code.

    All the public symbols in the module are defined in the CsvUtil namespace

    Currently the module provides the following classes:
    - @ref CsvUtil::AbstractCsvIterator "AbstractCsvIterator": base abstract iterator class for iterating line-based CSV data
    - @ref CsvUtil::CsvDataIterator "CsvDataIterator": iterator class allowing for CSV string data to be processed line by line on a record basis
    - @ref CsvUtil::CsvFileIterator "CsvFileIterator": iterator class allowing for CSV files to be processed line by line on a record basis
    - @ref CsvUtil::AbstractCsvWriter "AbstractCsvWriter": a base class for new CSV writer implementations
    - @ref CsvUtil::CsvFileWriter "CsvFileWriter": CSV file writer
    - @ref CsvUtil::CsvStringWriter "CsvStringWriter": CSV in memory writer

    Note that the @ref CsvUtil::CsvFileIterator "CsvFileIterator" class can be used to parse arbitrary text files; the field separator character can be specified in the @ref CsvUtil::CsvFileIterator::constructor() "constructor", as well as the quote character and end of line sequence.  See the @ref CsvUtil::CsvFileIterator::constructor() "constructor documentation" for more information.

    <b>Examples:</b>
    @code{.py}
#!/usr/bin/env qore

%new-style
%requires CsvUtil

CsvFileIterator i("example-file.csv");
CsvFileWriter writer("example-file-copy.csv");
while (i.next()) {
    printf("%d: %y\n", i.index(), i.getValue());
    writer.writeLine(i.getValue());
}
    @endcode

    If \c "example-file.csv" is:
    @verbatim
UK,1234567890,"Sony, Xperia S",31052012
UK,1234567891,"Sony, Xperia S",31052012
UK,1234567892,"Sony, Xperia S",31052012
UK,1234567893,"Sony, Xperia S",31052012
    @endverbatim

    The data is read verbatim, each value is returned as a string, header names are generated numerically; the output is:
    @verbatim
1: {0: "UK", 1: "1234567890", 2: "Sony, Xperia S", 3: "31052012"}
2: {0: "UK", 1: "1234567891", 2: "Sony, Xperia S", 3: "31052012"}
3: {0: "UK", 1: "1234567892", 2: "Sony, Xperia S", 3: "31052012"}
4: {0: "UK", 1: "1234567893", 2: "Sony, Xperia S", 3: "31052012"}
    @endverbatim

    Also the \c "example-file-copy.csv" will contain data from the original file formatted as CSV.

    @anchor complex_example
    If header names are provided and field types are specified, the output looks different:
    @code{.py}
#!/usr/bin/env qore

%new-style
%requires CsvFileIterator

CsvFileIterator i("example-file.csv", ("headers": ("cc", "serno", "desc", "received"), "fields": ("serno": "int", "received": ("type": "date", "format": "DDMMYYYY"))));
while (i.next())
    printf("%d: %y\n", i.index(), i.getValue());
    @endcode

    Now the hash keys in each record returned are those given in the @ref CsvUtil::CsvFileIterator::constructor() "constructor", and the fields \c "serno" and \c "received" are given other data types; this produces:
    @verbatim
1: {cc: "UK", serno: 1234567890, desc: "Sony, Xperia S", received: 2012-05-31 00:00:00 Thu +02:00 (CEST)}
2: {cc: "UK", serno: 1234567891, desc: "Sony, Xperia S", received: 2012-05-31 00:00:00 Thu +02:00 (CEST)}
3: {cc: "UK", serno: 1234567892, desc: "Sony, Xperia S", received: 2012-05-31 00:00:00 Thu +02:00 (CEST)}
4: {cc: "UK", serno: 1234567893, desc: "Sony, Xperia S", received: 2012-05-31 00:00:00 Thu +02:00 (CEST)}
    @endverbatim

    Use the \c "header_lines" and \c "header_names" @ref abstractcsviterator_options "options" to automatically read the header names from the file if present.  Use the \c "fields" @ref abstractcsviterator_options "option" to describe the fields and perform transformations on the data read.  For more information, see the @ref CsvUtil::CsvFileIterator "CsvFileIterator" class.

    @anchor multi_type
    Multi-type lines are supported as well. Multi-type means the line may have different structure, i.e.fields. The type of line is evaluated in run-time using \c "resolve_type" @ref abstractcsviterator_options "option", typically according to the value of the first field at line. It works for both @ref CsvUtil::AbstractCsvIterator "AbstractCsvIterator" and @ref CsvUtil::AbstractCsvWriter "AbstractCsvWriter".
    @code{.py}
#!/usr/bin/env qore

%new-style

%requires CsvUtil

const opts = (
    "fields": (
        "type": "int",

        "invoice_no": "string",
        "date": ("type": "date", "format": "YYYYMMDD"),

        "item_no": "string",
        "item": "string",
        "pcs": "int",
        "price": "number",

        "total": "number",
    ),
    "headers": (
        "header": ("type", "invoice_no", "date"),
        "item":   ("type", "item_no", "item", "pcs", "price"),
        "footer": ("type", "total"),
    ),
    'resolve_type': softstring sub(hash values) {
        softint type = exists values{'type'}?values{'type'}:values{'0'};
        switch (type) {
            case 1:
                return "header";
            case 2:
                return "item";
            case 3:
                return "footer";
        }
        return NULL;
    },
);

CsvFileIterator i("example-multi-file.csv", opts);
CsvFileWriter writer("example-multi-file-copy.csv", ("write-headers": False, "optimal-quotes" : True, "quote_escape" : '"')+opts);
while (i.next()) {
    printf("%d: %y\n", i.index(), i.getValue());
    writer.writeLine(i.getValue());
}
    @endcode


    If \c "example-multi-file.csv" is:
    @verbatim
1,2016-01,20160401
2,123,"Sony, Xperia S",1,100
2,124,"Nokia, Lumia",2,150
3,250
    @endverbatim

    The data is read verbatim, each value is returned as a string, header names are generated numerically; the output is:
    @verbatim
1: ("type": 1, "invoice_no": "2016-01", "date": 2016-04-01)
2: ("type": 2, "item_no": 123, "item": "Sony, Xperia S", "pcs": 1, "price": 100)
3: ("type": 2, "item_no": 124, "item": "Nokia, Lumia", "pcs": 2, "price": 150)
4: ("type": 3, "total": 250)
    @endverbatim

    Also the \c "example-multi-file-copy.csv" will contain data from the original file formatted as CSV.

    @section csvutil_relnotes Release Notes

    @subsection csvutil_v1_6 Version 1.6
    - implemented multi-type line support

    @subsection csvutil_v1_5 Version 1.5
    - fixed a bug handling the global option \c "eol"
    - converted to new-style
    - if "headers" are not given in the @ref CsvUtil::AbstractCsvWriter::constructor() but "fields" are, then set the headers from the field descriptions automatically
    - added write() methods returning the generated strings to the @ref CsvUtil::CsvStringWriter class for API compatibility with the corresponding FixedLengthDataWriter methods
    - implemented support for @ref Qore::SQL::SQLStatement "SQLStatement" as an iterator source for @ref CsvUtil::AbstractCsvWriter::write()
    - implemented the \c "datamap" and \c "info_log" options for CSV generation
    - implemented options with underscores to replace options with dashes:
      - @ref CsvUtil::AbstractCsvWriter
        - \c "date-format" is now \c "date_format"
        - \c "optimal-quotes" is now \c "optimal_quotes"
        - \c "verify-columns" is now \c "verify_columns"
        - \c "write-headers" is now \c "write_headers"
      - @ref CsvUtil::AbstractCsvIterator
        - \c "ignore-empty" is now \c "ignore_empty"
        - \c "ignore-whitespace" is now \c "ignore_whitespace"
        - \c "header-names" is now \c "header_names"
        - \c "header-lines" is now \c "header_lines"
        - \c "verify-columns" is now \c "verify_columns"

    @subsection csvutil_v1_4 Version 1.4
    - fixed the \c "format" field option when used with \c "*date" field types
    - implemented the \c "tolwr" parser option
    - changed the default field type when parsing and generating CSV files from \c "string" to \c "*string"

    @subsection csvutil_v1_3 Version 1.3
    - added the \c "write-headers" option to @ref CsvUtil::AbstractCsvWriter and subclasses to enable headers to be suppressed
    - added the \c "optimal-quotes" option to @ref CsvUtil::AbstractCsvWriter and subclasses to enable more efficient csv output (now the default output option); to revert back to the previous behavior (where all fields are quoted regardless of data type or content), set to @ref Qore::False "False" in the constructor

    @subsection csvutil_v1_2 Version 1.2
    - fixed @ref CsvUtil::CsvDataIterator::next() when header_lines > 0 and working with empty input data
    - implemented support for the \c "*int", \c "*float", \c "*number", and \c "*date" types
    - implemented support for allowing subclasses of @ref CsvUtil::CsvFileIterator to implement support for other custom types
    - fixed \c "date" type handling with empty input; now returns 1970-01-01 (use "*date" to map empty input to NOTHING)
    - added the @ref CsvUtil::CsvStringWriter, @ref CsvUtil::AbstractCsvWriter, and @ref CsvUtil::CsvFileWriter classes
    - if "headers" are not given in the @ref CsvUtil::CsvFileIterator::constructor() but "fields" are, then set the headers from the field descriptions automatically

    @subsection csvutil_v1_1 Version 1.1
    - bug fixes to header and fields option processing
    - fixed @ref CsvUtil::CsvFileIterator::index() to return the line index
    - added @ref CsvUtil::CsvFileIterator::lineNumber() to return the current line number in the file

    @subsection csvutil_v1_0 Version 1.0
    - initial version of module
*/

# private class used to iterate a list and skip elements without any value
class ListValueIterator inherits ListIterator {
    constructor(*list l) : ListIterator(l) {
    }

    bool next() {
        bool b;
        while ((b = ListIterator::next()) && !getValue()) {
        }
        return b;
    }
}

class CsvHelper {
    private {
        #! supported type codes (hash for quick lookups)
        const Types = (
            "int": True,
            "*int": True,
            "float": True,
            "*float": True,
            "number": True,
            "*number": True,
            "string": True,
            "*string": True,
            "date": True,
            "*date": True,
        );

        #! supported field description attribute codes
        const FieldAttrs = ("type", "format", "timezone", "code");

        #! flag to convert all header names to lower case
        bool tolwr = False;

        #! hash of field information (types, formats, and possible code), hash key = column name or number (starting with 0)
        *hash fields;

        #! current line type
        *hash curHFDef;

        #! headers / column names for lines iterated and
        #! list of field descriptions (from fields, ordered when headers are set)
        #! for each line type or just one item when no multi type is used
        hash hfDefs = {};

        #! multi-line detection based on record. List record is hashed (i.e. index is transformed to key), softstring sub (hash values) {}
        code resolveType;

    }

    # multi type data lines
    private bool isMultiType() {
        return hfDefs.size() > 1 || hfDefs.firstKey();
    }

    private bool hasHeaders() {
        return hfDefs.size() > 0;
    }

    # sets field description list
    private setFields() {
        foreach hash d in (hfDefs.pairIterator()) {
            if (!d.value.fdesc) {
                # TODO: can I modify value or is not ?
                if (d.value.headers && tolwr)
                    d.value.headers = (map $1.lwr(), d.value.headers);

                d.value.fdesc = ();

                # make a copy of the field description hash
                hash f = fields;
                foreach string h in (d.value.headers) {
                    if (f{h}) {
                        # add to field description list (and remove from the field description hash)
                        d.value.fdesc += remove f{h};
                        continue;
                    }
                    # add an entry with type "*string" to the list
                    d.value.fdesc += ("type": "*string");
                }

                # TODO: is it really error ?
                if (f && !isMultiType())
                    throw "CSVFILEWRITER-FIELD-ERROR", sprintf("field descriptions were given for the following non-existent fields: %y (known header / field names: %y)", f.keys(), d.value.headers);

                hfDefs{d.key} = d.value;  # TODO: needed ?
            }
        }
    }

    checkType(string key, string value) {
        if (!Types{value})
            throw "CSV-TYPE-ERROR", sprintf("while processing the hash value for option key \"fields\": unknown field type %y for field %y (supported types: %y)", value, key, Types.keys());
    }

    private addHeaders(softstring id, list h) {
        remove hfDefs{id};
        if (!h) return;
        hash d = (
            "headers": (),
            "fdesc": (),
        );

        foreach any c in (h.iterator()) {
            try {
                softstring v = c;
                d.headers += v;
            }
            catch (hash ex) {
                throw "CSVHELPER-ERROR", sprintf("expecting a string value or a value that can be converted to a string for header option; got %y (type %s) in header list position %d instead (full arg: %y)", c, c.type(), $#, h);
            }
        }
        hfDefs{id} = d;
    }

    private assignHeaders(any h) {
        switch (h.typeCode()) {
            case NT_HASH:
                # multi type lines
                foreach hash i in (h.pairIterator()) {
                    addHeaders(i.key, i.value);
                }
                break;
            case NT_LIST:
                addHeaders(NULL, h);
                break;
            default:
                throw "CSVHELPER-ERROR", sprintf("expecting a list or hash value for header option, got %y (type %s)", h, h.type());
        }
        setHFDef(NULL);
    }

    private bool setHFDef(any values) {
        curHFDef = NULL;
        if (isMultiType()) {
            if (values) {
                softstring t = doResolveType(values);
                if (exists hfDefs{t}) {
                    curHFDef = hfDefs{t};
                }
            }
        } else {
            if (hfDefs) {
                softstring t = hfDefs.firstKey();
                curHFDef = hfDefs{t};
            }
        }
        return curHFDef != NOTHING;
    }

    #! resolve line type when multi-type is needed. Type of values parameter is list (index based values) or hash for name based values.
    public softstring doResolveType(any values) {
        softint type = -1;
        my hash hval;
        if (values.typeCode() == NT_LIST) {
            hval = hash();
            # convert list to hash
            map hval.$# = $1, values;
        } else {
            hval = values;
        }
        if (resolveType.typeCode() == NT_CLOSURE) {
            return resolveType(hval);  # evaluation defined via options
        } else {
            return hfDefs.firstKey();
        }
    }

} # class CsvHelper

#! the CsvUtil namespace contains all the objects in the CsvUtil module
public namespace CsvUtil {
    #! Unix end of line character sequence (for new OS X too)
    public const EOL_UNIX = "\n";
    #! MS DOS/Windows end of line character sequence
    public const EOL_WIN = "\r\n";
    #! Old (pre-OSX) Macintosh end of line character sequence
    public const EOL_MACINTOSH = "\r";

    # helper list of end of line values
    const EOLS = (EOL_UNIX, EOL_WIN, EOL_MACINTOSH, );

    #! the AbstractCsvIterator class is an abstract base class that allows abstract CSV data to be iterated
    /**
        @section abstractcsviterator_options AbstractCsvIterator Constructor Option Hash Overview
        The AbstractCsvIterator class constructor takes an optional hash with possible keys given in the following table.  Note that
        key names are case-sensitive, and data types are soft (conversions are made when possible).

        <b>AbstractCsvIterator Options</b>
        |!Option|!Data Type|!Description
        |\c "encoding"|@ref string|the @ref character_encoding "character encoding" for the file (and for tagging string data read); if the value of this key is not a string then it will be ignored
        |\c "separator"|@ref string|the string separating the fields in the file (default: \c ",")
        |\c "quote"|@ref string|the field quote character (default: \c '\"')
        |\c "eol"|@ref string|the end of line character(s) (default: auto-detect); if the value of this key is not a string then it will be ignored
        |\c "ignore_empty"|@ref boolean|if @ref Qore::True "True" (the default) then empty lines will be ignored; this option is processed with @ref Qore::parse_boolean() "parse_boolean()"
        |\c "ignore_whitespace"|@ref boolean|if @ref Qore::True "True" (the default) then leading and trailing whitespace will be stripped from non-quoted fields; this option is processed with @ref Qore::parse_boolean() "parse_boolean()"
        |\c "header_names"|@ref boolean|if @ref Qore::True "True" then the object will parse the header names from the first header row, in this case \c "header_lines" must be &gt; 0. In case of multi-type lines \c "header_names" is mandatory @ref Qore::False "False".
        |\c "header_lines"|@ref integer|the number of headers lines in the file (must be &gt; 0 if \c "header_names" is @ref Qore::True "True")
        |\c "headers"|@ref list of strings|list of header / column names for the data iterated; if this is present, then \c "header_names" must be @ref Qore::False "False".
        |\c "headers"|@ref hash of lists of strings|Defines multi-type lines where key is name of type whose name is resolved by \c "resolve_type" custom function. Hash value is equal to \c "headers" as documented above.
        |\c "resolve_type"|@ref softstring sub(@ref hash values)|implement a custom function as closure to inspect record value and return type name.\c "Values" keys are field indexes/positions. If \c ignore_empty is @ref Qore::False "False" and the function returns id not defined in \c headers then line is resolved as an empty record
        |\c "verify_columns"|@ref boolean|if @ref Qore::True "True" (the default is @ref Qore::False "False") then if a line is parsed with a different
        column count than other lines, a \c CSVFILEITERATOR-DATA-ERROR exception is thrown
        |\c "fields"|@ref hash|the keys are column names (or numbers in case column names are not used) and the values are either strings (one of @ref abstractcsviterator_option_field_types giving the data type for the field) or a @ref abstractcsviterator_option_field_hash describing the field; also sets \a headers if not set automatically with \c "header_names"; if no field type is given, the default is \c "*string"
        |\c "timezone"|@ref string|the timezone to use when parsing dates (will be passed to @ref Qore::TimeZone::constructor())
        |\c "tolwr"|@ref boolean|if @ref Qore::True "True" then all header names will be converted to lower case letters

        @note the following options separated by dashes are still supported for backwards-compatibility:
        - \c "ignore-empty"
        - \c "ignore-whitespace"
        - \c "header-names"
        - \c "header-lines"
        - \c "verify-columns"

        @subsection abstractcsviterator_option_field_types Option Field Types

        <b>AbstractCsvIterator Option Field Types</b>
        |!Name|!Description
        |\c "int"|the value will be unconditionally converted to an @ref integer "integer" using the @ref Qore::int() function
        |\c "*int"|the value will be converted to @ref nothing if empty, otherwise it will be converted to an @ref integer "integer" using the @ref Qore::int() function
        |\c "float"|the value will be unconditionally converted to a @ref float "floating-point value" using the @ref Qore::float() function
        |\c "*float"|the value will be converted to @ref nothing if empty, otherwise it will be converted to a @ref float "floating-point value" using the @ref Qore::float() function
        |\c "number"|the value will be unconditionally converted to an @ref number "arbitrary-precision number value" using the @ref Qore::number() function
        |\c "*number"|the value will be converted to @ref nothing if empty, otherwise it will be converted to an @ref number "arbitrary-precision number value" using the @ref Qore::number() function
        |\c "string"|(the default) the value remains a string; no transformation is done on the input data
        |\c "*string"|the value will be converted to @ref nothing if empty, otherwise, it remains a string
        |\c "date"|in this case dates are parsed directly with the @ref Qore::date() function (and therefore are tagged automatically with the current @ref time_zones "time zone"); to specify another date format, use the @ref abstractcsviterator_option_field_hash "hash format" documented below
        |\c "*date"|the value will be converted to @ref nothing if empty, otherwise dates are parsed directly with the @ref Qore::date() function (and therefore are tagged automatically with the current @ref time_zones "time zone"); to specify another date format, use the @ref abstractcsviterator_option_field_hash "hash format" documented below

        @subsection abstractcsviterator_option_field_hash Option Field Hash
        See @ref complex_example "here" for an example of using the hash field description in the @ref CsvUtil::CsvFileIterator::constructor() "constructor()".

        <b>AbstractCsvIterator Option Field Hash</b>
        |!Key|!Value Description
        |\c "type"|one of the @ref abstractcsviterator_option_field_types "option type values" giving the field type
        |\c "format"|used only with the \c "date" type; this is a @ref date_mask "date/time format mask" for parsing dates
        |\c "timezone"|used only with the \c "date" type; this value is passed to @ref Qore::TimeZone::constructor() and the resulting timezone is used to parse the date (this value overrides any default time zone for the object; use only in the rare case that date/time values from different time zones are present in different columns of the same file)
        |\c "code"|this is a @ref closure or @ref call_reference that takes a single argument of the value (after formatting with any optional \c "type" formats) and returns the value that will be output for the field
     */
    public class AbstractCsvIterator inherits Qore::AbstractIterator, private CsvHelper {
        private {
            #! valid options for the object (a hash for quick lookups of valid keys)
            const Options = (
                "encoding": True,
                "eol": True,
                "fields": True,
                "header-lines": True,
                "header_lines": True,
                "header-names": True,
                "header_names": True,
                "headers": True,
                "ignore-empty": True,
                "ignore_empty": True,
                "ignore-whitespace": True,
                "ignore_whitespace": True,
                "quote": True,
                "resolve_type": True,
                "separator": True,
                "timezone": True,
                "tolwr": True,
                "verify-columns": True,
                "verify_columns": True,
                );

            # field separator
            string separator = ",";

            # field content delimiter
            string quote = "\"";

            # number of header lines
            softint headerLines = 0;

            # flag to use string names from the first header row if possible
            bool headerNames = False;

            # True if empty lines should be ignored
            bool ignoreEmptyLines = True;

            # Flag to trim the field content (trim leading and trailing whitespace) from unquoted fields
            bool ignoreWhitespace = True;

            # the @ref Qore::TimeZone to use when parsing dates (default: current time zone)
            *TimeZone tz;

            # verify the column count for every row; if a row does not match, then throw a \c CSVFILEITERATOR-DATA-ERROR exception
            bool checkElementCounts = False;

            # column count for verifying column counts
            int cc;

            # current record count for the index() method
            int rc = 0;
        }

        #! creates the AbstractCsvIterator with an option hash
        /** @param opts a hash of optional options; see @ref abstractcsviterator_options for more information

            @throw ABSTRACTCSVITERATOR-ERROR invalid or unknown option; invalid data type for option; \c "header-names" is @ref Qore::True "True" and \c "header_lines" is 0 or \c "headers" is also present; unknown field type
         */
        constructor(*hash opts) {
            foreach hash i in (opts.pairIterator()) {
                if (!exists Options.(i.key))
                    throw "ABSTRACTCSVITERATOR-ERROR", sprintf("unknown option %y passed to AbstractCsvIterator::constructor() (valid options: %y)", i.key, Options.keys());
                switch (i.key) {
                    case "separator": {
                        if (i.value.typeCode() != NT_STRING)
                            throw "ABSTRACTCSVITERATOR-ERROR", sprintf("expecting a string value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        separator = i.value;
                        break;
                    }
                    case "quote": {
                        if (i.value.typeCode() != NT_STRING)
                            throw "ABSTRACTCSVITERATOR-ERROR", sprintf("expecting a string value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        quote = i.value;
                        break;
                    }
                    case "ignore-empty":
                    case "ignore_empty": {
                        ignoreEmptyLines = parse_boolean(i.value);
                        break;
                    }
                    case "ignore-whitespace":
                    case "ignore_whitespace": {
                        ignoreWhitespace = parse_boolean(i.value);
                        break;
                    }
                    case "header-names":
                    case "header_names": {
                        headerNames = parse_boolean(i.value);
                        break;
                    }
                    case "verify-columns":
                    case "verify_columns": {
                        checkElementCounts = parse_boolean(i.value);
                        break;
                    }
                    case "header-lines":
                    case "header_lines": {
                        try {
                            headerLines = i.value;
                        }
                        catch (hash ex) {
                            throw "ABSTRACTCSVITERATOR-ERROR", sprintf("expecting integer value or a value that can be converted to an integer for option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        }
                        break;
                    }
                    case "headers": {
                        assignHeaders(i.value);
                        break;
                    }
                    case "timezone": {
                        tz = new TimeZone(i.value);
                        break;
                    }
                    case "tolwr": {
                        tolwr = parse_boolean(i.value);
                        break;
                    }
                    case "fields": {
                        if (i.value.typeCode() != NT_HASH)
                            throw "ABSTRACTCSVITERATOR-ERROR", sprintf("expecting a hash value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());

                        # iterate hash to process field descriptions
                        foreach hash hi in (i.value.pairIterator()) {
                            switch (hi.value.typeCode()) {
                                case NT_STRING: {
                                    checkType(hi.key, hi.value);
                                    fields.(hi.key) = ("type": hi.value);
                                    break;
                                }
                                case NT_HASH: {
                                    if (hi.value.empty())
                                        throw "ABSTRACTCSVITERATOR-ERROR", sprintf("while processing the hash value for option key \"fields\": empty hash passed as description for field %y", hi.key);
                                    hash h;
                                    foreach hash fh in (hi.value.pairIterator()) {
                                        switch (fh.key) {
                                            case "type": {
                                                checkType(hi.key, fh.value);
                                                h.type = fh.value;
                                                break;
                                            }
                                            case "format": {
                                                if (fh.value.typeCode() != NT_STRING)
                                                    throw "ABSTRACTCSVITERATOR-ERROR", sprintf("while processing the hash value for option key \"fields\": field %y \"format\" attributes expects a string value; got %y instead", hi.key, fh.value.type());
                                                h.format = fh.value;
                                                break;
                                            }
                                            case "timezone": {
                                                h.timezone = new TimeZone(fh.value);
                                                break;
                                            }
                                            case "code": {
                                                if (!fh.value.callp())
                                                    throw "ABSTRACTCSVITERATOR-ERROR", sprintf("while processing the hash value for option key \"fields\": field %y \"code\" attributes expects a callable value to process the field value; got %y instead", hi.key, fh.value.type());
                                                h.code = fh.value;
                                                break;
                                            }
                                            default: {
                                                throw "ABSTRACTCSVITERATOR-ERROR", sprintf("while processing the hash value for option key \"fields\": unknown field attribute value %y given for field %y (supported attribute values: %y)", fh.key, hi.key, FieldAttrs);

                                            }
                                        }
                                    }
                                    if (!h.type)
                                        h.type = "*string";
                                    if (h.type != "date" && h.type != "*date") {
                                        foreach string f in ("timezone", "format") {
                                            if (h{f})
                                                throw "ABSTRACTCSVITERATOR-ERROR", sprintf("while processing the hash value for option key \"fields\": field %y is type %y, but the %y attribute was also given, which is only valid for \"date\" fields", hi.key, h.type, f);
                                        }
                                    }
                                    fields.(hi.key) = h;
                                    break;
                                }
                                default: {
                                    throw "ABSTRACTCSVITERATOR-ERROR", sprintf("while processing the hash value for option key \"fields\": invalid value passed as the field description for field %y; expecting \"string\" or \"hash\"; got %y instead", i.key, hi.value.type());
                                }
                            }
                        }

                        break;
                    }
                    case "resolve_type": {
                        if (i.value.typeCode() != NT_CLOSURE) {
                            throw "ABSTRACTCSVITERATOR-ERROR", sprintf("\"resolve_type\" option is not closure; got %y instead", i.value.type());

                        }
                        resolveType = i.value;
                        break;
                    }
                }
            }
            if (headerNames && !headerLines)
                throw "ABSTRACTCSVITERATOR-ERROR", sprintf("\"header_names\" is True but \"header_lines\" is 0; there must be at least 1 header line to get header names");
            if (headerNames && hfDefs)
                throw "ABSTRACTCSVITERATOR-ERROR", sprintf("\"header_names\" is True but \"headers\" has a value (%y)", hfDefs);

            # set headers automatically from field names if not set
            if (fields && !hfDefs && !headerNames)
                assignHeaders(fields.keys());

            if (hfDefs && fields)
                setFields();
        }

        #! Returns the name of the input data
        private *string getDataName() {
            return "<csv input>";
        }

        #! Returns the current line number
        private abstract int lineNumberImpl();

        #! Returns the current line
        private abstract string getLineValueImpl();

        #! Moves the current line / record position to the next line / record; returns @ref False if there are no more lines to iterate
        private abstract bool nextLineImpl();

        #! Moves the current line / record position to the next line / record; returns @ref False if there are no more lines to iterate
        /** This method will return @ref True again after it returns @ref False once if the file being iterated has data that can be iterated, otherwise it will always return @ref False. The iterator object should not be used to retrieve a value after this method returns @ref False.
            @return @ref False if there are no lines / records to iterate (in which case the iterator object is invalid and should not be used); @ref True if successful (meaning that the iterator object is valid)

            @note that if headers are not given as an option to the constructor, then they are detected and set the first time AbstractCsvIterator::next() is run on a file (see @ref getHeaders())
         */
        bool next() {
            # try to parse any header and skip to data if we haven't started iterating yet
            if (!valid()) {
                if (headerLines) {
                    if (headerNames) {
                        # return False if there is no data to iterate
                        if (!nextLineImpl())
                            return False;

                        # get and parse header row
                        assignHeaders(parseLine());

                        # set field description list if necessary
                        if (fields)
                            setFields();
                    }
                    # skip the rest of the header rows
                    while (lineNumberImpl() < headerLines) {
                        if (!nextLineImpl())
                            return False;
                    }
                }
            }
            bool b = nextLineImpl();
            if (b) {
                # skip empty lines
                if (ignoreEmptyLines) {
                    while (b && (getLineValueImpl().empty() || isMultiType() && parseLine().size()==0))
                        b = nextLineImpl();
                }

                # generate fake header names with index positions if no header data is already available, note: multi-type has headers
                if (b && !hasHeaders()) {
                    list l = parseLine();
                    list h = ();
                    map h += string($#), l;
                    assignHeaders(h);

                    # set field description list if necessary
                    if (fields)
                        setFields();
                }
            }

            if (b)
                ++rc;
            else
                rc = 0;

            return b;
        }

        #! returns the given column value for the current row
        /** @param name the name of the field (header name) in record

            @return the value of the given header for the current record

            @throw INVALID-ITERATOR this error is thrown if the iterator is invalid; make sure that the next() method returns True before calling this method
            @throw ABSTRACTCSVITERATOR-FIELD-ERROR invalid or unknown field name given
         */
        any memberGate(string name) {
            hash h = getRecord();
            if (!h.hasKey(name))
                throw "ABSTRACTCSVITERATOR-FIELD-ERROR", sprintf("the requested header %y does not exist (known headers: %y)", name, curHFDef?curHFDef.headers:() );

            return h{name};
        }

        #! returns the current record as a hash
        /** @par Example:
            @code{.py}
hash h = i.getValue();
            @endcode

            @return the current record as a hash

            @throw INVALID-ITERATOR this error is thrown if the iterator is invalid; make sure that the next() method returns True before calling this method
         */
        hash getValue() {
            return getRecord();
        }

        #! returns the current record as a hash
        /** @par Example:
            @code{.py}
hash h = i.getRecord();
            @endcode

            @throw INVALID-ITERATOR this error is thrown if the iterator is invalid; make sure that the next() method returns True before calling this method

            @return the current record as a hash
         */
        hash getRecord() {
            list l = parseLine();
            hash h = {};
            foreach any v in (l) {
                string col = curHFDef.headers[$#] ? curHFDef.headers[$#] : string($#);
                h{col} = v;
            }

            return h;
        }

        #! returns the current record as a list
        /** @par Example:
            @code{.py}
list l = i.getRecordList();
            @endcode

            @throw INVALID-ITERATOR this error is thrown if the iterator is invalid; make sure that the next() method returns True before calling this method

            @return the current record as a list
         */
        list getRecordList() {
            return parseLine();
        }

        #! returns the current separator string
        /** @par Example:
            @code{.py}
string sep = i.getSeparator();
            @endcode

            @return the current separator string
         */
        string getSeparator() {
            return separator;
        }

        #! returns the current quote string
        /** @par Example:
            @code{.py}
string quote = i.getQuote();
            @endcode

            @return the current quote string
         */
        string getQuote() {
            return quote;
        }

        #! returns the current column headers or @ref nothing if no headers have been detected or saved yet
        /** @par Example:
            @code{.py}
            @endcode

            @note if headers are not saved against the object in the @ref constructor(), then they are written to the object after the first call to @ref next()
         */
        *list getHeaders() {
            return curHFDef ? curHFDef.headers : NULL;
        }

        #! returns the row index being iterated, which does not necessarily correspond to the line number when there are header rows and blank lines are skipped
        /** @par Example:
            @code{.py}
int index = i.index();
            @endcode

            @return the row index being iterated, which does not necessarily correspond to the line number when there are header rows and blank lines are skipped

            @see lineNumber()

            @since %CsvUtil 1.1
        */
        int index() {
            return rc;
        }

        #! returns the current iterator line number in the file (the first line is line 1) or 0 if not pointing at a valid element
        /** @par Example:
            @code{.py}
while (i.next()) {
    printf("+ line %d: %y\n", i.lineNumber(), i.getValue());
}
            @endcode

            @return returns the current iterator line number in the file (the first line is line 1) or 0 if not pointing at a valid element

            @note equivalent to @ref Qore::FileLineIterator::index()

            @see index()

            @since %CsvUtil 1.1
        */
        int lineNumber() {
            return lineNumberImpl();
        }

        private any handleType(hash fh, *string val) {
            any rv;
            string type = fh.type;
            # if it's an "or nothing" type and there is no value, then return nothing
            if (type =~ /^\*/) { #/){
                if (val.empty())
                    return NOTHING;
                splice type, 0, 1;
            }

            switch (type) {
                case "int": {
                    rv = int(val);
                    break;
                }
                case "float": {
                    rv = float(val);
                    break;
                }
                case "number": {
                    rv = number(val);
                    break;
                }
                case "date": {
                    if (val.empty())
                        rv = 1970-01-01;
                    else {
                        *TimeZone tz = fh.timezone ? fh.timezone : tz;
                        if (fh.format)
                            rv = tz ? tz.date(val, fh.format) : date(val, fh.format);
                        else
                            rv = tz ? tz.date(val) : date(val);
                    }
                    break;
                }
                default: rv = val; break;
            }

            return rv;
        }

        #! parses a line in the file and returns a processed list of the fields
        private list parseLine() {
            list l = getLineValueImpl().split(separator, quote, ignoreWhitespace);
            if (!setHFDef(l))
                return ();

            # verify column count if requested
            if (checkElementCounts) {
                if (!exists cc)
                    cc = l.size();
                else if (l.size() != cc)
                    throw "ABSTRACTCSVITERATOR-DATA-ERROR", sprintf("%s:%d line contained %d field%s, however the template record has %d (and option \"verify_columns\" is set)", getDataName(), lineNumberImpl(), l.size(), l.size() == 1 ? "" : "s", cc);
            }

            # appy transformations to data read if there are any transformations to apply
            ListValueIterator i(curHFDef.fdesc);
            while (i.next()) {
                hash fh = i.getValue();
                reference val = \l[i.index()];

                # first apply type transformations
                val = handleType(fh, val);

                # execute any callable value on the processed value
                if (fh.code)
                    val = fh.code(val);
            }
            return l;
        }
    }

    #! the CsvFileIterator class allows CSV files to be iterated on a record basis
    /** @see
        - @ref abstractcsviterator_options
        - @ref abstractcsviterator_option_field_types
        - @ref abstractcsviterator_option_field_hash
     */
    public class CsvFileIterator inherits CsvUtil::AbstractCsvIterator, Qore::FileLineIterator {
        #! creates the CsvFileIterator with the path of the file to read and optionally an option hash
        /** @param path the path to the CSV file to read
            @param opts a hash of optional options; see @ref abstractcsviterator_options for more information

            @throw ABSTRACTCSVITERATOR-ERROR invalid or unknown option; invalid data type for option; \c "header_names" is @ref Qore::True "True" and \c "header_lines" is 0 or \c "headers" is also present; unknown field type
         */
        constructor(string path, *hash opts) : AbstractCsvIterator(opts), FileLineIterator(path, opts.encoding.typeCode() == NT_STRING ? opts.encoding : NOTHING, opts.eol.typeCode() == NT_STRING ? opts.eol : NOTHING) {
        }

        #! Returns the name of the input data
        private *string getDataName() {
            return getFileName();
        }

        #! Returns the current line number
        private int lineNumberImpl() {
            return FileLineIterator::index();
        }

        #! Returns the current line trimmed of the EOL character(s)
        private string getLineValueImpl() {
            return FileLineIterator::getValue();
        }

        #! Moves the current line / record position to the next line / record; returns @ref False if there are no more lines to iterate
        private bool nextLineImpl() {
            return FileLineIterator::next();
        }
    } # CsvFileIterator class

    #! the CsvDataIterator class allows arbitrary CSV string data to be iterated on a record basis
    /** @see
        - @ref abstractcsviterator_options
        - @ref abstractcsviterator_option_field_types
        - @ref abstractcsviterator_option_field_hash
     */
    public class CsvDataIterator inherits CsvUtil::AbstractCsvIterator, DataLineIterator {

        #! creates the CsvDataIterator with the input data and optionally an option hash
        /** @param data the input data to iterate
            @param opts a hash of optional options; see @ref abstractcsviterator_options for more information

            @throw ABSTRACTCSVITERATOR-ERROR invalid or unknown option; invalid data type for option; \c "header_names" is @ref Qore::True "True" and \c "header_lines" is 0 or \c "headers" is also present; unknown field type
         */
        constructor(string data, *hash opts)
            : AbstractCsvIterator(opts),
              DataLineIterator(data, opts.eol)
        {
        }

        #! Returns the current line number; returns 0 if not pointing at any data
        private int lineNumberImpl() {
            return DataLineIterator::index();
        }

        #! Returns the current line trimmed of the EOL character(s)
        private string getLineValueImpl() {
            return DataLineIterator::getLine();
        }

        #! Moves the current line / record position to the next line / record; returns @ref False if there are no more lines to iterate
        private bool nextLineImpl() {
            return DataLineIterator::next();
        }
    }

    #! the AbstractCsvWriter class provides a parent for all CSV writers
    /**
        Any inherited class must provide concrete implementations for the following abstract method, where the real physical write action must be implemented.

        @code{.py} private writeRawLine(list values) @endcode

        @section csvwriter_options AbstractCsvWriter Constructor Option Hash Overview
        The AbstractCsvWriter class constructor takes an optional hash with possible keys given in the following table.
        Note that key names are case-sensitive, and data types are soft (conversions are made when possible).

        <b>AbstractCsvWriter Options</b>
        |!Option|!Data Type|!Description
        |\c "block"|@ref int|the block size when generating output based on a @ref Qore::SQL::SQLStatement "SQLStatement" source (default: \c 1000)
        |\c "datamap"|@ref hash|a hash mapping actual data key names to the output field names, for use in case the data field names differ; does not have to include every data or output key; keys not present will be assumed to be mapped 1:1
        |\c "date_format"|@ref string|the default mask for date values formatting
        |\c "encoding"|@ref string|the @ref character_encoding "character encoding" for the file (and for tagging string data read); if the value of this key is not a string then it will be ignored
        |\c "eol"|@ref string|the end of line character(s) (default: auto-detect); if the value of this key is not a string then it will be ignored
        |\c "fields"|@ref hash|describes the data to be output; see @ref abstractcsviterator_option_field_hash "option field hash" and @ref abstractcsviterator_option_field_types "option field types" for more information on the possible values of this option; if no field type is given, the default is \c "*string"
        |\c "headers"|@ref list of strings|list of header / column names for the data iterated.
        |\c "headers"|@ref hash of lists of strings|Defines multi-type lines where key is name of type whose name is resolved by \c "resolve-type" custom function. Hash value is equal to \c "headers" as documented above.
        |\c "resolve_type"|@ref softstring sub(@ref hash values)|implement a custom function as closure to inspect record value and return type name. "Values" keys are field names or field index. If function returns id not existing in \c "headers" then record is skipped
        |\c "info_log"|@ref code|a call reference / closure for informational logging when performing bulk generation with write(Qore::SQL::SQLStatement); must take a single string argument
        |\c "optimal_quotes"|@ref boolean|set to @ref Qore::False "False" to disable optimal quoting; when optimal quoting is disabled, all fields are quoted regardless of type or content, when it is enabled, then fields are quoted only if they require quoting (i.e. they contain a quote or separator character); the default is @ref Qore::True "True"
        |\c "quote"|@ref string|the field quote character (default: \c '\"')
        |\c "quote_escape"|@ref string|the escape character(s) used for \c "quote" (default: \c '\\')
        |\c "separator"|@ref string|the string separating the fields in the file (default: \c ",")
        |\c "verify_columns"|@ref boolean|if @ref Qore::True "True" (the default is @ref Qore::False "False") then if a line is parsed with a different column count than other lines, a \c CSVFILEWRITER-DATA-ERROR exception is thrown
        |\c "write_headers"|@ref boolean|set to @ref Qore::False "False" to suppress the output of headers; the default is @ref Qore::True "True", meaning to output headers if they are present. The value is @ref Qore::False "False" for multi-type lines.

        @note the following options with dashes in their names are supported for backwards-compatibility:
        - \c "date-format"
        - \c "optimal-quotes"
        - \c "verify-columns"
        - \c "write-headers"
     */
    public class AbstractCsvWriter inherits private CsvHelper {
        private {
            #! valid options for the object (a hash for quick lookups of valid keys)
            const Options = (
                "block": True,
                "datamap": True,
                "date_format": True,
                "date-format": True,
                "encoding": True,
                "eol": True,
                "fields": True,
                "headers": True,
                "info_log": True,
                "optimal_quotes": True,
                "optimal-quotes": True,
                "quote": True,
                "quote_escape": True,
                "resolve_type": True,
                "separator": True,
                "verify_columns": True,
                "verify-columns": True,
                "write_headers": True,
                "write-headers": True,
                );

            #! output file character encoding
            string encoding;

            #! field separator
            string separator = ",";

            #! field content delimiter
            string quote = "\"";

            #! quote escape character
            string m_quoteEscapeChar = "\\";

            #! end of line sequence
            string eol = EOL_UNIX;

            #! default date->string format
            string date_format = 'DD/MM/YYYY hh:mm:SS';

            #! verify the column count for every row; if a row does not match, then throw a \c CSVFILEITERATOR-DATA-ERROR exception
            bool checkElementCounts = False;

            #! the latest line number
            int lineNo = 0;

            #! block size for bulk DML
            int block = 1000;

            #! base template for value format
            string baseTemplate;

            #! the exeption \c "err" string
            string errname;

            # this flag determines if any stored headers are output
            bool write_headers = True;

            # stores the optimal quotes option
            bool optimal_quotes = True;

            # a hash mapping from output keys to data keys
            *hash datamap;

            # a closure/call reference for informational logging when using write(SQLStatement)
            *code info_log;
        }

        #! creates the AbstractCsvWriter
        /**
            @param n_errname a string to construct child class error message. For example: value 'FOO' will result in exception names 'CSVFOOWRITER-ERROR'
            @param n_opts @ref csvwriter_options

            @throw CSV<errname>ITER-ERROR in the case of incorrect options
         */
        constructor(string n_errname, *hash n_opts) {
            errname = sprintf("CSV%sWRITER-ERROR", n_errname);

            encoding = n_opts.encoding.typeCode() == NT_STRING ? n_opts.encoding : get_default_encoding();

            # set headers automatically from field names if not set
            if (n_opts.fields && !n_opts.headers)
                n_opts.headers = n_opts.fields.keys();

            # TODO/FIXME: shared with CsvFileIterator?
            foreach hash i in (n_opts.pairIterator()) {
                if (!exists Options.(i.key))
                    throw errname, sprintf("unknown option %y passed to %s::constructor() (valid options: %y)", i.key, self.className(), Options.keys());

                # if the option is not set, then ignore it
                if (!exists i.value || i.value === NULL)
                    continue;

                switch (i.key) {
                    case "block": {
                        if (!i.value.intp())
                            throw errname, sprintf("expecting an integer value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        block = i.value.toInt();
                        if (block < 1)
                            throw errname, sprintf("expecting a positive integer value to option %y; got %y instead", i.key, i.value);
                        break;
                    }
                    case "separator": {
                        if (i.value.typeCode() != NT_STRING)
                            throw errname, sprintf("expecting a string value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        separator = i.value;
                        break;
                    }
                    case "quote": {
                        if (i.value.typeCode() != NT_STRING)
                            throw errname, sprintf("expecting a string value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        quote = i.value;
                        break;
                    }
                    case "quote_escape": {
                        if (i.value.typeCode() != NT_STRING) {
                            throw errname, sprintf("expecting a string value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        }
                        m_quoteEscapeChar = i.value;
                        break;
                    }
                    case "eol": {
                        if (i.value.typeCode() != NT_STRING)
                            throw errname, sprintf("expecting a string value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        if (!inlist(i.value, EOLS))
                            throw errname, sprintf("expecting a known end of line value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        eol = i.value;
                        break;
                    }
                    case "date_format":
                    case "date-format": {
                        if (i.value.typeCode() != NT_STRING)
                            throw errname, sprintf("expecting a string value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        date_format = i.value;
                        break;
                    }
                    case "verify_columns":
                    case "verify-columns": {
                        checkElementCounts = parse_boolean(i.value);
                        break;
                    }
                    case "headers": {
                        assignHeaders(i.value);
                        break;
                    }
                    case "write_headers":
                    case "write-headers": {
                        write_headers = parse_boolean(i.value);
                        break;
                    }
                    case "optimal_quotes":
                    case "optimal-quotes": {
                        optimal_quotes = parse_boolean(i.value);
                        break;
                    }
                    case "info_log": {
                        if (!i.value.callp())
                            throw errname, sprintf("expecting a callable value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        info_log = i.value;
                        break;
                    }
                    case "datamap": {
                        if (i.value.typeCode() != NT_HASH)
                            throw errname, sprintf("expecting a hash value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        # ensure that all the values are strings
                        foreach hash h in (i.value.pairIterator()) {
                            if (h.value.typeCode() != NT_STRING)
                                throw errname, sprintf("\"datamap\" key %y has a non-string value; got type %y", h.key, h.value.type());
                        }

                        # reverse the mapping since we need output keys to input keys for later processing
                        datamap = map {$1.value: $1.key}, i.value.pairIterator();
                        break;
                    }
                    case "fields": {
                        if (i.value.typeCode() != NT_HASH)
                            throw errname, sprintf("expecting a hash value to option %y; got %y (type %s) instead", i.key, i.value, i.value.type());
                        # iterate hash to process field descriptions
                        foreach hash hi in (i.value.pairIterator()) {
                            switch (hi.value.typeCode()) {
                                case NT_STRING: {
                                    checkType(hi.key, hi.value);
                                    fields.(hi.key) = ("type": hi.value);
                                    break;
                                }
                                case NT_HASH: {
                                    if (hi.value.empty())
                                        throw errname, sprintf("while processing the hash value for option key \"fields\": empty hash passed as description for field %y", hi.key);
                                    hash h;
                                    foreach hash fh in (hi.value.pairIterator()) {
                                        switch (fh.key) {
                                            case "type": {
                                                checkType(hi.key, fh.value);
                                                h.type = fh.value;
                                                break;
                                            }
                                            case "format": {
                                                if (fh.value.typeCode() != NT_STRING)
                                                    throw errname, sprintf("while processing the hash value for option key \"fields\": field %y \"format\" attributes expects a string value; got %y instead", hi.key, fh.value.type());
                                                h.format = fh.value;
                                                break;
                                            }
                                            case "timezone": {
                                                h.timezone = new TimeZone(fh.value);
                                                break;
                                            }
                                            case "code": {
                                                if (!fh.value.callp())
                                                    throw errname, sprintf("while processing the hash value for option key \"fields\": field %y \"code\" attributes expects a callable value to process the field value; got %y instead", hi.key, fh.value.type());
                                                h.code = fh.value;
                                                break;
                                            }
                                            default: {
                                                throw errname, sprintf("while processing the hash value for option key \"fields\": unknown field attribute value %y given for field %y (supported attribute values: %y)", fh.key, hi.key, FieldAttrs);

                                            }
                                        }
                                    }
                                    if (!h.type)
                                        h.type = "*string";
                                    if (h.type != "date" && h.type != "*date") {
                                        foreach string f in ("timezone", "format") {
                                            if (h{f})
                                                throw errname, sprintf("while processing the hash value for option key \"fields\": field %y is type %y, but the %y attribute was also given, which is only valid for \"date\" fields", hi.key, h.type, f);
                                        }
                                    }
                                    fields.(hi.key) = h;
                                    break;
                                }
                                default: {
                                    throw errname, sprintf("while processing the hash value for option key \"fields\": invalid value passed as the field description for field %y; expecting \"string\" or \"hash\"; got %y instead", i.key, hi.value.type());
                                }
                            }
                        }

                        break;
                    }
                    case "resolve_type": {
                        if (i.value.typeCode() != NT_CLOSURE) {
                            throw errname, sprintf("\"resolve_type\" option is not closure; got %y instead", i.value.type());
                        }
                        resolveType = i.value;
                        break;
                    }
                }

            }
            if (write_headers && isMultiType()) {
                throw errname, sprintf("\"write_headers\" is True but \"headers\" defined as multi-type (%y)", hfDefs);
            }
            if (hfDefs && fields)
                setFields();

            # make eg. '"%s",' template
            baseTemplate = sprintf("%s%%s%s%s", quote, quote, separator);
        }

        #! write a line with a list of values. Data are checked against column rules.
        /**
            @param values a list with values

            @throw CSVFILEWRITER-DATA-ERROR when the data does not fit defined column constraints
         */
        writeLine(list values) {
            if (!setHFDef(values) && isMultiType())
                return;

            lineNo++;
            if (checkElementCounts && values.size() != curHFDef.headers.size())
                throw errname, sprintf("Line (%d), Header size (%d) and line size (%d) are different (enforced by the \"verify_columns\" option)", lineNo, curHFDef.headers.size(), values.size());

            for(int i = 0; i < values.size(); i++) {

                if (checkElementCounts && curHFDef && exists curHFDef.fdesc[i] && exists values[i]) {

                    switch (curHFDef.fdesc[i].type) {
                        case "int": {
                            if (int(values[i]) != values[i])
                                throw errname, sprintf("Line (%d), Column (%d) does not contain an integer value %n vs %n", lineNo, i, int(values[i]), values[i]);
                            break;
                        }
                        case "*int": {
                            if (!values[i].empty() && int(values[i]) != values[i])
                                throw errname, sprintf("Line (%d), Column (%d) does not contain an integer value %n vs %n", lineNo, i, int(values[i]), values[i]);
                            break;
                        }
                        case "float": {
                            if (float(values[i]) != values[i])
                                throw errname, sprintf("Line (%d), Column (%d) does not contain a float value %n vs %n", lineNo, i, float(values[i]), values[i]);
                            break;
                        }
                        case "*float": {
                            if (!values[i].empty() && float(values[i]) != values[i])
                                throw errname, sprintf("Line (%d), Column (%d) does not contain a float value %n vs %n", lineNo, i, float(values[i]), values[i]);
                            break;
                        }
                        case "number": {
                            if (number(values[i]) != values[i])
                                throw errname, sprintf("Line (%d), Column (%d) does not contain a number value %n vs %n", lineNo, i, number(values[i]), values[i]);
                            break;
                        }
                        case "*number": {
                            if (!values[i].empty() && number(values[i]) != values[i])
                                throw errname, sprintf("Line (%d), Column (%d) does not contain a number value %n vs %n", lineNo, i, number(values[i]), values[i]);
                            break;
                        }
                        case "date": {
                            if (values[i].typeCode() != NT_DATE)
                                throw errname, sprintf("Line (%d), Column (%d) does not contain a date value (%s)", lineNo, i, values[i].type());
                            break;
                        }
                        case "*date": {
                            if (!values[i].empty() && values[i].typeCode() != NT_DATE)
                                throw errname, sprintf("Line (%d), Column (%d) does not contain a date value (%s)", lineNo, i, values[i].type());
                            break;
                        }
                    }
                }

                # format date as requested
                if (values[i].typeCode() == NT_DATE)
                    values[i] = format_date(dateFormat(i), values[i]);
            }

            writeRawLine(values);
        }

        #! write a line with headers-values hash
        /**
            @param values a hash with keys as column headers.

            @throw CSVFILEWRITER-DATA-ERROR when the data does not fit defined column constraints
         */
        writeLine(hash values) {
            list line;
            if (!setHFDef(values))
                return;
            if (!curHFDef.headers)
                throw errname, "No header set in AbstractCsvWriter instance to bind the hash key";

            foreach string i in (curHFDef.headers) {
                # if we have mappings, then use the actual input field name if present
                if (datamap)
                    i = datamap{i} ?? i;
                if (!values.hasKey(i))
                    throw errname, sprintf("Line data does not contain key %y", i);
                else
                    push line, values{i};
            }

            writeLine(line);
        }

        #! stream iterator into the file.
        /**
            @param iterator an iterator to stream data into file

            The iterator has to return @ref list or @ref hash from the @ref Qore::AbstractIterator::getValue() "getValue()" method.

            @throw CSVFILEWRITER-DATA-ERROR when the data does not fit defined column constraints or when @ref Qore::AbstractIterator::getValue() "getValue()" does not return list or hash
         */
        write(Qore::AbstractIterator iterator) {
            while (iterator.next()) {
                any row = iterator.getValue();
                switch (row.typeCode()) {
                    case NT_HASH:
                        writeLine(row);
                        break;
                    case NT_LIST:
                        writeLine(row);
                        break;
                    default:
                        throw errname, sprintf("Iterator's getValue returned %s, expected list or hash", row.type());
                }
            }
        }

        #! stream iterator into the file.
        /**
            @param iterator an @ref Qore::SQL::SQLStatement "SQLStatement" iterator to stream data into file; @ref Qore::SQL::SQLStatement::fetchColumns() "SQLStatement::fetchColumns()" is used to leverage bulk DML for more efficient SQL I/O

            @throw CSVFILEWRITER-DATA-ERROR when the data does not fit defined column constraints

            @note if any \c "info_log" option is set in the constructor; it is used here to log each block of SQL data used to generate the corresponding number of lines; log messages look like: \c "query input generated bulk output lines: 1000"
         */
        write(Qore::SQL::SQLStatement iterator) {
            while (*hash h = iterator.fetchColumns(block)) {
                int n = h.firstValue().lsize();
                if (!n)
                    break;
                map writeLine($1), h.contextIterator();
                if (info_log)
                    info_log(sprintf("query input generated bulk output lines: %d", n));
            }
        }

        #! stream the contents of the list into the output
        /**
            @param l a list of input data to format as CSV output

            The list has to contain @ref list or @ref hash elements that can be formatted according to the CSV definition

            @throw CSVFILEWRITER-DATA-ERROR when the data does not fit defined column constraints or when the list elements have the wrong type or values
         */
        write(list l) {
            write(l.iterator());
        }

        #! real write implementation. Without any checking.
        abstract private writeRawLine(list values);

        #! Prepare a string (line with EOF) with formatting and escaping.
        /**
            @param values a list with values
            @return string a formatted and escaped line with EOF
        */
        private string prepareRawLine(list values) {
            if (!optimal_quotes) {
                # make full line template
                string template = strmul(baseTemplate, elements values, 1) + eol;
                # escape separators in strings
                list row = map replace(string($1), quote, m_quoteEscapeChar + quote), values;

                return vsprintf(template, row);
            }

            list l = ();
            foreach any v in (values) {
                if (v.typeCode() == NT_STRING) {
                    if (v.find(quote) >= 0) {
                        v = replace(v, quote, m_quoteEscapeChar + quote);
                        v = sprintf("\"%s\"", v);
                    }
                    else if (v.find(separator) >= 0)
                        v = sprintf("\"%s\"", v);
                    l += v;
                    continue;
                }
                l += string(v);
            }
            return (foldl $1 + separator + $2, l) + eol;
        }

        #! format date to string by options. Priority: 1) column definition 2) standard format
        private string dateFormat(int ix) {
            if (curHFDef && exists curHFDef.fdesc[ix] && (curHFDef.fdesc[ix].type == "date" || curHFDef.fdesc[ix].type == "*date") && exists curHFDef.fdesc[ix].format)
                return curHFDef.fdesc[ix].format;

            return date_format;
        }

    } # AbstractCsvWriter class

    #! the CsvFileWriter class for easy and safe CSV file creation
    public class CsvFileWriter inherits AbstractCsvWriter {

        private {
            # a file to write
            File file;
        }

        #! creates the CsvFileWriter with the path of the file to read with an options
        /**
        @param path a file name (with path optionally) to write
        @param opts @ref csvwriter_options

        The file is created with O_CREAT, O_TRUNC, O_WRONLY and 0644 access.

        @throw CSVFILEITER-ERROR in the case of incorrect options
        */
        constructor(string path, *hash opts) : AbstractCsvWriter("FILE", opts) {
            file = new File(encoding);
            file.open2(path, O_CREAT | O_TRUNC | O_WRONLY, 0644);

            if (hasHeaders() && write_headers)
                writeRawLine(hfDefs.firstValue().headers);  # multi-line impossible
        }

        private writeRawLine(list values) {
            file.print(prepareRawLine(values));
        }

    } # CsvFileWriter

    #! the CsvStringWriter class for in-memory string CSV creation
    public class CsvStringWriter inherits AbstractCsvWriter {

        private {
            # a csv content
            string content;
        }

        #! creates the CsvStringWriter with content in the memory
        /**
        @param opts @ref csvwriter_options

        @throw CSVSTRINGITER-ERROR in the case of incorrect options
        */
        constructor(*hash opts) : AbstractCsvWriter("STRING", opts) {
            if (hasHeaders() && write_headers)
                writeRawLine(hfDefs.firstValue().headers);  # multi-line impossible
        }

        private writeRawLine(list values) {
            content += prepareRawLine(values);
        }

        #! stream iterator and return CSV-formatted output string
        /**
            @param iterator an iterator to stream data

            @return the CSV-formatted output string corresponding to the input data

            The iterator has to contain @ref list or @ref hash as a return value of \c getValue() method.

            @throw CSVFILEWRITER-DATA-ERROR when the data does not fit defined column constraints or when \c getValue does not return list or hash
         */
        string write(Qore::AbstractIterator iterator) {
            AbstractCsvWriter::write(iterator);
            return content;
        }

        #! stream the contents of the list and return CSV-formatted output as a string
        /**
            @param l a list of input data to format as CSV output

            @return the CSV-formatted output string corresponding to the input data

            The list has to contain @ref list or @ref hash elements that can be formatted according to the CSV definition

            @throw CSVFILEWRITER-DATA-ERROR when the data does not fit defined column constraints or when the list elements have the wrong type or values
         */
        string write(list l) {
            AbstractCsvWriter::write(l);
            return content;
        }

        #! Get the current in-memory content as a string
        string getContent() {
            return content;
        }

    } # CsvStringWriter

} # CsvUtil namespace
