# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file FtpPoller.qm Qore user module providing FTP polling functionality

/*  FtpPoller.qm Copyright 2019 - 2024 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%new-style
%strict-args
%require-types
%enable-all-warnings
%allow-weak-references

# make sure we have the required qore version
%requires qore >= 2.0

%requires(reexport) FtpPollerUtil
%requires(reexport) DataProvider

module FtpPoller {
    version = "2.1";
    desc = "user module providing FTP polling functionality";
    author = "Alzhan Turlybekov <alzhan.turlybekov@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
    init = sub () {
        # register the data provider factory
        DataProvider::registerFactory(new FtpPollerDataProviderFactory());

        # register the data provider application
        # NOTE: this application is also registed in the FtpPoller module
        DataProviderActionCatalog::registerApp(<DataProviderAppInfo>{
            "name": FtpPoller::AppName,
            "display_name": "FTP Server",
            "short_desc": "Generic FTP server for exchanging files with FTP and FTPS",
            "desc": "Generic FTP server for exchanging files with FTP and FTPS",
            "scheme": "ftp",
            "logo": FtpWhiteLogo,
            "logo_file_name": "generic-ftp-logo.svg",
            "logo_mime_type": MimeTypeSvg,
        });

        # register all supported actions
        DataProviderActionCatalog::registerAction(<DataProviderActionInfo>{
            "app": FtpPoller::AppName,
            "path": "/",
            "action": "ftp-file-event",
            "display_name": "FTP File Received",
            "subtype": "ftppoller",
            "short_desc": "A file is uploaded to an FTP server",
            "desc": "React to files uploaded to an FTP server",
            "action_code": DPAT_EVENT,
            "action_val": EVENT_FTP_FILE,
            "output_type": FtpPollerFileEventInfoDataType,
            "convenience_options": DataProviderActionCatalog::getActionOptionFromFields(
                FtpPollerDataProviderBase::ConstructorOptions{"mask",} - ("url", "username", "password"), {
                    "preselected": True,
                    "required": True,
                },
            ),
            "advanced_options": DataProviderActionCatalog::getActionOptionFromFields(
                FtpPollerDataProviderBase::ConstructorOptions - ("mask", "url", "username", "password")
            ),
        });
    };
}

/** @mainpage FtpPoller Module

    @section ftppollerintro Introduction to the FtpPoller Module

    Available classes:
    - @ref FtpPoller::FtpDelayedPollerDataProvider "FtpDelayedPollerDataProvider"
    - @ref FtpPoller::FtpPoller "FtpPoller"
    - @ref FtpPoller::FtpPollerDataProvider "FtpPollerDataProvider"
    - @ref FtpPoller::FtpPollerDataProviderBase "FtpPollerDataProviderBase"
    - @ref FtpPoller::FtpPollerDataProviderFactory "FtpPollerDataProviderFactory"

    The FtpPoller module implements FTP file polling event data provider classes as well as an abstract class that
    will poll a remote directory with the FTP protocol and return matching files.

    To use the @ref FtpPoller::FtpPoller "FtpPoller" class, subclass it and implement the
    @ref FtpPoller::FtpPoller::singleFileEvent() and @ref FtpPoller::FtpPoller::postSingleFileEvent() methods.

    The data provider classes can be used with the data provider infrastructure, and each of these classes uses the
    @ref FtpPoller::FtpPoller "FtpPoller" class to perform the actual FTP file polling.

    @section ftppollerexamples FtpPoller Module Examples

    The following simple example will poll for files and then print out information for the files polled (as well as
    all info, detail, and debug messages) and exit immediately:
    @code
%requires FtpPoller

class MyFtpPoller inherits FtpPoller {
    constructor(FtpClient ftp_client, hash<auto> opts) : FtpPoller(ftp_client, opts) {
    }

    singleFileEvent(hash<FtpPollerFileEventInfo> file_info) {
        printf("GOT FILE: %y\n", file_info);
        # in this case, the polling stop operation will take effect after all the singleFileEvent() calls are made for
        # the polling operation
        stopNoWait();
    }

    postSingleFileEvent(hash<FtpPollerFileEventInfo> file_info) {
    }
}

code info = sub (string msg) { printf("INFO: %s\n", msg); };
code detail = sub (string msg) { printf("DETAIL: %s\n", msg); };
code debug = sub (string msg) { printf("DEBUG: %s\n", msg); };

hash<auto> opts = {
    "path": "/tmp"
    "log_info": info,
    "log_detail": detail,
    "log_debug": debug,
};

FtpClient ftp_client("ftp://user@pass:localhost");
FtpPoller poller(ftp_client, opts);
poller.waitStop();
    @endcode

    Note that @ref FtpPoller::FtpPoller::stopNoWait() "FtpPoller::stopNoWait()" was called in the event thread because
    calling @ref FtpPoller::FtpPoller::stop() "FtpPoller::stop()" in the event thread would cause an exception to be
    thrown.

    A useful poller class would implement the
    @ref FtpPoller::FtpPoller::singleFileEvent() "FtpPoller::singleFileEvent()" method which process already-
    transferred files and the @ref FtpPoller::FtpPoller::postSingleFileEvent() "FtpPoller::postSingleFileEvent()" by
    deleting / moving / renaming the files so that they would not be acquired on the next poll.

    @section ftpollersandbox FtpPoller Module in Sandboxed Programs

    The @ref FtpPoller::FtpPoller "FtpPoller" class includes support for running in sandboxed Program objects with the
    following parse options set:
    - \c PO_NO_THREAD_CONTROL: in this case the \c "start_thread" option is required in
      @ref FtpPoller::FtpPoller::constructor() "FtpPoller::constructor()"
    - \c PO_NO_PROCESS_CONTROL: in this case the \c "sleep" option is required in
      @ref FtpPoller::FtpPoller::constructor() "FtpPoller::constructor()"

    @section ftppollerrelnotes FtpPoller Module Release Notes

    @section ftppollerv2_1 Version 2.1
    - added support for the data provider action catalog API
      (<a href="https://github.com/qorelanguage/qore/issues/4808">issue 4808</a>)

    @section ftppollerv2_0 Version 2.0
    - added support for the event-based DataProvider API
      (<a href="https://github.com/qorelanguage/qore/issues/4557">issue 4557</a>)

    @section ftppollerv1_0 Version 1.0
    - initial release
*/

#! main FtpPoller namespace
public namespace FtpPoller {
#! Generic FTP server app name
public const AppName = "FTP";

#! FTP file event constant
public const EVENT_FTP_FILE = "ftp-file-event";

#! FtpPoller client class implementation
public class FtpPoller {
    public {
        #! ascending sort order
        const OrderAsc = 0;
        #! descending sort order
        const OrderDesc = 1;

        #! no sorting
        const SortNone = 0;
        #! sort by name
        const SortName = 1;
        const SortDate = 2;

        #! minimum required keys for all constructors
        const RequiredKeys = (
%ifdef PO_NO_PROCESS_CONTROL
            "sleep",
%endif
%ifdef PO_NO_THREAD_CONTROL
            "start_thread",
%endif
        );

        #! RequiredKeys for the constructor(hash) without an @ref Qore::FtpClient argument
        const RequiredKeysWithHost = RequiredKeys + "host";

        #! default values for constructor hash argument
        const Defaults = {
            "protocol": "ftp",
            "port": 21,
            "mask": "*",
            "poll_interval": 10,
            "reopts": 0,
            "tempfile_template": ".tmp.%s.part",
            "atomic_transfer": False,
        };

        #! optional constructor hash keys
        const OptionalKeys = (
            "path", "user", "pass", "regex_mask", "minage",
            "log_info", "log_detail", "log_debug", "local_dir",
%ifndef PO_NO_PROCESS_CONTROL
            "sleep",
%endif
%ifndef PO_NO_THREAD_CONTROL
            "start_thread",
%endif
        );

        #! all keys
        const AllKeys = RequiredKeysWithHost + keys Defaults + OptionalKeys;

        #! pause when Ftp errors are detected
        const ErrorDelay = 1m;
    }

    private {
        #! Protocol ("ftp" or "ftps")
        string protocol;

        #! host or address name
        string host;

        #! port
        int port;

        #! user
        string user;

        #! url
        string url;

        #! url hash
        hash<UrlInfo> urlh;

        #! password
        *string pass;

        #! path(s) to poll
        softlist<string> path = ".";

        #! path after connecting to Ftp server
        string rootFtpPath;

        #! file glob name mask (ignored if \c "regex_mask" also set)
        *string mask;

        #! poll interval in seconds
        int poll_interval;

        #! Local directory to transfer file
        string local_dir;

        #! The temporary filename template when \c local_dir is set
        string tempfile_template;

        #! Atomic transfer flag for use with \c local_dir
        bool atomic_transfer;

        #! run flag
        bool runflag = False;

        #! internal "get files" flag
        bool get_files;

        #! internal fatal error flag
        bool fatal = False;

        #! internal poll counter
        int pollcnt = 0;

        #! start mutex
        Mutex m();

        #! polling tid
        int tid;

        #! timeout in ms
        timeout timeout;

        #! stop counter
        Counter sc();

        #! FtpClient object
        Qore::FtpClient ftp;

        #! file matching regex options
        int reopts = 0;

        #! minimum file age
        *softint minage;

        #! optional info log closure
        *code log_info;

        #! optional detail log closure
        *code log_detail;

        #! optional debug log closure
        *code log_debug;

        #! optional start thread closure
        *code start_thread;

        #! optional sleep closure
        *code sleep;
    }

    #! creates the FtpPoller object from the @ref Qore::FtpClient "FtpClient" argument and configuration hash argument passed
    /** @param n_ftp the new @ref Qore::FtpClient "FtpClient" object
        @param nconf a hash with the following optional keys:
        - \c atomic_transfer: if @ref True and \c local_dir is set, then \c tempfile_template is used to write FTP
          files to a temporary filename during transfer
        - \c local_dir: a local directory to use to transfer remote files so large file data does not appear in events
        - \c log_debug: a @ref closure "closure" or @ref call_reference "call reference" for logging verbose
          debgugging information; must accept a single string giving the log message
        - \c log_detail: a @ref closure "closure" or @ref call_reference "call reference" for logging detailed
          information; must accept a single string giving the log message
        - \c log_info: a @ref closure "closure" or @ref call_reference "call reference" for logging important
          information; must accept a single string giving the log message
        - \c mask: the file glob mask to use (default: \c "*", ignored if \c "regex_mask" is also present)
        - \c minage: the minimum file age in seconds before a file will be acquired (default: 0)
        - \c path: the remote path(s) for retrieving the files; if a list of strings is given then each path will be
          polled for matching files according to the \c "mask" or \c "regex_mask" option
        - \c poll_interval: the integer polling interval in seconds (default: 10 seconds; must be > 0 if given)
        - \c regex_mask: a regular expression to use as a mask (overrides any \c "mask" value)
        - \c reopts: regular expression match options (ex RE_Caseless for case-insensitive matches)
        - \c sleep: (required when imported into a context where @ref Qore::PO_NO_PROCESS_CONTROL is set) a
          @ref closure "closure" or @ref call_reference "call reference" to use instead of @ref Qore::sleep() (if not
          set then @ref Qore::sleep() will be used)
        - \c start_thread: (required when imported into a context where @ref Qore::PO_NO_THREAD_CONTROL is set) a
          @ref closure "closure" or @ref call_reference "call reference" for starting threads; must return the integer
          thread ID (if not set then @ref background will be used)
        - \c tempfile_template: (used when \c local_dir and \c atomic_transfer are set) the temporary filename prefix
          to use when transferring files to the local directory specified by \c local_dir; use \c "%s" as the
          placeholder for the target filename

        @throw FTPPOLLER-CONSTRUCTOR-ERROR missing required key, invalid port or poll_interval given
        @throw FTPCLIENT-PARAMETER-ERROR empty hostname passed
        @throw SOCKET-CONNECT-ERROR error establishing socket connection (no listener, port blocked, etc); timeout
        establishing socket connection
        @throw SSH2CLIENT-CONNECT-ERROR no user name set; ssh2 or libssh2 error
        @throw SSH2-ERROR error initializing or establishing ssh2 session
        @throw SSH2CLIENT-AUTH-ERROR no proper authentication method found
        @throw FTPCLIENT-CONNECT-ERROR error initializing ftp session or getting remote path
    */
    constructor(Qore::FtpClient n_ftp, hash<auto> nconf) {
        # create hash of keys with only valid options in argument hash
        hash<auto> conf += Defaults + nconf{AllKeys};

        foreach string k in (RequiredKeys) {
            if (!exists conf{k}) {
                throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("required key %y missing from constructor hash argument)",
                    k);
            }
        }

        if (exists conf.local_dir && (!is_dir(conf.local_dir) || !is_writable(conf.local_dir))) {
            throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("invalid local directory %y; directory does not exist or "
                "cannot be written to", conf.local_dir);
        }

        conf.poll_interval = int(conf.poll_interval);

        if (conf.poll_interval <= 0) {
            throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("poll_interval cannot be <= 0 (val: %d)", conf.poll_interval);
        }

        bool re = False;
        if (conf.regex_mask) {
            mask = remove conf.regex_mask;
            re = True;
            conf -= "mask";
        }

        # set options
        self += conf;

        # set regex for mask if regex_mask was not already used
        if (!re) {
            setMask();
        }

        # assign FtpClient object
        ftp = n_ftp;
        rootFtpPath = ftp.pwd();

        {
            *string str = ftp.getUserName();
            if (str) {
                user = str;
            }
            str = ftp.getPassword();
            if (str) {
                pass = str;
            }
        }

        port = ftp.getPort();

        url = sprintf("%s://%s@%s:%d", protocol, user ?? "<none>", ftp.getHostName(), port);

        urlh = parse_url(ftp.getURL());

        if (mask) {
            logDetail("%s: file regex mask: %s", url, mask);
        }

        logInfo("%s: root path: %y", url, rootFtpPath);

        logInfo("%s: polling path is %y", url, path);
        if (path && path.size() == 1 && !path[0].empty() && path[0] != ".") {
            logInfo("%s: changing directory to %y", url, path[0]);
            # change to the target directory
            ftp.cwd(path[0]);
        }
    }

    #! creates the FtpPoller object from the configuration hash argument passed
    /** @param nconf a hash with the following keys:
        - \c atomic_transfer: if @ref True and \c local_dir is set, then \c tempfile_template is used to write FTP
          files to a temporary filename during transfer
        - \c host: (required) the hostname or address to connect to
        - \c local_dir: a local directory to use to transfer remote files so large file data does not appear in events
        - \c log_debug: a @ref closure "closure" or @ref call_reference "call reference" for logging verbose
          debgugging information; must accept a single string giving the log message
        - \c log_detail: a @ref closure "closure" or @ref call_reference "call reference" for logging detailed
          information; must accept a single string giving the log message
        - \c log_info: a @ref closure "closure" or @ref call_reference "call reference" for logging important
          information; must accept a single string giving the log message
        - \c mask: the file glob mask to use (default: \c "*", ignored if \c "regex_mask" is also present)
        - \c minage: the minimum file age in seconds before a file will be acquired (default: 0)
        - \c pass: the password to use for the connection
        - \c path: the remote path(s) for retrieving the files
        - \c poll_interval: the integer polling interval in seconds (default: 10 seconds; must be > 0 if given)
        - \c port: the integer port number to connect to (default 21; must be > 0 if given)
        - \c protocol: either \c "ftp" (the detault) or \c "ftps" for secure FTP
        - \c regex_mask: a regular expression to use as a mask (overrides any \c "mask" value)
        - \c reopts: regular expression match options (ex RE_Caseless for case-insensitive matches)
        - \c start_thread: (required when imported into a context where @ref Qore::PO_NO_THREAD_CONTROL is set) a
          @ref closure "closure" or @ref call_reference "call reference" for starting threads; must return the integer
          thread ID (if not set then @ref background will be used)
        - \c sleep: (required when imported into a context where @ref Qore::PO_NO_PROCESS_CONTROL is set) a
          @ref closure "closure" or @ref call_reference "call reference" to use instead of @ref Qore::sleep() (if not
          set then @ref Qore::sleep() will be used)
        - \c tempfile_template: (used when \c local_dir and \c atomic_transfer are set) the temporary filename prefix
          to use when transferring files to the local directory specified by \c local_dir; use \c "%s" as the
          placeholder for the target filename
        - \c user: the username to use for the connection

        @throw FTPPOLLER-CONSTRUCTOR-ERROR missing required key, invalid port, poll_interval, or protocol given
        @throw FTPCLIENT-PARAMETER-ERROR empty hostname passed
        @throw SOCKET-CONNECT-ERROR error establishing socket connection (no listener, port blocked, etc)
        @throw SSH2CLIENT-CONNECT-ERROR no user name set; ssh2 or libssh2 error
        @throw SSH2-ERROR error initializing or establishing ssh2 session
        @throw SSH2CLIENT-AUTH-ERROR no proper authentication method found
        @throw FTPCLIENT-CONNECT-ERROR error initializing ftp session or getting remote path
    */
    constructor(hash<auto> nconf) {
        # create hash of keys with only valid options in argument hash
        hash<auto> conf += Defaults + nconf{AllKeys};

        foreach string k in (RequiredKeysWithHost) {
            if (!exists conf{k}) {
                throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("required key %y missing from constructor hash "
                    "argument)", k);
            }
        }

        if (conf.protocol != "ftp" && conf.protocol != "ftps") {
            throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("invalid URL scheme %y; expecting \"ftp\" or \"ftps\"",
                conf.protocol);
        }

        if (exists conf.local_dir && (!is_dir(conf.local_dir) || !is_writable(conf.local_dir))) {
            throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("invalid local directory %y; directory does not exist or "
                "cannot be written to", conf.local_dir);
        }

        conf.poll_interval = int(conf.poll_interval);
        conf.port = int(conf.port);

        if (conf.poll_interval <= 0) {
            throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("poll_interval cannot be <= 0 (val: %d)",
                conf.poll_interval);
        }
        if (conf.port <= 0) {
            throw "FTPPOLLER-CONSTRUCTOR-ERROR", sprintf("port cannot be <= 0 (val: %d)", conf.port);
        }

        bool re = False;
        if (conf.regex_mask) {
            mask = remove conf.regex_mask;
            re = True;
            conf -= "mask";
        }

        # set options
        self += conf;

        # set regex for mask if regex_mask was not already used
        if (!re) {
            setMask();
        }

        # create FtpClient object
        ftp = new FtpClient(sprintf("%s://%s:%d", protocol, host, port));
        if (user) {
            ftp.setUserName(user);
        }
        if (pass) {
            ftp.setPassword(pass);
        }

        url = sprintf("%s://%s@%s:%d", protocol, user ? user : "<none>", host, port);

        if (mask) {
            logDetail("%s: file regex mask: %s", url, mask);
        }

        logDetail("%s: logging in", url);
        # connect to the remote system
        ftp.connect();
        rootFtpPath = ftp.pwd();

        logInfo("%s: root path: %y", url, rootFtpPath);

        logInfo("%s: polling path is %y", url, path);
        if (path && path.size() == 1 && !path[0].empty() && path[0] != ".") {
            logInfo("%s: changing directory to %y", url, path[0]);
            # change to the target directory
            ftp.cwd(path[0]);
        } else {
            logInfo("%s: connected", url);
        }
    }

    #! stops the polling operation if in progress and destroys the object
    destructor() {
        stop();
    }

    #! returns the current poll count
    int getPollCount() {
        return pollcnt;
    }

    #! calls the \c "log_info" @ref closure "closure" or @ref call_reference "call reference" with important information
    private logInfo(string fmt, ...) {
        if (log_info) {
            call_function(log_info, vsprintf(fmt, argv));
        }
    }

    #! calls the \c "log_detail" @ref closure "closure" or @ref call_reference "call reference" with detail information
    private logDetail(string fmt, ...) {
        if (log_detail) {
            call_function(log_detail, vsprintf(fmt, argv));
        }
    }

    #! calls the \c "log_debug" @ref closure "closure" or @ref call_reference "call reference" with verbose debugging information
    private logDebug(string fmt, ...) {
        if (log_debug) {
            call_function(log_debug, vsprintf(fmt, argv));
        }
    }

    #! converts a glob mask into a regex
    private setMask() {
        if (mask == "*") {
            delete mask;
            return;
        }

        # replace . -> \.
        mask =~ s/\./\\./g;
        # replace ? -> .
        mask =~ s/\?/./g;
        # replace * -> .*
        mask =~ s/\*/.*/g;
        mask = sprintf("^%s$", mask); #");
    }

    #! retrieves a remote file and stores it to a local path
    /** @param remote_path the remote file path
        @param local_path the local file path
    */
    getStoreFile(string remote_path, string local_path) {
        ftp.get(remote_path, local_path);
    }

    #! retrieves a text file and returns the file's contents
    string getTextFile(string path) {
        return ftp.getAsString(path);
    }

    #! retrieves a binary file and returns the file's contents
    binary getFile(string path) {
        return ftp.getAsBinary(path);
    }

    #! renames a file on the server
    rename(string old, string nnew) {
        ftp.rename(old, nnew);
    }

    #! deletes a file on the server
    removeFile(string fn) {
        ftp.del(fn);
    }

    #! returns a list of regular file hashes matching any file name mask set for the object
    /**
        @param subdir the directory to check
        @param sort the sort option for the list returned
        @param order the ordering of sorted data returned

        @return a list of regular file hashes with the following keys in each list element:
        - \c name: the name of the file, link, or directory
        - \c size: the size of the file in bytes
        - \c mtime: the last modified date/time of the file
    */
    list<hash<FtpPollerFileEventInfo>> getFiles(string subdir, int sort = FtpPoller::SortNone,
            int order = FtpPoller::OrderAsc) {
        if (subdir.val()) {
            ftp.cwd(subdir);
        }
        list<string> fl;
        {
            *string nlst = ftp.nlst();
            if (!exists nlst) {
                throw "FTP-ERROR", sprintf("no data returned from NLST command");
            }
            fl = nlst.split("\r\n");
        }

        # remove all files that don't fit the mask
        if (mask) {
            # apply regex filter to file list
            fl = map $1, fl, regex($1, mask, reopts);
        }

        # now get a list of info about file sizes and last modified timestamps
        list<hash<FtpPollerFileEventInfo>> l = ();
        foreach string fn in (fl) {
            hash<FtpResponseInfo> mh = ftp.sendControlMessage("MDTM", fn);
            # assume we have a directory if we get a 550 response to the MDTM command
            if (mh.code == 550) {
                continue;
            }
            if ((mh.code / 100) != 2) {
                throw "FTP-ERROR", sprintf("%s: MDTM failure; got from server: %d %y ", fn, mh.code, mh.msg);
            }
            date mtime = date(mh.msg);
            # check minimum age
            if (minage) {
                date now = Qore::now();
                if ((now - mtime).durationSeconds() < minage) {
                    logDebug("file %y is not old enough (minage: %d, current age: %d)", fn, minage,
                            (now - mtime).durationSeconds());
                    continue;
                }
            }

            mh = ftp.sendControlMessage("SIZE", fn);
            if ((mh.code / 100) != 2) {
                throw "FTP-ERROR", sprintf("SIZE %s failure; got from server: %d %y ", fn, mh.code, mh.msg);
            }
            int size = mh.msg.toInt();
            l += <FtpPollerFileEventInfo>{
                "name": fn,
                "size": size,
                "mtime": mtime,
            };
        }

        # return list of files
        switch (sort) {
            case FtpPoller::SortNone: {
                break;
            }

            # sort by file name
            case FtpPoller::SortName: {
                # sort closure
                code sorter = int sub (hash<FtpPollerFileEventInfo> lt, hash<FtpPollerFileEventInfo> rt) {
                    return lt.name <=> rt.name;
                };
                l = (order == FtpPoller::OrderAsc ? Qore::sort(l, sorter) : sort_descending(l, sorter));
                break;
            }

            case FtpPoller::SortDate: {
                # sort by last modification date
                code sorter = int sub (hash<FtpPollerFileEventInfo> l, hash<FtpPollerFileEventInfo> r) {
                    return l.mtime <=> r.mtime;
                };
                l = (order == FtpPoller::OrderAsc ? Qore::sort(l, sorter) : sort_descending(l, sorter));
                break;
            }

            # it *never* should get here
            default: throw "FTPPOLLER-GETFILES", sprintf("Unknown sort mode %y", sort);
        }

        logDetail("%s: polled %d matching file%s", url, l.size(), l.size() == 1 ? "" : "s");
        return l;
    }

    #! starts polling in the background; returns the thread ID of the polling thread
    /** if polling had already been started, then the thread ID of the polling thread is
        returned immediately
    */
    int start() {
        m.lock();
        on_exit m.unlock();

        if (runflag) {
            return tid;
        }

        sc.waitForZero();

        runflag = True;
        sc.inc();

%ifdef PO_NO_THREAD_CONTROL
        return call_function(start_thread, \run());
%else
        return start_thread ? call_function(start_thread, \run()) : background run();
%endif
    }

    #! stops the polling operation, returns immediately
    /** @see stop()
    */
    stopNoWait() {
        m.lock();
        on_exit m.unlock();

        runflag = False;
    }

    #! stops the polling operation, returns when the polling operation has been stopped
    /** if polling was not in progress then this method returns immediately

        @throw THREAD-ERROR this exception is thrown if this method is called from the event thread since it would
        result in a deadlock

        @see stopNoWait()
    */
    stop() {
        if (gettid() == tid && sc.getCount()) {
            throw "THREAD-ERROR", sprintf("cannot call FtpPoller::stop() from the event thread (%d)", tid);
        }
        m.lock();
        on_exit m.unlock();

        runflag = False;

        sc.waitForZero();
    }

    #! waits indefinitely for the polling operation to stop
    /** If polling was not in progress then this method returns immediately

        @throw THREAD-ERROR this exception is thrown if this method is called from the event thread since it would
        result in a deadlock
    */
    waitStop() {
        if (gettid() == tid) {
            throw "THREAD-ERROR", sprintf("cannot call FtpPoller::waitStop() from the event thread (%d)", tid);
        }
        sc.waitForZero();
    }

    #! starts the polling operation inline (not in a background thread)
    /**
        @throw FTPPOLLER-ERROR this exception is thrown if polling is already in progress
    */
    startInline() {
        {
            m.lock();
            on_exit m.unlock();

            if (runflag) {
                throw "FTPPOLLER-ERROR", sprintf("the polling thread is already running in TID %d", tid);
            }

            runflag = True;
            tid = gettid();
        }
        sc.inc();
        run();
    }

    #! runs a single poll (useful for checking for errors inline before starting a background thread)
    bool runOnce() {
        ++pollcnt;
        bool ret = False;
        foreach string subdir in (path) {
            get_files = True;
            if (path.size() > 1) {
                ftp.cwd(rootFtpPath);
                ftp.cwd(subdir);
            }
            string pwd = ftp.pwd();
            logInfo("polling %y", pwd);

            subdir =~ s/\/+$//;
            list<hash<FtpPollerFileEventInfo>> files = getFiles(subdir);

            if (files) {
                logDetail("got new files in %y: %y", pwd, files);

                if (fileEvent(files)) {
                    foreach hash<FtpPollerFileEventInfo> event in (files) {
                        get_files = True;
                        event.filepath = subdir == "." ? event.name : (subdir + DirSep + event.name);
                        if (local_dir) {
                            if (atomic_transfer) {
                                event = retrieveTempFile(event);
                            } else {
                                event = retrieveFile(event);
                            }
                        } else {
                            event = getRemoteFileData(event);
                        }
                        # make sure any errors after this point cause the polling operation to stop
                        get_files = False;

                        singleFileEvent(event);

                        # set the "fatal" flag if an exception is thrown in postSingleFileEvent()
                        on_error fatal = True;

                        postSingleFileEvent(event);
                    }
                }
                ret = True;
            }
        }
        return ret;
    }

    #! Retrieves remote file data and adds it to the event data
    hash<FtpPollerFileEventInfo> getRemoteFileData(hash<FtpPollerFileEventInfo> event) {
        # get file to binary stream
        BinaryOutputStream binstream();

        logInfo("retrieving %y (%d bytes) to memory", event.filepath, event.size);
        date start = now_us();
        ftp.get(event.filepath, binstream);
        event.transfer_time = now_us() - start;
        logInfo("retrieved %y in %y", event.filepath, event.transfer_time);

        # write binary data to event hash
        event += {
            "data": binstream.getData(),
        };

        return event;
    }

    #! Retrieves the remote file to local_dir using a temporary file
    private hash<FtpPollerFileEventInfo> retrieveTempFile(hash<FtpPollerFileEventInfo> event) {
        # add filename
        string tmp_name = sprintf(tempfile_template, event.name);
        string tmp_path = normalize_dir(local_dir + DirSep + tmp_name);
        string local_path = normalize_dir(local_dir + DirSep + event.name);

        logInfo("using local dir %y to stream %y -> %y (%d bytes)", local_dir, event.filepath,
            tmp_path, event.size);
        date start = now_us();
        if (event.size) {
            # stream remote file to local file
            ftp.get(event.filepath, tmp_path);
        } else {
            File f();
            f.open2(tmp_path, O_CREAT | O_WRONLY | O_TRUNC);
        }

        # move to target filename after transfer to ensure atomicity
        if (tmp_path != local_path) {
            # NOTE: uses a simple rename() which may cause problems on some OSes if moving between filesystems
            Qore::rename(tmp_path, local_path);
            logInfo("renamed %y -> %y", tmp_path, local_path);
        }

        event += {
            "transfer_time": now_us() - start,
            "local_path": local_path,
        };
        logInfo("streamed %d byte%s from %y -> %y in %y", event.size, event.size == 1 ? "" : "s", event.filepath,
            local_path, event.transfer_time);
        return event;
    }

    #! Retrieves the remote file to local_dir directly
    private hash<FtpPollerFileEventInfo> retrieveFile(hash<FtpPollerFileEventInfo> event) {
        # add filename
        string local_path = normalize_dir(local_dir + DirSep + event.name);

        logInfo("using local dir %y to stream %y -> %y (%d bytes)", local_dir, event.filepath,
            local_path, event.size);
        date start = now_us();
        if (event.size) {
            # stream remote file to local file
            ftp.get(event.filepath, local_path);
        } else {
            File f();
            f.open2(local_path, O_CREAT | O_WRONLY | O_TRUNC);
        }

        event += {
            "transfer_time": now_us() - start,
            "local_path": local_path,
        };
        logInfo("streamed %d byte%s from %y -> %y in %y", event.size, event.size == 1 ? "" : "s", event.filepath,
            local_path, event.transfer_time);
        return event;
    }

    #! sleeps for the specificed number of seconds
    private ftpSleep(softint secs) {
        date end = now_us() + seconds(secs);
        while (runflag) {
%ifdef PO_NO_PROCESS_CONTROL
            call_function(sleep, 1);
%else
            sleep ? call_function(sleep, 1) : Qore::usleep(250ms);
%endif
            if (!runflag || (now_us() >= end)) {
                break;
            }
        }
    }

    #! starts the polling operation
    private run() {
        on_exit {
            sc.dec();
        }

        while (runflag) {
            try {
                runOnce();
                ftpSleep(poll_interval);
            } catch (hash<ExceptionInfo> ex) {
                if (get_files) {
                    logInfo("FTP error in %y: %s: %s; waiting %y for next try", path, ex.err, ex.desc, ErrorDelay);
                    ftpSleep(ErrorDelay);
                } else {
                    # error thrown in "post transfer" code
                    logInfo("error in post transfer code; polling terminated: %s: %s", ex.err, ex.desc);
                    rethrow;
                }
            }
        }

        logInfo("polling finished");
    }

    #! called for each poll with a list of all files matched before transfer
    /** if this method returns False or @ref nothing, then the singleFileEvent method is not called
    */
    *bool fileEvent(list<hash<FtpPollerFileEventInfo>> l) {
        return True;
    }

    #! called for each matching file individually whenever matching files are polled
    /** If any error occurs here, the error is logged and the polling operation is retried

        @param event a hash of file data
    */
    abstract singleFileEvent(hash<FtpPollerFileEventInfo> event);

    #! called after singleFileEvent() for each matching file individually
    /** If any error occurs here, the polling operation stops

        This method would normally delete / rename / move files processed by singleFileEvent() so that they would not
        be polled a second time.
        If an error occurs in this operation, then the polling event will stop since continuing after failing to
        delete, rename, or move a file already processed would cause the file to be processed more than once.

        @param event a hash of file data
    */
    abstract postSingleFileEvent(hash<FtpPollerFileEventInfo> event);

    #! checks a path on the local file system
    /**
        @throw DIR-ERROR this exception is thrown if the local path does not exist, is not readable, is not a
        directory, or should be writable and is not
    */
    static checkPath(string path, string type, bool write = False) {
        *hash<StatInfo> h = hstat(path);
        if (!h) {
            throw "DIR-ERROR", sprintf("%y: %s path does not exist", path, type);
        }
        if (h.type != "DIRECTORY") {
            throw "DIR-ERROR", sprintf("%y: %s path is not a directory (%s)", path, type, h.type);
        }

        # check if the directory is readable
        if (!is_readable(path)) {
            throw "DIR-ERROR", sprintf("%y: %s path is not readable", path, type);
        }

        # check if the directory is writable
        if (write && !is_writable(path)) {
            throw "DIR-ERROR", sprintf("%y: %s path is not writable", path, type);
        }
    }
}

#! Event-based data provider for FTP polling events
/** When using the \c local_dir option, the local file must be removed / moved / archived by the event handler
*/
public class FtpPollerDataProviderBase inherits DataProvider::AbstractDataProvider {
    public {
        #! Constructor options
        const ConstructorOptions = {
            "atomic_transfer":  <DataProviderOptionInfo>{
                "display_name": "Atomic File Transfer",
                "short_desc": "Use an atomic file transfer mechanism",
                "type": AbstractDataProviderTypeMap."bool",
                "desc": "Use an atomic transfer mechanism with `local_dir` where remote files are first moved to a "
                    "temporary location and then moved to the final location when they have been fully "
                    "transferred.\n\n"
                    "This ensures that files will never be read until they are fully transferred",
                "default_value": True,
            },

            "local_dir": <DataProviderOptionInfo>{
                "display_name": "Local Directory",
                "short_desc": "A local directory that will be used to retrieve files",
                "type": AbstractDataProviderTypeMap."*string",
                "desc": "A local directory that will be used to retrieve files",
            },

            "mask": <DataProviderOptionInfo>{
                "display_name": "Glob Mask",
                "short_desc": "The glob mask to use to match files to poll",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "The glob mask to use to match files to poll; will be treated as a regex if `regex` is "
                    "`true`",
                "default_value": "*",
            },

            "minage": <DataProviderOptionInfo>{
                "display_name": "Minimum Polling Age",
                "short_desc": "The minimum age of files to poll in seconds",
                "type": AbstractDataProviderTypeMap."int",
                "desc": "An integer giving the minimum file age in seconds before the file will be polled; this is "
                    "meant to work around non-atomic file transfer operations.\n\n"
                    "If this option is necessary, set it to a value that is larger than the longest time it should "
                    "take to transfer a file",
            },

            "password": <DataProviderOptionInfo>{
                "display_name": "Password",
                "short_desc": "Sets the authentication password",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "The password for authentication; only used if no username or password is set in the URL "
                    "and if the `username` option is also used",
                "sensitive": True,
            },

            "poll_interval": <DataProviderOptionInfo>{
                "display_name": "Poll Interval",
                "short_desc": "The poll interval in seconds",
                "type": AbstractDataProviderTypeMap."int",
                "desc": "The interval in seconds between polling for files",
                "default_value": 10,
            },

            "regex": <DataProviderOptionInfo>{
                "display_name": "Regular Expression Match",
                "short_desc": "If true then the 'mask' argument is treated as a regular expression",
                "type": AbstractDataProviderTypeMap."bool",
                "desc": "If `true` then `mask` is treated as a regular expression instead of a glob pattern",
            },

            "reopt": <DataProviderOptionInfo>{
                "display_name": "Regular Expression Options",
                "short_desc": "A bitfield of regular expression options",
                "type": AbstractDataProviderTypeMap."int",
                "desc": "A bitfield of regular expression options (`1` = ignore case, `2` = treat EOL as a regular "
                    "character); ignored if `regex` is not `true`",
            },

            "sort_desc": <DataProviderOptionInfo>{
                "display_name": "Sort Descending",
                "short_desc": "Sort files in descending order",
                "type": AbstractDataProviderTypeMap."bool",
                "desc": "Sort descending; if not given then an ascending sort is assumed if a `sort_type` is given",
            },

            "sort_type": <DataProviderOptionInfo>{
                "display_name": "Sort Type",
                "short_desc": "Field to sort files on",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "Either `name` or `date` for the data to use for sorting",
            },

            "url": <DataProviderOptionInfo>{
                "display_name": "FTP URL",
                "short_desc": "The URL for the FTP connection",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "A URL for an FTP connection",
                "required": True,
            },

            "username": <DataProviderOptionInfo>{
                "display_name": "Username",
                "short_desc": "The username for authentication",
                "type": AbstractDataProviderTypeMap."string",
                "desc": "The username for authentication; only used if no username or password is set in the URL "
                    "and if the `password` option is also used",
            },
        };
    }

    private {
        #! The file poller itself
        EmbeddedFtpPoller poller;
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) {
        hash<auto> copts = checkOptions("CONSTRUCTOR-ERROR", ConstructorOptions, options);
        string url = remove copts.url;
        hash<UrlInfo> url_info = parse_url(url);

        copts += url_info;
        if (copts.username) {
            copts.user = remove copts.username;
        }
        if (copts.password) {
            copts.pass = remove copts.password;
        }

        bool regex = remove copts.regex ?? False;
        if (!copts.mask) {
            copts.mask = regex ? ".*" : ConstructorOptions.mask.default_value;
        }
        if (*string sort_type = remove copts.sort_type) {
            if (sort_type == "name") {
                copts.sort_type = FtpPoller::SortName;
            } else if (sort_type == "date") {
                copts.sort_type = FtpPoller::SortDate;
            } else {
                throw "CONSTRUCTOR-ERROR", sprintf("expecting \"name\" or \"date\" for the \"sort_type\" option "
                    "value; got %y instead", sort_type);
            }
            if (remove copts.sort_desc) {
                copts.sort_order = FtpPoller::OrderDesc;
            }
        } else {
            remove copts.sort_desc;
        }

        if (regex) {
            copts.regex_mask = remove copts.mask;
        }

        copts.log_info = sub (string msg) {
            info("%s", msg);
        };
        copts.log_detail = sub (string msg) {
            info("%s", msg);
        };
        copts.log_debug = sub (string msg) {
            debug("%s", msg);
        };

        poller = new EmbeddedFtpPoller(self, copts);
    }

    destructor() {
        delete poller;
    }

    string getName() {
        return "ftppoller";
    }

    #! Returns the data provider description
    *string getDesc() {
        return "Provides an event-based FTP polling source";
    }

    #! Returns a hash of all supported event types
    /** @return a hash of all supported event types

        @note only called if the provider supports the observer pattern / event API
    */
    private hash<string, hash<DataProviderMessageInfo>> getEventTypesImpl() {
        return {
            EVENT_FTP_FILE: <DataProviderMessageInfo>{
                "desc": "FTP file polled event",
                "type": FtpPollerFileEventInfoDataType,
            },
        };
    }
}

#! Event-based data provider for FTP polling events
/** When using the \c local_dir option, the local file must be removed / moved / archived by the event handler

    The event ID raised for FTP file events is \c "ftp-file-event" (see @ref EVENT_FTP_FILE)
*/
public class FtpPollerDataProvider inherits FtpPollerDataProviderBase, DataProvider::Observable {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "FtpPollerDataProvider",
            "supports_observable": True,
            "constructor_options": ConstructorOptions,
        };
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) : FtpPollerDataProviderBase(options) {
        poller.start();
    }

    private hash<DataProviderInfo> getStaticInfoImpl() {
        return ProviderInfo;
    }
}

#! Event-based data provider for FTP polling events
/** When using the \c local_dir option, the local file must be removed / moved / archived by the event handler

    The event ID raised for FTP file events is \c "ftp-file-event" (see @ref EVENT_FTP_FILE)
*/
public class FtpDelayedPollerDataProvider inherits FtpPollerDataProviderBase, DataProvider::DelayedObservable {
    public {
        #! Provider info
        const ProviderInfo = <DataProviderInfo>{
            "type": "FtpDelayedPollerDataProvider",
            "supports_observable": True,
            "constructor_options": ConstructorOptions,
        };
    }

    #! Creates the object from constructor options
    constructor(*hash<auto> options) : FtpPollerDataProviderBase(options) {
    }

    #! Called when all observers have been added to the object
    /** This method is meant to trigger event generation
    */
    observersReady() {
        poller.start();
    }

    private hash<DataProviderInfo> getStaticInfoImpl() {
        return ProviderInfo;
    }
}

#! The FTP poller data provider factory
public class FtpPollerDataProviderFactory inherits AbstractDataProviderFactory {
    private {
        #! Data provider type info
        static Class cls = new Class("FtpPollerDataProvider");

        #! Factory info
        const FactoryInfo = <DataProviderFactoryInfo>{
            "name": "ftppoller",
            "desc": "FTP poller data provider factory",
            "children_can_support_observers": True,
        };
    }

    #! Returns static factory information without \a provider_info
    /** @return static factory information without \a provider_info which is provided by @ref getProviderInfo()
    */
    private hash<DataProviderFactoryInfo> getInfoImpl() {
        return FactoryInfo;
    }

    #! Returns static provider information
    /** @note the \c name and \c children attributes are not returned as they are dynamic attributes
    */
    private hash<DataProviderInfo> getProviderInfoImpl() {
        return FtpPollerDataProvider::ProviderInfo;
    }

    #! Returns the class for the data provider object
    private Class getClassImpl() {
        return cls;
    }
}
}

# private namespace; not exported
namespace Priv {
class EmbeddedFtpPoller inherits FtpPoller {
    private {
        #! The parent observer object
        Observable observable;
    }

    constructor(FtpPollerDataProviderBase provider, hash<auto> options)
            : FtpPoller(options) {
        observable := cast<Observable>(provider);
    }

    singleFileEvent(hash<FtpPollerFileEventInfo> event) {
        observable.notifyObservers("ftp-file-event", event);
    }

    postSingleFileEvent(hash<FtpPollerFileEventInfo> event) {
    }
}

const FtpWhiteLogo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>
<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">
<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 2363 2363\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" xmlns:serif=\"http://www.serif.com/\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;\">
    <g transform=\"matrix(1.48976,0,0,1.48976,-564.384,-343.803)\">
        <g transform=\"matrix(958.333,0,0,958.333,325.244,1408.5)\">
            <path d=\"M0.496,-0.367C0.496,-0.354 0.489,-0.347 0.476,-0.347L0.169,-0.347L0.169,-0.02C0.169,-0.007 0.162,-0 0.149,-0L0.098,-0C0.085,-0 0.078,-0.007 0.078,-0.02L0.078,-0.564C0.078,-0.688 0.149,-0.75 0.291,-0.75C0.379,-0.75 0.444,-0.748 0.486,-0.744C0.493,-0.743 0.496,-0.738 0.496,-0.73L0.496,-0.68C0.496,-0.672 0.492,-0.668 0.485,-0.668L0.292,-0.668C0.241,-0.668 0.208,-0.66 0.191,-0.645C0.176,-0.631 0.169,-0.604 0.169,-0.564L0.169,-0.425L0.476,-0.425C0.489,-0.425 0.496,-0.418 0.496,-0.405L0.496,-0.367Z\" style=\"fill:white;fill-rule:nonzero;\"/>
        </g>
        <g transform=\"matrix(958.333,0,0,958.333,853.286,1408.5)\">
            <path d=\"M0.555,-0.681C0.555,-0.67 0.549,-0.665 0.536,-0.665L0.341,-0.665L0.341,-0.02C0.341,-0.007 0.335,-0 0.323,-0L0.268,-0C0.256,-0 0.25,-0.007 0.25,-0.02L0.25,-0.665L0.055,-0.665C0.042,-0.665 0.035,-0.67 0.035,-0.681L0.035,-0.725C0.035,-0.737 0.042,-0.743 0.055,-0.743L0.536,-0.743C0.549,-0.743 0.555,-0.737 0.555,-0.725L0.555,-0.681Z\" style=\"fill:white;fill-rule:nonzero;\"/>
        </g>
        <g transform=\"matrix(958.333,0,0,958.333,1418.7,1408.5)\">
            <path d=\"M0.548,-0.52C0.548,-0.371 0.455,-0.296 0.268,-0.296C0.245,-0.296 0.211,-0.298 0.168,-0.301L0.168,-0.02C0.168,-0.007 0.162,-0 0.15,-0L0.096,-0C0.084,-0 0.078,-0.007 0.078,-0.02L0.078,-0.717C0.078,-0.732 0.086,-0.74 0.102,-0.742C0.148,-0.747 0.203,-0.75 0.268,-0.75C0.455,-0.75 0.548,-0.678 0.548,-0.533L0.548,-0.52ZM0.457,-0.533C0.457,-0.583 0.442,-0.619 0.411,-0.641C0.381,-0.662 0.333,-0.673 0.268,-0.673C0.233,-0.673 0.2,-0.672 0.168,-0.669L0.168,-0.376L0.268,-0.372C0.336,-0.372 0.385,-0.384 0.414,-0.407C0.443,-0.43 0.457,-0.467 0.457,-0.52L0.457,-0.533Z\" style=\"fill:white;fill-rule:nonzero;\"/>
        </g>
    </g>
</svg>";

const FtpBlackLogo = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>
<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">
<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 2363 2363\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" xmlns:serif=\"http://www.serif.com/\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;\">
    <g transform=\"matrix(1.48976,0,0,1.48976,-564.384,-343.803)\">
        <g transform=\"matrix(958.333,0,0,958.333,325.244,1408.5)\">
            <path d=\"M0.496,-0.367C0.496,-0.354 0.489,-0.347 0.476,-0.347L0.169,-0.347L0.169,-0.02C0.169,-0.007 0.162,-0 0.149,-0L0.098,-0C0.085,-0 0.078,-0.007 0.078,-0.02L0.078,-0.564C0.078,-0.688 0.149,-0.75 0.291,-0.75C0.379,-0.75 0.444,-0.748 0.486,-0.744C0.493,-0.743 0.496,-0.738 0.496,-0.73L0.496,-0.68C0.496,-0.672 0.492,-0.668 0.485,-0.668L0.292,-0.668C0.241,-0.668 0.208,-0.66 0.191,-0.645C0.176,-0.631 0.169,-0.604 0.169,-0.564L0.169,-0.425L0.476,-0.425C0.489,-0.425 0.496,-0.418 0.496,-0.405L0.496,-0.367Z\" style=\"fill-rule:nonzero;\"/>
        </g>
        <g transform=\"matrix(958.333,0,0,958.333,853.286,1408.5)\">
            <path d=\"M0.555,-0.681C0.555,-0.67 0.549,-0.665 0.536,-0.665L0.341,-0.665L0.341,-0.02C0.341,-0.007 0.335,-0 0.323,-0L0.268,-0C0.256,-0 0.25,-0.007 0.25,-0.02L0.25,-0.665L0.055,-0.665C0.042,-0.665 0.035,-0.67 0.035,-0.681L0.035,-0.725C0.035,-0.737 0.042,-0.743 0.055,-0.743L0.536,-0.743C0.549,-0.743 0.555,-0.737 0.555,-0.725L0.555,-0.681Z\" style=\"fill-rule:nonzero;\"/>
        </g>
        <g transform=\"matrix(958.333,0,0,958.333,1418.7,1408.5)\">
            <path d=\"M0.548,-0.52C0.548,-0.371 0.455,-0.296 0.268,-0.296C0.245,-0.296 0.211,-0.298 0.168,-0.301L0.168,-0.02C0.168,-0.007 0.162,-0 0.15,-0L0.096,-0C0.084,-0 0.078,-0.007 0.078,-0.02L0.078,-0.717C0.078,-0.732 0.086,-0.74 0.102,-0.742C0.148,-0.747 0.203,-0.75 0.268,-0.75C0.455,-0.75 0.548,-0.678 0.548,-0.533L0.548,-0.52ZM0.457,-0.533C0.457,-0.583 0.442,-0.619 0.411,-0.641C0.381,-0.662 0.333,-0.673 0.268,-0.673C0.233,-0.673 0.2,-0.672 0.168,-0.669L0.168,-0.376L0.268,-0.372C0.336,-0.372 0.385,-0.384 0.414,-0.407C0.443,-0.43 0.457,-0.467 0.457,-0.52L0.457,-0.533Z\" style=\"fill-rule:nonzero;\"/>
        </g>
    </g>
</svg>";
}
