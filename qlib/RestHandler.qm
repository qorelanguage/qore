# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file RestHandler.qm Qore handler definition for the HttpServer module for exporting REST services

/* RestHandler.qm Copyright (C) 2013 - 2020 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum qore version
%requires qore >= 0.9

# use new-style
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

%requires Util
%requires HttpServerUtil >= 0.3.11
%requires Mime >= 1.3
%requires(reexport) RestSchemaValidator >= 1.0
%requires reflection

%try-module yaml >= 0.5
%define NoYaml
%endtry

%try-module xml >= 1.3
%define NoXml
%endtry

%try-module json >= 1.5
%define NoJson
%endtry

module RestHandler {
    version = "1.3.1";
    desc = "user module for implementing REST services with the Qore HTTP server";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage RestHandler Module

    @tableofcontents

    @section resthandlerintro Introduction to the RestHandler Module

    The %RestHandler module provides functionality for implementing REST services with the %Qore HTTP server.

    To use this module, use \c "%requires RestHandler" and \c "%requires HttpServer" in your code.

    All the public symbols in the module are defined in the RestHandler namespace.

    The main classes are:
    - @ref RestHandler::AbstractRestClass "AbstractRestClass": this class provides the functionality of the REST object currently being accessed (and access to subobjects or subclasses)
    - @ref RestHandler::RestHandler "RestHandler": this class can be used to plug in to the %Qore <a href="../../HttpServer/html/index.html">HttpServer</a> to expose REST services

    see example file \c "restserver.q" in the examples directory for an example of using this module to implement REST services.

    @section restserialization Data Serialization Support

    The @ref RestHandler::RestHandler "RestHandler" class uses any of the following modules if the modules are available when the RestHandler module is initialized:
    - <a href="https://github.com/qorelanguage/module-json">json</a>: provides automatic support for JSON payload de/serialization
    - <a href="https://github.com/qorelanguage/module-xml">xml</a>: provides automatic support for XML-RPC payload de/serialization
    - <a href="https://github.com/qorelanguage/module-yaml">yaml</a>: provides automatic support for YAML payload de/serialization

    URL form encoding is supported as well for message bodies according to <a href="https://tools.ietf.org/html/rfc1738">RFC 2738 2.2</a> with \c "Content-Type: application/x-www-form-urlencoded".

    For standard REST web service development, the <a href="https://github.com/qorelanguage/module-json">json</a> module will be required to support JSON serialization.

    The @ref RestHandler::RestHandler "RestHandler" class will automatically deserialize request bodies if the incoming MIME type is supported and additionally will serialize outgoing messages automatically based on the client's declared capabilities (normally responses are serialized with the same serialization as the incoming message).

    @section restimplementation Implementing REST Services

    The class that models a REST entity or object in this module is @ref RestHandler::AbstractRestClass "AbstractRestClass".

    This class should be subclassed for each object type, and methods implemented for each REST method that the object will support.

    Incoming requests matched by your @ref RestHandler::RestHandler "RestHandler" subclass (when called by the @ref HttpServer::HttpServer "HttpServer" when requests are appropriately matched) will be dispatched to methods in your @ref RestHandler::AbstractRestClass "AbstractRestClass" specialization (ie your user-defined subclass of this class) first according to the following naming convention:
    - <tt>httpmethod</tt>[<i>RequestRestAction</i>]

    For example:
    - \c "GET /obj HTTP/1.1": matches method \c AbstractRestClass::get()
    - \c "POST /obj HTTP/1.1": matches method \c AbstractRestClass::post()
    - \c "DELETE /obj/subobj": match method \c AbstractRestClass::del()
    - \c "GET /obj?action=status HTTP/1.1": matches method \c AbstractRestClass::getStatus()
    - \c "PUT /obj?action=status HTTP/1.1": matches method \c AbstractRestClass::putStatus()
    - \c "PATCH /obj?action=status HTTP/1.1": matches method \c AbstractRestClass::patchStatus()

    In other words, if a REST action is given in the request (either as a URI parameter or in the message body), the first letter of the action name is capitalized and appended to a lower case version of the HTTP method name (except \c "DELETE" is mapped to \c "del" because \c "delete" is a keyword); if such a method exists in your @ref RestHandler::AbstractRestClass "AbstractRestClass" specialization, then it is called.  If not, then, if the REST action exists under a different HTTP method (ie a request comes with \c "HTTP GET /something?action=setData", and  \c "putSetData" exists, but \c "getSetData" was used for the search), then a 405 \c "Method Not Allowed" response is returned.  If no variation of the requested REST method exists, then a 501 \c "Not Implemented" response is returned.

    If a REST request is made with no action name, then a method in your class is attempted to be called with just the HTTP method name in lower case (except \c "DELETE" is mapped to \c "del" because \c "delete" is a keyword).

    <b>HTTP Method Name to %Qore Method Name</b>
    |!HTTP Method|!%Qore Method
    |\c GET|\c AbstractRestClass::get()
    |\c PUT|\c AbstractRestClass::put()
    |\c PATCH|\c AbstractRestClass::patch()
    |\c POST|\c AbstractRestClass::post()
    |\c DELETE|\c AbstractRestClass::del()
    |\c OPTIONS|\c AbstractRestClass::options()

    If no action is provided in the URL and the final URI path component does not match to a subclass, and an action
    method is defined in the last REST class, then this method will be run.

    For example (assuming no subclass match for the trailing \c "status" path component):
    - \c "GET /obj/status HTTP/1.1": matches method \c AbstractRestClass::getStatus()
    - \c "PUT /obj/status HTTP/1.1": matches method \c AbstractRestClass::putStatus()
    - \c "PATCH /obj/status HTTP/1.1": matches method \c AbstractRestClass::patchStatus()

    It is recommended to avoid requiringg an \c "action" parameter, because this approach is generally not compatible
    with REST schema solutions such as Swaggger/OAS or RAML.

    In all cases, the signature for these methods looks like:
    @code{.py}
    hash<auto> method(hash<auto> cx, *hash<auto> ah) {}
    @endcode

    The arguments passed to the REST action methods are as follows:
    - \a cx: a call context hash; the same value as documented in the \a cx parameter of @ref HttpServer::AbstractHttpRequestHandler::handleRequest(); with the following additions:
      - \a body: the deserialized message body (if any); if no body was sent, then any parsed URI arguments are copied here
      - \a hdr: a copy of the header hash as returned by @ref Qore::Socket::readHTTPHeader() "Socket::readHTTPHeader()" as received by the @ref HttpServer::HttpServer "HttpServer" (for example cx.hdr.path gives the original URI request path)
      - \a orig_method: the string if any \c "action" argumnt was sent either in the message body or as a URI argument
      - \a rest_method: same as \a orig_method, only with the first letter capitalized (only present if an \c "action" argument was sent)
      - \a rest_action_method: the method name that will be called on the actual %Qore REST class (a subclass of @ref RestHandler::AbstractRestClass "AbstractRestClass")
    - \c ah: these are the parsed URI query arguments to the REST call; see @ref restargs for more information

    The return value for these methods is the same as the return value for @ref HttpServer::AbstractHttpRequestHandler::handleRequest().

    consider the following example class:
    @code{.py}
class AbstractExampleInstanceBaseClass inherits AbstractRestClass {
    private {
        hash<auto> h;
    }

    constructor(hash<auto> n_h) {
        h = n_h;
    }

    hash<auto> get(hash<auto> cx, *hash<auto> ah) {
        return RestHandler::makeResponse(200, h);
    }

    hash<auto> putChown(hash<auto> cx, *hash<auto> ah) {
        if (!exists cx.body.user && !exists cx.body.group)
            return RestHandler::make400("missing 'user' and/or 'group' parameters for chown(%y)", h.path);
        int rc = chown(h.path, cx.body.user, cx.body.group);
        return rc ? RestHandler::make400("ERROR chown(%y): %s", h.path, strerror()) : RestHandler::makeResponse(200, "OK");
    }

    hash<auto> putChmod(hash<auto> cx, *hash<auto> ah) {
        if (!exists cx.body.mode)
            return RestHandler::make400("missing 'mode' parameter for chmod(%y)", h.path);
        int rc = chmod(h.path, cx.body.mode);
        return rc ? RestHandler::make400("ERROR chmod(%y): %s", h.path, strerror()) : RestHandler::makeResponse(200, "OK");
    }

    hash<auto> putRename(hash<auto> cx, *hash<auto> ah) {
        if (!exists cx.body.newPath)
            return RestHandler::make400("missing 'newPath' parameter for rename(%y)", h.path);
        try {
            rename(h.path, cx.body.newPath);
        } catch (hash<ExceptionInfo> ex) {
            return RestHandler::make400("rename (%y): %s: %s", h.path, ex.err, ex.desc);
        }
        return RestHandler::makeResponse(200, "OK");
    }
}
    @endcode

    Assuming this object corresponds to URL path /files/info.txt, the following requests are supported:
    - \c "GET /files/info.txt HTTP/1.1": calls the get() method above (no action)
    - \c "PUT /files/info.txt/chown;user=username HTTP/1.1": calls the putChown() method above (such arguments
      could also be passed in the message body; see @ref restargs for more information)
    - \c "PUT /files/info.txt/chmod;mode=420 HTTP/1.1": calls the putChmod() method above (note that 420 = 0644)
    - \c "PUT /files/info.txt/rename;newPath=/tmp/old.txt HTTP/1.1": calls the putRename() method above
    - \c "PUT /files/info.txt?action=chown;user=username HTTP/1.1": calls the putChown() method above (such arguments
      could also be passed in the message body; see @ref restargs for more information)
    - \c "PUT /files/info.txt?action=chmod;mode=420 HTTP/1.1": calls the putChmod() method above
      (note that 420 = 0644)
    - \c "PUT /files/info.txt?action=rename;newPath=/tmp/old.txt HTTP/1.1": calls the putRename() method above

    @section resthierarchy Implementing Object Hierarchies

    To implement a hisearchy of REST objects in the URL, each @ref RestHandler::AbstractRestClass "AbstractRestClass"
    subclass adds static subclass references using the
    @ref RestHandler::AbstractRestClass::addClass() "AbstractRestClass::addClass()" method and can also reimplement
    the @ref RestHandler::AbstractRestClass::subClassImpl() "subClassImpl()" method to return a child
    @ref RestHandler::AbstractRestClass "AbstractRestClass" object representing the child object programmatically
    based on REST API arguments or the current application state.

    If no such sub object exists, then the method should return @ref nothing, which will cause a
    <tt>404 Bad Request</tt> response to be returned by (to change this behavior, reimplement
    @ref RestHandler::RestHandler::unknownSubClassError() "unknownSubClassError()" in your specialization of
    @ref RestHandler::RestHandler "RestHandler".  Otherwise, if an exception occurs handling the request, a
    <tt>409 Conflict</tt> response is returned; see @ref restexceptions for more information.

    The following is an example of a class implementing a
    @ref RestHandler::AbstractRestClass::subClassImpl() "subClassImpl()"
    method:
    @code{.py}
class WorkflowOrderRestClass inherits AbstractRestClass {
    private {
        # this holds the information or state of the REST object
        hash<auto> wf;
    }

    constructor(hash<auto> n_wf) {
        wf = n_wf;
    }

    # the name of the REST object
    string name() {
        return "orders";
    }

    # supports subclass requests by returning an object if the id is recognized
    *AbstractRestClass subClassImpl(softint order_id, hash<auto> cx, *hash<auto> ah) {
        *hash<auto> h = sysinfo.getOrderInfo(wf.id, order_id);
        if (h) {
            return new WorkflowOrderInstanceRestClass(h);
        }
    }

    # supports \c GET requests on the object
    hash<HttpHandlerResponseInfo> get(hash<auto> cx, *hash<auto> ah) {
        return RestHandler::makeResponse(200, wf);
    }
}

class WorkflowOrderInstanceRestClass inherits AbstractRestClass {
    private {
        # this holds the information or state of the REST object
        hash<auto> oh;
    }

    constructor(hash<auto> n_oh) {
        oh = n_oh;
    }

    # the name of the REST object
    string name() {
        return oh.order_instanceid;
    }

    # supports \c PUT requests where action=retry on the object
    hash<HttpHandlerResponseInfo> putRetry(hash<auto> cx, *hash<auto> ah) {
        return RestHandler::makeResponse(200, api.retryOrder(oh.order_instanceid));
    }

    # supports \c GET requests on the object
    hash<HttpHandlerResponseInfo> get(hash<auto> cx, *hash<auto> ah) {
        return RestHandler::makeResponse(200, oh);
    }
}
    @endcode

    @note REST classes directly under the base handler object inheriting @ref RestHandler::RestHandler "RestHandler"
    can add subclasses by calling @ref RestHandler::RestHandler::addClass() "RestHandler::addClass()" as well; the
    value of the @ref RestHandler::AbstractRestClass::name() "AbstractRestClass::name()" method provides the name of
    the subclass.

    @section restargs Argument and Message Body Handling

    There are two ways to pass arguments to REST action methods:
    - 1: pass them as URI query arguments
    - 2: pass them as a hash in the message body

    REST action methods have the following signature:
    @code{.py}
    hash<HttpHandlerResponseInfo> method(hash<auto> cx, *hash<auto> ah) {}
    @endcode

    In the usual case when only one of the above methods is used, then the argument information is copied to both
    places, making it easier for the %Qore REST implementation to handle arguments in a consistent way regardless
    of how they were passed.  This means arguments (including any \c action argument), can be passed in either the
    URI path as URI query arguments, or in the message body as a hash.

    Therefore, the following cases are identical:

    <b>Request With URI Argument</b>
    @verbatim
PUT /files/info.txt/chmod;mode=420 HTTP/1.1
Accept: application/x-yaml
User-Agent: Qore-RestClient/1.0
Accept-Encoding: deflate,gzip,bzip2
Connection: Keep-Alive
Host: localhost:8001
    @endverbatim

    <b>Request With Arguments in the Message Body</b>
    @verbatim
PUT /files/info.txt/chmod HTTP/1.1
Accept: application/x-yaml
User-Agent: Qore-RestClient/1.0
Accept-Encoding: deflate,gzip,bzip2
Connection: Keep-Alive
Host: localhost:8001
Content-Type: application/json;charset=utf-8
Content-Length: 16

{ "mode" : 420 }
    @endverbatim

    @par REST URI Arguments
    REST URI arguments are available in the \a "ah" argument to the method.  REST URI arguments are provided internally with the @ref HttpServer::parse_uri_query() "parse_uri_query" function.\n\n
    If no URI query argument were provided in the request, then the \a "ah" parameter is populated by the deserialized message body, if it is deserialized to a hash.

    @par REST Message Body
    The REST request message body is automatically deserialized and made available as \a "cx.body" in REST action methods.\n\n
    If no message body was included in the client request, then any parsed URI parameters are copied to \a "cx.body".\n\n
    For requests with long or complex arguments should send arguments as message bodies and not as serialized URI query arguments.

    @note The @ref RestHandler::RestHandler "RestHandler" class allows for HTTP \c GET requests to be served
    with a message body, but this is not compliant with HTTP 1.1 RFCs and therefore could lead to compatibility
    problems should this technique be used with other servers; see @ref httpclient_get_with_body for more information

    @section restexceptions Exception Handling in REST Calls

    %Qore exceptions are serialized in a consistent way by the @ref RestHandler::RestHandler "RestHandler" class so that they can be recognized and handled appropriately by clients.

    %Qore exceptions are returned with a 409 \c "Conflict" HTTP return code with the message body as an @ref Qore::ExceptionInfo "ExceptionInfo" hash.

    @section resthandler_relnotes RestHandler Release Notes

    @subsection rh_1_3_1 RestHandler v1.3.1
    - fixed a bug handling exceptions in REST methods with unserializable exception data
      (<a href="https://github.com/qorelanguage/qore/issues/3667">issue 3667</a>)
    - renamed \c RestHandler::getPossibleSubClasses() to
      @ref RestHandler::RestHandler::doGetPossibleSubClasses() "RestHandler::doGetPossibleSubClasses()" in order to
      avoid a collision with a REST method name
      (<a href="https://github.com/qorelanguage/qore/issues/3614">issue 3614</a>)
    - fixed RestHandler losing internal exception info when response was considered invalid by schema validator
      (<a href="https://github.com/qorelanguage/qore/issues/3435">issue 3435</a>)
    - fixed RestHandler incorrectly handling Accept header of incoming requests
      (<a href="https://github.com/qorelanguage/qore/issues/3426">issue 3426</a>)
    - added debug loggging for REST schema validation errors
      (<a href="https://github.com/qorelanguage/qore/issues/3410">issue 3410</a>)

    @subsection rh_1_3 RestHandler v1.3
    - added the @ref RestHandler::RestHandler::returnRestException() "RestHandler::returnRestException()" method that
      allows subclasses to determine how exceptions are handled
      (<a href="https://github.com/qorelanguage/qore/issues/3235">issue 3235</a>)
    - updated to support alternative URI paths for actions so that an "action=xxx" argument is not needed; instead
      the action can be added to the end of the URI path so that \c "PUT path/xxx" can be used instead of
      \c "PUT path?action=xxx".  Additionally, support for fast static REST subclass lookups was added by moving the
      @ref RestHandler::AbstractRestClass::addClass() "addClass()" method from the
      @ref RestHandler::RestHandler "RestHandler" class to the @ref RestHandler::AbstractRestClass "AbstractRestClass"
      class.
      (<a href="https://github.com/qorelanguage/qore/issues/2994">issue 2994</a>)

    @subsection rh_1_2_1 RestHandler v1.2.1
    - updated to return a 400 Bad Request error when REST schema validation fails on messages received (<a href="https://github.com/qorelanguage/qore/issues/2344">issue 2344</a>)
    - updated to return a 400 Bad Request error when there are string encoding errors with messages received (<a href="https://github.com/qorelanguage/qore/issues/2398">issue 2398</a>)
    - updated to return a 404 Not Found error when REST subclass does not exist (<a href="https://github.com/qorelanguage/qore/issues/2405">issue 2405</a>)
    - updated to return a 400 Bad Request error when ENCODING-CONVERSION-ERROR occurs during request parsing (<a href="https://github.com/qorelanguage/qore/issues/2543">issue 2543</a>)

    @subsection rh_1_2 RestHandler v1.2
    - added logic to allow sensitive data to be masked in log messages (<a href="https://github.com/qorelanguage/qore/issues/1086">issue 1086</a>)
    - added @ref RestHandler::RestHandler::handleExternalRequest "RestHandler::handleExternalRequest()" to allow for REST API methods to be called internally (i.e. without an HTTP call)
    - updated for complex types (<a href="https://github.com/qorelanguage/qore/issues/1724">issue 1724</a>)
    - added support for REST schema validation
    - added default support for the HTTP \c "PATCH" method

    @subsection rh_1_1 RestHandler v1.1
    - added support for the HTTP \c OPTIONS method
    - return an error if an unsupported HTTP method is used in a REST call
    - fixed a type error in the ah member of @ref RestHandler::AbstractRestStreamRequestHandler
    - fixed a bug where an error calling an internal nonexistent method would be reported with an incorrect error message
    - implemented support for notifying persistent connections when the connection is terminated while a persistent connection is in place
    - @ref RestHandler::AbstractRestStreamRequestHandler is now the base abstract class for REST stream request handlers
    - send errors are now reported in the @ref RestHandler::AbstractRestStreamRequestHandler object so they can be properly logged (<a href="https://github.com/qorelanguage/qore/issues/734">issue 734</a>)
    - unknown REST class errors with the base class are now reported consistently like all other such errors (<a href="https://github.com/qorelanguage/qore/issues/859">issue 859</a>)

    @subsection rh_1_0_1 RestHandler v1.0.1
    - added support for URL form encoded formatted message bodies (<a href="https://github.com/qorelanguage/qore/issues/1436">issue 1436</a>)

    @subsection rh_1_0 RestHandler v1.0
    - the initial version of the RestHandler module
*/

#! the RestHandler namespace contains all the objects in the RestHandler module
public namespace RestHandler {
    #! the base abstract class for REST stream request handlers
    /**
        The calling order is as follows:
        - constructor(): this is called when the request is received; then context argument contains the request header along with other information
        - recv(): this is called once for each HTTP chunk (if data is sent chunked), and then once with any message trailer.  If data is sent non-chunked, then this method is called with the monolithic message body and then again with @ref nothing to signify the end of the transfer and to simulate a chunked transfer.  Subclasses should re-implement recvImpl() which is called by this method
        - getResponseHeaderMessage(): this is called after the message body has been received to get the response headers and optionally a message body.  Subclasses should reimplement getResponseHeaderMessageImpl() which is called by this method
        - send(): this is called if no message body is returned by getResponseHeaderMessage(); each time this method returns data, the data is sent in a response chunk; when this method returns @ref nothing, then no more data is sent.  Subclasses should re-implement sendImpl() which is called by this method
    */
    public class AbstractRestStreamRequestHandler {
        public {}

        private {
            #! call context hash
            hash<auto> cx;

            #! if an exception is raised in a callback then the exception hash is saved here
            *hash<auto> ex;

            #! call argument hash
            *hash<auto> ah;

            #! headers to add in the response
            hash<auto> rhdr;

            #! socket I/O timeout in milliseconds
            *int timeout_ms;
        }

        #! creates the object with the given arguments
        /** @param n_cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parse_url())
            - \c id: the unique HTTP connection ID
            - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
            - \c listener-id: the HTTP server listener ID (see HttpServer::HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            - \c hdr: a hash of header information as returned by @ref Qore::Socket::readHTTPHeader()
            - \c body: the deserialized message body
            - \c aih: a hash of \c "Accept" values
            @param n_ah any URI arguments in the request
        */
        constructor(hash<auto> n_cx, *hash<auto> n_ah) {
            cx = n_cx;
            ah = n_ah;
        }

        #! this method returns the response message description hash by calling getResponseHeaderMessageImpl()
        /**
            @return a @ref HttpServer::HttpHandlerResponseInfo "HttpHandlerResponseInfo" hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response; if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and sendImpl() are not called
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            @note this method is called after the message body has been received
        */
        hash<HttpServer::HttpHandlerResponseInfo> getResponseHeaderMessage() {
            hash<HttpHandlerResponseInfo> h;
            try {
                h = cast<hash<HttpHandlerResponseInfo>>(getResponseHeaderMessageImpl());
            } catch (hash<ExceptionInfo> n_ex) {
                ex = n_ex;
                rethrow;
            }

            if (h.code >= 200 && h.code <= 300 && rhdr)
                h.hdr += rhdr;
            return h;
        }

        #! this method provides the callback method for receiving chunked data by calling recvImpl()
        /**
            @param v the first time this method is called with a hash of the message headers in the \c "hdr" key, and then with any message body in the \c "data"; if a chunked HTTP message is received, then this method is called once for each chunk; when the message has been received, then this method is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
            - \c "data": the string or binary data, or, in the case of a non-chunked request, the already decoded and deserialized request body, in which case the \c "deserialized" key will be @ref True
            - \c "chunked": @ref True if the data was received with chunked transfer encoding, @ref False if not
            - \c "deserialized": present and set to @ref True if a non-chunked request was received, and the body has already been deserialized
            .
            Header or trailer data is placed in a hash with the following keys:
            - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
            - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
        */
        nothing recv(hash<auto> v) {
            try {
                recvImpl(v);
            } catch (hash<ExceptionInfo> n_ex) {
                ex = n_ex;
                rethrow;
            }
        }

        #! this method provides the callback method for sending chunked data by calling sendImpl()
        /**
            @return The chunked HTTP data to send; this method must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be returned or simply @ref nothing which will close the chunked message
        */
        auto send() {
            try {
                return sendImpl();
            } catch (hash<ExceptionInfo> n_ex) {
                ex = n_ex;
                rethrow;
            }
        }

        #! returns a callable value in case a persistent connection is in progress; @ref nothing if not; this method in the base class returns @ref nothing
        *code getPersistentClosedNotification() {
        }

        #! returns @ref True if the connection is persistent; this method in the base class returns @ref False by default
        bool isPersistent() {
            return False;
        }

        #! sets the internal socket I/O timeout value in ms
        setTimeout(timeout n_timeout_ms) {
            timeout_ms = n_timeout_ms;
        }

        #! returns the timeout in milliseconds or @ref nothing if no timeout is set
        *int getTimeout() {
            return timeout_ms;
        }

        #! registers stream errors in the send operation with the stream handler if no error is already present
        streamError(hash<auto> n_ex) {
            if (!ex)
                ex = n_ex;
        }

        #! this method should return the response message description hash
        /**
            @return an @ref HttpServer::HttpHandlerResponseInfo hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response; if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and sendImpl() are not called
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            @note this method is called after the message body has been received
        */
        abstract hash<auto> getResponseHeaderMessageImpl();

        #! abstract callback method for receiving chunked data
        /**
            @param v the first time this method is called with a hash of the message headers in the \c "hdr" key, and then with any message body in the \c "data"; if a chunked HTTP message is received, then this method is called once for each chunk; when the message has been received, then this method is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
            - \c "data": the string or binary data, or, in the case of a non-chunked request, the already decoded and deserialized request body, in which case the \c "deserialized" key will be @ref True
            - \c "chunked": @ref True if the data was received with chunked transfer encoding, @ref False if not
            - \c "deserialized": present and set to @ref True if a non-chunked request was received, and the body has already been deserialized
            .
            Header or trailer data is placed in a hash with the following keys:
            - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
            - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
        */
        abstract nothing recvImpl(hash<auto> v);

        #! abstract callback method for sending chunked data
        /**
            @return The chunked HTTP data to send; this method must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be returned or simply @ref nothing which will close the chunked message
        */
        abstract auto sendImpl();
    }

    #! the base class for handling HTTP chunked requests and responses within the RestHandler infrastructure
    public class RestStreamRequest inherits HttpServer::AbstractStreamRequest {
        private {
            RestHandler::AbstractRestStreamRequestHandler stream;
            bool deserialized;
        }

        #! creates the object with the given attributes
        constructor(RestHandler::AbstractRestStreamRequestHandler n_stream, HttpServer::HttpListenerInterface listener, HttpServer::AbstractHttpRequestHandler handler, Socket s, hash<auto> cx, hash<auto> hdr, auto body) : HttpServer::AbstractStreamRequest(listener, handler, s, cx + (exists body ? ("deserialized": True) : NOTHING), hdr, body) {
            stream = n_stream;
            if (!handler.isPersistent()) {
                *code c = stream.getPersistentClosedNotification();
                if (c) {
                    handler.notifyClosed(c);
                    handler.setPersistent();
                }
            }

            # set timeout if applicable
            {
                *int stream_timeout_ms = stream.getTimeout();
                if (stream_timeout_ms) {
                    timeout_ms = stream_timeout_ms;
                    s.setSendTimeout(stream_timeout_ms);
                    s.setRecvTimeout(stream_timeout_ms);
                }
            }

            deserialized = exists body;
        }

        #! destroys the object and updates the request handler about the status of the persistent connection
        destructor() {
            if (handler.isPersistent() && !stream.isPersistent()) {
                handler.notifyClosed();
                handler.setPersistent(False);
            }
        }

        # callback method for the response header; this calls @ref RestHandler::AbstractRestStreamRequestHandler::getResponseHeaderMessage() and returns the result
        /**
            @return a @ref HttpServer::HttpHandlerResponseInfo "HttpHandlerResponseInfo" hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response; if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and sendImpl() are not called
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            @note this method is called after the message body has been received
        */
        private hash<HttpServer::HttpHandlerResponseInfo> getResponseHeaderMessageImpl() {
            return stream.getResponseHeaderMessage();
        }

        #! callback method for receiving chunked data; this calls @ref RestHandler::AbstractRestStreamRequestHandler::recv() with the argument
        /**
            @param v the first time this method is called with a hash of the message headers in the \c "hdr" key, and then with any message body in the \c "data"; if a chunked HTTP message is received, then this method is called once for each chunk; when the message has been received, then this method is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
            - \c "data": the string or binary data, or, in the case of a non-chunked request, the already decoded and deserialized request body, in which case the \c "deserialized" key will be @ref True
            - \c "chunked": True if the data was received with chunked transfer encoding, False if not
            - \c "deserialized": present and set to @ref True if a non-chunked request was received, and the body has already been deserialized
            .
            Header or trailer data is placed in a hash with the following keys:
            - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
            - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
        */
        private nothing recvImpl(hash<auto> v) {
            stream.recv(v);
        }

        #! callback method for sending chunked data; this calls @ref RestHandler::AbstractRestStreamRequestHandler::send() and returns the result
        /**
            @return The chunked HTTP data to send; this method must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be returned or simply @ref nothing which will close the chunked message
        */
        private auto sendImpl() {
            return stream.send();
        }
    }

    #! the base abstract class for REST handler classes
    public class AbstractRestClass {
        public {
            #! class hash: name -> AbstractRestClass
            hash<string, AbstractRestClass> class_hash;

            #! set of REST class method names based on basic HTTP methods
            const RestBasicMethodSet = map {$1: True}, RestHandler::Methods.iterator();
        }

        constructor() {
        }

        #! this provides the name of the REST class
        abstract string name();

        #! adds a REST class to the handler
        addClass(AbstractRestClass cls) {
            string name = cls.name();
            if (class_hash{name}) {
                throw "RESTHANDLER-ERROR", sprintf("class %y has already been registered with this handler", name);
            }
            class_hash{name} = cls;
        }

        #! this method will be called to find a sub-class (ie with GET /invoices/1 - if this class represents "invoices", then subClass("1") will be called to return invoice 1; return @ref nothing if the object doesn't exist
        /** @param name the name of the subclass
            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parse_url())
            - \c id: the unique HTTP connection ID
            - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
            - \c listener-id: the HTTP server listener ID (see HttpServer::HttpServer::getListenerInfo())
            - \c hdr: a hash of header information as returned by @ref Qore::Socket::readHTTPHeader()
            - \c body: the deserialized message body
            - \c aih: a hash of \c "Accept" values
            @param args the holds URI and / or message body arguments for the REST call; if a request has both URI
            query arguments and message body arguments, then this value will be a combination of URI query arguments
            and deserialized message body arguments with URI query arguments taking precedence over the message body
            arguments

            @return an object corresponding to the \c name argument or @ref nothing if none can be matched

            This method first looks for a static subclass in the \a class_hash member (as populated by @ref addClass()
            for example), and then if no match is found calls @ref subClassImpl() for a potential dynamic lookup.

            @note it's recommended to reimplement subClassImpl() instead of this method to leave the static subclass
            lookup in place
         */
        *AbstractRestClass subClass(string name, hash<auto> cx, *hash<auto> args) {
            return class_hash{name} ?? subClassImpl(name, cx, args);
        }

        #! this method will be called to find a sub-class (ie with GET /invoices/1 - if this class represents "invoices", then subClass("1") will be called to return invoice 1; return @ref nothing if the object doesn't exist
        /** @param name the name of the subclass
            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parse_url())
            - \c id: the unique HTTP connection ID
            - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
            - \c listener-id: the HTTP server listener ID (see HttpServer::HttpServer::getListenerInfo())
            - \c hdr: a hash of header information as returned by @ref Qore::Socket::readHTTPHeader()
            - \c body: the deserialized message body
            - \c aih: a hash of \c "Accept" values
            @param args the holds URI and / or message body arguments for the REST call; if a request has both URI
            query arguments and message body arguments, then this value will be a combination of URI query arguments
            and deserialized message body arguments with URI query arguments taking precedence over the message body
            arguments

            @return an object corresponding to the \c name argument or @ref nothing if none can be matched; this base
            class method returns @ref nothing by default; override in subclasses to provide programmatic support for
            REST subclasses

            @note Use addClass() for fast static subclass lookups
         */
        *AbstractRestClass subClassImpl(string name, hash<auto> cx, *hash<auto> args) {
        }

        #! this method is called by the RestHandler class to match the right object with incoming requests
        hash<HttpServer::HttpHandlerResponseInfo> handleRequest(HttpListenerInterface listener, RestHandler rh, Socket s, *list<string> cl, string mn, hash<auto> cx, *hash<auto> args) {
            if (!args && cx.body.typeCode() == NT_HASH) {
                args = cx.body - "action";
            }
            if (cl) {
                string cname = shift cl;
                *AbstractRestClass cls = subClass(cname, cx, args);
                if (!cls) {
                    # issue #2994: if we are on the last class and there is no "action" argument; see if we can find an action method instead
                    if (!cl && !args.action) {
                        string mname = sprintf("%s%s%s", mn, cname[0].upr(), cname[1..]);
                        if (self.hasCallableMethod(mname)) {
                            return cast<hash<HttpHandlerResponseInfo>>(dispatch(rh, mname, args, cx));
                        }
                    }

                    rh.logDebug("REST DBG: class %y: unknown subclass %y: method %y args: %y", name(), cname, mn, args);
                    return unknownSubClassError(cname, cx);
                }

                rh.logDebug("REST DBG: class %y: dispatching to subclass %y: method %y args: %y", name(), cname, mn, args);
                return cls.handleRequest(listener, rh, s, cl, mn, cx, args);
            }

            # try to mask passwords and sensitive data in args
            string astr = rh.maskData(sprintf("%y", args));
            rh.logDebug("REST DBG: class %y: dispatching method %y args: %s", name(), mn, astr);
            return dispatchStream(listener, rh, s, mn, args, cx);
        }

        #! this method is called to dispatch streamed requests on the given object
        private hash<HttpServer::HttpHandlerResponseInfo> dispatchStream(HttpListenerInterface listener, RestHandler rh, Socket s, string mn, *hash<auto> ah, hash<auto> cx) {
            string sn = "stream" + mn[0].upr() + mn.substr(1);
            AbstractRestStreamRequestHandler rsh;
            try {
                cx.socketobject = s;
                rsh = call_object_method_args(self, sn, (cx, ah));
            } catch (hash<ExceptionInfo> ex) {
                if (ex.err == "METHOD-DOES-NOT-EXIST" && ex.desc.find(sn) != -1) {
                    if (cx.hdr."transfer-encoding" == "chunked")
                        cx.body = rh.getMessageBody(s, cx.hdr, NOTHING);

                    return cast<hash<HttpHandlerResponseInfo>>(dispatch(rh, mn, ah, cx));
                }
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);
                rh.logDebug("REST DBG: class %y: stream method %y: %s", name(), sn, desc);
                rethrow;
            }
            try {
                RestStreamRequest req(rsh, listener, rh, s, cx, cx.hdr, cx.hdr."content-length" ? cx.body : NOTHING);
                return req.handleRequest();
            } catch (hash<ExceptionInfo> ex) {
                # make sure the error is registered with the stream handler
                if (rsh)
                    rsh.streamError(ex);
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);
                rh.logDebug("REST DBG: class %y: stream method %y: %s", name(), sn, desc);
                rethrow;
            }
        }

        #! this method is called to dispatch requests on the given object
        /** @param rh the RestHandler object
            @param mn the method name
            @param ah the holds URI and / or message body arguments for the REST call; if a request has both URI
            query arguments and message body arguments, then this value will be a combination of URI query arguments
            and deserialized message body arguments with URI query arguments taking precedence over the message body
            arguments
            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parse_url())
            - \c id: the unique HTTP connection ID
            - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
            - \c listener-id: the HTTP server listener ID (see HttpServer::HttpServer::getListenerInfo())

            @return the return value is the same as the return value for @ref HttpServer::AbstractHttpRequestHandler::handleRequest()
         */
        private hash<HttpServer::HttpHandlerResponseInfo> dispatch(RestHandler rh, string mn, *hash<auto> ah, hash<auto> cx) {
            try {
                return cast<hash<HttpHandlerResponseInfo>>(call_object_method_args(self, mn, (cx, ah)));
            } catch (hash<ExceptionInfo> ex) {
                if (ex.err == "METHOD-DOES-NOT-EXIST") {
                    # try to mask passwords in args
                    string astr = rh.maskData(sprintf("%y", ah));
                    rh.logError("DISPATCH-ERROR: cannot dispatch to unimplemented method %y: class %y, args: %s", mn, name(), astr);
                    # see if alternate methods would work
                    list hl = ();
                    # break flag
                    bool brk;
                    foreach hash<auto> mh in (RestHandler::Methods.pairIterator()) {
                        string nmn = mh.value + cx.rest_method;
                        if (self.hasCallableMethod(nmn)) {
                            if (mh.key == cx.hdr.method) {
                                brk = True;
                                break;
                            }
                            hl += mh.key;
                        }
                    }
                    if (!brk) {
                        if (!hl)
                            return cast<hash<HttpHandlerResponseInfo>>(RestHandler::make501("REST class %y (%s) does not implement method %y", name(), self.className(), cx.orig_method ? cx.orig_method : mn));

                        string ml = foldl $1 + "," + $2, hl;
                        string desc = sprintf("HTTP method %s is unimplemented in REST class %y (%s)", cx.hdr.method, name(), self.className());
                        if (cx.orig_method)
                            desc += sprintf(" REST method %y", cx.orig_method);
                        desc += sprintf(", available methods: %s", ml);
                        return cast<hash<HttpHandlerResponseInfo>>(HttpServer::AbstractHttpRequestHandler::makeResponse(("Allow": ml), 405, desc));
                    }
                }
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);
                rh.logDebug("REST DBG: class %y: method %y: %s", name(), mn, desc);
                rethrow;
            }
        }

        #! returns a 404 Not Found response when a request tries to access an unknown subclass
        /** @param cls_name the URI path element that could not be matched to a REST subclass
            @param cx the HTTP call context hash

            @return REST response information

            @since RestHandler 1.3 added the \a cx argument
        */
        private hash<HttpServer::HttpHandlerResponseInfo> unknownSubClassError(string cls_name, hash<auto> cx) {
            # return possible subclasses, if any are known
            *hash<string, bool> name_set = doGetPossibleSubClasses(cx);
            string msg;
            if (name_set) {
                msg = sprintf("; known subclasses: %s", (foldl $1 + ", " + $2, (map sprintf("%y", $1), keys name_set)));
            }

            return new hash<HttpServer::HttpHandlerResponseInfo>({
                "code": 404,
                "body": sprintf("404 Not Found: class %y has no subclass %y for HTTP method %y%s", name(), cls_name,
                    cx.hdr.method, msg),
            });
        }

        #! returns a set of possible subclasses for a particular request
        /** @param cx the HTTP call context hash

            @return a set of possible subclasses for the request

            @since RestHandler 1.3
        */
        private *hash<string, bool> doGetPossibleSubClasses(hash<auto> cx) {
            # set of subclass names
            *hash<string, bool> name_set = map {$1 : True}, keys class_hash;

            # add any direct action methods for the HTTP method
            string http_method = cx.hdr.method.lwr();
            foreach Reflection::AbstractMethod method in (Reflection::Class::getClass(self).getMethods()) {
                string method_name = method.getName();
                # do not return basic method names as subclasses
                if (!RestBasicMethodSet{method_name} && !method_name.comparePartial(http_method)) {
                    if (http_method.size() < method_name.size()) {
                        method_name = method_name[http_method.size()].lwr() + method_name[(http_method.size() + 1)..];
                    }
                    name_set{method_name} = True;
                }
            }
            return name_set;
        }
    }

    #! this is the main handler class to be registered with the HttpServer
    /** The @ref RestHandler::RestHandler "RestHandler" class should be subclassed to customize its behavior.

        To provide for logging; the following methods can be reimplemented in subclasses:
        - @ref RestHandler::RestHandler::logInfo()
        - @ref RestHandler::RestHandler::logError()
        - @ref RestHandler::RestHandler::logDebug()

        In order to match REST requests under a root path, reimplement the following method in a subclass:
        - @ref RestHandler::RestHandler::removeRootPath()
    */
    public class RestHandler inherits HttpServer::AbstractHttpRequestHandler, AbstractRestClass {
        public {
            #! a hash for a 501 Unimplemented error message
            const Err501 = new hash<HttpResponseInfo>({
                "code": 501,
                "body": "not implemented",
            });

            #! supported HTTP methods
            const Methods = {
                "GET": "get",
                "POST": "post",
                "PUT": "put",
                "DELETE": "del",
                "OPTIONS": "options",
                "PATCH": "patch",
            };

            #! supported mime types for de/serializing responses
            const MimeDataTypes = {
%ifndef NoJson
                MimeTypeJsonRpc: (
                    "serialize": \make_json(),
                    "deserialize": \parse_json(),
                ),
%endif
%ifndef NoYaml
                MimeTypeYaml: (
                    "serialize": \make_yaml(),
                    "deserialize": \parse_yaml(),
                ),

                MimeTypeYamlRpc: (
                    "serialize": \make_yaml(),
                    "deserialize": \parse_yaml(),
                ),
%endif
%ifndef NoXml
                MimeTypeXml: (
                    "serialize": \make_xmlrpc_value(),
                    "deserialize": \parse_xmlrpc_value(),
                ),
                MimeTypeXmlApp: (
                    "serialize": string sub (auto v) {
                        switch (v.typeCode()) {
                            case NT_LIST: return make_xml(("list": ("element": v)));
                            case NT_HASH: return v.size() == 1 && v.firstValue().lsize() == 1 ? make_xml(v) : make_xml(("value": v));
                        }
                        return make_xml(("value": v));
                    },
                    "deserialize": hash<auto> sub (string xml) {
                        try {
                            return parse_xmlrpc_value(xml);
                        } catch (hash<ExceptionInfo> ex) {
                            try {
                                return parse_xml(xml);
                            } catch () {
                                rethrow;
                            }
                        }
                    },
                ),
%endif
                MimeTypeFormUrlEncoded: (
                    "serialize": \mime_get_form_urlencoded_string(),
                    "deserialize": \mime_parse_form_urlencoded_string(),
                ),
                MimeTypeHtml: (
                    "serialize": string sub (auto body) { return sprintf("<pre>%N</pre>", body); },
                ),
            };
        }

        private {
            #! REST schema validator
            RestSchemaValidator::AbstractRestSchemaValidator validator;
        }

        #! create the object optionally with the given HttpServer::AbstractAuthenticator
        /** @param auth the authentication object to use to authenticate connections (see HttpServer::AbstractAuthenticator); if no HttpServer::AbstractAuthenticator object is passed, then by default no authentication will be required
            @param validator a REST API schema validator object; if none is present, then the default REST de/serialization support is provided as documented in @ref RestSchemaValidator::NullRestSchemaValidator
         */
        constructor(*HttpServer::AbstractAuthenticator auth, RestSchemaValidator::AbstractRestSchemaValidator validator = new NullRestSchemaValidator()) : HttpServer::AbstractHttpRequestHandler(auth, True) {
            self.validator = validator;
        }

        #! returns the name of the root REST class
        string name() {
            return "/";
        }

        #! processes REST API calls outside the HTTP server
        /** Requests will be dispatched to REST classes registered with this object

            @param method the HTTP method; if the the method is unknown, an \c UNKNOWN-REST-METHOD exception is raised
            @param path the URI path for the call
            @param body the arguments to the call; note that arguments are combined with any arguments provided in \a path
            @param cx simulated HTTP call context hash

            @return the response value of the REST method

            @throw UNKNOWN-REST-METHOD the HTTP method is unknown / unsupported
            @throw INVALID-URI-PATH URI cannot be parsed
            @throw INVALID-REST-ARGS invalid REST action
            @throw REST-CLASS-ERROR invalid / unknown REST class in URI path
            @throw REST-ERROR an error response was returned from the REST handler for the given method

            @note
            - the \c arg key of the exception hash in the exceptions above contains the HTTP status code of the response
            - exceptions thrown internally by REST handlers are returned directly; no \c 409 status code is added in the \c arg key of the exception hash

            @since %RestHandler 1.2
         */
        auto handleExternalRequest(string method, string path, *hash<auto> body, hash<auto> cx = {}) {
            if (!Methods{method})
                throw "UNKNOWN-REST-METHOD", sprintf("unsupported HTTP method %y given in REST call %y; known methods: %y", method, path, Methods), 400;

            # REST call context hash
            cx += (
                "hdr": (
                    "method": method,
                ),
                "url": ("path": path),
                "body": body,
            );

            # get object and args
            hash<auto> ah = parse_uri_query(path);

            *hash<auto> args;
            if (ah.params) {
                if (ah.params.typeCode() != NT_HASH)
                    throw "INVALID-URI-PATH", sprintf("cannot parse arguments in REST call %y, URI arguments must be key/value pairs with an 'action' key; got type %y instead (value: %y)", path, ah.params.type(), ah.params), 400;
                args = ah.params;
            }

            if (!body)
                body = args;

            if (body)
                map args.$1 = body.$1, keys body, !exists args.$1;

            # make method name
            string mn;

            {
                auto action;
                if (args.action)
                    action = remove args.action;
                else if (body.action)
                    action = body.action;

                if (action) {
                    if (action.typeCode() != NT_STRING)
                        throw "INVALID-REST-ARGS", sprintf("cannot parse arguments in REST call %y, the 'action' key is not assigned to a string; got %y instead", path, action.type()), 400;
                    mn = action;
                    cx.orig_method = mn;
                    # ensure first letter of the action is in upper case
                    splice mn, 0, 1, mn[0].upr();
                    cx.rest_method = mn;
                    mn = Methods{method} + mn;
                } else {
                    mn = Methods{method};
                }
            }

            cx.rest_action_method = mn;

            # remove leading slash from method name
            if (ah.method =~ /^\//)
                splice ah.method, 0, 1;

            # get class chain
            *list<string> cl;
            if (ah.method) {
                # combine continuous "/" chars into a single one
                ah.method =~ s/\/\/+/\//g;
                cl = ah.method.split("/");
            }

            # get initial class
            *string cls = shift cl;

            AbstractRestClass rcls;

            if (!cls)
                rcls = self;
            else {
                *AbstractRestClass c = subClass(cls, cx, args);
                if (!c) {
                    # issue #2994: if we are on the last class and there is no "action" argument; see if we can find an action method instead
                    if (!cl && !args.action) {
                        string mname = sprintf("%s%s%s", mn, cls[0].upr(), cls[1..]);
                        if (self.hasCallableMethod(mname)) {
                            c = self;
                            mn = mname;
                        }
                    }

                    if (!c) {
                        throw "REST-CLASS-ERROR", sprintf("unknown root REST class %y in path %y (valid classes: %y)", cls, cx.url.path, sort(keys doGetPossibleSubClasses(cx))), 404;
                    }
                }
                rcls = c;
            }

            # dummy HttpListenerInterface object
            DummyListenerInterface listener();
            # socket object needed for call; will not be used
            Socket s();

            hash<HttpHandlerResponseInfo> rv = rcls.handleRequest(listener, self, s, cl, mn, cx, args);
            if (rv.code < 200 || rv.code >= 300)
                throw "REST-ERROR", rv.body, rv.code;
            return rv.body;
        }

        #! called by the HTTP server to handle incoming HTTP requests
        /** Requests will be dispatched to REST classes registered with this object

            @param listener a listener API object
            @param s the @ref Qore::Socket "Socket" object serving the request
            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parse_url())
            - \c id: the unique HTTP connection ID
            - \c ssl: @ref True "True" if the request was encrypted with HTTPS, @ref False "False" if not
            - \c listener-id: the HTTP server listener ID (see HttpServer::HttpServer::getListenerInfo())
            @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys will be present:
            - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
            - \c path: the HTTP path given in the request, after processing by decode_url() (Qore function)
            - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")
            @param b message body, if any

            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response
         */
        hash<HttpResponseInfo> handleRequest(HttpListenerInterface listener, Socket s, hash<auto> cx, hash<auto> hdr, *data b) {
            #logDebug("REST DBG: cx: %N", cx);
            #logDebug("REST DBG: hdr: %N", hdr);

            auto body = b;

            # get rest class name
            string path = cx.url.path ?? "";

            removeRootPath(\path);

            hash<RestRequestServerInfo> req;
            try {
                if (b) {
                    string bstr = maskData(b.typeCode() == NT_STRING ? trim(b) : sprintf("%y", b));
                    logDebug("REST DBG: body: %s", bstr);
                }

                req = validator.parseRequest(hdr.method, path, body, \hdr);
            } catch (hash<ExceptionInfo> ex) {
                logDebug("REST DBG: %s", get_exception_string(ex));
                # return a 400 Bad Request response to encoding, serialization, or validation errors
                if (ex.err == "INVALID-ENCODING"
                    || ex.err == "ENCODING-CONVERSION-ERROR"
                    || ex.err == "DESERIALIZATION-ERROR"
                    || ex.err == "SCHEMA-VALIDATION-ERROR")
                    return AbstractHttpRequestHandler::make400("%s: %s", ex.err, ex.desc);
                if (ex.err == "INVALID-METHOD") {
                    string ml = (foldl $1 + "," + $2, ex.arg) ?? "";
                    return AbstractHttpRequestHandler::makeResponse(405, sprintf("HTTP method %y is not supported with URI path %y; supported methods: %s", hdr.method, path, ml ?* "<none>"), ("Allow": ml));
                }
                rethrow;
            }

            # get object and args
            hash<auto> ah = path ? (
                "method": req.path,
                "params": req.query,
            ) : {};
            #path ? parse_uri_query(path) : {};

            *hash<auto> args;
            if (ah.params) {
                if (ah.params.typeCode() != NT_HASH)
                    return RestHandler::make400("cannot parse arguments in REST call %y, URI arguments must be key/value pairs with an 'action' key; got type %y instead (value: %y)", path, ah.params.type(), ah.params);
                args = {} + ah.params;
            }

            if (exists body)
                body = req.body;
            else
                body = args;

            # reflect body in arguments if body is a hash
            if (body.typeCode() == NT_HASH)
                map args.$1 = body.$1, keys body, !exists args.$1;

            if (!Methods.(hdr.method))
                return RestHandler::make400("unsupported HTTP method %y given in REST call %y", hdr.method, path);

            # make method name
            string mn;
            if (args.action) {
                if (args.action.typeCode() != NT_STRING)
                    return RestHandler::make400("cannot parse arguments in REST call %y, the 'action' key is not assigned to a string; got %y instead", path, args.action.type());
                mn = args.action;
                args -= "action";
                # ensure first letter of the action is in upper case
                cx.orig_method = mn;
                splice mn, 0, 1, mn[0].upr();
                cx.rest_method = mn;
                mn = Methods.(hdr.method) + mn;
            } else if (body.action) {
                if (body.action.typeCode() != NT_STRING)
                    return RestHandler::make400("cannot parse arguments in REST call %y, the 'action' key is not assigned to a string; got %y instead", path, args.action.type());
                mn = body.action;
                cx.orig_method = mn;
                # ensure first letter of the action is in upper case
                splice mn, 0, 1, mn[0].upr();
                cx.rest_method = mn;
                mn = Methods.(hdr.method) + mn;
            } else {
                mn = Methods.(hdr.method);
            }

            cx.rest_action_method = mn;

            # remove leading slash from method name
            if (ah.method =~ /^\//)
                splice ah.method, 0, 1;

            # get class chain
            *list<string> cl;
            if (ah.method) {
                # combine continuous "/" chars into a single one
                ah.method =~ s/\/\/+/\//g;
                cl = ah.method.split("/");
            }

            # get initial class
            *string cls = shift cl;

            # make a hash of "accept" values
            *string astr = hdr.accept;
            hash<auto> aih;
            if (astr) {
                do {
                    astr =~ s/;[^,]*//;
                } while (astr.rfind(";") != -1);
                astr =~ s/ +//g;
                map aih.$1 = True, astr.split(",");
            } else {
                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html: If no Accept header field is present, then it is assumed that the client accepts all media types
                aih."*/*" = True;
            }

            #logDebug("REST DBG: aih: %y", aih);

            # set up context hash
            cx += {"hdr": hdr, "body": body, "aih": aih};

            # handle call with class
            hash<HttpHandlerResponseInfo> rv;

            try {
                AbstractRestClass rcls;

                if (!cls) {
                    rcls = self;
                } else {
                    *AbstractRestClass c = subClass(cls, cx, args);
                    if (!c) {
                        # issue #2994: if we are on the last class and there is no "action" argument; see if we can find an action method instead
                        if (!cl && !args.action) {
                            string mname = sprintf("%s%s%s", mn, cls[0].upr(), cls[1..]);
                            if (self.hasCallableMethod(mname)) {
                                rcls = self;
                                mn = mname;
                            }
                        }

                        if (!rcls) {
                            rv = unknownSubClassError(cls, cx);
                        }
                    } else {
                        rcls = c;
                    }
                }

                if (!rv) {
                    rv = rcls.handleRequest(listener, self, s, cl, mn, cx, args);
                }
            } catch (hash<ExceptionInfo> ex) {
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);

                logError(desc);
                rv = returnRestException(ex);
            }

            if (!rv.reply_sent) {
                # verify response with the REST schema
                hash<HttpResponseInfo> res;

                try {
                    res = validator.processResponse(hdr.method, req.path, rv.code, rv.body, rv.hdr, aih."*/*" ? NOTHING : keys aih);
                } catch (hash<ExceptionInfo> ex) {
                    logDebug("REST DBG: %s", get_exception_string(ex));
                    if (ex.err == "ACCEPT-ERROR") {
                        responseSerializationError(cx, aih, rv);
                        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html: If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.
                        return AbstractHttpRequestHandler::makeResponse(406, ex.desc);
                    }

                    # add original resp to the exception (only if it was an error)
                    if (rv.code >= 400 && rv.code < 600)
                        ex.desc += sprintf(" ... Original response: code: %d, body: %y, hdr: %y", rv.code, rv.body, rv.hdr);

                    throw ex.err, ex.desc, ex.arg;
                }

                rv += {
                    "body": res.body,
                    "hdr": res.hdr,
                };

                logDebug("REST DBG: response serialization: %d %s (%d bytes)", rv.code, rv.hdr."Content-Type" ?? "n/a", rv.body.size());
            }

            #logDebug("REST DBG: rv: %N", rv);

            return cast<hash<HttpResponseInfo>>(rv);
        }

        #! method that determines how exceptions handling REST requests are returned
        /** by default a <tt>409 Conflict</tt> response is returned with the serialized exception information in the
            message body
        */
        private hash<HttpHandlerResponseInfo> returnRestException(hash<ExceptionInfo> ex) {
            # if there is an exception, by default return a 409 Conflict error to the client with the exception information
            # issue #3667: ensure that the exception argument is serializable
            checkExceptionSerializable(\ex);
            return <HttpHandlerResponseInfo>{
                "code": 409,
                "body": ex,
            };
        }

        #! Recursively ensure that exception arguments are serializable
        private checkExceptionSerializable(reference<hash<ExceptionInfo>> ex) {
            if (ex.arg.typeCode() == NT_OBJECT && !(ex.arg instanceof Serializable)) {
                string new_arg;
                if (ex.arg.hasCallableMethod("toString")) {
                    try {
                        new_arg = sprintf("unserializable arg.toString(): %s", ex.arg.toString());
                    } catch (hash<ExceptionInfo> ex1) {
                    }
                }
                if (!exists new_arg) {
                    new_arg = sprintf("unserializable arg: %y", ex.arg);
                }
                ex.arg = new_arg;
            } else {
                if (ex.arg.ex instanceof hash<ExceptionInfo>) {
                    checkExceptionSerializable(\ex.arg.ex);
                }
            }
        }

        #! default get handler for the base handler class
        hash<auto> get(hash<auto> cx, *hash<auto> ah) {
            return RestHandler::makeResponse(200, keys class_hash);
        }

        #! default implementation is empty
        removeRootPath(reference<string> path) {
        }

        #! default implementation is empty
        requestDeserializationError(hash<auto> hdr, hash<auto> cx, string body) {
        }

        #! default implementation is empty
        responseSerializationError(hash<auto> cx, *hash<auto> aih, hash<auto> rv) {
        }

        #! default implementation is empty; this method is called with informational log messages; reimplement in subclasses to provide for logging
        logInfo(string fmt) {
            delete argv;
        }

        #! default implementation is empty; this method is called with error log messages; reimplement in subclasses to provide for logging
        logError(string fmt) {
            delete argv;
        }

        #! default implementation is empty; this method is called with debug log messages; reimplement in subclasses to provide for logging
        logDebug(string fmt) {
            delete argv;
        }

        #! creates a hash for an HTTP response with the response code and a literal response message body
        static hash<HttpHandlerResponseInfo> makeResponse(int code, auto body, *hash<auto> hdr) {
            return <HttpHandlerResponseInfo>{
                "code": code,
                "body": body,
                "hdr": hdr,
            };
        }
    }
}

# private, unexported namespace
namespace Priv {
    # dummy HttpListenerInterface class
    class DummyListenerInterface inherits HttpListenerInterface {
        addUserThreadContext(hash<auto> uctx) {
        }

        auto removeUserThreadContext(*string k) {
        }

        log(string fmt) {
        }

        logError(string fmt) {
        }
    }
}
