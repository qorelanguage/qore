# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file RestHandler.qm Qore handler definition for the HttpServer module for exporting REST services

/* RestHandler.qm Copyright (C) 2013 - 2016 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum qore version
%requires qore >= 0.8.12

# use new-style
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

%requires Util
%requires HttpServerUtil >= 0.3.11
%requires Mime >= 1.3

%try-module yaml >= 0.5
%define NoYaml
%endtry

%try-module xml >= 1.3
%define NoXml
%endtry

%try-module json >= 1.5
%define NoJson
%endtry

module RestHandler {
    version = "1.1";
    desc = "user module for implementing REST services with the Qore HTTP server";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage RestHandler Module

    @tableofcontents

    @section resthandlerintro Introduction to the RestHandler Module

    The %RestHandler module provides functionality for implementing REST services with the %Qore HTTP server.

    To use this module, use \c "%requires RestHandler" and \c "%requires HttpServer" in your code.

    All the public symbols in the module are defined in the RestHandler namespace.

    The main classes are:
    - @ref RestHandler::AbstractRestClass "AbstractRestClass": this class provides the functionality of the REST object currently being accessed (and access to subobjects or subclasses)
    - @ref RestHandler::RestHandler "RestHandler": this class can be used to plug in to the %Qore <a href="../../HttpServer/html/index.html">HttpServer</a> to expose REST services

    see example file \c "restserver.q" in the examples directory for an example of using this module to implement REST services.

    @section restserialization Data Serialization Support

    The @ref RestHandler::RestHandler "RestHandler" class uses any of the following modules if the modules are available when the RestHandler module is initialized:
    - <a href="http://qore.org/qore-modules/41-json-module">json</a>: provides automatic support for JSON payload de/serialization
    - <a href="http://qore.org/qore-modules/40-xml-module">xml</a>: provides automatic support for XML-RPC payload de/serialization
    - <a href="http://qore.org/qore-modules/38-yaml-module">yaml</a>: provides automatic support for YAML payload de/serialization

    For standard REST web service development, the <a href="http://qore.org/qore-modules/41-json-module">json</a> module will be required to support JSON serialization.

    The @ref RestHandler::RestHandler "RestHandler" class will automatically deserialize request bodies if the incoming MIME type is supported and additionally will serialize outgoing messages automatically based on the client's declared capabilities (normally responses are serialized with the same serialization as the incoming message).

    @section restimplementation Implementing REST Services

    The class that models a REST entity or object in this module is @ref RestHandler::AbstractRestClass "AbstractRestClass".

    This class should be subclassed for each object type, and methods implemented for each REST method that the object will support.

    Incoming requests matched by your @ref RestHandler::RestHandler "RestHandler" subclass (when called by the @ref HttpServer::HttpServer "HttpServer" when requests are appropriately matched) will be dispatched to methods in your @ref RestHandler::AbstractRestClass "AbstractRestClass" specialization (ie your user-defined subclass of this class) according to the following naming convention:
    - <tt>httpmethod</tt>[<i>RequestRestAction</i>]

    For example:
    - \c "GET /obj HTTP/1.1": matches method \c AbstractRestClass::get()
    - \c "POST /obj HTTP/1.1": matches method \c AbstractRestClass::post()
    - \c "DELETE /obj/subobj": match method \c AbstractRestClass::del()
    - \c "GET /obj?action=status HTTP/1.1": matches method \c AbstractRestClass::getStatus()
    - \c "PUT /obj?action=status HTTP/1.1": matches method \c AbstractRestClass::putStatus()

    In other words, if a REST action is given in the request (either as a URI parameter or in the message body), the first letter of the action name is capitalized and appended to a lower case version of the HTTP method name (except \c "DELETE" is mapped to \c "del" because \c "delete" is a keyword); if such a method exists in your @ref RestHandler::AbstractRestClass "AbstractRestClass" specialization, then it is called.  If not, then, if the REST action exists under a different HTTP method (ie a request comes with \c "HTTP GET /something?action=setData", and  \c "putSetData" exists, but \c "getSetData" was used for the search), then a 405 \c "Method Not Allowed" response is returned.  If no variation of the requested REST method exists, then a 501 \c "Not Implemented" response is returned.

    If a REST request is made with no action name, then a method in your class is attempted to be called with just the HTTP method name in lower case (except \c "DELETE" is mapped to \c "del" because \c "delete" is a keyword).

    <b>HTTP Method Name to %Qore Method Name</b>
    |!HTTP Method|!%Qore Method
    |\c GET|\c AbstractRestClass::get()
    |\c PUT|\c AbstractRestClass::put()
    |\c POST|\c AbstractRestClass::post()
    |\c DELETE|\c AbstractRestClass::del()
    |\c OPTIONS|\c AbstractRestClass::options()

    In all cases, the signature for these methods looks like:
    @code{.py}
    hash method(hash cx, *hash ah) {}
    @endcode

    The arguments passed to the REST action methods are as follows:
    - \a cx: a call context hash; the same value as documented in the \a cx parameter of @ref HttpServer::AbstractHttpRequestHandler::handleRequest(); with the following additions:
      - \a body: the deserialized message body (if any); if no body was sent, then any parsed URI arguments are copied here
      - \a hdr: a copy of the header hash as returned by @ref Qore::Socket::readHTTPHeader() "Socket::readHTTPHeader()" as received by the @ref HttpServer::HttpServer "HttpServer" (for example cx.hdr.path gives the original URI request path)
      - \a orig_method: the string if any \c "action" argumnt was sent either in the message body or as a URI argument
      - \a rest_method: same as \a orig_method, only with the first letter capitalized (only present if an \c "action" argument was sent)
      - \a rest_action_method: the method name that will be called on the actual %Qore REST class (a subclass of @ref RestHandler::AbstractRestClass "AbstractRestClass")
    - \c ah: these are the parsed URI query arguments to the REST call; see @ref restargs for more information

    The return value for these methods is the same as the return value for @ref HttpServer::AbstractHttpRequestHandler::handleRequest().

    consider the following example class:
    @code{.py}
class AbstractExampleInstanceBaseClass inherits AbstractRestClass {
    private {
        hash h;
    }

    constructor(hash n_h) {
        h = n_h;
    }

    hash get(hash cx, *hash ah) {
        return RestHandler::makeResponse(200, h);
    }

    hash putChown(hash cx, *hash ah) {
        if (!exists cx.body.user && !exists cx.body.group)
            return RestHandler::make400("missing 'user' and/or 'group' parameters for chown(%y)", h.path);
        int rc = chown(h.path, cx.body.user, cx.body.group);
        return rc ? RestHandler::make400("ERROR chown(%y): %s", h.path, strerror()) : RestHandler::makeResponse(200, "OK");
    }

    hash putChmod(hash cx, *hash ah) {
        if (!exists cx.body.mode)
            return RestHandler::make400("missing 'mode' parameter for chmod(%y)", h.path);
        int rc = chmod(h.path, cx.body.mode);
        return rc ? RestHandler::make400("ERROR chmod(%y): %s", h.path, strerror()) : RestHandler::makeResponse(200, "OK");
    }

    hash putRename(hash cx, *hash ah) {
        if (!exists cx.body.newPath)
            return RestHandler::make400("missing 'newPath' parameter for rename(%y)", h.path);
        try {
            rename(h.path, cx.body.newPath);
        }
        catch (hash ex) {
            return RestHandler::make400("rename (%y): %s: %s", h.path, ex.err, ex.desc);
        }
        return RestHandler::makeResponse(200, "OK");
    }
}
    @endcode

    Assuming this object corresponds to URL path /files/info.txt, the following requests are supported:
    - \c "GET /files/info.txt HTTP/1.1": calls the get() method above (no action)
    - \c "PUT /files/info.txt?action=chown;user=username HTTP/1.1": calls the putChown() method above (such arguments could also be passed in the message body; see @ref restargs for more information)
    - \c "PUT /files/info.txt?action=chmod;mode=420 HTTP/1.1": calls the putChmod() method above (note that 420 = 0644)
    - \c "PUT /files/info.txt?action=rename;newPath=/tmp/old.txt HTTP/1.1": calls the putRename() method above

    @section resthierarchy Implementing Object Hierarchies

    To implement a hisearchy of REST objects in the URL, each @ref RestHandler::AbstractRestClass "AbstractRestClass" subclass reimplements the @ref RestHandler::AbstractRestClass::subClass() "subClass()" method that returns a child @ref RestHandler::AbstractRestClass "AbstractRestClass" object representing the child object.

    If no such sub object exists, then the method should return @ref nothing, which will cause a \c "REST-CLASS-ERROR" exception to be thrown by default (to change this behavior, reimplement @ref RestHandler::RestHandler::unknownSubClassError() "unknownSubClassError()" in your specialization of @ref RestHandler::RestHandler "RestHandler".  See @ref restexceptions for more information

    The following is an example of a class implementing a @ref RestHandler::AbstractRestClass::subClass() "subClass()" method:
    @code{.py}
class WorkflowOrderRestClass inherits AbstractRestClass {
    private {
        # this holds the information or state of the REST object
        hash wf;
    }

    constructor(hash n_wf) {
        wf = n_wf;
    }

    # the name of the REST object
    string name() {
        return "orders";
    }

    # supports subclass requests by returning an object if the id is recognized
    *AbstractRestClass subClass(softint order_id, hash cx, *hash ah) {
        *hash h = sysinfo.getOrderInfo(wf.id, order_id);
        if (h)
            return new WorkflowOrderInstanceRestClass(h);
    }

    # supports \c GET requests on the object
    hash get(hash cx, *hash ah) {
        return RestHandler::makeResponse(200, wf);
    }
}

class WorkflowOrderInstanceRestClass inherits AbstractRestClass {
    private {
        # this holds the information or state of the REST object
        hash oh;
    }

    constructor(hash n_oh) {
        oh = n_oh;
    }

    # the name of the REST object
    string name() {
        return oh.order_instanceid;
    }

    # supports \c PUT requests where action=retry on the object
    hash putRetry(hash cx, *hash ah) {
        return RestHandler::makeResponse(200, api.retryOrder(oh.order_instanceid));
    }

    # supports \c GET requests on the object
    hash get(hash cx, *hash ah) {
        return RestHandler::makeResponse(200, oh);
    }
}
    @endcode

    @note REST classes directly under the base handler object inheriting @ref RestHandler::RestHandler "RestHandler" can add subclasses by calling @ref RestHandler::RestHandler::addClass() "RestHandler::addClass()" as well; the value of the @ref RestHandler::AbstractRestClass::name() "AbstractRestClass::name()" method provides the name of the subclass.

    @section restargs Argument and Message Body Handling

    There are two ways to pass arguments to REST action methods:
    - 1: pass them as URI query arguments
    - 2: pass them as a hash in the message body

    REST action methods have the following signature:
    @code{.py}
    hash method(hash cx, *hash ah) {}
    @endcode

    In the usual case when only one of the above methods is used, then the argument information is copied to both places, making it easier for the %Qore REST implementation to handle arguments in a consistent way regardless of how they were passed.  This means arguments, including any \c action argument, can be passed in either the URI path as URI query arguments, or in the message body as a hash.

    Therefore, the following cases are identical:

    <b>Request With URI Argument</b>
    @verbatim
GET /files/info.txt?action=info;option=verbose HTTP/1.1
Accept: application/x-yaml
User-Agent: Qore-RestClient/1.0
Accept-Encoding: deflate,gzip,bzip2
Connection: Keep-Alive
Host: localhost:8001
    @endverbatim

    <b>Request With Arguments in the Message Body</b>
    @verbatim
GET /files/info.txt HTTP/1.1
Accept: application/x-yaml
User-Agent: Qore-RestClient/1.0
Accept-Encoding: deflate,gzip,bzip2
Connection: Keep-Alive
Host: localhost:8001
Content-Type: application/json;charset=utf-8
Content-Length: 36

{ "action" : "info", "verbose" : 1 }
    @endverbatim

    @par REST URI Arguments
    REST URI arguments are available in the \a "ah" argument to the method.  REST URI arguments are provided internally with the @ref HttpServer::parse_uri_query() "parse_uri_query" function.\n\n
    If no URI query argument were provided in the request, then the \a "ah" parameter is populated by the deserialized message body, if it is deserialized to a hash.

    @par REST Message Body
    The REST request message body is automatically deserialized and made available as \a "cx.body" in REST action methods.\n\n
    If no message body was included in the client request, then any parsed URI parameters are copied to \a "cx.body".\n\n
    For requests with long or complex arguments should send arguments as message bodies and not as serialized URI query arguments.

    @section restexceptions Exception Handling in REST Calls

    %Qore exceptions are serialized in a consistent way by the @ref RestHandler::RestHandler "RestHandler" class so that they can be recognized and handled appropriately by clients.

    %Qore exceptions are returned with a 409 \c "Conflict" HTTP return code with the message body as an @ref exception_hash "exception hash".

    @section resthandler_relnotes RestHandler Release Notes

    @subsection rh_1_1 RestHandler v1.1
    - added support for the HTTP \c OPTIONS method
    - return an error if an unsupported HTTP method is used in a REST call
    - fixed a type error in the ah member of @ref RestHandler::AbstractRestStreamRequestHandler
    - fixed a bug where an error calling an internal nonexistent method would be reported with an incorrect error message
    - implemented support for notifying persistent connections when the connection is terminated while a persistent connection is in place
    - @ref RestHandler::AbstractRestStreamRequestHandler is now the base abstract class for REST stream request handlers
    - send errors are now reported in the @ref RestHandler::AbstractRestStreamRequestHandler object so they can be properly logged (<a href="https://github.com/qorelanguage/qore/issues/734">issue 734</a>)
    - unknown REST class errors with the base class are now reported consistently like all other such errors (<a href="https://github.com/qorelanguage/qore/issues/859">issue 859</a>)

    @subsection rh_1_0 RestHandler v1.0
    - the initial version of the RestHandler module
*/

#! the RestHandler namespace contains all the objects in the RestHandler module
public namespace RestHandler {
    #! the base abstract class for REST stream request handlers
    /**
        The calling order is as follows:
        - constructor(): this is called when the request is received; then context argument contains the request header along with other information
        - recv(): this is called once for each HTTP chunk (if data is sent chunked), and then once with any message trailer.  If data is sent non-chunked, then this method is called with the monolithic message body and then again with @ref nothing to signify the end of the transfer and to simulate a chunked transfer.  Subclasses should re-implement recvImpl() which is called by this method
        - getResponseHeaderMessage(): this is called after the message body has been received to get the response headers and optionally a message body.  Subclasses should reimplement getResponseHeaderMessageImpl() which is called by this method
        - send(): this is called if no message body is returned by getResponseHeaderMessage(); each time this method returns data, the data is sent in a response chunk; when this method returns @ref nothing, then no more data is sent.  Subclasses should re-implement sendImpl() which is called by this method
    */
    public class AbstractRestStreamRequestHandler {
        public {}

        private {
            #! call context hash
            hash cx;

            #! if an exception is raised in a callback then the exception hash is saved here
            *hash ex;

            #! call argument hash
            *hash ah;

            #! headers to add in the response
            hash rhdr;

            #! socket I/O timeout in milliseconds
            *int timeout_ms;
        }

        #! creates the object with the given arguments
        /** @param n_cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parseURL())
            - \c id: the unique HTTP connection ID
            - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            - \c hdr: a hash of header information as returned by @ref Qore::Socket::readHTTPHeader()
            - \c body: the deserialized message body
            - \c aih: a hash of \c "Accept" values
            @param n_ah any URI arguments in the request
        */
        constructor(hash n_cx, *hash n_ah) {
            cx = n_cx;
            ah = n_ah;
        }

        #! this method returns the response message description hash by calling getResponseHeaderMessageImpl()
        /**
            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response; if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and sendImpl() are not called
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            @note this method is called after the message body has been received
        */
        hash getResponseHeaderMessage() {
            hash h;
            try {
                h = getResponseHeaderMessageImpl();
            }
            catch (hash n_ex) {
                ex = n_ex;
                rethrow;
            }

            if (h.code >= 200 && h.code <= 300 && rhdr)
                h.hdr += rhdr;
            return h;
        }

        #! this method provides the callback method for receiving chunked data by calling recvImpl()
        /**
            @param v the first time this method is called with a hash of the message headers in the \c "hdr" key, and then with any message body in the \c "data"; if a chunked HTTP message is received, then this method is called once for each chunk; when the message has been received, then this method is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
            - \c "data": the string or binary data, or, in the case of a non-chunked request, the already decoded and deserialized request body, in which case the \c "deserialized" key will be @ref True
            - \c "chunked": @ref True if the data was received with chunked transfer encoding, @ref False if not
            - \c "deserialized": present and set to @ref True if a non-chunked request was received, and the body has already been deserialized
            .
            Header or trailer data is placed in a hash with the following keys:
            - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
            - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
        */
        nothing recv(hash v) {
            try {
                recvImpl(v);
            }
            catch (hash n_ex) {
                ex = n_ex;
                rethrow;
            }
        }

        #! this method provides the callback method for sending chunked data by calling sendImpl()
        /**
            @return The chunked HTTP data to send; this method must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be returned or simply @ref nothing which will close the chunked message
        */
        any send() {
            try {
                return sendImpl();
            }
            catch (hash n_ex) {
                ex = n_ex;
                rethrow;
            }
        }

        #! returns a callable value in case a persistent connection is in progress; @ref nothing if not; this method in the base class returns @ref nothing
        *code getPersistentClosedNotification() {
        }

        #! returns @ref True if the connection is persistent; this method in the base class returns @ref False by default
        bool isPersistent() {
            return False;
        }

        #! sets the internal socket I/O timeout value in ms
        setTimeout(timeout n_timeout_ms) {
            timeout_ms = n_timeout_ms;
        }

        #! returns the timeout in milliseconds or @ref nothing if no timeout is set
        *int getTimeout() {
            return timeout_ms;
        }

        #! registers stream errors in the send operation with the stream handler if no error is already present
        streamError(hash n_ex) {
            if (!ex)
                ex = n_ex;
        }

        #! this method should return the response message description hash
        /**
            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response; if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and sendImpl() are not called
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            @note this method is called after the message body has been received
            */
        abstract hash getResponseHeaderMessageImpl();

        #! abstract callback method for receiving chunked data
        /**
            @param v the first time this method is called with a hash of the message headers in the \c "hdr" key, and then with any message body in the \c "data"; if a chunked HTTP message is received, then this method is called once for each chunk; when the message has been received, then this method is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
            - \c "data": the string or binary data, or, in the case of a non-chunked request, the already decoded and deserialized request body, in which case the \c "deserialized" key will be @ref True
            - \c "chunked": @ref True if the data was received with chunked transfer encoding, @ref False if not
            - \c "deserialized": present and set to @ref True if a non-chunked request was received, and the body has already been deserialized
            .
            Header or trailer data is placed in a hash with the following keys:
            - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
            - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
        */
        abstract nothing recvImpl(hash v);

        #! abstract callback method for sending chunked data
        /**
            @return The chunked HTTP data to send; this method must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be returned or simply @ref nothing which will close the chunked message
            */
        abstract any sendImpl();
    }

    #! the base class for handling HTTP chunked requests and responses within the RestHandler infrastructure
    public class RestStreamRequest inherits HttpServer::AbstractStreamRequest {
        private {
            RestHandler::AbstractRestStreamRequestHandler stream;
            bool deserialized;
        }

        #! creates the object with the given attributes
        constructor(RestHandler::AbstractRestStreamRequestHandler n_stream, HttpServer::HttpListenerInterface listener, HttpServer::AbstractHttpRequestHandler handler, Socket s, hash cx, hash hdr, any body) : HttpServer::AbstractStreamRequest(listener, handler, s, cx + (exists body ? ("deserialized": True) : NOTHING), hdr, body) {
            stream = n_stream;
            if (!handler.isPersistent()) {
                *code c = stream.getPersistentClosedNotification();
                if (c) {
                    handler.notifyClosed(c);
                    handler.setPersistent();
                }
            }

            # set timeout if applicable
            {
                *int stream_timeout_ms = stream.getTimeout();
                if (stream_timeout_ms) {
                    timeout_ms = stream_timeout_ms;
                    s.setSendTimeout(stream_timeout_ms);
                    s.setRecvTimeout(stream_timeout_ms);
                }
            }

            deserialized = exists body;
        }

        #! destroys the object and updates the request handler about the status of the persistent connection
        destructor() {
            if (handler.isPersistent() && !stream.isPersistent()) {
                handler.notifyClosed();
                handler.setPersistent(False);
            }
        }

        # callback method for the response header; this calls @ref RestHandler::AbstractRestStreamRequestHandler::getResponseHeaderMessage() and returns the result
        /**
            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response; if this key is returned, then the reply is sent immediately; a chunked reply is not made, and send() and sendImpl() are not called
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            @note this method is called after the message body has been received
        */
        private hash getResponseHeaderMessageImpl() {
            return stream.getResponseHeaderMessage();
        }

        #! callback method for receiving chunked data; this calls @ref RestHandler::AbstractRestStreamRequestHandler::recv() with the argument
        /**
            @param v the first time this method is called with a hash of the message headers in the \c "hdr" key, and then with any message body in the \c "data"; if a chunked HTTP message is received, then this method is called once for each chunk; when the message has been received, then this method is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
            - \c "data": the string or binary data, or, in the case of a non-chunked request, the already decoded and deserialized request body, in which case the \c "deserialized" key will be @ref True
            - \c "chunked": True if the data was received with chunked transfer encoding, False if not
            - \c "deserialized": present and set to @ref True if a non-chunked request was received, and the body has already been deserialized
            .
            Header or trailer data is placed in a hash with the following keys:
            - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
            - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
        */
        private nothing recvImpl(hash v) {
            stream.recv(v);
        }

        #! callback method for sending chunked data; this calls @ref RestHandler::AbstractRestStreamRequestHandler::send() and returns the result
        /**
            @return The chunked HTTP data to send; this method must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be returned or simply @ref nothing which will close the chunked message
        */
        private any sendImpl() {
            return stream.send();
        }
    }

    #! the base abstract class for REST handler classes
    public class AbstractRestClass {
        public {}

        constructor() {
        }

        #! this provides the name of the REST class
        abstract string name();

        #! this method will be called to find a sub-class (ie with GET /invoices/1 - if this class represents "invoices", then subClass("1") will be called to return invoice 1; return @ref nothing if the object doesn't exist
        /** @param name the name of the subclass
            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parseURL())
            - \c id: the unique HTTP connection ID
            - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            - \c hdr: a hash of header information as returned by @ref Qore::Socket::readHTTPHeader()
            - \c body: the deserialized message body
            - \c aih: a hash of \c "Accept" values
            @param args any URI arguments in the request

            @return an object corresponding to the \c name argument or @ref nothing if none can be matched
         */
        *AbstractRestClass subClass(string name, hash cx, *hash args) {
        }

        #! this method is called by the RestHandler class to match the right object with incoming requests
        hash handleRequest(HttpListenerInterface listener, RestHandler rh, Socket s, *list cl, string mn, hash cx, *hash args) {
            if (!args && cx.body.typeCode() == NT_HASH)
                args = cx.body;
            if (cl) {
                string cname = shift cl;
                *AbstractRestClass cls = subClass(cname, cx, args);
                if (!cls) {
                    rh.logDebug("REST DBG: class %y: unknown subclass %y: method %y args: %y", name(), cname, mn, args);
                    return unknownSubClassError(cname);
                }

                rh.logDebug("REST DBG: class %y: dispatching to subclass %y: method %y args: %y", name(), cname, mn, args);
                return cls.handleRequest(listener, rh, s, cl, mn, cx, args);
            }

            rh.logDebug("REST DBG: class %y: dispatching method %y args: %y", name(), mn, args);
            return dispatchStream(listener, rh, s, mn, args, cx);
        }

        #! this method is called to dispatch streamed requests on the given object
        private hash dispatchStream(HttpListenerInterface listener, RestHandler rh, Socket s, string mn, *hash ah, hash cx) {
            string sn = "stream" + mn[0].upr() + mn.substr(1);
            AbstractRestStreamRequestHandler rsh;
            try {
                cx.socketobject = s;
                rsh = call_object_method_args(self, sn, (cx, ah));
            }
            catch (hash ex) {
                if (ex.err == "METHOD-DOES-NOT-EXIST") {
                    if (cx.hdr."transfer-encoding" == "chunked")
                        cx.body = rh.getMessageBody(s, cx.hdr, NOTHING);

                    return dispatch(rh, mn, ah, cx);
                }
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);
                rh.logDebug("REST DBG: class %y: stream method %y: %s", name(), sn, desc);
                rethrow;
            }
            try {
                RestStreamRequest req(rsh, listener, rh, s, cx, cx.hdr, cx.hdr."content-length" ? cx.body : NOTHING);
                return req.handleRequest();
            }
            catch (hash ex) {
                # make sure the error is registered with the stream handler
                rsh.streamError(ex);
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);
                rh.logDebug("REST DBG: class %y: stream method %y: %s", name(), sn, desc);
                rethrow;
            }
        }

        #! this method is called to dispatch requests on the given object
        private hash dispatch(RestHandler rh, string mn, *hash ah, hash cx) {
            try {
                return call_object_method_args(self, mn, (cx, ah));
            }
            catch (hash ex) {
                if (ex.err == "METHOD-DOES-NOT-EXIST") {
                    rh.logError("DISPATCH-ERROR: cannot dispatch to unimplemented method %y: class %y, args: %y", mn, name(), ah);
                    # see if alternate methods would work
                    list hl = ();
                    # break flag
                    bool brk;
                    foreach hash mh in (RestHandler::Methods.pairIterator()) {
                        string nmn = mh.value + cx.rest_method;
                        if (self.hasCallableMethod(nmn)) {
                            if (mh.key == cx.hdr.method) {
                                brk = True;
                                break;
                            }
                            hl += mh.key;
                        }
                    }
                    if (!brk) {
                        if (!hl)
                            return RestHandler::make501("REST class %y (%s) does not implement method %y", name(), self.className(), cx.orig_method ? cx.orig_method : mn);

                        string ml = foldl $1 + "," + $2, hl;
                        string desc = sprintf("HTTP method %s is unimplemented in REST class %y (%s)", cx.hdr.method, name(), self.className());
                        if (cx.orig_method)
                            desc += sprintf(" REST method %y", cx.orig_method);
                        desc += sprintf(", available methods: %s", ml);
                        return HttpServer::AbstractHttpRequestHandler::makeResponse(("Allow": ml), 405, desc);
                    }
                }
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);
                rh.logDebug("REST DBG: class %y: method %y: %s", name(), mn, desc);
                rethrow;
            }
        }

        #! throws a \c "REST-CLASS-ERROR" exception when a request tries to access an unknown subclass
        private hash unknownSubClassError(string n_name) {
            throw "REST-CLASS-ERROR", sprintf("class %y has no subclass %y", name(), n_name);
        }
    }

    #! this is the main handler class to be registered with the HttpServer
    /** The @ref RestHandler::RestHandler "RestHandler" class should be subclassed to customize its behavior.

        To provide for logging; the following methods can be reimplemented in subclasses:
        - @ref RestHandler::RestHandler::logInfo()
        - @ref RestHandler::RestHandler::logError()
        - @ref RestHandler::RestHandler::logDebug()

        In order to match REST requests under a root path, reimplement the following method in a subclass:
        - @ref RestHandler::RestHandler::removeRootPath()
    */
    public class RestHandler inherits HttpServer::AbstractHttpRequestHandler, AbstractRestClass {
        public {
            #! a hash for a 501 Unimplemented error message
            const Err501 = (
                "code": 501,
                "body": "not implemented",
                );

            #! supported HTTP methods
            const Methods = (
                "GET": "get",
                "POST": "post",
                "PUT": "put",
                "DELETE": "del",
                "OPTIONS": "options",
                );

            #! supported mime types for de/serializing responses
            const MimeDataTypes = (
%ifndef NoJson
                MimeTypeJsonRpc: (
                    "serialize": \make_json(),
                    "deserialize": \parse_json(),
                ),
%endif
%ifndef NoYaml
                MimeTypeYaml: (
                    "serialize": \make_yaml(),
                    "deserialize": \parse_yaml(),
                ),

                MimeTypeYamlRpc: (
                    "serialize": \make_yaml(),
                    "deserialize": \parse_yaml(),
                ),
%endif
%ifndef NoXml
                MimeTypeXml: (
                    "serialize": \make_xmlrpc_value(),
                    "deserialize": \parse_xmlrpc_value(),
                ),
%endif
                MimeTypeHtml: (
                    "serialize": string sub (any body) { return sprintf("<pre>%N</pre>", body); },
                ),
                );
        }

        private {
            #! class hash: name -> AbstractRestClass
            hash ch;

            #! mutex lock
            Mutex mx();
        }

        #! create the object optionally with the given HttpServer::AbstractAuthenticator
        /** @param auth the authentication object to use to authenticate connections (see HttpServer::AbstractAuthenticator); if no HttpServer::AbstractAuthenticator object is passed, then by default no authentication will be required
         */
        constructor(*HttpServer::AbstractAuthenticator auth) : HttpServer::AbstractHttpRequestHandler(auth, True) {
        }

        #! returns the name of the root REST class
        string name() {
            return "/";
        }

        #! called by the HTTP server to handle incoming HTTP requests
        /** Requests will be dispatched to REST classes registered with this object

            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parseURL())
            - \c id: the unique HTTP connection ID
            - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys will be present:
            - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
            - \c path: the HTTP path given in the request, after processing by decode_url() (Qore function)
            - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")
            @param b message body, if any

            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response
            - \c "close": (optional) set this key to @ref True if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response
         */
        hash handleRequest(HttpListenerInterface listener, Socket s, hash cx, hash hdr, *data b) {
            #logDebug("REST DBG: cx: %N", cx);
            #logDebug("REST DBG: hdr: %N", hdr);
            if (b)
                logDebug("REST DBG: body: %s", b.typeCode() == NT_STRING ? trim(b) : sprintf("%y", b));

            any body = b;

            # get rest class name
            *string path = cx.url.path;

            removeRootPath(\path);

            # get object and args
            hash ah = path ? parse_uri_query(path) : {};

            *hash args;
            if (ah.params) {
                if (ah.params.typeCode() != NT_HASH)
                    return RestHandler::make400("cannot parse arguments in REST call %y, URI arguments must be key/value pairs with an 'action' key; got type %y instead (value: %y)", path, ah.params.type(), ah.params);
                args = ah.params;
            }

            # deserialize body according to Content-Type
            if (body) {
                *code ds = MimeDataTypes.(hdr."content-type").deserialize;
                if (!ds) {
                    requestDeserializationError(hdr, cx, body);
                    return RestHandler::make501("cannot deserialize request body; content-type is: %y; types supported: %y; discarding request body: %y", hdr."content-type", MimeDataTypes.keys(), body);
                }

                body = ds(body);
            }
            else
                body = args;

            # reflect body in arguments if body is a hash
            if (body.typeCode() == NT_HASH)
                map args.$1 = body.$1, body.keyIterator(), !exists args.$1;

            if (!Methods.(hdr.method))
                return RestHandler::make400("unsupported HTTP method %y given in REST call %y", hdr.method, path);

            # make method name
            string mn;
            if (args.action) {
                if (args.action.typeCode() != NT_STRING)
                    return RestHandler::make400("cannot parse arguments in REST call %y, the 'action' key is not assigned to a string; got %y instead", path, args.action.type());
                mn = args.action;
                args -= "action";
                # ensure first letter of the action is in upper case
                cx.orig_method = mn;
                splice mn, 0, 1, mn[0].upr();
                cx.rest_method = mn;
                mn = Methods.(hdr.method) + mn;
            }
            else if (body.action) {
                if (body.action.typeCode() != NT_STRING)
                    return RestHandler::make400("cannot parse arguments in REST call %y, the 'action' key is not assigned to a string; got %y instead", path, args.action.type());
                mn = body.action;
                cx.orig_method = mn;
                # ensure first letter of the action is in upper case
                splice mn, 0, 1, mn[0].upr();
                cx.rest_method = mn;
                mn = Methods.(hdr.method) + mn;
            }
            else
                mn = Methods.(hdr.method);

            cx.rest_action_method = mn;

            # remove leading slash from method name
            if (ah.method =~ /^\//)
                splice ah.method, 0, 1;

            # get class chain
            *list cl = ah.method ? ah.method.split("/") : NOTHING;

            # get initial class
            *string cls = shift cl;

            # make a hash of "accept" values
            *string astr = hdr.accept;
            hash aih;
            if (astr) {
                astr =~ s/;.*//;#/;
                astr =~ s/ +//g;
                map aih.$1 = True, astr.split(",");
            }
            else {
                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html: If no Accept header field is present, then it is assumed that the client accepts all media types
                aih."*/*" = True;
            }

            #logDebug("REST DBG: aih: %y", aih);

            # set up context hash
            cx += ("hdr": hdr, "body": body, "aih": aih);

            # handle call with class
            hash rv;

            try {
                AbstractRestClass rcls;

                if (!cls)
                    rcls = self;
                else {
                    if (!ch{cls}) {
                        *AbstractRestClass c = subClass(cls, cx, args);
                        if (!c)
                            throw "REST-CLASS-ERROR", sprintf("unknown root REST class %y in path %y (valid classes: %y)", cls, cx.url.path, sort(ch.keys()));
                        rcls = c;
                    }
                    else
                        rcls = ch{cls};
                }

                # check method
                if (!Methods.(hdr.method))
                    return RestHandler::make501("cannot handle HTTP method %y; valid methods: %y", hdr.method, Methods.keys());
                rv = rcls.handleRequest(listener, self, s, cl, mn, cx, args);
            }
            catch (hash ex) {
                string desc = !cx.debug
                    ? sprintf("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc)
                    : get_exception_string(ex);

                # if there is an exception, return a 409 Conflict error to the client with the exception information
                logError(desc);
                rv = (
                    "code": 409,
                    "body": ex,
                    );
            }

            #logDebug("DBG: rv: %y", rv);

            if (!rv.reply_sent) {
                # serialize response according to client's capabilities if necessary
                bool encoded;
                if (rv.already_encoded)
                    encoded = True;

                # process Accept values in the order sent by the sender
                if (!encoded && !rv.reply_sent) {
                    *code ds;
                    foreach string a in (aih.keyIterator()) {
                        ds = MimeDataTypes{a}.serialize;
                        if (ds) {
                            rv.body = ds(rv.body);
                            rv.hdr += ("Content-Type": a);
                            break;
                        }
                    }

                    # if still not encoded and the client accepts anything, encode with the first possible serialization method
                    if (!ds && aih."*/*") {
                        foreach string k in (MimeDataTypes.keyIterator()) {
                            ds = MimeDataTypes{k}.serialize;
                            if (ds) {
                                rv.body = ds(rv.body);
                                rv.hdr += ("Content-Type": k);
                                break;
                            }
                        }
                        if (!ds) {
                            responseSerializationError(cx, aih, rv);
                            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html: If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.
                            return RestHandler::makeResponse(406, "cannot serialize response; you claim to accept only: %y; types supported: %y; discarding response: %y", aih.keys(), MimeDataTypes.keys(), rv.body);
                        }
                    }
                }

                logDebug("REST DBG: response serialization: %d %s (%d bytes)", rv.code, rv.hdr."Content-Type", rv.body.size());
            }

            #logDebug("REST DBG: rv: %N", rv);

            return rv;
        }

        #! default implementation is empty
        removeRootPath(reference path) {
        }

        #! default implementation is empty
        requestDeserializationError(hash hdr, hash cx, string body) {
        }

        #! default implementation is empty
        responseSerializationError(hash cx, *hash aih, hash rv) {
        }

        #! default implementation is empty; this method is called with informational log messages; reimplement in subclasses to provide for logging
        logInfo(string fmt) {
            delete argv;
        }

        #! default implementation is empty; this method is called with error log messages; reimplement in subclasses to provide for logging
        logError(string fmt) {
            delete argv;
        }

        #! default implementation is empty; this method is called with debug log messages; reimplement in subclasses to provide for logging
        logDebug(string fmt) {
            delete argv;
        }

        #! adds a REST class to the handler
        addClass(AbstractRestClass cls) {
            mx.lock();
            on_exit mx.unlock();

            string name = cls.name();
            if (ch{name})
                throw "RETSHANDLER-ERROR", sprintf("class %y has already been registered with this handler", name);
            ch{name} = cls;
        }

        #! default get handler
        hash get(hash cx, *hash ah) {
            return RestHandler::makeResponse(200, ch.keys());
        }

        #! creates a hash for an HTTP response with the response code and a literal response message body
        static hash makeResponse(int code, any body, *hash hdr) {
            return (
                "code": code,
                "body": body,
                "hdr": hdr,
                );
        }
    }
}
