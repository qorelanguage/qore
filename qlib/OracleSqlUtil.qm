# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file OracleSqlUtil.qm Qore user module for working with Oracle SQL data

/*  OracleSqlUtil.qm Copyright 2013 - 2020 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.9.4

# requires the SqlUtil module
%requires SqlUtil >= 1.6

# requires the Util module
%requires Util >= 1.0

# for bindOracleCollection
%try-module oracle
%define NO_ORACLE
%endtry

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module OracleSqlUtil {
    version = "1.4";
    desc = "user module for working with Oracle SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*  Version History: see docs below
*/

/** @mainpage OracleSqlUtil Module

    @tableofcontents

    @section oraclesqlutilintro OracleSqlUtil Module Introduction

    The %OracleSqlUtil module provides a high level API for working with Oracle database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires OracleSqlUtil" in your code.

    All the public symbols in the module are defined in the OracleSqlUtil namespace

    @note This module requires the <a href="https://github.com/qorelanguage/module-oracle">oracle</a> binary module for communication with Oracle databases

    @section ora_sql_operations SQL Operations on Oracle

    @subsection ora_paging Select With Paging on Oracle

    Select with paging on Oracle is more complicated than on some databases due to the lack of direct \c limit and \c offset
    support (applies to Oracle pre 12c).

    For example, for the following select:
    @code{.py}
my *list $rows = $table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    the following SQL is generated for Oracle with a pre 12c server:
    @code{.py}
$ds.vselectRows("select * from (select /*+ first_rows(100) *<!--%%-->/ a.*, rownum rnum from (select * from schema.table where type = %v order by type) a where rownum <= %v) where rnum > %v", ("user", 300, 200));
    @endcode
    note that the following simpler SQL is generated for Oracle 12c+ servers:
    @code{.py}
$ds.vselectRows("select * from schema.table where type = %v order by type offset %v rows fetch next %v rows only", ("user", 200, 100));
    @endcode

    @subsection ora_in_operator IN Operator on Oracle

    In order to avoid dynamic SQL and better manage the server's shared pool (in particular, the number of parsed statements), the %OracleSqlUtil
    module uses bind by value with the SQL \c IN operator.

    For example, the following query:
    @code{.py}
my *hash $q = $table.select(("where": ("col1": op_in(1, 2, 3, 4))));
    @endcode

    Results in the equivalent of the following SQL:
    @code{.py}
my *hash $q = $ds.select("select * from schema.table where col1 in (select column_value from table(%v))", bindOracleCollection("SYS.ODCIVARCHAR2LIST", (1,2,3,4)));
    @endcode

    |!Qore Type|!Oracle Collection
    |Date|\c SYS.ODCIDATELIST
    |Float|\c SYS.ODCINUMBERLIST
    |Integer|\c SYS.ODCINUMBERLIST
    |Number|\c SYS.ODCINUMBERLIST
    |String|\c SYS.ODCIVARCHAR2LIST

    There universal collections are limited to 32767 elements. And \c SYS.ODCIVARCHAR2LIST element size is \c VARCHAR2(4000).

    @subsection ora_partitioning_select Partition Support in Selects

    It's possible to select from a particular partition of a table with %OracleSqlUtil;
    @ref OracleSqlUtil::OracleTable::OracleSelectOptions "OracleSelectOptions" defines the \c "partition" key which can be added to a
    @ref select_option_hash "select option hash" to specify the partition to select from as in the following example:
    @code{.py}
my *list $rows = $table.selectRows(("created": op_gt(2012-05-01), "partition": "p1"));
    @endcode
    Which generates an SQL command like the following:
    @code{.py}
my *list $rows = $ds.vselectRows("select * from schema.table partition(p1) where created > %v", (2012-05-01));
    @endcode

    @subsection ora_partitioning_join Partition Support in Joins

    It's possible to perform a join on a particular partition of a table with %OracleSqlUtil; the join option \c "partition" is
    supported to specify the partition to join on as in the following example:
    @code{.py}
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid"), NOTHING, ("partition": "p2"))));
    @endcode
    Which generates an SQL command like the following:
    @code{.py}
my *list $rows = $ds.vselectRows("select * from schema.table inner join schema.table2 partition(p2) t2 on (schema.table.id = t2.altid)");
    @endcode

    @section ora_schema_management Schema Management on Oracle

    Note that when getting an object description from an Oracle database, if the object cannot be found in the connection schema, then
    if a synonym of the same type exists and the target object is accessible, then the target object is read automatically and the owning
    schema name is also set to the actual owner of the object.

    @subsection ora_type_mapping Type Mapping

    Column types are mapped from %Qore types as follows:

    <b>Oracle Column Type Mappings</b>
    |!Generic Type Name|!Oracle Type Used
    |\c float|\c number
    |\c integer|\c number
    |\c number|\c number
    |\c string|\c varchar2
    |\c date|\c timestamp(6)
    |\c binary|\c blob
    |@ref SqlUtil::BLOB|\c blob
    |@ref SqlUtil::CHAR|\c char
    |@ref SqlUtil::CLOB|\c clob
    |@ref SqlUtil::NUMERIC|\c number
    |@ref SqlUtil::VARCHAR|\c varchar2

    To use other types, use the \c "native_type" @ref SqlUtil::AbstractTable::ColumnDescOptions "column description option" with the
    native Oracle type name instead (under the \c "driver" and \c "oracle" keys for schemas supporting multiple databases).

    @subsection ora_other_objects Additional Object Types Supported

    The following additional schema objects can be managed with %OracleSqlUtil:
    - @ref ora_materialized_views "materialized views"
    - @ref ora_packages "packages"
    - @ref ora_types "types"

    @subsection ora_materialized_views Materialized Views

    The @ref schema_desc_hash takes an optional key, \c "materialized_views" that allows materialized views in Oracle schemas to be managed along with other objects.

    The \c "materialized_views" should be assigned to a hash, each key name is the name of the materialized view, and the values are hashes with the
    following keys:
    - \c "logging": (@ref bool_type "bool") if the materialized view should be logged
    - \c "use_index": (@ref bool_type "bool") if the materialized view should be indexed
    - \c "src": (@ref bool_type "bool") the source of the materialized view

    The \c "materialized_views" key can go in the top level of the @ref schema_desc_hash for Oracle-only schemas, or, for schemas targeting multiple database types, under the \c "driver" and \c "oracle" keys as in the following example:

    @code{.py}
hash schema = (
    "driver": (
        "oracle": (
            "materialized_views": (
                "example_mv": (
                    "logging": False,
                    "use_index": False,
                    "src": "select type, count(1) total_count from table group by type",
                ),
            ),
        ),
    ),
);
    @endcode

    @subsection ora_packages Packages

    The @ref schema_desc_hash takes an optional key, \c "packages" that allows packages in Oracle schemas to be managed along with other objects.

    The \c "packages" should be assigned to a hash, each key name is the name of the package, and the values are hashes with the
    following key:
    - \c "src": (@ref bool_type "bool") the source of the package

    The \c "packages" key can go in the top level of the @ref schema_desc_hash for Oracle-only schemas, or, for schemas targeting multiple database types, under the \c "driver" and \c "oracle" keys as in the following example:

    @code{.py}
hash schema = (
    "driver": (
        "oracle": (
            "packages": (
                "example_pkg": (
                    "src": "types as
type cursorType is ref cursor;
MYSTATCOMPLETE constant order_status.orderstatus%type := 'C';
MYSTATERROR constant order_status.orderstatus%type := 'E';
",
                ),
            ),
        ),
    ),
);
    @endcode

    @subsection ora_types Types

    The @ref schema_desc_hash takes an optional key, \c "types" that allows types in Oracle schemas to be managed along with other objects.

    The \c "types" should be assigned to a hash, each key name is the name of the type, and the values are strings giving the type definition.

    The \c "types" key can go in the top level of the @ref schema_desc_hash for Oracle-only schemas, or, for schemas targeting multiple database types, under the \c "driver" and \c "oracle" keys as in the following example:

    @code{.py}
hash schema = (
    "driver": (
        "oracle": (
            "types": (
                "num_array": "table of number",
                "str_array": "table of varchar2(240)",
            ),
        ),
    ),
);
    @endcode

    @see OracleSqlUtil::OracleDatabase::OracleSchemaDescriptionOptions for a list of Oracle-specific schema description hash keys.

    @section ora_relnotes Release Notes

    @subsection v14 OracleSqlUtil v1.4
    - added support for the DataProvider module
      (<a href="https://github.com/qorelanguage/qore/issues/3545">issue 3545</a>)

    @subsection v131 OracleSqlUtil v1.3.1
    - fixed quoting of reserved words in column names in table alignment
      (<a href="https://github.com/qorelanguage/qore/issues/3400">issue 3400</a>)

    @subsection v13 OracleSqlUtil v1.3
    - added support for serializing and deserializing @ref SqlUtil::AbstractTable "AbstractTable" objects (<a href="https://github.com/qorelanguage/qore/issues/2663">issue 2663</a>)

    @subsection v125 OracleSqlUtil v1.2.5
    - worked around an Oracle bug in materialized view creation where when the schema user is missing the <tt>CREATE MATERIALIZED VIEW</tt> grant the table backing the view is created but the materialized view itself is not created causing future creation actions to fail (<a href="https://github.com/qorelanguage/qore/issues/2643">issue 2643</a>)

    @subsection v124 OracleSqlUtil v1.2.4
    - implemented support for custom column operators (<a href="https://github.com/qorelanguage/qore/issues/2314">issue 2314</a>)
    - implemented support for chained synonyms (<a href="https://github.com/qorelanguage/qore/issues/2408">issue 2408</a>)
    - allow to use DBA_* views instead of ALL_* if possible (<a href="https://github.com/qorelanguage/qore/issues/2418">issue 2418</a>)

    @subsection v123 OracleSqlUtil v1.2.3
    - fixed a bug in \c character_semantics for standalone column (<a href="https://github.com/qorelanguage/qore/issues/1688">issue 1688</a>)
    - implemented @ref cop_trunc_date() operator (<a href="https://github.com/qorelanguage/qore/issues/2032">issue 2032</a>)

    @subsection v122 OracleSqlUtil v1.2.2
    - fixed a bug in the \a force option (i.e. cascade) for dropping types (<a href="https://github.com/qorelanguage/qore/issues/1683">issue 1683</a>)

    @subsection v121 OracleSqlUtil v1.2.1
    - implemented the \a force option (i.e. cascade) for dropping code objects (<a href="https://github.com/qorelanguage/qore/issues/1314">issue 1314</a>)
    - worked around ORA-22165 from op_in() caused by Oracle's limit on number of collection elements (<a href="https://github.com/qorelanguage/qore/issues/1660">issue 1660</a>)

    @subsection v12 OracleSqlUtil v1.2
    - implemented support for the \c "returning" clause as an insert option
    - implemented support for views for DML in the @ref OracleSqlUtil::OracleTable class
    - implemented @ref OracleSqlUtil::OracleTable::getBaseType()
    - implemented support for Oracle pseudocolumns in queries
    - implemented support for @ref SqlUtil::cop_cast() operator
    - fixed bugs in @ref SqlUtil::cop_seq() and @ref SqlUtil::cop_seq_currval() (<a href="https://github.com/qorelanguage/qore/issues/624">issue 624</a>)
    - return lists from Oracle's data dictionary ordered
    - implemented @ref OracleSqlUtil::OracleTable::bindEmptyStringsAsNull()
    - implemented high-performance "upsert" (merge) support also supporting bulk DML
    - implemented @ref SqlUtil::cop_substr() and @ref SqlUtil::uop_substr() operators (<a href="https://github.com/qorelanguage/qore/issues/801">issue 801</a>)
    - implemented @ref SqlUtil::op_substr() where operator (<a href="https://github.com/qorelanguage/qore/issues/883">issue 883</a>)

    @subsection v11 OracleSqlUtil v1.1
    - fixed selects with "limit" but no "offset"
    - convert date/time values to timestamps with microseconds resolution instead of dates with second resolution when dynamically inserting values as strings in SQL (binding by value not affected)
    - fixed schema information classes when the "string-numbers" driver option is enabled

    @subsection v10 OracleSqlUtil v1.0
    - initial release
*/

#! the OracleSqlUtil namespace contains all the objects in the OracleSqlUtil module
public namespace OracleSqlUtil {
    #! returns an OracleTable object corresponding to the arguments
    public OracleTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
        return new OracleTable(nds, nname, opts);
    }

    #! returns an OracleDatabase object corresponding to the arguments
    public OracleDatabase sub get_database(AbstractDatasource nds, *hash opts) {
        return new OracleDatabase(nds, opts);
    }

    #! Oracle savepoint helper
    public class OracleSavepointHelper inherits AbstractSavepointHelper {
        #! Creates the object
        /** @note Oracle identifiers cannot be longer than 30 character by default; the default savepoint value uses
            the unique hash for the object, which is 40 characters long, so we have to use another algorithm to create
            the savepoint string on Oracle
        */
        constructor(AbstractDatasource ds, *string savepoint = "x" + get_random_string(29)) : AbstractSavepointHelper(ds, savepoint) {
        }

        #! Creates the savepoint
        private createSavepointImpl() {
            ds.exec("savepoint " + savepoint);
        }

        #! Rolls back to the savepoint
        private rollbackImpl() {
            ds.exec("rollback to " + savepoint);
        }

        #! Deletes the savepoint
        private deleteSavepointImpl() {
            # this method intentionally left blank
        }
    }

    #! the data type for Oracle NUMBER columns
    public class OracleNumberDataType inherits SqlUtil::AbstractNumericDataType {
        #! creates the object
        constructor(string native_type, bool nullable, *hash<auto> options) : AbstractNumericDataType(native_type, nullable, options) {
        }
    }

    #! represents an Oracle column
    public class OracleColumn inherits SqlUtil::AbstractColumn {
        public {
            #! the column uses character semantics
            bool char_used;
            #! byte size of the column
            int byte_size;
        }

        #! empty constructor for subclasses
        private constructor() {
        }

        constructor(string n, string nt, *string qt, softint sz, bool nul, *string dv, *string cm, bool is_char = False, bool cu = False, softint bs) : AbstractColumn(n, nt, qt, sz, nul, dv, cm) {
            # only set "char_used" if we are dealing with a char column
            char_used = is_char && cu;
            byte_size = bs;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the colunn to a table or when creating the table)
        string getNativeTypeString() {
            if (char_used)
                return sprintf("%s(%d char)", native_type, size);
            return AbstractColumn::getNativeTypeString();
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code{.py}
list l = col.getAddColumnSql(t);
            @endcode

            @param t the AbstractTable object to modify
         */
        list getAddColumnSql(AbstractTable t) {
            list l += sprintf("alter table %s add %s", t.getSqlName(), AbstractColumn::getCreateSql(t));
            if (comment)
                l += sprintf("comment on column %s.%s is %s", t.getSqlName(), ddl_name, t.getSqlValue(comment));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code{.py}
list l = col.getModifySql(t, newcol);
            @endcode

            The column names are assumed to be equal

            @param t the AbstractTable object to modify
            @param col the new column definition
            @param opt ignored
         */
        list getModifySqlImpl(AbstractTable t, AbstractColumn col, *hash opt) {
            list l = ();
            OracleColumn c = col;

            bool modified;
            string sql = sprintf("alter table %s modify %s", t.getSqlName(), ddl_name);

            # get new native type declaration string
            string nts = c.getNativeTypeString();
            if (getNativeTypeString() != nts) {
                sql += sprintf(" %s", nts);
                modified = True;
            }

            if (def_val != c.def_val) {
                sql += sprintf(" default %s", exists c.def_val ? c.def_val : "null");
                modified = True;
            }

            if (nullable != c.nullable) {
                sql += sprintf(" %snull", c.nullable ? "" : "not ");
                modified = True;
            }
            if (modified)
                l += sql;

            # to remove a comment we set it to the empty string ('')
            # http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_4009.htm
            if (c.comment != comment)
                l += sprintf("comment on column %s.%s is %s", t.getSqlName(), ddl_name, c.comment ? t.getSqlValue(c.comment) : "''");
            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code{.py}
string str = col.getRenameSql(t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("alter table %s rename column %s to %s", t.getSqlName(), ddl_name, getDdlName(new_name));
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equalImpl(AbstractColumn c) {
            return char_used == cast<OracleColumn>(c).char_used;
        }

        #! returns the column name with quoting in case the column name is a reserved word
        /** the name returned here will be used when executing DDL
        */
        string getDdlName(string name) {
            return OracleDatabase::OracleReservedWords{name.lwr()} ? ("\"" + name + "\"") : name;
        }
    }

    #! represents an Oracle number column
    public class OracleNumberColumn inherits OracleColumn, SqlUtil::NumericColumnInfo {
        constructor(string n, string nt, *string qt, softint sz, bool nul, *string dv, *string cm, softint bs, softint n_scale = 0) : OracleColumn(n, nt, qt, sz, nul, dv, cm, False, False, bs), NumericColumnInfo(n_scale) {
        }

        string getNativeTypeString() {
            return NumericColumnInfo::getNativeTypeString(native_type, size);
        }
    }

    #! represents an Oracle index
    public class OracleIndex inherits SqlUtil::AbstractIndex {
        public {
            #! the native type of the index (if supported)
            string native_type;

            #! the tablespace name of the index (if supported)
            *string tablespace;
        }

        #! creates the object from the arguments
        constructor(string n, bool u, hash c, string nt, *string t) : AbstractIndex(n, u, c) {
            native_type = nt;
            tablespace = t;
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.getSqlColumnNameIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            if (opt.compute_statistics)
                sql += " compute statistics";

            return sql;
        }

        #! returns @ref True "True" if the argument is equal to the current index, @ref False "False" if not
        bool equalImpl(AbstractIndex ix) {
            return True;
        }

        #! returns a string that can be used to rename the index in the database
        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter index %s rename to %s", name, new_name);
        }
    }

    #! represents an Oracle foreign constraint
    public class OracleForeignConstraint inherits SqlUtil::AbstractForeignConstraint {
        public {
            #! @ref True "True" if the constraint is enabled, @ref False "False" if not
            bool enabled;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t, bool e) : AbstractForeignConstraint(n, c, t) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, h.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    #! represents an Oracle check constraint
    public class OracleCheckConstraint inherits SqlUtil::AbstractCheckConstraint {
        public {
            #! @ref True "True" if the constraint is enabled, @ref False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool e = True) : AbstractCheckConstraint(n, n_src) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    #! represents an Oracle unique constraint
    public class OracleUniqueConstraint inherits SqlUtil::AbstractUniqueConstraint {
        private {
            #! @ref True "True" if the constraint is enabled, @ref False "False" if not
            bool enabled;

            #! any tablespace for the unique key index
            *string tablespace;
        }

        constructor(string n, hash n_cols, bool e = True, *string ts) : AbstractUniqueConstraint(n, n_cols) {
            enabled = e;
            tablespace = ts;
        }

        #! returns the OracleColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        OracleColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s unique (%s)", table_name, name, (foldl $1 + ", " + $2, getSqlColumnNameIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }

        #! returns @ref True "True" if the constraint is enabled, @ref False "False" if not
        bool isEnabled() {
            return enabled;
        }

        #! returns the tablespace name used for this constraint, if known
        *string getTablespace() {
            return tablespace;
        }
    }

    #! represents an Oracle primary key
    public class OraclePrimaryKey inherits SqlUtil::AbstractPrimaryKey {
        private {
            #! any tablespace for the primary key index
            *string tablespace;
        }

        constructor() {
        }

        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c) {
            tablespace = ts;
        }

        #! returns the OracleColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code{.py}
auto v = c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        OracleColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, getSqlColumnNameIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to drop the constraint from the database
        /** we use "keep index" to ensure that indexes are not dropped automatically for consistency's sake
        */
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop primary key keep index", table_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    #! represents an Oracle sequence
    public class OracleSequence inherits SqlUtil::AbstractSequence {
        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_end) : AbstractSequence(n_name, n_start, n_increment, n_end) {
        }

        #! returns a string that can be used to create the sequence in the database
        string getCreateSql(*hash opt) {
            string sql = sprintf("create sequence %s start with %d increment by %d ", name, start, increment);
            sql += max ? sprintf("maxvalue %d", max) : "nomaxvalue";
            return sql;
        }

        #! returns a string that can be used to rename the sequence in the database
        /** The object is renamed in place with this call
            @param new_name the new name of the object
            @param opt this option is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("rename %s to %s", name, new_name);
        }
    }

    #! represents an Oracle view
    public class OracleView inherits SqlUtil::AbstractView {
        public {
            #! Type clause of the typed view
            *string type_text;
            #! WITH OID clause of the typed view
            *string oid_text;
            #! Owner of the type of the view if the view is a typed view
            *string view_type_owner;
            #! Type of the view if the view is a typed view
            *string view_type;
            #! Name of the superview
            *string superview_name;
            #! Indicates whether the view contains container-specific data
            bool container_data;
        }

        #! creates the object from the arguments
        constructor(string n_name, string n_src, *string n_schema, *string n_type_text,
                    *string n_oid_text, *string n_view_type_owner,
                    *string n_view_type, *string n_superview_name,
                    bool n_updatable, bool n_container_data)
                : AbstractView(n_name, n_src) {
            updatable = n_updatable;
            schema = n_schema;
            type_text = n_type_text;
            oid_text = n_oid_text;
            view_type_owner = n_view_type_owner;
            view_type = n_view_type;
            superview_name = n_superview_name;
            container_data = n_container_data;
        }

        #! returns a string that can be used to create the view in the database
        string getCreateSql(*hash opt) {
            # TODO/FIXME: more oracle options
            return sprintf("create %s%sview %s as %s",
                           opt.replace ? "or replace " : "",
                           opt.force ? "force " : "noforce ",
                           name,
                           src
                          );
        }

        #! returns a string that can be used to rename the view in the database
        /** The object is renamed in place with this call
            @param new_name the new name of the object
            @param opt this option is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("rename %s to %s", name, new_name);
        }
    }

    #! represents an Oracle trigger
    public class OracleTrigger inherits SqlUtil::AbstractTrigger {
        public {
            #! @ref True "True" if the trigger is enabled, @ref False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool en = True) : AbstractTrigger(n, n_src) {
            enabled = en;
        }

        softlist getCreateSql(string table_name, *hash opt) {
            return sprintf("create%s trigger %s %s", opt.replace ? " or replace" : "", name, src);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return enabled == cast<OracleTrigger>(t).enabled;
        }

        #! returns a string that can be used to rename the trigger in the database
        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter trigger %s rename to %s", name, new_name);
        }

        #! returns a string that can be used to drop the trigger from the database
        softlist getDropSql(string table_name) {
            return sprintf("drop trigger %s", name);
        }
    }

    #! the base class for Oracle code objects
    public class OracleCodeBase inherits SqlUtil::AbstractFunction {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : AbstractFunction(n, n_type, n_src) {
        }

        #! returns a string that can be used to create the object in the database
        /** @param opt create options; if \a replace is @ref True "True", then <tt>CREATE OR REPLACE</tt> will be used in the create statement
         */
        softlist getCreateSql(*hash opt) {
            return sprintf("create%s %s %s", opt.replace ? " or replace" : "", type, src);
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the object in the database
        /** The object is renamed in place with this call
            @param new_name the new name of the object
            @param opt this option is ignored
         */
        softlist getRenameSql(string new_name, *hash opt) {
            return sprintf("rename %s to %s", name, new_name);
        }
    }

    #! the base class for Oracle code objects that cannot be renamed in place
    public class OracleCodeBaseNoRename inherits OracleCodeBase {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : OracleCodeBase(n, n_type, n_src) {
        }

        #! returns a string that can be used to rename the object in the database
        /** The object is dropped and recreated with this method call

            @param new_name the new name of the object
            @param opt rename options; if \a force if @ref True "True", then the \c FORCE option will be used with the drop statement
         */
        softlist getRenameSql(string new_name, *hash opt) {
            list l = ();
            l += getDropSql(opt);
            l += getCreateSql();
            return l;
        }
    }

    #! represents an Oracle type
    public class OracleType inherits OracleCodeBaseNoRename {
        constructor(string n_name, string n_src) : OracleCodeBaseNoRename(n_name, "type", n_src) {
        }

        #! returns a string that can be used to drop the type from the database
        /** @param opt drop options; if \a force is @ref True "True", then the \c FORCE option will be used in the drop statement
         */
        string getDropSql(*hash opt) {
            return sprintf("drop %s %s%s", type, name, opt.force ? " force" : "");
        }
    }

    #! represents an Oracle function
    public class OracleFunction inherits OracleCodeBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleCodeBase(n, "function", n_src) {
        }
    }

    #! represents an Oracle procedure
    public class OracleProcedure inherits OracleCodeBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleCodeBase(n, "procedure", n_src) {
        }
    }

    #! represents an Oracle package
    public class OraclePackage inherits OracleCodeBaseNoRename {
        public {
            #! package body source
            *string body_src;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the package
            @param n_src the source of the package declaration
            @param n_body_src the package body source
         */
        constructor(string n, string n_src, *string n_body_src) : OracleCodeBaseNoRename(n, "package", n_src) {
            body_src = n_body_src;
        }

        #! returns a string that can be used to create the package in the database
        list getCreateSql(*hash opt) {
            list l = ();
            # package declaration
            l += sprintf("create%s package %s", opt.replace ? " or replace" : "", src);
            # package body
            if (body_src)
                l += sprintf("create%s package body %s", opt.replace ? " or replace" : "", body_src);
            return l;
        }

        #! returns @ref True "True" if the argument is equal to the current object, @ref False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return body_src == cast<OraclePackage>(t).body_src;
        }
    }

    #! represents an Oracle materialized view
    public class OracleMaterializedView inherits OracleCodeBaseNoRename {
        public {
            #! Flag if is loggign mode used
            bool logging;
            #! Flag if is index used
            bool use_index;
            #! Name of the potential tablespace
            *string tablespace;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the materialized view
            @param n_src the source of the materialized view
            @param n_tablespace the optional data tablespace used by the materialized view
            @param n_logging if the materialized view should use logging
            @param n_use_index if the materialized view should use an index
         */
        constructor(string n, string n_src, bool n_logging = True, bool n_use_index = True, *string n_tablespace) : OracleCodeBaseNoRename(n, "materialized view", n_src) {
            logging = n_logging;
            use_index = n_use_index;
            tablespace = n_tablespace;
        }

        #! returns a string that can be used to create the object in the database
        softlist getCreateSql(*hash opt) {
            string sql = sprintf("create %s %s", type, name);

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            sql += logging ? " logging" : " nologging";
            sql += use_index ? " using index" : " using no index";

            sql += " as " + src;

            return sql;
        }

        bool equalImpl(AbstractFunctionBase t) {
            OracleMaterializedView mv = cast<OracleMaterializedView>(t);
            return mv.logging == logging && mv.use_index == use_index;
        }
    }

    #! the Oracle specialization for SqlUtil::AbstractDatabase
    public class OracleDatabase inherits SqlUtil::AbstractDatabase {
        public {
            #! oracle-specific generic creation options
            const OracleCreationOptions = AbstractDatabase::CreationOptions + (
                "compute_statistics": Type::Boolean,
                );

            #! oracle-specific schema description / alignment options
            const OracleAlignSchemaOptions = AbstractDatabase::AlignSchemaOptions
                + OracleCreationOptions
                + OracleTable::OracleAlignTableOptions
                ;

            #! oracle-specific schema description keys
            /** This constant extends @ref SqlUtil::AbstractDatabase::SchemaDescriptionOptions as returned by @ref OracleSqlUtil::OracleDatabase::getSchemaDescriptionOptions with the following Oracle-specific keys:
                - \c types: for Oracle type definitions
                - \c type_map: to automatically renaming Oracle types during schema alignment
                - \c packages: for Oracle package descriptions
                - \c package_map: for automatically renaming Oracle types during schema alignment
                - \c materialized_views: for Oracle materialized view descriptions
                - \c materialized_view_map: for automatically renaming Oracle materialized views during schema alignment
            */
            const OracleSchemaDescriptionOptions = AbstractDatabase::SchemaDescriptionOptions + (
                "types": Type::Hash,
                "type_map": Type::Hash,

                "packages": Type::Hash,
                "package_map": Type::Hash,

                "materialized_views": Type::Hash,
                "materialized_view_map": Type::Hash,

                #"synonyms": Type::Hash,
                #"synonym_map": Type::Hash,
                );

            #! oracle-specific package description options
            const OraclePackageDescriptionOptions = (
                "src": Type::String,
                "body": Type::String,
                );

            #! oracle-specific materialized view description options
            const OracleMaterializedViewDescriptionOptions = (
                "logging": Type::Boolean,
                "use_index": Type::Boolean,
                "tablespace": Type::String,
                "src": Type::String,
                );

            #! hash of reserved words
            const OracleReservedWords = (
                "access": True,
                "else": True,
                "modify": True,
                "start": True,
                "add": True,
                "exclusive": True,
                "noaudit": True,
                "select": True,
                "all": True,
                "exists": True,
                "nocompress": True,
                "session": True,
                "alter": True,
                "file": True,
                "not": True,
                "set": True,
                "and": True,
                "float": True,
                "notfound": True,
                "share": True,
                "any": True,
                "for": True,
                "nowait": True,
                "size": True,
                "arraylen": True,
                "from": True,
                "null": True,
                "smallint": True,
                "as": True,
                "grant": True,
                "number": True,
                "sqlbuf": True,
                "asc": True,
                "group": True,
                "of": True,
                "successful": True,
                "audit": True,
                "having": True,
                "offline": True,
                "synonym": True,
                "between": True,
                "identified": True,
                "on": True,
                "sysdate": True,
                "by": True,
                "immediate": True,
                "online": True,
                "table": True,
                "char": True,
                "in": True,
                "option": True,
                "then": True,
                "check": True,
                "increment": True,
                "or": True,
                "to": True,
                "cluster": True,
                "index": True,
                "order": True,
                "trigger": True,
                "column": True,
                "initial": True,
                "pctfree": True,
                "uid": True,
                "comment": True,
                "insert": True,
                "prior": True,
                "union": True,
                "compress": True,
                "integer": True,
                "privileges": True,
                "unique": True,
                "connect": True,
                "intersect": True,
                "public": True,
                "update": True,
                "create": True,
                "into": True,
                "raw": True,
                "user": True,
                "current": True,
                "is": True,
                "rename": True,
                "validate": True,
                "date": True,
                "level": True,
                "resource": True,
                "values": True,
                "decimal": True,
                "like": True,
                "revoke": True,
                "varchar": True,
                "default": True,
                "lock": True,
                "row": True,
                "varchar2": True,
                "delete": True,
                "long": True,
                "view": True,
                "desc": True,
                "maxextents": True,
                "rowlabel": True,
                "whenever": True,
                "distinct": True,
                "minus": True,
                "rownum": True,
                "where": True,
                "drop": True,
                "mode": True,
                "rows": True,
                "with": True,
                );

            #! Options for rebuildIndex()
            const OracleRebuildIndexOptions = (
                "parallel"          : Type::Boolean,
                "logging"           : Type::Boolean,
                "statictics"        : Type::Boolean,
                "tablespace"        : Type::String,
                "cond_rebuild"      : Type::Boolean,
                "cond_maxheight"    : Type::Int,
                "cond_maxleafpct"   : Type::Int,
                );

            #! Options for computeStatistics()
            const OracleComputeStatisticsOptions = ComputeStatisticsOptions + (
                "estimate_percent"  : Type::Int,
                "block_sample"      : Type::Boolean,
                "method_opt"        : Type::String,
                "degree"            : Type::Int,
                "granularity"       : Type::String,
                "cascade"           : Type::Boolean,
                "stattab"           : Type::String,
                "statid"            : Type::String,
                "options"           : Type::String,
                "statown"           : Type::String,
                );
        }

        #! creates the object from the arguments given
        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
        }

        private list<string> featuresImpl() {
            return (
                DB_FUNCTIONS,
                DB_MVIEWS,
                DB_PACKAGES,
                DB_PROCEDURES,
                DB_SEQUENCES,
                DB_TABLES,
                DB_TYPES,
                DB_VIEWS,
                DB_SYNONYMS,
            );
        }

        private OracleSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return new OracleSequence(name, start, increment, end);
        }

        private getSchemaName(reference<string> name, reference<string> schema) {
            # see if there is a schema in the name
            *string sstr = (name =~ x/^(\w+)\.\w+/)[0];
            if (sstr) {
                schema = sstr;
                splice name, 0, schema.size() + 1;
            }
            else
                schema = ds.getUserName();
        }

        private *AbstractSequence getSequenceImpl(string name) {
            string schema;
            getSchemaName(\name, \schema);

            *hash<auto> row = ds.selectRow("select * from all_sequences where sequence_owner = %v and sequence_name = %v", schema.upr(), name.upr());
            if (!row)
                return;
            return new OracleSequence(name, row.min_value, row.increment_by, row.max_value > 9000000000000000000n ? NOTHING : row.max_value);
        }

        private *AbstractView getViewImpl(string name) {
            string schema;
            getSchemaName(\name, \schema);

            *hash<auto> row = ds.selectRow("select * from all_views where owner = %v and view_name = %v", schema.upr(), name.upr());
            if (!row)
                return;

            HashIterator it(row);
            while (it.next()) {
                if (it.getValue() == NULL)
                    row{it.getKey()} = NOTHING;
            }

            return new OracleView(name, row.text, schema, row.type_text,
                                  row.oid_text, row.view_type_owner,
                                  row.view_type, row.superview_name,
                                  row.read_only == 'N', row.container_data == 'Y');
        }

        private OracleFunction makeFunctionImpl(string name, string src, *hash opts) {
            checkSource("function", name, \src);

            return new OracleFunction(name, src);
        }

        private OracleProcedure makeProcedureImpl(string name, string src, *hash opts) {
            checkSource("procedure", name, \src);

            return new OracleProcedure(name, src);
        }

        private OraclePackage makePackage(string name, string src, string body, *hash opts) {
            checkSource("package", name, \src);

            return new OraclePackage(name, src, body);
        }

        private OraclePackage makePackageFromDescription(string name, hash ph, *hash opts) {
            validateOptionsIntern("PACKAGE-DESCRIPTION-ERROR", OraclePackageDescriptionOptions, \ph);
            if (!ph.src)
                throw "PACKAGE-DESCRIPTION-ERROR", sprintf("package %y: description hash has no 'src' key (keys: %y)", name, ph.keys());

            checkSource("package", name, \ph.src);
            if (ph.body)
                checkSource("package", name, \ph.body);

            return new OraclePackage(name, ph.src, ph.body);
        }

        private OracleType makeType(string name, string src, *hash opts) {
            return new OracleType(name, sprintf("%s as %s", name, src));
        }

        private OracleMaterializedView makeMaterializedView(string name, string src, bool logging = True, bool use_index = True, *string tablespace, *hash opts) {
            return new OracleMaterializedView(name, src, logging, use_index, tablespace);
        }

        private OracleMaterializedView makeMaterializedViewFromDescription(string name, hash mvh, *hash opts) {
            validateOptionsIntern("MATERIALIZEDVIEW-DESCRIPTION-ERROR", OracleMaterializedViewDescriptionOptions, \mvh);
            if (!mvh.src)
                throw "MATERIALIZEDVIEW-DESCRIPTION-ERROR", sprintf("materialized view %y: description hash has no 'src' key (keys: %y)", name, mvh.keys());

            return new OracleMaterializedView(name, mvh.src, mvh.logging, mvh.use_index, mvh.tablespace);
        }

        private list getDropSchemaSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                # drop materialized views
                list tl = dropSqlUnlocked("materialized_view", schema_hash, \getMaterializedView(), \makeMaterializedViewFromDescription(), opt, Type::Hash);
                if (tl) l += tl;

                # drop packages
                tl = dropSqlUnlocked("package", schema_hash, \getPackage(), \makePackageFromDescription(), opt, Type::Hash);
                if (tl) l += tl;

                return l;
            }

            # drop types
            list tl = dropSqlUnlocked("type", schema_hash, \getType(), \makeType(), opt, Type::String);
            if (tl) l += tl;

            return l;
        }

        private list getAlignSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                # create types
                list tl = alignCodeUnlocked("type", schema_hash, \getType(), \makeType(), opt, Type::String);
                if (tl) l += tl;

                return l;
            }

            # create packages
            list tl = alignCodeUnlocked("package", schema_hash, \getPackage(), \makePackageFromDescription(), opt, Type::Hash);
            if (tl) l += tl;

            # create materialized views
            if (!opt.error_callback) {
                opt.error_callback = \oracleErrorCallback();
            }
            tl = alignCodeUnlocked("materialized_view", schema_hash, \getMaterializedView(), \makeMaterializedViewFromDescription(), opt, Type::Hash);
            if (tl) l += tl;

            return l;
        }

        private *OracleFunction getFunctionImpl(string name) {
            *string src = getSource("FUNCTION", name);
            if (!src)
                return;

            return new OracleFunction(name, src);
        }

        private *OracleProcedure getProcedureImpl(string name) {
            *string src = getSource("PROCEDURE", name);
            if (!src)
                return;

            return new OracleProcedure(name, src);
        }

        #! returns an OraclePackage object for the package name given or @ref nothing if the object does not exist or is not accessible
        *OraclePackage getPackage(string name) {
            *string src = getSource("PACKAGE", name);
            if (!src)
                return;

            *string body_src = getSource("PACKAGE BODY", name);
            return new OraclePackage(name, src, body_src);
        }

        #! returns an OracleType object for the package name given or @ref nothing if the object does not exist or is not accessible
        *OracleType getType(string name) {
            *string src = getSource("TYPE", name);
            if (!src)
                return;

            return new OracleType(name, src);
        }

        #! returns an OracleMaterializedView object for the package name given or @ref nothing if the object does not exist or is not accessible
        *OracleMaterializedView getMaterializedView(string name) {
            *hash<auto> row = ds.selectRow("select * from user_mviews mv, user_tables t where mview_name = %v and mview_name = table_name", name.upr());
            if (!row)
                return;

            if (!native_case)
                map row.$1 = row.$1.lwr(), ("tablespace_name");

            return new OracleMaterializedView(name, row.query, row.logging == "YES", row.use_no_index == "N", row.tablespace_name);
        }

        private *string getSource(string type, string name) {
            *list l = ds.select("select text from user_source where type = %v and name = %v order by line", type, name.upr()).text;
            if (!l)
                return;
            string src = foldl $1 + $2, l;

            if (!regex(src, "^" + type + "([[:blank:]]|$)", RE_Caseless))
                throw "SOURCE-ERROR", sprintf("source to %s %y does not begin with the type name %y; source: %y", type, name, type, src.substr(0, 50));

            # remove the type name from the beginning of the string
            splice src, 0, type.size() + 1;

            checkSource(type, name, \src);
            return src;
        }

        private checkSource(string type, string name, reference<string> src) {
            # remove whitespace from the beginning and end of the string
            trim src;

            # ensure the name of the object is at the beginning of the string
            if (!regex(src, "^(\")?" + name + "(\")?", RE_Caseless))
                throw "SOURCE-ERROR", sprintf("source to %s %y does not begin with the %s name %y; source: %y", type, name, type, name, src.substr(0, 50));
        }

        #! returns a list of string synonym names in the database
        list<string> listSynonyms() {
            return getListIntern("SYNONYM");
        }

        #! returns an iterator listing the string synonym names in the database
        ListIterator synonymIterator() {
            return listSynonyms().iterator();
        }

        #! returns a list of string type names in the database
        list<string> listTypes() {
            return getListIntern("TYPE");
        }

        #! returns an iterator listing the string type names in the database
        ListIterator typeIterator() {
            return listTypes().iterator();
        }

        #! returns a list of string package names in the database
        list<string> listPackages() {
            return getListIntern("PACKAGE");
        }

        #! returns an iterator listing the string package names in the database
        ListIterator packageIterator() {
            return listPackages().iterator();
        }

        #! returns a list of string materialized view names in the database
        list<string> listMaterializedViews() {
            return getListIntern("MATERIALIZED VIEW");
        }

        #! returns an iterator listing the string materialized view names in the database
        ListIterator materializedViewIterator() {
            return listMaterializedViews().iterator();
        }

        private list<string> listTablesImpl() {
            list<string> l = getListIntern(ds.select("select table_name from user_tables order by 1").table_name);

            # add all tables accessible with synonyms
            *list<string> tl = ds.select("select synonym_name from user_synonyms s, all_tables t where s.table_owner = t.owner and s.table_name = t.table_name order by 1").synonym_name;
            if (tl)
                l += native_case ? tl : (map $1.lwr(), tl);

            return l;
        }

        private list<string> listFunctionsImpl() {
            return getListIntern("FUNCTION");
        }

        private list<string> listProceduresImpl() {
            return getListIntern("PROCEDURE");
        }

        private list<string> listSequencesImpl() {
            return getListIntern("SEQUENCE");
        }

        private list<string> listViewsImpl() {
            return getListIntern("VIEW");
        }

        private list<string> getListIntern(string type) {
            return getListIntern(ds.select("select object_name from user_objects where object_type = %v order by 1", type).object_name);
        }

        private list<string> getListIntern(list<auto> l) {
            return native_case ? l : (map $1.lwr(), l);
        }

        private string getCreateSqlImpl(list l) {
            return OracleDatabase::getCreateSql(l);
        }

        static string getCreateSql(list l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l);
        }

        #! returns driver-specific options to the base abstract class
        private hash getCreationOptions() {
            return OracleCreationOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getAlignSchemaOptions() {
            return OracleAlignSchemaOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getSchemaDescriptionOptions() {
            return OracleSchemaDescriptionOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getRebuildIndexOptions() {
            return OracleRebuildIndexOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getComputeStatisticsOptions() {
            return OracleComputeStatisticsOptions;
        }

        #! returns the next value in the given sequence
        private softint getNextSequenceValueImpl(string name) {
            return ds.selectRow("select %s.nextval from dual", name).nextval;
        }

        #! returns the last value issued for the given sequence in the current session
        private softint getCurrentSequenceValueImpl(string name) {
            return ds.selectRow("select %s.currval from dual", name).nextval;
        }

        #! returns @ref True "True" if the database supports sequences
        private bool supportsSequencesImpl() {
            return True;
        }

        #! returns @ref True "True" if the database supports named types
        private bool supportsTypesImpl() {
            return True;
        }

        #! returns @ref True "True" if the database supports packages
        private bool supportsPackagesImpl() {
            return True;
        }

        #! analyze index with ALTER INDEX ANAYZE. Then it checks INDEX_STATS for advices to rebuild.
        /** Outputs of this method are hints only. Real investigation of index is strongly recommended.

            @warning content of this method can be changed anytime when there will be any better way how to analyze indexes.

            @param index an AbstractIndex to analyze
            @param maxh maximum oracle index height before rebuilding index
            @param maxleaf maximum oracle percentage of deleted leaf nodes before rebuilding index

            @return bool True for "suggested for rebuilding", False for "no action needed"

            @throws ANALYZE-INDEX-ERROR if there are no data in INDEX_STATS table
        */
        bool rebuildIndexAnalyze(AbstractIndex index, int maxh, int maxleaf) {
            return rebuildIndexAnalyze(index.name, maxh, maxleaf);
        }

        #! analyze index with ALTER INDEX ANAYZE. Then it checks INDEX_STATS for advices to rebuild.
        /** Outputs of this method are hints only. Real investigation of index is strongly recommended.

            @warning content of this method can be changed anytime when there will be any better way how to analyze indexes.

            @param name index name
            @param maxh maximum oracle index height before rebuilding index
            @param maxleaf maximum oracle percentage of deleted leaf nodes before rebuilding index

            @return bool True for "suggested for rebuilding", False for "no action needed"

            @throws ANALYZE-INDEX-ERROR if there are no data in INDEX_STATS table
        */
        bool rebuildIndexAnalyze(string name, int maxh, int maxleaf) {
            # unfortunately analyze index/select * from index_stats requires one transaction
            ds.select("analyze index " + name + " validate structure");
            *hash<auto> is = ds.selectRow("select name, height, lf_rows as leafrows, del_lf_rows as leafrowsdeleted from index_stats");
            if (!is)
                return False;

            softfloat pct = is.leafrows ? float(is.leafrowsdeleted) * 100 / is.leafrows : 0;
            return is.height > maxh || (is.leafrowsdeleted > 0 && pct > maxleaf);
        }

        #! rebuild index implementation. See @ref SqlUtil::AbstractDatabase::rebuildIndex()
        private bool rebuildIndexImpl(string name, *hash options) {
            bool rebuild = True;
            # this conditional rebuilding is still place to be used carefully.
            # See eg. https://richardfoote.wordpress.com/2011/05/22/del_lf_rows-index-rebuild-criteria-codex/
            if (options.cond_rebuild) {
                int maxh = options.cond_maxheight ?? 20;
                int maxleaf = options.cond_maxleafpct ?? 3;
                rebuild = rebuildIndexAnalyze(name, maxh, maxleaf);
            }

            if (!rebuild)
                return False;

            string sql = sprintf("alter index %s rebuild ", name);
            sql += options.parallel ? "parallel " : "";
            sql += options.logging ? "" : "nologging ";
            sql += options.statictics ? "compute statistics" : "";
            if (strlen(options.tablespace))
                sql += " tablespace " + options.tablespace;

            ds.select(sql);
            return True;
        }

        #! compute statistics implementation. See @ref SqlUtil::AbstractDatabase::computeStatistics()
        private computeStatisticsImpl(*hash options) {
            if (options.tables)
                return computeStatisticsTablesImpl(options);
            else
                return computeStatisticsSchemaImpl(options);
        }

        #! compute statistics for schema - a helper method
        private computeStatisticsSchemaImpl(*hash options) {
            string sql = "begin
            dbms_stats.gather_schema_stats(
                                        ownname => %v,
                                        estimate_percent => %s,
                                        block_sample => %s,
                                        method_opt => %v,
                                        degree => %v,
                                        granularity => %v,
                                        cascade => %s,
                                        stattab => %v,
                                        statid => %v,
                                        options => %v,
                                        statown => %v
                                    );
            end;";

            ds.select(sql,  ds.getUserName(),
                            options.estimate_percent ?? "dbms_stats.auto_sample_size",
                            options.block_sample ? "true" : "false",
                            options.method_opt ?? "for all columns size auto",
                            options.degree ?? NULL,
                            options.granularity ?? "all",
                            !exists options.cascade ? "dbms_stats.auto_cascade" : options.cascade ? "true" : "false",
                            options.stattab ?? NULL,
                            options.statid ?? NULL,
                            options.options ?? "gather auto",
                            options.statown ?? NULL
                     );
        }

        #! compute statistics for table(s) - a helper method
        private computeStatisticsTablesImpl(*hash options) {
            string sql = "begin
                dbms_stats.gather_table_stats (
                                        ownname => %v,
                                        tabname => %v,
                                        partname => %v,
                                        estimate_percent => %s,
                                        block_sample => %s,
                                        method_opt => %v,
                                        degree => %v,
                                        granularity => %v,
                                        cascade => %s,
                                        stattab => %v,
                                        statid => %v,
                                        statown => %v
                                    );
                end;";

            foreach string i in (options.tables) {
                ds.select(sql,  ds.getUserName(),
                                i,
                                options.partname ?? NULL,
                                options.estimate_percent ?? "dbms_stats.auto_sample_size",
                                options.block_sample ? "true" : "false",
                                options.method_opt ?? "for all columns size auto",
                                options.degree ?? NULL,
                                options.granularity ?? "all",
                                options.cascade ? "true" : "false",
                                options.stattab ?? NULL,
                                options.statid ?? NULL,
                                options.statown ?? NULL
                         );
            }
        }

        #! reclaim space implementation. See @ref SqlUtil::AbstractDatabase::reclaimSpace()
        private reclaimSpaceImpl(*hash options) {
            string sql = "alter table %s shrink space cascade";
            softlist tables = options.tables ? options.tables : listTables();

            foreach string i in (tables.iterator()) {
                ds.select(sql, i);
            }
        }

        #! @ref SqlUtil::AbstractDatabase.getPhysicalSize()
        private int getPhysicalSizeImpl() {
            return ds.selectRow("select sum(bytes) as val from user_segments").val ?? GET_PHYSICAL_DB_SIZE_NOVAL;
        }

        private oracleErrorCallback(int ac, string type, string name, *string table, *string new_name, *string info, string sql, hash<ExceptionInfo> ex) {
            # issue #2643: if there is an ORA-01031 "insufficient privileges" error creating a materialized view,
            # try to drop any table possibly created due to an Oracle bug
            if (ac == AC_Create && type == "materialized_view" && ex.arg.alterr == "OCI-01031") {
                # try to drop any table created to back the materialized view, ignoring ORA-00942
                # "table or view does not exist" errors but rethrowing all others
                ds.exec("begin execute immediate 'drop table " + name + "'; exception when others then if sqlcode != -942 then raise; end if; end;", name);
            }
        }
   }

    #! represents an Oracle table
    /** this is the specialization of SqlUtil::AbstractTable
    */
    public class OracleTable inherits SqlUtil::AbstractTable {
        public {
            #! maps oracle type names to type descriptions
            const OraTypeMap = {
                "number": ("qore": Type::Number, "size": SZ_NUM, "size_range": (1, 38), "scale_range": (-84, 127)),
                "varchar2": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "char": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "date": ("qore": Type::Date,),
                "timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "timestamp with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "timestamp with local time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "interval year to month": ("qore": Type::Date,),
                "interval day to second": ("qore": Type::Date,),
                "timestamp(0)": ("qore": Type::Date,),
                "timestamp(1)": ("qore": Type::Date,),
                "timestamp(2)": ("qore": Type::Date,),
                "timestamp(3)": ("qore": Type::Date,),
                "timestamp(4)": ("qore": Type::Date,),
                "timestamp(5)": ("qore": Type::Date,),
                "timestamp(6)": ("qore": Type::Date,),
                "timestamp(7)": ("qore": Type::Date,),
                "timestamp(8)": ("qore": Type::Date,),
                "timestamp(9)": ("qore": Type::Date,),
                "timestamp(0) with time zone": ("qore": Type::Date,),
                "timestamp(1) with time zone": ("qore": Type::Date,),
                "timestamp(2) with time zone": ("qore": Type::Date,),
                "timestamp(3) with time zone": ("qore": Type::Date,),
                "timestamp(4) with time zone": ("qore": Type::Date,),
                "timestamp(5) with time zone": ("qore": Type::Date,),
                "timestamp(6) with time zone": ("qore": Type::Date,),
                "timestamp(7) with time zone": ("qore": Type::Date,),
                "timestamp(8) with time zone": ("qore": Type::Date,),
                "timestamp(9) with time zone": ("qore": Type::Date,),
                "timestamp(0) with local time zone": ("qore": Type::Date,),
                "timestamp(1) with local time zone": ("qore": Type::Date,),
                "timestamp(2) with local time zone": ("qore": Type::Date,),
                "timestamp(3) with local time zone": ("qore": Type::Date,),
                "timestamp(4) with local time zone": ("qore": Type::Date,),
                "timestamp(5) with local time zone": ("qore": Type::Date,),
                "timestamp(6) with local time zone": ("qore": Type::Date,),
                "timestamp(7) with local time zone": ("qore": Type::Date,),
                "timestamp(8) with local time zone": ("qore": Type::Date,),
                "timestamp(9) with local time zone": ("qore": Type::Date,),
                "interval year(0) to month": ("qore": Type::Date,),
                "interval year(1) to month": ("qore": Type::Date,),
                "interval year(2) to month": ("qore": Type::Date,),
                "interval year(3) to month": ("qore": Type::Date,),
                "interval year(4) to month": ("qore": Type::Date,),
                "interval year(5) to month": ("qore": Type::Date,),
                "interval year(6) to month": ("qore": Type::Date,),
                "interval year(7) to month": ("qore": Type::Date,),
                "interval year(8) to month": ("qore": Type::Date,),
                "interval year(9) to month": ("qore": Type::Date,),
                "interval day(0) to second(0)": ("qore": Type::Date,),
                "interval day(0) to second(1)": ("qore": Type::Date,),
                "interval day(0) to second(2)": ("qore": Type::Date,),
                "interval day(0) to second(3)": ("qore": Type::Date,),
                "interval day(0) to second(4)": ("qore": Type::Date,),
                "interval day(0) to second(5)": ("qore": Type::Date,),
                "interval day(0) to second(6)": ("qore": Type::Date,),
                "interval day(0) to second(7)": ("qore": Type::Date,),
                "interval day(0) to second(8)": ("qore": Type::Date,),
                "interval day(0) to second(9)": ("qore": Type::Date,),
                "interval day(1) to second(0)": ("qore": Type::Date,),
                "interval day(1) to second(1)": ("qore": Type::Date,),
                "interval day(1) to second(2)": ("qore": Type::Date,),
                "interval day(1) to second(3)": ("qore": Type::Date,),
                "interval day(1) to second(4)": ("qore": Type::Date,),
                "interval day(1) to second(5)": ("qore": Type::Date,),
                "interval day(1) to second(6)": ("qore": Type::Date,),
                "interval day(1) to second(7)": ("qore": Type::Date,),
                "interval day(1) to second(8)": ("qore": Type::Date,),
                "interval day(1) to second(9)": ("qore": Type::Date,),
                "interval day(2) to second(0)": ("qore": Type::Date,),
                "interval day(2) to second(1)": ("qore": Type::Date,),
                "interval day(2) to second(2)": ("qore": Type::Date,),
                "interval day(2) to second(3)": ("qore": Type::Date,),
                "interval day(2) to second(4)": ("qore": Type::Date,),
                "interval day(2) to second(5)": ("qore": Type::Date,),
                "interval day(2) to second(6)": ("qore": Type::Date,),
                "interval day(2) to second(7)": ("qore": Type::Date,),
                "interval day(2) to second(8)": ("qore": Type::Date,),
                "interval day(2) to second(9)": ("qore": Type::Date,),
                "clob": ("qore": Type::String,),
                "blob": ("qore": Type::Binary,),
                "long": ("qore": Type::Binary,),
                "raw": ("qore": Type::Binary, "size": SZ_MAND, "size_range": (1, 2000)),
                "bfile": ("qore": Type::Binary,),
                "binary_float": ("qore": Type::Float,),
                "binary_double": ("qore": Type::Float,),
                "rowid": ("qore": Type::String,),
                "urowid": ("qore": Type::String, "size": SZ_OPT, "size_range": (1, 4000)),
            };

            #! maps qore type names to an oracle type
            const QoreTypeMap = {
                "integer": "number",
                "float": "number",
                "number": "number",
                "string": "varchar2",
                "date": "timestamp(6)",
                "binary": "blob",
                SqlUtil::CHAR: "char",
                SqlUtil::CLOB: "clob",
                SqlUtil::BLOB: "blob",
            };

            const OraColumnOpts = {
                "character_semantics": Type::Boolean,
            };

            #! Oracle-specific column options
            /** this constant extends @ref SqlUtil::AbstractTable::ColumnOptions as returned by \c OracleSqlUtil::OracleTable::getColumnOptions() with the following keys:
                - \c character_semantics: adds "char" to the column type name for applicable character columns to use character semantics for the column
            */
            const OraColumnOptions = AbstractTable::ColumnOptions + OraColumnOpts;

            #! Oracle-specific column options
            /** this constant extends @ref SqlUtil::AbstractTable::ColumnDescOptions as returned by \c OracleSqlUtil::OracleTable::getColumnDescOptions() with the following keys:
                - \c character_semantics: to specify that applicable character columns use character semantics in the column definition
            */
            const OraColumnDescOptions = AbstractTable::ColumnDescOptions + OraColumnOpts;

            #! Oracle-specific index options
            /** this constant extends @ref SqlUtil::AbstractTable::IndexOptions as returned by \c OracleSqlUtil::OracleTable::getIndexOptions() with the following keys:
                - \c compute_statistics: adds "compute statistics" to index creation strings
            */
            const OracleIndexOptions = AbstractTable::IndexOptions + {
                "compute_statistics": Type::Boolean,
            };

            #! Oracle-specific constraint options
            /** this constant extends @ref OracleIndexOptions as returned by \c OracleSqlUtil::OracleTable::getConstraintOptions() with the following keys:
                - \c index: adds "using index <indexname>" to the constraint creation string
            */
            const OracleConstraintOptions = OracleIndexOptions + {
                "index": Type::String,
            };

            #! Oracle table creation options
            const OracleTableCreationOptions = AbstractTable::TableCreationOptions
                + OracleConstraintOptions
                + OraColumnOptions
                ;

            const OracleAlignTableOptions = AbstractTable::AlignTableOptions + OracleTableCreationOptions;

            #! Oracle select options
            /** This constant extends @ref SqlUtil::AbstractTable::SelectOptions with the following options as returned by
                @ref OracleSqlUtil::OracleTable::getSelectOptions():
                - \c partition: the partition name to use in a query (see @ref ora_partitioning_select)
            */
            const OracleSelectOptions = AbstractTable::SelectOptions + {
                "partition": Type::String,
            };

            #! where operator specializations for Oracle
            const OracleOpMap = DefaultOpMap + (
                OP_IN: (
                    "code": string sub (object t, string cn, softlist arg, reference<list> args, *hash jch, bool join = False, *hash ch, *hash psch) {
%ifndef NO_ORACLE
                        # Qorus bug #989 SqlUtil: oracle op_in can fail in large amount of input elements
                        # There is no support for CLOBs in WHERE clause in Oracle at all.
                        # Binding large strings (over 4000 chars is performed by a CLOB in Qore driver.
                        # Result of op_in operator can be "ORA-00932: inconsistent datatypes" if is
                        # the list longer or if it contains large items with:
                        # return cn + " in (select regexp_substr(%v,'[^,]+', 1, level) from dual connect by regexp_substr(%v, '[^,]+', 1, level) is not null)";

                        # determine list members type. Let's assume the 1st non NULL/NOTHING
                        # element gives the type code for all elements.
                        ListIterator it(arg);
                        int ltype;
                        while (it.next()) {
                            switch (it.getValue().typeCode()) {
                                case NT_NULL:
                                case NT_NOTHING:
                                    continue;
                                case NT_DATE:
                                case NT_INT:
                                case NT_FLOAT:
                                case NT_NUMBER:
                                case NT_STRING:
                                    ltype = it.getValue().typeCode();
                                    break;
                                default:
                                    throw "ORACLE-DRIVER-ERROR", sprintf("op_in operator unexpected list member type: %s. Only simple types are supported.", it.getValue().type());
                            }
                            if (ltype) break;
                        }

                        # Split long array to chunks of no more than 32767 elements due to Oracle limitation
                        # "ORA-22165: OCI-22165: given index [32767] must be in the range of [0] to [32766]"
                        int count;
                        while (arg.size()) {
                            ++count;
                            list chunk = extract arg, 0, 32767;

                            # Bind to Oracle by expected type
                            switch (ltype) {
                                case NT_DATE:
                                    args += bindOracleCollection("SYS.ODCIDATELIST", chunk);
                                    break;
                                case NT_INT:
                                case NT_FLOAT:
                                case NT_NUMBER:
                                    args += bindOracleCollection("SYS.ODCINUMBERLIST", chunk);
                                    break;
                                default:
                                    args += bindOracleCollection("SYS.ODCIVARCHAR2LIST", chunk);
                            }
                        }

                        if (count)
                            return cn + " in (" + (map "select column_value from table(%v)", xrange(count)).join(" union all ") + ")";
                        else
                            return "1 != 1";
%else
                        throw "MISSING-ORACLE-DRIVER", "op_in requires oracle driver";
%endif
                    },
                ),
                OP_SUBSTR: (
                    "code": string sub (object t, string cn, auto arg, reference<list> args, *hash jch, bool join = False, *hash ch, *hash psch) {
                        args += arg[0]; # start
                        if (!exists arg[1]) {
                            args += arg[2]; # text
                            return sprintf("substr(%s,%v) = %v", cn);
                        }
                        args += arg[1]; # count
                        args += arg[2]; # text
                        return sprintf("substr(%s,%v,%v) = %v", cn);
                    },
                ),
            );

            #! column operator specializations for Oracle
            const OracleCopMap = (
                COP_CAST: (
                    "code": string sub (string cve, list<auto> args) {
                        string name = QoreTypeMap{args[0]} ?? args[0];
                        hash desc = OraTypeMap{name};
                        string sql = sprintf ("cast (%s as %s", cve, name);
                        switch (name) {
                            default:
                                if (desc.size == SZ_MAND) {
                                    if (!exists args[1] && !exists desc.size_range)
                                        throw "OPERATOR-ERROR", sprintf ("op_cast operator missing size for type %s", name);
                                    sql += sprintf("(%d)", args[1] ?? desc.size_range[1]);
                                }
                                else if (desc.size == SZ_NUM && exists args[1]) {
                                    sql += args[1] == "*" ? "(*" : sprintf("(%d", args[1]);
                                    sql += exists args[2] ? sprintf(",%d)", args[2]) : ")";
                                }
                                else if (desc.size == SZ_OPT && exists args[1]) {
                                    sql += sprintf("(%d)", args[1]);
                                }
                        }
                        sql += ")";
                        return sql;
                    },
                ),
                COP_SUBSTR: (
                    "code": string sub (string cve, list<auto> args) {
                        if (!exists args[1])
                            return sprintf("substr(%s,%d)", cve, args[0]);
                        return sprintf("substr(%s,%d,%d)", cve, args[0], args[1]);
                    },
                ),
                COP_YEAR: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY')", arg1);
                    }
                ),
                COP_YEAR_MONTH: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY-MM')", arg1);
                    }
                ),
                COP_YEAR_DAY: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY-MM-DD')", arg1);
                    }
                ),
                COP_YEAR_HOUR: (
                    "code": string sub (string arg1, auto arg) {
                        return sprintf("to_char(%s, 'YYYY-MM-DD HH24')", arg1);
                    }
                ),
                COP_SEQ: (
                    "nocolumn": True,
                    "withalias": True,
                    "code": string sub (*string cve, hash arg, reference<hash> psch) {
                        string sql = sprintf("%s.nextval", arg.seq);
                        if (arg.as) {
                            psch{arg.as} = sql;
                            sql += " " + arg.as;
                        }
                        return sql;
                    }
                ),
                COP_SEQ_CURRVAL: (
                    "nocolumn": True,
                    "withalias": True,
                    "code": string sub (*string cve, hash arg, reference<hash> psch) {
                        string sql = sprintf("%s.currval", arg.seq);
                        if (arg.as) {
                            psch{arg.as} = sql;
                            sql += " " + arg.as;
                        }
                        return sql;
                    }
                ),
                COP_TRUNC_DATE: (
                    "code": string sub(string arg1, auto arg) {
                        if (!OracleTruncDate.hasKey(arg)) {
                            throw "COP-TRUNC-DATE-ERROR", sprintf("Not allowed format argument: %y: allowed: %y", arg, OracleTruncDate.keys());
                        }
                        # seconds are not part of TRUNC() in oracle
                        if (exists OracleTruncDate{arg}) {
                            return sprintf("trunc(%s, %s)", arg1, OracleTruncDate{arg});
                        }
                        # for timestamps
                        return sprintf("cast (%s as date)", arg1);
                    }
                )
                );

            #! Map @ref SqlUtil::cop_trunc_date() constants to Oracle internal masks
            const OracleTruncDate = (
                    DT_YEAR     : "'YYYY'",
                    DT_MONTH    : "'MM'",
                    DT_DAY      : "'DD'",
                    DT_HOUR     : "'HH24'",
                    DT_MINUTE   : "'MI'",
                    DT_SECOND   : NOTHING,
                );

            #! a hash of default value operator descriptions for Oracle
            const OracleIopMap = DefaultIopMap + (
                IOP_SEQ: (
                    "arg": Type::String,
                    "immediate": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("%s.nextval", arg);
                    },
                ),
                IOP_SEQ_CURRVAL: (
                    "arg": Type::String,
                    "immediate": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("%s.currval", arg);
                    },
                ),
                );

            #! a hash of default update operator definitions for Oracle
            const OracleUopMap = DefaultUopMap + (
                COP_SEQ: (
                    "nocolumn": True,
                    "code": string sub (*string cve, string arg) {
                        return sprintf("%s.nextval", arg);
                    }
                ),
                COP_SEQ_CURRVAL: (
                    "nocolumn": True,
                    "code": string sub (*string cve, string arg) {
                        return sprintf("%s.currval", arg);
                    }
                ),
                );

            #! a hash of valid pseudocolumns
            const OraclePseudoColumnHash = (
                "rowid": True,
                "rownum": True,
                "object_id": True,
                "object_value": True,
                "ora_rowscn": True,
                );
        }

        private {
            # schema name
            string schema;

            # tablespace name
            *string tablespace;

            # is the table read only?
            bool readonly;

            # table comment
            *string comment;

            # dblink
            *string dblink;

            # Oracle server major version
            int ora_major;

            # helper flag to indicate if is the OracleTable real table or a view
            bool m_isView = False;

            # oraclesqlutil: allow to use DBA_* views instead of ALL_* if possible #2418
            # An internal cache to find the highest priority available
            # system dictionary object. Priority: DBA > ALL
            hash<string, string> m_sys_views = {
                    "dba_col_comments"      : "all_col_comments",
                    "dba_cons_columns"      : "all_cons_columns",
                    "dba_constraints"       : "all_constraints",
                    "dba_db_links"          : "all_db_links",
                    "dba_ind_columns"       : "all_ind_columns",
                    "dba_ind_expressions"   : "all_ind_expressions",
                    "dba_indexes"           : "all_indexes",
                    "dba_objects"           : "all_objects",
                    "dba_sequences"         : "all_sequences",
                    "dba_synonyms"          : "all_synonyms",
                    "dba_tab_columns"       : "all_tab_columns",
                    "dba_tab_comments"      : "all_tab_comments",
                    "dba_tables"            : "all_tables",
                    "dba_triggers"          : "all_triggers",
                    "dba_views"             : "all_views",
            };
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a dblink in the name
            *string dbl = (nname =~ x/@(.*)/)[0];
            if (dbl) {
                dblink = dbl.upr();
                splice nname, nname.size() - (dbl.size() + 1);
                name = nname;
                setDblinkSchema();
            }
            else {
                # see if there is a schema in the name
                *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
                if (sstr) {
                    schema = sstr;
                    splice nname, 0, schema.size() + 1;
                    name = nname;
                }
                else
                    schema = ds.getUserName();
            }

            # the oracle driver >= 3.0 supports selecting from LONG columns
            if (compare_version("3.0", get_module_hash().oracle.version) > 0)
                throw "ORACLE-DRIVER-ERROR", sprintf("OracleSqlUtil requires oracle module 3.0+ to query system catalogs since LONG support was added in oracle module version 3.0; current module version: %s; upgrade your oracle module to at least 3.0 to use OracleSqlUtil", get_module_hash().oracle.version);

            ora_major = (nds.getServerVersion() =~ x/([0-9]+)/)[0].toInt();

%ifndef NO_ORACLE
            # validate presence of DBA_* views for this connection/user
            hash dba_in = bindOracleCollection("SYS.ODCIVARCHAR2LIST", map $1.upr(), m_sys_views.keys());
            hash dba_sys = nds.select("select /* OracleSqlUtil::OracleTable::constructor */
                                            object_name
                                        from all_objects
                                        where owner = %v
                                            and object_name in (select column_value from table(%v))
                                            and object_type = %v",
                                      "SYS", dba_in, "VIEW");
            context (dba_sys) {
                string n = %object_name.lwr();
                m_sys_views{n} = n;
            }
%endif
%ifdef NO_ORACLE
            throw "MISSING-ORACLE-DRIVER", "system catalogue/dictionary access requires oracle driver";
%endif
        }

        # oraclesqlutil: allow to use DBA_* views instead of ALL_* if possible #2418
        # get the most appropriate system catalogue/dictinary view available
        private string systemView(string name) {
            name = name.lwr();
            if (!m_sys_views.hasKey(name)) {
                throw "TABLE-ERROR", sprintf("Unknown system view %s, known: %y", name, m_sys_views.keys());
            }
            return m_sys_views{name};
        }

        private bool checkExistenceImpl() {
            try {
                setTableInfoIntern();
            }
            catch (hash<ExceptionInfo> ex) {
                if (ex.err == "TABLE-ERROR")
                    return False;
                rethrow;
            }
            return True;
        }

        private setTableInfoIntern() {
            hash<auto> row = (schema.lwr() == ds.getUserName().lwr()) ? setTable() : setSchemaTable();

            tablespace = row.tablespace_name;
            readonly = row.read_only == "YES";
            if (!native_case && tablespace)
                tablespace = tablespace.lwr();

            # get any comment
            if (!m_isView) {
                auto cm = ds.selectRow("select * from " + systemView("dba_tab_comments") + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr()).comments;
                comment = cm ? cm : NOTHING;
            }

            inDb = True;
        }

        #! returns the schema and table name in dot notation
        string getSqlName() {
            return sprintf("%s.%s" + (dblink ? "@" + dblink : ""), schema, name);
        }

        #! This method can change itself or disappear in the near future. Do not use it.
        bool isView() {
            return m_isView;
        }

        private hash setSchemaTable() {
            # get the table information if possible
            *hash<auto> row = ds.selectRow("select * from " + systemView("dba_tables") + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (row)
                return row;

            row = ds.selectRow("select * from " + systemView("dba_views") + (dblink ? "@" + dblink : "") + " where owner = %v and view_name = %v", schema.upr(), name.upr());
            if (row) {
                m_isView = True;
                return row;
            }

            throw "TABLE-ERROR", sprintf("table %y.%y does not exist or is not accessible to this user (%s)", schema, name, getDBString());
        }

        private setDblinkSchema() {
            *hash dblr = ds.selectRow("select * from " + systemView("dba_db_links") + " where owner in ('PUBLIC', %v) and db_link = %v and rownum = 1", ds.getUserName().upr(), dblink);
            if (!dblr)
                throw "TABLE-ERROR", sprintf("dblink %y is unknown", dblink);
            schema = dblr.username;
            if (!native_case)
                schema = schema.lwr();
        }

        # Oracle has supprt for unlimitted synonym loops. There
        # can be mo relevels of synonyms before the real object
        # is listed.
        private *hash resolveSynonym(string s_owner, string s_name) {
            *hash ret;

            # dbms_utility.name_resolve handled some Oracle EBS
            # cryptic aliases and view-hideouts out of the box.
            # select(), no exec(), is used here for reason:
            # we don't want to grab the transaction lock here.
            try {
                hash plsql = ds.select("declare
                                        o_owner varchar2(30);
                                        o_table varchar2(30);
                                        o_db_link varchar2(30);
                                        o_tmp1 varchar2(30);
                                        o_tmp2 number;
                                        o_tmp3 number;
                                    begin
                                    dbms_utility.name_resolve(%v, 0, o_owner, o_table, o_db_link, o_tmp1, o_tmp2, o_tmp3);
                                    :owner := o_owner;
                                    :table := o_table;
                                    :link := o_db_link;
                                    end;",
                                    sprintf("%s.%s", s_owner.upr(), s_name.upr()),
                                    Type::String, Type::String, Type::String
                            );
                # simulate resultset from all_synonyms output
                return ("owner" : s_owner,
                        "synonym_name" : s_name,
                        "table_owner" : plsql.owner,
                        "table_name" : plsql.table,
                        "db_link" : plsql.link,
                    );
            }
            catch (hash ex) {
                # exceptions are silently ignored - session can miss
                # dbms_utility grants, requested object can be missing etc.
                #printf("resolveSynonym dbms_utility.name_resolve error: %s\n", get_exception_string(ex));
            }

            # fallback synonym resolution if there is no dbms_utility available
            do {
                # TODO/FIXME: db link handling
                ret = ds.selectRow("select s.*, o.object_type
                                    from " + systemView("dba_synonyms") + " s
                                        join " + systemView("dba_objects") + " o
                                        on
                                        (
                                                s.table_owner = o.owner
                                            and s.table_name = o.object_name
                                        )
                                    where s.owner = %v
                                        and s.synonym_name = %v
                                        and o.object_type in ('TABLE', 'VIEW', 'SYNONYM')",
                                s_owner.upr(), s_name.upr());

                # ret can be NOTHING in case:
                #  - no such synonym exists
                #  - there is a broken synonym eg. pointing to non-existing object
                if (!ret) break;

                s_owner = ret.table_owner;
                s_name = ret.table_name;
            }
            while (ret && ret.object_type == 'SYNONYM');

            return ret;
        }

        private hash setTable() {
            # see if the current user has the table
            *hash<auto> row = ds.selectRow("select * from user_tables where table_name = %v", name.upr());
            if (row) {
                schema = getUserSchema();
                return row;
            }

            row = ds.selectRow("select * from user_views where view_name = %v", name.upr());
            if (row) {
                m_isView = True;
                schema = getUserSchema();
                return row;
            }

            bool pub = False;
            # see if there is a user synonym with this name
            row = resolveSynonym(schema, name);
            if (!row) {
                # see if there is a public synonym with this name
                row = resolveSynonym("PUBLIC", name);
                if (!row)
                    throw "TABLE-ERROR", sprintf("table %y or synonym %y does not exist or is not accessible to this user (%s)", name, name, getDBString());
                pub = True;
            }

            # update the table name if necessary
            string orig_name = name;
            if (name.upr() != row.table_name) {
                name = row.table_name;
                if (!native_case)
                    name = name.lwr();
            }

            if (row.db_link) {
                dblink = row.db_link;

                setDblinkSchema();

                if (!native_case)
                    dblink = dblink.lwr();
            }

            if (row.table_owner) {
                schema = row.table_owner;
                if (!native_case)
                    schema = schema.lwr();
            }

            # get the table information if possible
            row = ds.selectRow("select * from " + systemView("dba_tables") + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (row)
                return row;

            row = ds.selectRow("select * from " + systemView("dba_views") + (dblink ? "@" + dblink : "") + " where owner = %v and view_name = %v", schema.upr(), name.upr());
            if (row) {
                m_isView = True;
                return row;
            }

            throw "TABLE-ERROR", sprintf("%y is a %ssynonym pointing to table %y.%y which does not exist or is not accessible to this user (%s)", orig_name, pub ? "public " : "", schema, name, getDBString());
        }

        private string getUserSchema() {
            string rv = ds.getUserName();
            if (native_case)
                rv = rv.upr();
            return rv;
        }

        private string getDBString() {
            return sprintf("%s@%s", ds.getUserName(), ds.getDBName());
        }

        #! returns the schema name
        string getSchemaName() {
            return schema;
        }

        #! returns the data tablespace name for the table if any or @ref nothing if none is known
        *string getTablespaceName() {
            return tablespace;
        }

        #! returns any table comment or @ref nothing if none is known
        *string getComment() {
            return comment;
        }

        bool readOnly() {
            return readonly;
        }

        private hash getColumnOptions() {
            return OraColumnOptions;
        }

        private hash getColumnDescOptions() {
            return OraColumnDescOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getSelectOptions() {
            return OracleSelectOptions;
        }

        private getSelectWhereSqlUnlocked(reference<string> sql, reference<list> args, *hash qh, *hash jch, bool join = False, *hash ch, *hash psch) {
            AbstractTable::getSelectWhereSqlUnlocked(\sql, \args, qh, jch, join, ch, psch);
            # Oracle 12c+ supports limit (fetch) and offset
            if (ora_major >= 12)
                return;

            if (qh.limit && !qh.orderby) {
                if (!qh."where")
                    sql += " where ";
                else
                    sql += " and ";
                sql += sprintf("rownum <= %v", qh.limit);
                args += qh.limit;
                # insert optimizer hint
                int i = sql.find(" from ");
                # http://www.oracle.com/technetwork/issue-archive/2006/06-sep/o56asktom-086197.html
                # /*+ first_rows(n) */ is an optimizer hint that we want the first rows as fast as possible
                splice sql, i + 5, 0, sprintf(" /*+ first_rows(%d) */", qh.limit);
            }
        }

        private doSelectOrderByWithOffsetSqlUnlockedImpl(reference<string> sql, reference<list> args, *hash qh, *hash jch, *hash ch, *hash psch, list coll) {
            # Oracle 12c+ supports limit (fetch) and offset
            if (ora_major >= 12) {
                doSelectOrderBySqlUnlocked(\sql, \args, qh, jch, ch, psch, coll);

                if (qh.offset) {
                    sql += " offset %v rows";
                    args += qh.offset;
                }

                if (qh.limit) {
                    sql += " fetch next %v rows only";
                    args += qh.limit;
                }

                return;
            }

            list ce = getOrderByListUnlocked(qh, jch, ch, psch, coll);
            string sort = foldl $1 + ", " + $2, ce;
            # http://www.oracle.com/technetwork/issue-archive/2006/06-sep/o56asktom-086197.html
            # /*+ first_rows(n) */ is an optimizer hint that we want the first rows as fast as possible
            sql = sprintf("select * from (select /*+ first_rows(%d) */ a.*, rownum rnum from (%s order by %s%s) a where rownum <= %v) where rnum > %v", qh.limit, sql, sort, qh.desc ? " desc" : "");
            if (qh.offset)
                qh.limit += qh.offset;
            args += qh.limit;
            args += qh.offset ? qh.offset : 0;
        }

        #! processes a string for use in SQL select statements when there is a "limit" argument, but no "orderby" or "offset" arguments
        private doSelectLimitOnlyUnlockedImpl(reference<string> sql, reference<list> args, *hash qh) {
            if (!qh.limit)
                return;

            # Oracle 12c+ supports limit (fetch) and offset
            if (ora_major >= 12) {
                sql += " fetch next %v rows only";
                args += qh.limit;
                return;
            }

            # /*+ first_rows(n) */ is an optimizer hint that we want the first rows as fast as possible
            sql = sprintf("select * from (select /*+ first_rows(%d) */ a.*, rownum rnum from (%s) a where rownum <= %v)", qh.limit, sql);
            args += qh.limit;
        }

        private Columns describeImpl() {
            if (!tablespace)
                setTableInfoIntern();

            # get column descriptions
            *hash qh = ds.select("select col.column_name, data_type, data_length, data_precision, data_scale, nullable, data_default, char_length, char_used, comments from " + systemView("dba_tab_columns") + (dblink ? "@" + dblink : "") + " col, " + systemView("dba_col_comments") + (dblink ? "@" + dblink : "") + " com where col.owner = %v and col.table_name = %v and com.owner = col.owner and com.table_name = col.table_name and com.column_name = col.column_name order by column_id", schema.upr(), name.upr());
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y.%y in %y", schema, name, dsdesc);

            # now we have to find unvalidated but enabled not null constraints - because these cause the column to appear to be "nullable" when it really isn't
            # also we can't filter by search_condition, because it's a LONG, otherwise we could make a left join above :(
            *hash nnq = ds.select("select * from " + systemView("dba_constraints") + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v and generated = 'GENERATED NAME' and constraint_type = 'C' and status = 'ENABLED' and validated != 'VALIDATED'", schema.upr(), name.upr());
            hash cnh;
            context (nnq) {
                *string cn = (%search_condition =~ x/"([^"]+)" IS NOT NULL$/)[0];
                if (cn)
                    cnh{cn} = True;
            }

            hash rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                #if (row.column_name == "TAX_AMOUNT")
                #    printf("DBG: %y\n", row);
                *hash th = OraTypeMap.(row.data_type.lwr());
                int size = row.data_type == "NUMBER" && row.data_precision ? row.data_precision : row.data_length;
                switch (row.data_type) {
                    case "ROWID":
                    case "UROWID":
                    case "DATE":
                    case "BINARY_FLOAT":
                    case "BINARY_DOUBLE":
                    case =~ /^TIMESTAMP/:
                    case =~ /^INTERVAL/:
                    case "BFILE":
                    case "BLOB":
                    case "CLOB": size = 0; break;
                }
                # there is no size for NTY objects (not listed in registered types in OraTypeMap)
                if (!exists th) {
                    size = 0;
                }

                # set default numeric precision to 0 if not given
                if (row.data_precision === NULL && row.data_type == "NUMBER") {
                    row.data_precision = 0;
                    row.data_scale = 0;
                }

                bool nullable = row.nullable == "Y" && !cnh{row.column_name};
                if (!native_case) {
                    row.column_name = row.column_name.lwr();
                    row.data_type = row.data_type.lwr();
                }
                trim row.data_default;

                bool char_used;
                if (row.char_used == "C") {
                    char_used = True;
                    size = row.char_length;
                }
                else
                    char_used = False;

                OracleColumn c;
                if (row.data_precision || row.data_type == "number")
                    c = new OracleNumberColumn(row.column_name, row.data_type, th.qore, row.data_precision, nullable, row.data_default, row.comments ? row.comments : NOTHING, row.data_length, row.data_scale);
                else
                    c = new OracleColumn(row.column_name, row.data_type, th.qore, size, nullable, row.data_default, row.comments ? row.comments : NOTHING, th.is_char, row.char_used == "C", row.data_length);

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private OraclePrimaryKey getPrimaryKeyImpl() {
            if (!tablespace)
                setTableInfoIntern();

            hash rv;

            # get primary key description
            *hash qh = ds.select("select cons.constraint_name, cols.column_name, cols.position, cons.status, cons.index_name from " + systemView("dba_constraints") + (dblink ? "@" + dblink : "") + " cons, " + systemView("dba_cons_columns") + (dblink ? "@" + dblink : "") + " cols where cols.owner = %v and cols.table_name = %v and cons.constraint_type = 'P' and cons.owner = cols.owner and cons.constraint_name = cols.constraint_name order by cols.position", schema.upr(), name.upr());
            if (!qh.constraint_name)
                return new OraclePrimaryKey();

            foreach string col in (qh.column_name) {
                string cn = native_case ? col : col.lwr();
                rv{cn} = columns{cn};
            }

            string pkname = qh.constraint_name[0];
            if (!native_case)
                pkname = pkname.lwr();

            OraclePrimaryKey pk(pkname, rv);
            # set the base index if present
            if (qh.index_name[0]) {
                if (!native_case)
                    qh.index_name[0] = qh.index_name[0].lwr();
                pk.setIndexBase(qh.index_name[0]);
            }
            return pk;
        }

        private Indexes getIndexesImpl() {
            if (!tablespace)
                setTableInfoIntern();

            hash rv;

            # get index description
            *hash qh = ds.select("select i.index_name, index_type, uniqueness, tablespace_name, constraint_name
 from " + systemView("dba_indexes") + (dblink ? "@" + dblink : "") + " i left join " + systemView("dba_constraints") + (dblink ? "@" + dblink : "") + " c on (i.index_name = c.index_name and i.owner = c.owner and i.table_name = c.table_name)
 where i.owner = %v and i.table_name = %v", schema.upr(), name.upr());
            if (qh.index_name) {
                hash<auto> ih;

                # get column info for all indexes in 1 query
                *hash<auto> iqh = ds.select("select c.index_name, c.column_name, e.column_expression from " + systemView("dba_ind_columns") + (dblink ? "@" + dblink : "") + " c left join " + systemView("dba_ind_expressions") + (dblink ? "@" + dblink : "") + " e on (c.table_owner = e.index_owner and c.index_name = e.index_name and c.table_name = e.table_name) where c.table_owner = %v and c.table_name = %v order by c.index_name, c.column_position", schema.upr(), name.upr());
                foreach hash<auto> row in (iqh.contextIterator()) {
                    if (!native_case)
                        map row.$1 = row.$1.lwr(), ("index_name", "column_name", "column_expression"), row.$1;
                    # process function indexes
                    if (row.column_expression) {
                        row.column_expression =~ s/"//g;
                        ih{row.index_name}{row.column_expression} = {};
                    }
                    else
                        ih{row.index_name}{row.column_name} = columns{row.column_name};
                }

                foreach hash<auto> row in (qh.contextIterator()) {
                    if (!native_case)
                        map row.$1 = row.$1.lwr(), ("index_name", "tablespace_name", "constraint_name"), row.$1;

                    # skip system indexes
                    if (!ih{row.index_name})
                        continue;
                    rv.(row.index_name) = new OracleIndex(row.index_name, row.uniqueness == "UNIQUE", ih{row.index_name}, row.index_type, row.tablespace_name);
                    if (row.constraint_name) {
                        *AbstractUniqueConstraint uk = findUniqueConstraintUnlocked(row.constraint_name);
                        if (uk) {
                            rv.(row.index_name).setSupportingConstraint(uk);
                            uk.setIndexBase(row.index_name);
                        }
                    }
                }

            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl(*hash opts) {
            if (!tablespace)
                setTableInfoIntern();

            hash ch;

            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, status from user_constraints" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v and constraint_type = 'R'", schema.upr(), name.upr());
            if (qh.status) {
                hash rv;
                foreach hash<auto> row in (qh.contextIterator()) {
                    if (!native_case)
                        row.constraint_name = row.constraint_name.lwr();
                    rv.(row.constraint_name) = (
                        "enabled": row.status == "ENABLED",
                        );
                }
                qh = ds.select("select c.constraint_name, status, cols1.column_name source_column, cols1.position, cols2.table_name target_table, cols2.column_name target_column from " + systemView("dba_constraints") + (dblink ? "@" + dblink : "") + " c, " + systemView("dba_cons_columns") + (dblink ? "@" + dblink : "") + " cols1, " + systemView("dba_cons_columns") + (dblink ? "@" + dblink : "") + " cols2 where c.owner = %v and c.table_name = %v and c.constraint_name = cols1.constraint_name and constraint_type = 'R' and c.r_constraint_name = cols2.constraint_name and cols1.position = cols2.position and cols1.owner = c.owner and cols2.owner = c.owner order by cols1.position", schema.upr(), name.upr());
                foreach hash<auto> row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.constraint_name = row.constraint_name.lwr();
                        row.source_column = row.source_column.lwr();
                        row.target_column = row.target_column.lwr();
                        row.target_table = row.target_table.lwr();
                    }
                    reference<hash> c = \rv.(row.constraint_name);
                    #if (!columns.hasKey(row.source_column))# && c.target.columns.(row.target_column)) {
                    #    printf("ERROR: %y.%y ->  %y.%y (%y): %y\n", name, row.source_column, row.target_table, row.target_column, row.constraint_name, columns.keys());
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                foreach hash<auto> c in (rv.pairIterator()) {
                    # get a description of the target table's columns
                    Columns targ_columns = getReferencedTableColumnsUnlocked(c.value.target.table, opts.table_cache);
                    ForeignConstraintTarget fct(c.value.target.table, targ_columns.subset(c.value.target.columns.keys()));
                    ch.(c.key) = new OracleForeignConstraint(c.key, new Columns(c.value.columns), fct, c.value.enabled);
                }
            }

            return new ForeignConstraints(ch);
        }

        private Constraints getConstraintsImpl() {
            if (!tablespace)
                setTableInfoIntern();

            # get only user check constraints
            *hash qh = ds.select("select constraint_name, search_condition, status from " + systemView("dba_constraints") + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v and constraint_type = 'C' and generated != 'GENERATED NAME'", schema.upr(), name.upr());
            hash rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                if (!native_case)
                    row.constraint_name = row.constraint_name.lwr();
                rv.(row.constraint_name) = new OracleCheckConstraint(row.constraint_name, row.search_condition, row.status == "ENABLED");
            }

            Constraints c(rv);

            # now get unique constraints
            qh = ds.select("select c.constraint_name, status, cols.column_name, cols.position, status, c.index_name from " + systemView("dba_constraints") + (dblink ? "@" + dblink : "") + " c, " + systemView("dba_cons_columns") + (dblink ? "@" + dblink : "") + " cols where c.owner = %v and c.table_name = %v and c.constraint_name = cols.constraint_name and constraint_type = 'U' and cols.owner = c.owner and generated != 'GENERATED NAME' order by cols.position", schema.upr(), name.upr());
            delete rv;
            foreach hash<auto> row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("constraint_name", "column_name");
                reference<OracleUniqueConstraint> ch = \rv.(row.constraint_name);
                if (!ch) {
                    ch = new OracleUniqueConstraint(row.constraint_name, {}, row.status == "ENABLED");
                    if (row.index_name)
                        ch.setIndexBase(row.index_name);
                }
                ch.add(row.column_name, columns{row.column_name});
            }

            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();

            return c;
        }

        private string getSelectSqlName(*hash qh) {
            if (!qh.partition)
                return getSqlName();
            return sprintf("%s partition (%s)", getSqlName(), qh.partition);
        }

        private Triggers getTriggersImpl() {
            if (!tablespace)
                setTableInfoIntern();

            hash<string, OracleTrigger> rv;

            # get trigger description
            *hash<auto> qh = ds.select("select * from " + systemView("dba_triggers") + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr());
            foreach hash<auto> row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("trigger_name", "trigger_type", "triggering_event", "referencing_names");
                #printf("%y: %s\n", row.trigger_name, row.description);

                # replace newlines with spaces
                row.description =~ s/\n/ /g;
                trim row.description;

                # remove trigger name from description line
                row.description = regex_subst(row.description, "^.*" + row.trigger_name + ".", "", RE_Caseless);
                rv{row.trigger_name} = new OracleTrigger(row.trigger_name, row.description + "\n" + row.trigger_body, row.status == "ENABLED");
            }

            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map sprintf("  %s", $1.getCreateSql(self)), columns.iterator());
            sql += "\n)";

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        private *list getCreateMiscSqlImpl(*hash opt, bool cache) {
            if (cache)
                getColumnsUnlocked();
            return map AbstractDatabase::doCallback(opt, sprintf("comment on column %s.%s is %s", name, $1.ddl_name, getSqlValueImpl($1.comment)), AbstractDatabase::AC_Add, "column comment", $1.name, name), columns.iterator(), $1.comment;
        }

        private string getCreateSqlImpl(list l) {
            return OracleDatabase::getCreateSql(l);
        }

        private string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            if (opt.precision)
                return new OracleNumberColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable, opt.default_value, opt.comment, 0, opt.scale);
            return new OracleColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value, opt.comment, opt.local_def.is_char, opt.character_semantics, 0);
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new OraclePrimaryKey(cname, ch, opt.index_tablespace);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new OracleIndex(iname, enabled, ch, "normal", opt.index_tablespace);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new OracleForeignConstraint(cname, new Columns(ch), fct, True);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new OracleCheckConstraint(cname, src);
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt) {
            return new OracleUniqueConstraint(cname, ch, True, opt.index_tablespace);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new OracleTrigger(tname, src);
        }

        private bool tryInsertImpl(string sql, hash<auto> row) {
            try {
                ds.vexec(sql, row.values());
            } catch (hash<ExceptionInfo> ex) {
                if (ex.desc =~ /ORA-00001/)
                    return False;
                rethrow;
            }
            return True;
        }

        private *list getAlignSqlImpl(AbstractTable t, *hash opt) {
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return OraTypeMap;
        }

        private hash getIndexOptions() {
            return OracleIndexOptions;
        }

        private hash getConstraintOptions() {
            return OracleConstraintOptions;
        }

        private hash getTableCreationOptions() {
            return OracleTableCreationOptions;
        }

        private hash getAlignTableOptions() {
            return OracleAlignTableOptions;
        }

        #! returns the "where" operator map for this object
        private hash getWhereOperatorMap() {
            return OracleOpMap;
        }

        #! returns the column operator map for this object
        private hash getColumnOperatorMapImpl() {
            return OracleCopMap;
        }

        #! returns the insert operator map for this object
        private hash getInsertOperatorMap() {
            return OracleIopMap;
        }

        #! returns the raw (default) update operator map for this object
        private hash getRawUpdateOperatorMap() {
            return OracleUopMap;
        }

        #! returns a hash of valid pseudocolumns
        private *hash getPseudoColumnHash() {
            return OraclePseudoColumnHash;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(auto v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_NUMBER:
                case NT_INT: return v.toString();

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "1" : "0";

                case NT_DATE: return sprintf("to_timestamp('%s', 'YYYYMMDDHH24MISSFF6')", v.format("YYYYMMDDHHmmSSus"));
            }
        }

        #! returns the column name for use in SQL strings; subclasses can return a special string in case the column name is a reserved word
        string getColumnSqlName(string col) {
            return OracleDatabase::OracleReservedWords{col.lwr()} ? ("\"" + col + "\"") : col;
        }

        #! returns a list of column names for use in SQL strings; subclasses can process the argument list in case a column name is a reserved word
        list getColumnSqlNames(softlist cols) {
            return map (OracleDatabase::OracleReservedWords{$1.lwr()} ? ("\"" + $1 + "\"") : $1), cols;
        }

        #! returns the base type of the underlying object (either \"table\" or \c "view")
        /**
            @since OracleSqlUtil 1.2
        */
        string getBaseType() {
            return m_isView ? "view" : "table";
        }

        #! Oracle always supports bulk merging
        code getBulkUpsertClosure(hash example_row, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return getUpsertClosure(example_row, upsert_strategy, opt);
        }

        #! returns a closure for performing upserts; if the \a upsert_strategy argument is @ref UpsertInsertFirst or @ref UpsertUpdateFirst, then this argument is ignored and a closure using an Oracle merge statement is returned
        code getUpsertClosure(hash<auto> row, int upsert_strategy = UpsertAuto, *hash opt) {
            Columns cols = checkUpsertRow(row, \upsert_strategy);

            switch (upsert_strategy) {
                case UpsertInsertOnly:
                    # if the strategy is "insert only", then respect this strategy (no updates)
                    return getUpsertInsertOnly(cols, row, opt);

                case UpsertSelectFirst:
                    # if the strategy is "select first", then respect this strategy; this is a slow upsert method anyway
                    return getUpsertSelectFirst(cols, row, opt);

                case UpsertUpdateOnly:
                    # if the strategy is "update only", then respect this strategy
                    return getUpsertUpdateOnly(cols, row, opt);
            }

            # get update columns
            list updc = ();
            # hash of columns to skip on update if applicable
            *hash suh = map {$1: True}, opt.omit_update;
            map updc += $1, row.keyIterator(), !cols.hasKey($1) && !suh.$1;
            # cannot use merge where only the join columns are present
            if (!updc)
                return getUpsertInsertOnly(cols, row, opt);

            string sql = sprintf("merge into %s t using (select ", getSqlName());
            sql += foldl $1 + "," + $2, (map sprintf("%v as %s", $1), row.keys());
            sql += " from dual) source on (";
            sql += foldl $1 + " and " + $2, (map sprintf("t.%s = source.%s", $1, $1), getColumnSqlNames(cols.keys()));
            sql += sprintf(") when not matched then insert (");
            sql += foldl $1 + "," + $2, getColumnSqlNames(row.keys());
            sql += ") values (";
            sql += foldl $1 + "," + $2, (map sprintf("source.%s", $1), getColumnSqlNames(row.keys()));
            sql += sprintf(") when matched then update set ");
            sql += (foldl $1 + "," + $2, (map sprintf("%s = source.%s", $1, $1), getColumnSqlNames(updc)));

            #printf("sql: %s\n", sql);

            return int sub (hash crow) {
                list<auto> args = crow.values();
                #on_error printf("SQL: %s args: %y\n", sql, args);
                ds.vexec(sql, args);
                return UR_Verified;
            };
        }

        #! high-performance "insert only" upsert supporting bulk DML
        private code getUpsertInsertOnly(Columns cols, hash<auto> row, *hash opt) {
            string sql = sprintf("merge into %s t using (select ", getSqlName());
            sql += foldl $1 + "," + $2, (map sprintf("%v as %s", $1), row.keys());
            sql += " from dual) source on (";
            sql += foldl $1 + " and " + $2, (map sprintf("t.%s = source.%s", $1, $1), getColumnSqlNames(cols.keys()));
            sql += sprintf(") when not matched then insert (");
            sql += foldl $1 + "," + $2, getColumnSqlNames(row.keys());
            sql += ") values (";
            sql += foldl $1 + "," + $2, (map sprintf("source.%s", $1), getColumnSqlNames(row.keys()));
            sql += ")";

            #printf("sql: %s\n", sql);

            return int sub (hash crow) {
                list<auto> args = crow.values();
                #on_error printf("SQL: %s args: %y\n", sql, args);
                int rc = ds.vexec(sql, args);
                return crow.firstValue().lsize() > 1 ? UR_Verified : (rc ? UR_Inserted : UR_Unchanged);
            };
        }

        #! high-performance "update only" upsert supporting bulk DML
        private code getUpsertUpdateOnly(Columns cols, hash<auto> row, *hash opt) {
            # get update columns
            list updc = ();
            # hash of columns to skip on update if applicable
            *hash suh = map {$1: True}, opt.omit_update;
            map updc += $1, row.keyIterator(), !cols.hasKey($1) && !suh.$1;
            # cannot use merge where only the join columns are present
            if (!updc)
                throw "UPSERT-ERROR", sprintf("cannot use the UpsertUpdateOnly upsert option on table %y when the only columns present are the columns for the unique key used for the update: %y", getSqlName(), row.keys());

            string sql = sprintf("merge into %s t using dual on (", getSqlName());
            sql += foldl $1 + " and " + $2, (map sprintf("%s=%v", $1), getColumnSqlNames(cols.keys()));
            sql += sprintf(") when matched then update set ");

            # get update columns
            sql += (foldl $1 + "," + $2, (map sprintf("%s=%v", $1), getColumnSqlNames(updc)));

            #printf("sql: %s\n", sql);

            return int sub (hash crow) {
                list<auto> args = crow.(cols.keys()).values() + crow{updc}.values();
                #on_error printf("SQL: %s args: %y\n", sql, args);
                int rc = ds.vexec(sql, args);
                return crow.firstValue().lsize() > 1 ? UR_Verified : (rc ? UR_Verified : UR_Unchanged);
            };
        }

        #! returns @ref True "True" because the oracle driver supports array binds / bulk DML operations
        bool hasArrayBind() {
            return True;
        }

        #! returns @ref True because Oracle treats empty strings like @ref NULL on insert
        /** @since OracleSqlUtil 1.2
        */
        bool bindEmptyStringsAsNull() {
            return True;
        }

        #! returns @ref True if the database requires a wildcard \c "*" to be prefixed with the table name when it appears with other column arguments in a select statement
        private bool asteriskRequiresPrefix() {
            return True;
        }

        private *hash doReturningImpl(hash<auto> opt, reference<string> sql, list<auto> args) {
            list l = ();
            foreach auto v in (opt.returning) {
                hash rh;
                switch (v.typeCode()) {
                    case NT_STRING: rh.key = v; break;
                    case NT_HASH: rh = v; break;
                    default: throw "RETURNING-ERROR", sprintf("got type %y in \"returning\" option; expected \"string\" or \"hash\"", v.type());
                }
                if (!rh.key.val() || rh.key.typeCode() != NT_STRING)
                    throw "RETURNING-ERROR", sprintf("got %y for \"returning\" option key value instead of name of output column", rh.key.type());

                *OracleColumn c = columns{rh.key};
                if (!c)
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column for the \"returning\" clause (valid columns: %y)", name, rh.key, columns.keys());
                l += rh.key;
                args += rh.type ?* c.qore_type ?* Type::String;
            }
            sql += sprintf(" returning %s into %s", (foldl $1 + "," + $2, l), (foldl $1 + "," + $2, (map ":" + $1, l)));

            return execData(opt, sql, args);
        }

        private bool emptyImpl() {
            return True;
        }

        private setupTableImpl(hash<auto> desc, *hash<auto> opt) {
        }

        #! returns @ref True "True" if the database links constraints to indexes (ie dropping the constraint drops the index, etc)
        private bool constraintsLinkedToIndexesImpl() {
            return False;
        }

        #! returns @ref True "True" if the database automatically creates a unique constraint when a unique index is created (ex: mysql)
        private bool uniqueIndexCreatesConstraintImpl() {
            return False;
        }

        #! returns @ref True "True" if the database support tablespaces
        private bool supportsTablespacesImpl() {
            return True;
        }

        #! db-specific copy actions
        private copyImpl(AbstractTable old) {
        }

        #! returns the type for number / numeric columns for the database so that data conversions can be handled properly
        private AbstractDataProviderType getNumericTypeImpl(string native_type, bool nullable, *hash<auto> options) {
            return new OracleNumberDataType(native_type, nullable, options);
        }

        #! get DB-specific savepoint helper
        /** @param savepoint the savepoint string, if not given a unique savepoint string will be generated

            @since SqlUtil 1.6
        */
        private AbstractSavepointHelper getSavepointHelperImpl(*string savepoint) {
            return new OracleSavepointHelper(ds, savepoint);
        }
    }
}
