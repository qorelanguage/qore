# -*- mode: qore; indent-tabs-mode: nil -*-
# @file OracleSqlUtil.qm Qore user module for working with Oracle SQL data

/*  OracleSqlUtil.qm Copyright 2013 - 2015 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.12 or better
%requires qore >= 0.8.12

# requires the SqlUtil module
%requires SqlUtil >= 1.0

# requires the Util module
%requires Util >= 1.0

# for bindOracleCollection
%try-module oracle
%define NO_ORACLE
%endtry


# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module OracleSqlUtil {
    version = "1.2";
    desc = "user module for working with Oracle SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*  Version History: see docs below
*/

/** @mainpage OracleSqlUtil Module

    @tableofcontents

    @section oraclesqlutilintro OracleSqlUtil Module Introduction

    The %OracleSqlUtil module provides a high level API for working with Oracle database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires OracleSqlUtil" in your code.

    All the public symbols in the module are defined in the OracleSqlUtil namespace

    @note This module requires the <a href="http://qore.org/qore-modules/14-oracle-module">oracle</a> binary module for communication with Oracle databases

    @section ora_sql_operations SQL Operations on Oracle

    @subsection ora_paging Select With Paging on Oracle

    Select with paging on Oracle is more complicated than on some databases due to the lack of direct \c limit and \c offset
    support (applies to Oracle pre 12c).

    For example, for the following select:
    @code
my *list $rows = $table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    the following SQL is generated for Oracle with a pre 12c server:
    @code
$ds.vselectRows("select * from (select /*+ first_rows(100) *<!--%%-->/ a.*, rownum rnum from (select * from schema.table where type = %v order by type) a where rownum <= %v) where rnum > %v", ("user", 300, 200));
    @endcode
    note that the following simpler SQL is generated for Oracle 12c+ servers:
    @code
$ds.vselectRows("select * from schema.table where type = %v order by type offset %v rows fetch next %v rows only", ("user", 200, 100));
    @endcode

    @subsection ora_in_operator IN Operator on Oracle

    In order to avoid dynamic SQL and better manage the server's shared pool (in particular, the number of parsed statements), the %OracleSqlUtil
    module uses bind by value with the SQL \c IN operator.

    For example, the following query:
    @code
my *hash $q = $table.select(("where": ("col1": op_in(1, 2, 3, 4))));
    @endcode

    Results in the equivalent of the following SQL:
    @code
my *hash $q = $ds.select("select * from schema.table where col1 in (select column_value from table(%v))", bindOracleCollection("SYS.ODCIVARCHAR2LIST", (1,2,3,4)));
    @endcode

    |!Qore Type|!Oracle Collection
    |Date|\c SYS.ODCIDATELIST
    |Float|\c SYS.ODCINUMBERLIST
    |Integer|\c SYS.ODCINUMBERLIST
    |Number|\c SYS.ODCINUMBERLIST
    |String|\c SYS.ODCIVARCHAR2LIST

    There universal collections are limited to 32767 elements. And \c SYS.ODCIVARCHAR2LIST element size is \c VARCHAR2(4000).

    @subsection ora_partitioning_select Partition Support in Selects

    It's possible to select from a particular partition of a table with %OracleSqlUtil;
    @ref OracleSqlUtil::OracleTable::OracleSelectOptions "OracleSelectOptions" defines the \c "partition" key which can be added to a
    @ref select_option_hash "select option hash" to specify the partition to select from as in the following example:
    @code
my *list $rows = $table.selectRows(("created": op_gt(2012-05-01), "partition": "p1"));
    @endcode
    Which generates an SQL command like the following:
    @code
my *list $rows = $ds.vselectRows("select * from schema.table partition(p1) where created > %v", (2012-05-01));
    @endcode

    @subsection ora_partitioning_join Partition Support in Joins

    It's possible to perform a join on a particular partition of a table with %OracleSqlUtil; the join option \c "partition" is
    supported to specify the partition to join on as in the following example:
    @code
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid"), NOTHING, ("partition": "p2"))));
    @endcode
    Which generates an SQL command like the following:
    @code
my *list $rows = $ds.vselectRows("select * from schema.table inner join schema.table2 partition(p2) t2 on (schema.table.id = t2.altid)");
    @endcode

    @section ora_schema_management Schema Management on Oracle

    Note that when getting an object description from an Oracle database, if the object cannot be found in the connection schema, then
    if a synonym of the same type exists and the target object is accessible, then the target object is read automatically and the owning
    schema name is also set to the actual owner of the object.

    @subsection ora_type_mapping Type Mapping

    Column types are mapped from %Qore types as follows:

    <b>Oracle Column Type Mappings</b>
    |!Generic Type Name|!Oracle Type Used
    |\c float|\c number
    |\c integer|\c number
    |\c number|\c number
    |\c string|\c varchar2
    |\c date|\c timestamp(6)
    |\c binary|\c blob
    |@ref SqlUtil::BLOB|\c blob
    |@ref SqlUtil::CHAR|\c char
    |@ref SqlUtil::CLOB|\c clob
    |@ref SqlUtil::NUMERIC|\c number
    |@ref SqlUtil::VARCHAR|\c varchar2

    To use other types, use the \c "native_type" @ref SqlUtil::AbstractTable::ColumnDescOptions "column description option" with the
    native Oracle type name instead (under the \c "driver" and \c "oracle" keys for schemas supporting multiple databases).

    @subsection ora_other_objects Additional Object Types Supported

    The following additional schema objects can be managed with %OracleSqlUtil:
    - @ref ora_materialized_views "materialized views"
    - @ref ora_packages "packages"
    - @ref ora_types "types"

    @subsection ora_materialized_views Materialized Views

    The @ref schema_desc_hash takes an optional key, \c "materialized_views" that allows materialized views in Oracle schemas to be managed along with other objects.

    The \c "materialized_views" should be assigned to a hash, each key name is the name of the materialized view, and the values are hashes with the
    following keys:
    - \c "logging": (@ref bool_type "bool") if the materialized view should be logged
    - \c "use_index": (@ref bool_type "bool") if the materialized view should be indexed
    - \c "src": (@ref bool_type "bool") the source of the materialized view

    The \c "materialized_views" key can go in the top level of the @ref schema_desc_hash for Oracle-only schemas, or, for schemas targeting multiple database types, under the \c "driver" and \c "oracle" keys as in the following example:

    @code
my hash $schema = (
    "driver": (
        "oracle": (
            "materialized_views": (
                "example_mv": (
                    "logging": False,
                    "use_index": False,
                    "src": "select type, count(1) total_count from table group by type",
                ),
            ),
        ),
    ),
);
    @endcode

    @subsection ora_packages Packages

    The @ref schema_desc_hash takes an optional key, \c "packages" that allows packages in Oracle schemas to be managed along with other objects.

    The \c "packages" should be assigned to a hash, each key name is the name of the package, and the values are hashes with the
    following key:
    - \c "src": (@ref bool_type "bool") the source of the package

    The \c "packages" key can go in the top level of the @ref schema_desc_hash for Oracle-only schemas, or, for schemas targeting multiple database types, under the \c "driver" and \c "oracle" keys as in the following example:

    @code
my hash $schema = (
    "driver": (
        "oracle": (
            "packages": (
                "example_pkg": (
                    "src": "types as
type cursorType is ref cursor;
MYSTATCOMPLETE constant order_status.orderstatus%type := 'C';
MYSTATERROR constant order_status.orderstatus%type := 'E';
",
                ),
            ),
        ),
    ),
);
    @endcode

    @subsection ora_types Types

    The @ref schema_desc_hash takes an optional key, \c "types" that allows types in Oracle schemas to be managed along with other objects.

    The \c "types" should be assigned to a hash, each key name is the name of the type, and the values are strings giving the type definition.

    The \c "types" key can go in the top level of the @ref schema_desc_hash for Oracle-only schemas, or, for schemas targeting multiple database types, under the \c "driver" and \c "oracle" keys as in the following example:

    @code
my hash $schema = (
    "driver": (
        "oracle": (
            "types": (
                "num_array": "table of number",
                "str_array": "table of varchar2(240)",
            ),
        ),
    ),
);
    @endcode

    @see OracleSqlUtil::OracleDatabase::OracleSchemaDescriptionOptions for a list of Oracle-specific schema description hash keys.

    @section ora_relnotes Release Notes

    @subsection v12 OracleSqlUtil v1.2
    - implemented support for the \c "returning" clause as an insert option
    - implemented support for views for DML in the @ref OracleSqlUtil::OracleTable class
    - implemented @ref OracleSqlUtil::OracleTable::getBaseType()
    - implemented support for Oracle pseudocolumns in queries
    - implemented support for \c cop_cast operator

    @subsection v11 OracleSqlUtil v1.1
    - fixed selects with "limit" but no "offset"
    - convert date/time values to timestamps with microseconds resolution instead of dates with second resolution when dynamically inserting values as strings in SQL (binding by value not affected)
    - fixed schema information classes when the "string-numbers" driver option is enabled

    @subsection v10 OracleSqlUtil v1.0
    - initial release
*/

#! the OracleSqlUtil namespace contains all the objects in the OracleSqlUtil module
public namespace OracleSqlUtil {
    #! returns an OracleTable object corresponding to the arguments
    public OracleTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
        return new OracleTable(nds, nname, opts);
    }

    #! returns an OracleDatabase object corresponding to the arguments
    public OracleDatabase sub get_database(AbstractDatasource nds, *hash opts) {
        return new OracleDatabase(nds, opts);
    }

    #! represents an Oracle column
    public class OracleColumn inherits SqlUtil::AbstractColumn {
        public {
            #! the column uses character semantics
            bool char_used;
            #! byte size of the column
            int byte_size;
        }

        constructor(string n, string nt, *string qt, softint sz, bool nul, *string dv, *string cm, bool is_char = False, bool cu = False, softint bs) : AbstractColumn(n, nt, qt, sz, nul, dv, cm) {
            # only set "char_used" if we are dealing with a char column
            char_used = is_char && cu;
            byte_size = bs;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the colunn to a table or when creating the table)
        string getNativeTypeString() {
            if (char_used)
                return sprintf("%s(%d char)", native_type, size);
            return AbstractColumn::getNativeTypeString();
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getAddColumnSql($t);
            @endcode

            @param t the AbstractTable object to modify
         */
        list getAddColumnSql(AbstractTable t) {
            list l += sprintf("alter table %s add %s", t.getSqlName(), AbstractColumn::getCreateSql(t));
            if (comment)
                l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, t.getSqlValue(comment));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal

            @param t the AbstractTable object to modify
            @param col the new column definition
         */
        list getModifySqlImpl(AbstractTable t, AbstractColumn col, *hash opt) {
            list l = ();
            OracleColumn c = col;

            bool modified;
            string sql = sprintf("alter table %s modify %s", t.getSqlName(), name);

            # get new native type declaration string
            string nts = c.getNativeTypeString();
            if (getNativeTypeString() != nts) {
                sql += sprintf(" %s", nts);
                modified = True;
            }

            if (def_val != c.def_val) {
                sql += sprintf(" default %s", exists c.def_val ? c.def_val : "null");
                modified = True;
            }

            if (nullable != c.nullable) {
                sql += sprintf(" %snull", c.nullable ? "" : "not ");
                modified = True;
            }
            if (modified)
                l += sql;

            # to remove a comment we set it to the empty string ('')
            # http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_4009.htm
            if (c.comment != comment)
                l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, c.comment ? t.getSqlValue(c.comment) : "''");
            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code
my string $str = $col.getRenameSql($t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("alter table %s rename column %s to %s", t.getSqlName(), name, new_name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractColumn c) {
            return char_used == cast<OracleColumn>(c).char_used;
        }
    }

    #! represents an Oracle number column
    public class OracleNumberColumn inherits OracleColumn, SqlUtil::NumericColumnInfo {
        constructor(string n, string nt, *string qt, softint sz, bool nul, *string dv, *string cm, softint bs, softint n_scale = 0) : OracleColumn(n, nt, qt, sz, nul, dv, cm, False, False, bs), NumericColumnInfo(n_scale) {
        }

        string getNativeTypeString() {
            return NumericColumnInfo::getNativeTypeString(native_type, size);
        }
    }

    #! represents an Oracle index
    public class OracleIndex inherits SqlUtil::AbstractIndex {
        public {
            #! the native type of the index (if supported)
            string native_type;

            #! the tablespace name of the index (if supported)
            *string tablespace;
        }

        #! creates the object from the arguments
        constructor(string n, bool u, hash c, string nt, *string t) : AbstractIndex(n, u, c) {
            native_type = nt;
            tablespace = t;
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            if (opt.compute_statistics)
                sql += " compute statistics";

            return sql;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        bool equalImpl(AbstractIndex ix) {
            return True;
        }

        #! returns a string that can be used to rename the index in the database
        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter index %s rename to %s", name, new_name);
        }
    }

    #! represents an Oracle foreign constraint
    public class OracleForeignConstraint inherits SqlUtil::AbstractForeignConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t, bool e) : AbstractForeignConstraint(n, c, t) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, h.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    #! represents an Oracle check constraint
    public class OracleCheckConstraint inherits SqlUtil::AbstractCheckConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool e = True) : AbstractCheckConstraint(n, n_src) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    #! represents an Oracle unique constraint
    public class OracleUniqueConstraint inherits SqlUtil::AbstractUniqueConstraint {
        private {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;

            #! any tablespace for the unique key index
            *string tablespace;
        }

        constructor(string n, hash n_cols, bool e = True, *string ts) : AbstractUniqueConstraint(n, n_cols) {
            enabled = e;
            tablespace = ts;
        }

        #! returns the OracleColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        OracleColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s unique (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }

        #! returns @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
        bool isEnabled() {
            return enabled;
        }

        #! returns the tablespace name used for this constraint, if known
        *string getTablespace() {
            return tablespace;
        }
    }

    #! represents an Oracle primary key
    public class OraclePrimaryKey inherits SqlUtil::AbstractPrimaryKey {
        private {
            #! any tablespace for the primary key index
            *string tablespace;
        }

        constructor() {
        }

        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c) {
            tablespace = ts;
        }

        #! returns the OracleColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        OracleColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to drop the constraint from the database
        /** we use "keep index" to ensure that indexes are not dropped automatically for consistency's sake
        */
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop primary key keep index", table_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    #! represents an Oracle sequence
    public class OracleSequence inherits SqlUtil::AbstractSequence {
        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_end) : AbstractSequence(n_name, n_start, n_increment, n_end) {
        }

        #! returns a string that can be used to create the sequence in the database
        string getCreateSql(*hash opt) {
            string sql = sprintf("create sequence %s start with %d increment by %d ", name, start, increment);
            sql += max ? sprintf("maxvalue %d", max) : "nomaxvalue";
            return sql;
        }

        #! returns a string that can be used to rename the sequence in the database
        string getRenameSql(string new_name) {
            return sprintf("rename %s to %s", name, new_name);
        }
    }

    #! represents an Oracle view
    public class OracleView inherits SqlUtil::AbstractView {
        public {
            #! Type clause of the typed view
            *string type_text;
            #! WITH OID clause of the typed view
            *string oid_text;
            #! Owner of the type of the view if the view is a typed view
            *string view_type_owner;
            #! Type of the view if the view is a typed view
            *string view_type;
            #! Name of the superview
            *string superview_name;
            #! Indicates whether the view contains container-specific data
            bool container_data;
        }

        #! creates the object from the arguments
        constructor(string n_name, string n_src, *string n_schema, *string n_type_text,
                    *string n_oid_text, *string n_view_type_owner,
                    *string n_view_type, *string n_superview_name,
                    bool n_updatable, bool n_container_data)
                : AbstractView(n_name, n_src) {
            updatable = n_updatable;
            schema = n_schema;
            type_text = n_type_text;
            oid_text = n_oid_text;
            view_type_owner = n_view_type_owner;
            view_type = n_view_type;
            superview_name = n_superview_name;
            container_data = n_container_data;
        }

        #! returns a string that can be used to create the view in the database
        string getCreateSql(*hash opt) {
            # TODO/FIXME: more oracle options
            return sprintf("create %s%sview %s as %s",
                           opt.replace ? "or replace " : "",
                           opt.force ? "force " : "noforce ",
                           name,
                           src
                          );
        }

        #! returns a string that can be used to rename the view in the database
        softlist getRenameSql(string new_name) {
            return sprintf("rename %s to %s", name, new_name);
        }
    }

    #! represents an Oracle trigger
    public class OracleTrigger inherits SqlUtil::AbstractTrigger {
        public {
            #! @ref Qore::True "True" if the trigger is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool en = True) : AbstractTrigger(n, n_src) {
            enabled = en;
        }

        softlist getCreateSql(string table_name, *hash opt) {
            return sprintf("create%s trigger %s %s", opt.replace ? " or replace" : "", name, src);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return enabled == cast<OracleTrigger>(t).enabled;
        }

        #! returns a string that can be used to rename the trigger in the database
        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("alter trigger %s rename to %s", name, new_name);
        }

        #! returns a string that can be used to drop the trigger from the database
        softlist getDropSql(string table_name) {
            return sprintf("drop trigger %s", name);
        }
    }

    #! the base class for Oracle code objects
    public class OracleCodeBase inherits SqlUtil::AbstractFunction {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : AbstractFunction(n, n_type, n_src) {
        }

        #! returns a string that can be used to create the object in the database
        softlist getCreateSql(*hash opt) {
            return sprintf("create%s %s %s", opt.replace ? " or replace" : "", type, src);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the object in the database
        list getRenameSql(string new_name) {
            list l = ();
            l += getDropSql();
            l += getCreateSql();
            return l;
        }
    }

    #! represents an Oracle type
    public class OracleType inherits OracleCodeBase {
        constructor(string n_name, string n_src) : OracleCodeBase(n_name, "type", n_src) {
        }

        #! Force to drop named type (object or collection)
        /** Named types in schema can have dependencies between each other.
            But the FORCE keyword used in drop allows us to avoid complex
            dependency tree calculation because all objects will be droped
            at the end

            @note It should be used only in Schema management
         */
        string getDropSqlForce() {
            return sprintf("drop %s %s force", type, name);
        }
    }

    #! represents an Oracle function
    public class OracleFunction inherits OracleCodeBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleCodeBase(n, "function", n_src) {
        }
    }

    #! represents an Oracle procedure
    public class OracleProcedure inherits OracleCodeBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleCodeBase(n, "procedure", n_src) {
        }
    }

    #! represents an Oracle package
    public class OraclePackage inherits OracleCodeBase {
        private {
            #! package body source
            *string body_src;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the package
            @param n_src the source of the package declaration
            @param n_body_src the package body source
         */
        constructor(string n, string n_src, *string n_body_src) : OracleCodeBase(n, "package", n_src) {
            body_src = n_body_src;
        }

        #! returns a string that can be used to create the package in the database
        list getCreateSql(*hash opt) {
            list l = ();
            # package declaration
            l += sprintf("create%s package %s", opt.replace ? " or replace" : "", src);
            # package body
            if (body_src)
                l += sprintf("create%s package body %s", opt.replace ? " or replace" : "", body_src);
            return l;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return body_src == cast<OraclePackage>(t).body_src;
        }
    }

    #! represents an Oracle materialized view
    public class OracleMaterializedView inherits OracleCodeBase {
        public {
            #! Flag if is loggign mode used
            bool logging;
            #! Flag if is index used
            bool use_index;
            #! Name of the potential tablespace
            *string tablespace;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the materialized view
            @param n_src the source of the materialized view
            @param n_tablespace the optional data tablespace used by the materialized view
            @param n_logging if the materialized view should use logging
            @param n_use_index if the materialized view should use an index
         */
        constructor(string n, string n_src, bool n_logging = True, bool n_use_index = True, *string n_tablespace) : OracleCodeBase(n, "materialized view", n_src) {
            logging = n_logging;
            use_index = n_use_index;
            tablespace = n_tablespace;
        }

        #! returns a string that can be used to create the object in the database
        softlist getCreateSql(*hash opt) {
            string sql = sprintf("create %s %s", type, name);

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            sql += logging ? " logging" : " nologging";
            sql += use_index ? " using index" : " using no index";

            sql += " as " + src;

            return sql;
        }

        bool equalImpl(AbstractFunctionBase t) {
            OracleMaterializedView mv = cast<OracleMaterializedView>(t);
            return mv.logging == logging && mv.use_index == use_index;
        }
    }

    #! the Oracle specialization for SqlUtil::AbstractDatabase
    public class OracleDatabase inherits SqlUtil::AbstractDatabase {
        public {
            #! oracle-specific generic creation options
            const OracleCreationOptions = AbstractDatabase::CreationOptions + (
                "compute_statistics": Type::Boolean,
                );

            #! oracle-specific schema description / alignment options
            const OracleAlignSchemaOptions = AbstractDatabase::CreationOptions
                + OracleCreationOptions
                + OracleTable::OracleAlignTableOptions
                ;

            #! oracle-specific schema description keys
            /** This constant extends @ref SqlUtil::AbstractDatabase::SchemaDescriptionOptions as returned by @ref OracleSqlUtil::OracleTable::getSchemaDescriptionOptions with the following Oracle-specific keys:
                - \c types: for Oracle type definitions
                - \c type_map: to automatically renaming Oracle types during schema alignment
                - \c packages: for Oracle package descriptions
                - \c package_map: for automatically renaming Oracle types during schema alignment
                - \c materialized_views: for Oracle materialized view descriptions
                - \c materialized_view_map: for automatically renaming Oracle materialized views during schema alignment
            */
            const OracleSchemaDescriptionOptions = AbstractDatabase::SchemaDescriptionOptions + (
                "types": Type::Hash,
                "type_map": Type::Hash,

                "packages": Type::Hash,
                "package_map": Type::Hash,

                "materialized_views": Type::Hash,
                "materialized_view_map": Type::Hash,

                #"synonyms": Type::Hash,
                #"synonym_map": Type::Hash,
                );

            #! oracle-specific package description options
            const OraclePackageDescriptionOptions = (
                "src": Type::String,
                "body": Type::String,
                );

            #! oracle-specific materialized view description options
            const OracleMaterializedViewDescriptionOptions = (
                "logging": Type::Boolean,
                "use_index": Type::Boolean,
                "tablespace": Type::String,
                "src": Type::String,
                );

            #! hash of reserved words
            const OracleReservedWords = (
                "access": True,
                "else": True,
                "modify": True,
                "start": True,
                "add": True,
                "exclusive": True,
                "noaudit": True,
                "select": True,
                "all": True,
                "exists": True,
                "nocompress": True,
                "session": True,
                "alter": True,
                "file": True,
                "not": True,
                "set": True,
                "and": True,
                "float": True,
                "notfound": True,
                "share": True,
                "any": True,
                "for": True,
                "nowait": True,
                "size": True,
                "arraylen": True,
                "from": True,
                "null": True,
                "smallint": True,
                "as": True,
                "grant": True,
                "number": True,
                "sqlbuf": True,
                "asc": True,
                "group": True,
                "of": True,
                "successful": True,
                "audit": True,
                "having": True,
                "offline": True,
                "synonym": True,
                "between": True,
                "identified": True,
                "on": True,
                "sysdate": True,
                "by": True,
                "immediate": True,
                "online": True,
                "table": True,
                "char": True,
                "in": True,
                "option": True,
                "then": True,
                "check": True,
                "increment": True,
                "or": True,
                "to": True,
                "cluster": True,
                "index": True,
                "order": True,
                "trigger": True,
                "column": True,
                "initial": True,
                "pctfree": True,
                "uid": True,
                "comment": True,
                "insert": True,
                "prior": True,
                "union": True,
                "compress": True,
                "integer": True,
                "privileges": True,
                "unique": True,
                "connect": True,
                "intersect": True,
                "public": True,
                "update": True,
                "create": True,
                "into": True,
                "raw": True,
                "user": True,
                "current": True,
                "is": True,
                "rename": True,
                "validate": True,
                "date": True,
                "level": True,
                "resource": True,
                "values": True,
                "decimal": True,
                "like": True,
                "revoke": True,
                "varchar": True,
                "default": True,
                "lock": True,
                "row": True,
                "varchar2": True,
                "delete": True,
                "long": True,
                "view": True,
                "desc": True,
                "maxextents": True,
                "rowlabel": True,
                "whenever": True,
                "distinct": True,
                "minus": True,
                "rownum": True,
                "where": True,
                "drop": True,
                "mode": True,
                "rows": True,
                "with": True,
                );

            #! Options for rebuildIndex()
            const OracleRebuildIndexOptions = (
                "parallel"          : Type::Boolean,
                "logging"           : Type::Boolean,
                "statictics"        : Type::Boolean,
                "tablespace"        : Type::String,
                "cond_rebuild"      : Type::Boolean,
                "cond_maxheight"    : Type::Int,
                "cond_maxleafpct"   : Type::Int,
                );

            #! Options for computeStatistics()
            const OracleComputeStatisticsOptions = ComputeStatisticsOptions + (
                "estimate_percent"  : Type::Int,
                "block_sample"      : Type::Boolean,
                "method_opt"        : Type::String,
                "degree"            : Type::Int,
                "granularity"       : Type::String,
                "cascade"           : Type::Boolean,
                "stattab"           : Type::String,
                "statid"            : Type::String,
                "options"           : Type::String,
                "statown"           : Type::String,
                );
        }

        #! creates the object from the arguments given
        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
        }

        private list featuresImpl() {
            return list(DB_FUNCTIONS, DB_MVIEWS, DB_PACKAGES, DB_PROCEDURES,
                        DB_SEQUENCES, DB_TABLES, DB_TYPES, DB_VIEWS);
        }

        private OracleSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return new OracleSequence(name, start, increment, end);
        }

        private getSchemaName(reference name, reference schema) {
            # see if there is a schema in the name
            *string sstr = (name =~ x/^(\w+)\.\w+/)[0];
            if (sstr) {
                schema = sstr;
                splice name, 0, schema.size() + 1;
            }
            else
                schema = ds.getUserName();
        }

        private *AbstractSequence getSequenceImpl(string name) {
            string schema;
            getSchemaName(\name, \schema);

            *hash row = ds.selectRow("select * from all_sequences where sequence_owner = %v and sequence_name = %v", schema.upr(), name.upr());
            if (!row)
                return;
            return new OracleSequence(name, row.min_value, row.increment_by, row.max_value > 9000000000000000000n ? NOTHING : row.max_value);
        }

        private *AbstractView getViewImpl(string name) {
            string schema;
            getSchemaName(\name, \schema);

            *hash row = ds.selectRow("select * from all_views where owner = %v and view_name = %v", schema.upr(), name.upr());
            if (!row)
                return;

            HashIterator it(row);
            while (it.next()) {
                if (it.getValue() == NULL)
                    row{it.getKey()} = NOTHING;
            }

            return new OracleView(name, row.text, schema, row.type_text,
                                  row.oid_text, row.view_type_owner,
                                  row.view_type, row.superview_name,
                                  row.read_only == 'N', row.container_data == 'Y');
        }

        private OracleFunction makeFunctionImpl(string name, string src, *hash opts) {
            checkSource("function", name, \src);

            return new OracleFunction(name, src);
        }

        private OracleProcedure makeProcedureImpl(string name, string src, *hash opts) {
            checkSource("procedure", name, \src);

            return new OracleProcedure(name, src);
        }

        private OraclePackage makePackage(string name, string src, string body, *hash opts) {
            checkSource("package", name, \src);

            return new OraclePackage(name, src, body);
        }

        private OraclePackage makePackageFromDescription(string name, hash ph, *hash opts) {
            validateOptionsIntern("PACKAGE-DESCRIPTION-ERROR", OraclePackageDescriptionOptions, \ph);
            if (!ph.src)
                throw "PACKAGE-DESCRIPTION-ERROR", sprintf("package %y: description hash has no 'src' key (keys: %y)", name, ph.keys());

            checkSource("package", name, \ph.src);
            if (ph.body)
                checkSource("package", name, \ph.body);

            return new OraclePackage(name, ph.src, ph.body);
        }

        private OracleType makeType(string name, string src, *hash opts) {
            return new OracleType(name, sprintf("%s as %s", name, src));
        }

        private OracleMaterializedView makeMaterializedView(string name, string src, bool logging = True, bool use_index = True, *string tablespace, *hash opts) {
            return new OracleMaterializedView(name, src, logging, use_index, tablespace);
        }

        private OracleMaterializedView makeMaterializedViewFromDescription(string name, hash mvh, *hash opts) {
            validateOptionsIntern("MATERIALIZEDVIEW-DESCRIPTION-ERROR", OracleMaterializedViewDescriptionOptions, \mvh);
            if (!mvh.src)
                throw "MATERIALIZEDVIEW-DESCRIPTION-ERROR", sprintf("materialized view %y: description hash has no 'src' key (keys: %y)", name, mvh.keys());

            return new OracleMaterializedView(name, mvh.src, mvh.logging, mvh.use_index, mvh.tablespace);
        }

        private list getDropSchemaSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                # drop materialized views
                list tl = dropSqlUnlocked("materialized_view", schema_hash, \getMaterializedView(), \makeMaterializedViewFromDescription(), opt, Type::Hash);
                if (tl) l += tl;

                # drop packages
                tl = dropSqlUnlocked("package", schema_hash, \getPackage(), \makePackageFromDescription(), opt, Type::Hash);
                if (tl) l += tl;

                return l;
            }

            # drop types
            list tl = dropSqlUnlocked("type", schema_hash, \getType(), \makeType(), opt, Type::String);
            if (tl) l += tl;

            return l;
        }

        private list getAlignSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                # create types
                list tl = alignCodeUnlocked("type", schema_hash, \getType(), \makeType(), opt, Type::String);
                if (tl) l += tl;

                return l;
            }

            # create packages
            list tl = alignCodeUnlocked("package", schema_hash, \getPackage(), \makePackageFromDescription(), opt, Type::Hash);
            if (tl) l += tl;

            # create materialized views
            tl = alignCodeUnlocked("materialized_view", schema_hash, \getMaterializedView(), \makeMaterializedViewFromDescription(), opt, Type::Hash);
            if (tl) l += tl;

            return l;
        }

        private *OracleFunction getFunctionImpl(string name) {
            *string src = getSource("FUNCTION", name);
            if (!src)
                return;

            return new OracleFunction(name, src);
        }

        private *OracleProcedure getProcedureImpl(string name) {
            *string src = getSource("PROCEDURE", name);
            if (!src)
                return;

            return new OracleProcedure(name, src);
        }

        #! returns an OraclePackage object for the package name given or @ref nothing if the object does not exist or is not accessible
        *OraclePackage getPackage(string name) {
            *string src = getSource("PACKAGE", name);
            if (!src)
                return;

            *string body_src = getSource("PACKAGE BODY", name);
            return new OraclePackage(name, src, body_src);
        }

        #! returns an OracleType object for the package name given or @ref nothing if the object does not exist or is not accessible
        *OracleType getType(string name) {
            *string src = getSource("TYPE", name);
            if (!src)
                return;

            return new OracleType(name, src);
        }

        #! returns an OracleMaterializedView object for the package name given or @ref nothing if the object does not exist or is not accessible
        *OracleMaterializedView getMaterializedView(string name) {
            *hash row = ds.selectRow("select * from user_mviews mv, user_tables t where mview_name = %v and mview_name = table_name", name.upr());
            if (!row)
                return;

            if (!native_case)
                map row.$1 = row.$1.lwr(), ("tablespace_name");

            return new OracleMaterializedView(name, row.query, row.logging == "YES", row.use_no_index == "N", row.tablespace_name);
        }

        private *string getSource(string type, string name) {
            *list l = ds.select("select text from user_source where type = %v and name = %v order by line", type, name.upr()).text;
            if (!l)
                return;
            string src = foldl $1 + $2, l;

            if (!regex(src, "^" + type + "([[:blank:]]|$)", RE_Caseless))
                throw "SOURCE-ERROR", sprintf("source to %s %y does not begin with the type name %y; source: %y", type, name, type, src.substr(0, 50));

            # remove the type name from the beginning of the string
            splice src, 0, type.size() + 1;

            checkSource(type, name, \src);
            return src;
        }

        private checkSource(string type, string name, reference src) {
            # remove whitespace from the beginning and end of the string
            trim src;

            # ensure the name of the object is at the beginning of the string
            if (!regex(src, "^(\")?" + name + "(\")?", RE_Caseless))
                throw "SOURCE-ERROR", sprintf("source to %s %y does not begin with the %s name %y; source: %y", type, name, type, name, src.substr(0, 50));
        }

        #! returns a list of string synonym names in the database
        list listSynonyms() {
            return getListIntern("SYNONYM");
        }

        #! returns an iterator listing the string synonym names in the database
        ListIterator synonymIterator() {
            return listSynonyms().iterator();
        }

        #! returns a list of string type names in the database
        list listTypes() {
            return getListIntern("TYPE");
        }

        #! returns an iterator listing the string type names in the database
        ListIterator typeIterator() {
            return listTypes().iterator();
        }

        #! returns a list of string package names in the database
        list listPackages() {
            return getListIntern("PACKAGE");
        }

        #! returns an iterator listing the string package names in the database
        ListIterator packageIterator() {
            return listPackages().iterator();
        }

        #! returns a list of string materialized view names in the database
        list listMaterializedViews() {
            return getListIntern("MATERIALIZED VIEW");
        }

        #! returns an iterator listing the string materialized view  names in the database
        ListIterator materializedViewIterator() {
            return listMaterializedViews().iterator();
        }

        private list listTablesImpl() {
            list l = getListIntern(ds.select("select table_name from user_tables").table_name);

            # add all tables accessible with synonyms
            *list tl = ds.select("select synonym_name from user_synonyms s, all_tables t where s.table_owner = t.owner and s.table_name = t.table_name").synonym_name;
            if (tl)
                l += native_case ? tl : (map $1.lwr(), tl);

            return l;
        }

        private list listFunctionsImpl() {
            return getListIntern("FUNCTION");
        }

        private list listProceduresImpl() {
            return getListIntern("PROCEDURE");
        }

        private list listSequencesImpl() {
            return getListIntern("SEQUENCE");
        }

        private list listViewsImpl() {
            return getListIntern("VIEW");
        }

        private list getListIntern(string type) {
            return getListIntern(ds.select("select object_name from user_objects where object_type = %v", type).object_name);
        }

        private list getListIntern(list l) {
            return native_case ? l : (map $1.lwr(), l);
        }

        private string getCreateSqlImpl(list l) {
            return OracleDatabase::getCreateSql(l);
        }

        static string getCreateSql(list l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l);
        }

        #! returns driver-specific options to the base abstract class
        private hash getCreationOptions() {
            return OracleCreationOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getAlignSchemaOptions() {
            return OracleAlignSchemaOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getSchemaDescriptionOptions() {
            return OracleSchemaDescriptionOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getRebuildIndexOptions() {
            return OracleRebuildIndexOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getComputeStatisticsOptions() {
            return OracleComputeStatisticsOptions;
        }

        #! returns the next value in the given sequence
        private softint getNextSequenceValueImpl(string name) {
            return ds.selectRow("select %s.nextval from dual", name).nextval;
        }

        #! returns the last value issued for the given sequence in the current session
        private softint getCurrentSequenceValueImpl(string name) {
            return ds.selectRow("select %s.currval from dual", name).nextval;
        }

        #! returns @ref Qore::True "True" if the database supports sequences
        private bool supportsSequencesImpl() {
            return True;
        }

        #! returns @ref Qore::True "True" if the database supports named types
        private bool supportsTypesImpl() {
            return True;
        }

        #! returns @ref Qore::True "True" if the database supports packages
        private bool supportsPackagesImpl() {
            return True;
        }

        #! analyze index with ALTER INDEX ANAYZE. Then it checks INDEX_STATS for advices to rebuild.
        /** Outputs of this method are hints only. Real investigation of index is strongly recommended.

            @warning content of this method can be changed anytime when there will be any better way how to analyze indexes.

            @param index an AbstractIndex to analyze
            @param maxh maximum oracle index height before rebuilding index
            @param maxleaf maximum oracle percentage of deleted leaf nodes before rebuilding index

            @return bool True for "suggested for rebuilding", False for "no action needed"

            @throws ANALYZE-INDEX-ERROR if there are no data in INDEX_STATS table
        */
        bool rebuildIndexAnalyze(AbstractIndex index, int maxh, int maxleaf) {
            return rebuildIndexAnalyze(index.name, maxh, maxleaf);
        }

        #! analyze index with ALTER INDEX ANAYZE. Then it checks INDEX_STATS for advices to rebuild.
        /** Outputs of this method are hints only. Real investigation of index is strongly recommended.

            @warning content of this method can be changed anytime when there will be any better way how to analyze indexes.

            @param name index name
            @param maxh maximum oracle index height before rebuilding index
            @param maxleaf maximum oracle percentage of deleted leaf nodes before rebuilding index

            @return bool True for "suggested for rebuilding", False for "no action needed"

            @throws ANALYZE-INDEX-ERROR if there are no data in INDEX_STATS table
        */
        bool rebuildIndexAnalyze(string name, int maxh, int maxleaf) {
            # unfortunately analyze index/select * from index_stats requires one transaction
            ds.select("analyze index " + name + " validate structure");
            *hash is = ds.selectRow("select name, height, lf_rows as leafrows, del_lf_rows as leafrowsdeleted from index_stats");
            if (!is)
                return False;

            softfloat pct = is.leafrows ? float(is.leafrowsdeleted) * 100 / is.leafrows : 0;
            return is.height > maxh || (is.leafrowsdeleted > 0 && pct > maxleaf);
        }

        #! rebuild index implementation. See @ref SqlUtil::AbstractDatabase::rebuildIndex()
        private bool rebuildIndexImpl(string name, *hash options) {
            bool rebuild = True;
            # this conditional rebuilding is still place to be used carefully.
            # See eg. https://richardfoote.wordpress.com/2011/05/22/del_lf_rows-index-rebuild-criteria-codex/
            if (options.cond_rebuild) {
                int maxh = options.cond_maxheight ?? 20;
                int maxleaf = options.cond_maxleafpct ?? 3;
                rebuild = rebuildIndexAnalyze(name, maxh, maxleaf);
            }

            if (!rebuild)
                return False;

            string sql = sprintf("alter index %s rebuild ", name);
            sql += options.parallel ? "parallel " : "";
            sql += options.logging ? "" : "nologging ";
            sql += options.statictics ? "compute statistics" : "";
            if (strlen(options.tablespace))
                sql += " tablespace " + options.tablespace;

            ds.select(sql);
            return True;
        }

        #! compute statistics implementation. See @ref SqlUtil::AbstractDatabase::computeStatistics()
        private computeStatisticsImpl(*hash options) {
            if (options.tables)
                return computeStatisticsTablesImpl(options);
            else
                return computeStatisticsSchemaImpl(options);
        }

        #! compute statistics for schema - a helper method
        private computeStatisticsSchemaImpl(*hash options) {
            string sql = "begin
            dbms_stats.gather_schema_stats(
                                        ownname => %v,
                                        estimate_percent => %s,
                                        block_sample => %s,
                                        method_opt => %v,
                                        degree => %v,
                                        granularity => %v,
                                        cascade => %s,
                                        stattab => %v,
                                        statid => %v,
                                        options => %v,
                                        statown => %v
                                    );
            end;";

            ds.select(sql,  ds.getUserName(),
                            options.estimate_percent ?? "dbms_stats.auto_sample_size",
                            options.block_sample ? "true" : "false",
                            options.method_opt ?? "for all columns size auto",
                            options.degree ?? NULL,
                            options.granularity ?? "all",
                            !exists options.cascade ? "dbms_stats.auto_cascade" : options.cascade ? "true" : "false",
                            options.stattab ?? NULL,
                            options.statid ?? NULL,
                            options.options ?? "gather auto",
                            options.statown ?? NULL
                     );
        }

        #! compute statistics for table(s) - a helper method
        private computeStatisticsTablesImpl(*hash options) {
            string sql = "begin
                dbms_stats.gather_table_stats (
                                        ownname => %v,
                                        tabname => %v,
                                        partname => %v,
                                        estimate_percent => %s,
                                        block_sample => %s,
                                        method_opt => %v,
                                        degree => %v,
                                        granularity => %v,
                                        cascade => %s,
                                        stattab => %v,
                                        statid => %v,
                                        statown => %v
                                    );
                end;";

            foreach string i in (options.tables) {
                ds.select(sql,  ds.getUserName(),
                                i,
                                options.partname ?? NULL,
                                options.estimate_percent ?? "dbms_stats.auto_sample_size",
                                options.block_sample ? "true" : "false",
                                options.method_opt ?? "for all columns size auto",
                                options.degree ?? NULL,
                                options.granularity ?? "all",
                                options.cascade ? "true" : "false",
                                options.stattab ?? NULL,
                                options.statid ?? NULL,
                                options.statown ?? NULL
                         );
            }
        }

        #! reclaim space implementation. See @ref SqlUtil::AbstractDatabase::reclaimSpace()
        private reclaimSpaceImpl(*hash options) {
            string sql = "alter table %s shrink space cascade";
            softlist tables = options.tables ? options.tables : listTables();

            foreach string i in (tables.iterator()) {
                ds.select(sql, i);
            }
        }

    }

    #! represents an Oracle table
    /** this is the specialization of SqlUtil::AbstractTable
    */
    public class OracleTable inherits SqlUtil::AbstractTable {
        public {
            #! maps oracle type names to type descriptions
            const OraTypeMap = (
                "number": ("qore": Type::Number, "size": SZ_NUM, "size_range": (1, 38), "scale_range": (-84, 127)),
                "varchar2": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "char": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "date": ("qore": Type::Date,),
                "timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "timestamp with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "timestamp with local time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "interval year to month": ("qore": Type::Date,),
                "interval day to second": ("qore": Type::Date,),
                "timestamp(0)": ("qore": Type::Date,),
                "timestamp(1)": ("qore": Type::Date,),
                "timestamp(2)": ("qore": Type::Date,),
                "timestamp(3)": ("qore": Type::Date,),
                "timestamp(4)": ("qore": Type::Date,),
                "timestamp(5)": ("qore": Type::Date,),
                "timestamp(6)": ("qore": Type::Date,),
                "timestamp(7)": ("qore": Type::Date,),
                "timestamp(8)": ("qore": Type::Date,),
                "timestamp(9)": ("qore": Type::Date,),
                "timestamp(0) with time zone": ("qore": Type::Date,),
                "timestamp(1) with time zone": ("qore": Type::Date,),
                "timestamp(2) with time zone": ("qore": Type::Date,),
                "timestamp(3) with time zone": ("qore": Type::Date,),
                "timestamp(4) with time zone": ("qore": Type::Date,),
                "timestamp(5) with time zone": ("qore": Type::Date,),
                "timestamp(6) with time zone": ("qore": Type::Date,),
                "timestamp(7) with time zone": ("qore": Type::Date,),
                "timestamp(8) with time zone": ("qore": Type::Date,),
                "timestamp(9) with time zone": ("qore": Type::Date,),
                "timestamp(0) with local time zone": ("qore": Type::Date,),
                "timestamp(1) with local time zone": ("qore": Type::Date,),
                "timestamp(2) with local time zone": ("qore": Type::Date,),
                "timestamp(3) with local time zone": ("qore": Type::Date,),
                "timestamp(4) with local time zone": ("qore": Type::Date,),
                "timestamp(5) with local time zone": ("qore": Type::Date,),
                "timestamp(6) with local time zone": ("qore": Type::Date,),
                "timestamp(7) with local time zone": ("qore": Type::Date,),
                "timestamp(8) with local time zone": ("qore": Type::Date,),
                "timestamp(9) with local time zone": ("qore": Type::Date,),
                "interval year(0) to month": ("qore": Type::Date,),
                "interval year(1) to month": ("qore": Type::Date,),
                "interval year(2) to month": ("qore": Type::Date,),
                "interval year(3) to month": ("qore": Type::Date,),
                "interval year(4) to month": ("qore": Type::Date,),
                "interval year(5) to month": ("qore": Type::Date,),
                "interval year(6) to month": ("qore": Type::Date,),
                "interval year(7) to month": ("qore": Type::Date,),
                "interval year(8) to month": ("qore": Type::Date,),
                "interval year(9) to month": ("qore": Type::Date,),
                "interval day(0) to second(0)": ("qore": Type::Date,),
                "interval day(0) to second(1)": ("qore": Type::Date,),
                "interval day(0) to second(2)": ("qore": Type::Date,),
                "interval day(0) to second(3)": ("qore": Type::Date,),
                "interval day(0) to second(4)": ("qore": Type::Date,),
                "interval day(0) to second(5)": ("qore": Type::Date,),
                "interval day(0) to second(6)": ("qore": Type::Date,),
                "interval day(0) to second(7)": ("qore": Type::Date,),
                "interval day(0) to second(8)": ("qore": Type::Date,),
                "interval day(0) to second(9)": ("qore": Type::Date,),
                "interval day(1) to second(0)": ("qore": Type::Date,),
                "interval day(1) to second(1)": ("qore": Type::Date,),
                "interval day(1) to second(2)": ("qore": Type::Date,),
                "interval day(1) to second(3)": ("qore": Type::Date,),
                "interval day(1) to second(4)": ("qore": Type::Date,),
                "interval day(1) to second(5)": ("qore": Type::Date,),
                "interval day(1) to second(6)": ("qore": Type::Date,),
                "interval day(1) to second(7)": ("qore": Type::Date,),
                "interval day(1) to second(8)": ("qore": Type::Date,),
                "interval day(1) to second(9)": ("qore": Type::Date,),
                "interval day(2) to second(0)": ("qore": Type::Date,),
                "interval day(2) to second(1)": ("qore": Type::Date,),
                "interval day(2) to second(2)": ("qore": Type::Date,),
                "interval day(2) to second(3)": ("qore": Type::Date,),
                "interval day(2) to second(4)": ("qore": Type::Date,),
                "interval day(2) to second(5)": ("qore": Type::Date,),
                "interval day(2) to second(6)": ("qore": Type::Date,),
                "interval day(2) to second(7)": ("qore": Type::Date,),
                "interval day(2) to second(8)": ("qore": Type::Date,),
                "interval day(2) to second(9)": ("qore": Type::Date,),
                "clob": ("qore": Type::String,),
                "blob": ("qore": Type::Binary,),
                "long": ("qore": Type::Binary,),
                "raw": ("qore": Type::Binary, "size": SZ_MAND, "size_range": (1, 2000)),
                "bfile": ("qore": Type::Binary,),
                "binary_float": ("qore": Type::Float,),
                "binary_double": ("qore": Type::Float,),
                "rowid": ("qore": Type::String,),
                "urowid": ("qore": Type::String, "size": SZ_OPT, "size_range": (1, 4000)),
                );

            #! maps qore type names to an oracle type
            const QoreTypeMap = (
                "integer": "number",
                "float": "number",
                "number": "number",
                "string": "varchar2",
                "date": "timestamp(6)",
                "binary": "blob",
                SqlUtil::CHAR: "char",
                SqlUtil::CLOB: "clob",
                SqlUtil::BLOB: "blob",
                );

            const OraColumnOpts = (
                "character_semantics": Type::Boolean,
                );

            #! Oracle-specific column options
            /** this constant extends @ref SqlUtil::AbstractTable::ColumnOptions as returned by @ref OracleSqlUtil::OracleTable::getColumnOptions() with the following keys:
                - \c character_semantics: adds "char" to the column type name for applicable character columns to use character semantics for the column
            */
            const OraColumnOptions = AbstractTable::ColumnOptions + OraColumnOpts;

            #! Oracle-specific column options
            /** this constant extends @ref SqlUtil::AbstractTable::ColumnDescOptions as returned by @ref OracleSqlUtil::OracleTable::getColumnDescOptions() with the following keys:
                - \c character_semantics: to specify that applicable character columns use character semantics in the column definition
            */
            const OraColumnDescOptions = AbstractTable::ColumnDescOptions + OraColumnOpts;

            #! Oracle-specific index options
            /** this constant extends @ref SqlUtil::AbstractTable::IndexOptions as returned by @ref OracleSqlUtil::OracleTable::getIndexOptions() with the following keys:
                - \c compute_statistics: adds "compute statistics" to index creation strings
            */
            const OracleIndexOptions = AbstractTable::IndexOptions + (
                "compute_statistics": Type::Boolean,
                );

            #! Oracle-specific constraint options
            /** this constant extends @ref OracleIndexOptions as returned by @ref OracleSqlUtil::OracleTable::getConstraintOptions() with the following keys:
                - \c index: adds "using index <indexname>" to the constraint creation string
            */
            const OracleConstraintOptions = OracleIndexOptions + (
                "index": Type::String,
                );

            #! Oracle table creation options
            const OracleTableCreationOptions = AbstractTable::TableCreationOptions
                + OracleConstraintOptions
                + OraColumnOptions
                ;

            const OracleAlignTableOptions = AbstractTable::AlignTableOptions + OracleTableCreationOptions;

            #! Oracle select options
            /** This constant extends @ref SqlUtil::AbstractTable::SelectOptions with the following options as returned by
                @ref OracleSqlUtil::OracleTable::getSelectOptions():
                - \c partition: the partition name to use in a query (see @ref ora_partitioning_select)
            */
            const OracleSelectOptions = AbstractTable::SelectOptions + (
                "partition": Type::String,
                );

            #! where operator specializations for Oracle
            const OracleOpMap = DefaultOpMap + (
                OP_IN: (
                    "code": string sub (object t, string cn, softlist arg, reference args, *hash jch, bool join = False, *hash ch, *hash psch) {
%ifndef NO_ORACLE
                        # Qorus bug #989 SqlUtil: oracle op_in can fail in large amount of input elements
                        # There is no support for CLOBs in WHERE clause in Oracle at all.
                        # Binding large strings (over 4000 chars is performed by a CLOB in Qore driver.
                        # Result of op_in operator can be "ORA-00932: inconsistent datatypes" if is
                        # the list longer or if it contains large items with:
                        # return cn + " in (select regexp_substr(%v,'[^,]+', 1, level) from dual connect by regexp_substr(%v, '[^,]+', 1, level) is not null)";

                        # determine list members type. Let's assume the 1st non NULL/NOTHING
                        # element gives the type code for all elements.
                        ListIterator it(arg);
                        int ltype;
                        while (it.next()) {
                            switch (it.getValue().typeCode()) {
                                case NT_NULL:
                                case NT_NOTHING:
                                    continue;
                                case NT_DATE:
                                case NT_FLOAT:
                                case NT_INT:
                                case NT_NUMBER:
                                case NT_STRING:
                                    ltype = it.getValue().typeCode();
                                    break;
                                default:
                                    throw "ORACLE-DRIVER-ERROR", sprintf("op_in operator unexpected list member type: %s. Only simple types are supported.", it.getValue().type());
                            }
                            if (ltype) break;
                        }

                        # Bind to oracle by expected type
                        switch (ltype) {
                            case NT_DATE:
                                args += bindOracleCollection("SYS.ODCIDATELIST", arg);
                                break;
                            case NT_FLOAT:
                            case NT_NUMBER:
                            case NT_INT:
                                args += bindOracleCollection("SYS.ODCINUMBERLIST", arg);
                                break;
                            default:
                                args += bindOracleCollection("SYS.ODCIVARCHAR2LIST", arg);
                        }

                        return cn + " in (select column_value from table(%v))";
%endif
%ifdef NO_ORACLE
                        throw "MISSING-ORACLE-DRIVER", "op_in requires oracle driver";
%endif
                    },
                ),
            );

            #! column operator specializations for Oracle
            const OracleCopMap = DefaultCopMap + (
                COP_CAST: (
                    "code": string sub (string cve, list args) {
                        string name = QoreTypeMap{args[0]} ?? args[0];
                        hash desc = OraTypeMap{name};
                        string sql = sprintf ("cast (%s as %s", cve, name);
                        switch (name) {
                            default:
                                if (desc.size == SZ_MAND) {
                                    if (!exists args[1] && !exists desc.size_range)
                                        throw "OPERATOR-ERROR", sprintf ("op_cast operator missing size for type %s", name);
                                    sql += sprintf("(%d)", args[1] ?? desc.size_range[1]);
                                }
                                else if (desc.size == SZ_NUM && exists args[1]) {
                                    sql += args[1] == "*" ? "(*" : sprintf("(%d", args[1]);
                                    sql += exists args[2] ? sprintf(",%d)", args[2]) : ")";
                                }
                                else if (desc.size == SZ_OPT && exists args[1]) {
                                    sql += sprintf("(%d)", args[1]);
                                }
                        }
                        sql += ")";
                        return sql;
                    },
                ),
                COP_OVER: (
                    "argcolumn": True,
                    "argoptional": True,
                    "code": string sub (*string cve, *string arg) {
                        string sql = cve + " over (";
                        if (arg)
                            sql += sprintf("partition by %s", arg);
                        sql += ")";
                        return sql;
                    },
                ),
                COP_YEAR: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("to_char(%s, 'YYYY')", arg1);
                    }
                ),
                COP_YEAR_MONTH: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("to_char(%s, 'YYYY-MM')", arg1);
                    }
                ),
                COP_YEAR_DAY: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("to_char(%s, 'YYYY-MM-DD')", arg1);
                    }
                ),
                COP_YEAR_HOUR: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("to_char(%s, 'YYYY-MM-DD HH24')", arg1);
                    }
                ),
                COP_SEQ: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("%s.nextval", arg);
                    }
                ),
                COP_SEQ_CURRVAL: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("%s.currval", arg);
                    }
                ),
                );

            #! a hash of default value operator descriptions for Oracle
            const OracleIopMap = DefaultIopMap + (
                IOP_SEQ: (
                    "arg": Type::String,
                    "immediate": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("%s.nextval", arg);
                    },
                ),
                IOP_SEQ_CURRVAL: (
                    "arg": Type::String,
                    "immediate": True,
                    "code": string sub (string cve, string arg) {
                        return sprintf("%s.currval", arg);
                    },
                ),
                );

            #! a hash of valid pseudocolumns
            const OraclePseudoColumnHash = (
                "rowid": True,
                "rownum": True,
                "object_id": True,
                "object_value": True,
                "ora_rowscn": True,
                );
        }

        private {
            # schema name
            string schema;

            # tablespace name
            *string tablespace;

            # is the table read only?
            bool readonly;

            # table comment
            *string comment;

            # dblink
            *string dblink;

            # Oracle server major version
            int ora_major;

            # helper flag to indicate if is the OracleTable real table or a view
            bool m_isView = False;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a dblink in the name
            *string dbl = (nname =~ x/@(.*)/)[0];
            if (dbl) {
                dblink = dbl.upr();
                splice nname, nname.size() - (dbl.size() + 1);
                name = nname;
                setDblinkSchema();
            }
            else {
                # see if there is a schema in the name
                *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
                if (sstr) {
                    schema = sstr;
                    splice nname, 0, schema.size() + 1;
                    name = nname;
                }
                else
                    schema = ds.getUserName();
            }

            # the oracle driver >= 3.0 supports selecting from LONG columns
            if (compare_version("3.0", get_module_hash().oracle.version) > 0)
                throw "ORACLE-DRIVER-ERROR", sprintf("OracleSqlUtil requires oracle module 3.0+ to query system catalogs since LONG support was added in oracle module version 3.0; current module version: %s; upgrade your oracle module to at least 3.0 to use OracleSqlUtil", get_module_hash().oracle.version);

            ora_major = (nds.getServerVersion() =~ x/([0-9]+)/)[0].toInt();
        }

        private bool checkExistenceImpl() {
            try {
                setTableInfoIntern();
            }
            catch (hash ex) {
                if (ex.err == "TABLE-ERROR")
                    return False;
                rethrow;
            }
            return True;
        }

        private setTableInfoIntern() {
            hash row = (schema.lwr() == ds.getUserName().lwr()) ? setTable() : setSchemaTable();

            tablespace = row.tablespace_name;
            readonly = row.read_only == "YES";
            if (!native_case && tablespace)
                tablespace = tablespace.lwr();

            # get any comment
            if (!m_isView) {
                any cm = ds.selectRow("select * from all_tab_comments" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr()).comments;
                comment = cm ? cm : NOTHING;
            }

            inDb = True;
        }

        #! returns the schema and table naem in dot notation
        string getSqlName() {
            return sprintf("%s.%s" + (dblink ? "@" + dblink : ""), schema, name);
        }

        #! This method can change itself or disappear in the near future. Do not use it.
        bool isView() {
            return m_isView;
        }

        private hash setSchemaTable() {
            # get the table information if possible
            *hash row = ds.selectRow("select * from all_tables" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (row)
                return row;

            row = ds.selectRow("select * from all_views" + (dblink ? "@" + dblink : "") + " where owner = %v and view_name = %v", schema.upr(), name.upr());
            if (row) {
                m_isView = True;
                return row;
            }

            throw "TABLE-ERROR", sprintf("table %y.%y does not exist or is not accessible to this user (%s)", schema, name, getDBString());
        }

        private setDblinkSchema() {
            *hash dblr = ds.selectRow("select * from all_db_links where owner in ('PUBLIC', %v) and db_link = %v and rownum = 1", ds.getUserName().upr(), dblink);
            if (!dblr)
                throw "TABLE-ERROR", sprintf("dblink %y is unknown", dblink);
            schema = dblr.username;
            if (!native_case)
                schema = schema.lwr();
        }

        private hash setTable() {
            # see if the current user has the table
            *hash row = ds.selectRow("select * from user_tables where table_name = %v", name.upr());
            if (row) {
                schema = getUserSchema();
                return row;
            }

            row = ds.selectRow("select * from user_views where view_name = %v", name.upr());
            if (row) {
                m_isView = True;
                schema = getUserSchema();
                return row;
            }

            bool pub = False;
            # see if there is a user synonym with this name
            row = ds.selectRow("select * from user_synonyms where synonym_name = %v", name.upr());
            if (!row) {
                # see if there is a public synonym with this name
                row = ds.selectRow("select * from all_synonyms where owner = 'PUBLIC' and synonym_name = %v", name.upr());
                if (!row)
                    throw "TABLE-ERROR", sprintf("table %y or synonym %y does not exist or is not accessible to this user (%s)", name, name, getDBString());
                pub = True;
            }

            # update the table name if necessary
            string orig_name = name;
            if (name.upr() != row.table_name) {
                name = row.table_name;
                if (!native_case)
                    name = name.lwr();
            }

            if (row.db_link) {
                dblink = row.db_link;

                setDblinkSchema();

                if (!native_case)
                    dblink = dblink.lwr();
            }

            if (row.table_owner) {
                schema = row.table_owner;
                if (!native_case)
                    schema = schema.lwr();
            }

            # get the table information if possible
            row = ds.selectRow("select * from all_tables" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (row)
                return row;

            row = ds.selectRow("select * from all_views" + (dblink ? "@" + dblink : "") + " where owner = %v and view_name = %v", schema.upr(), name.upr());
            if (row) {
                m_isView = True;
                return row;
            }

            throw "TABLE-ERROR", sprintf("%y is a %ssynonym pointing to table %y.%y which does not exist or is not accessible to this user (%s)", orig_name, pub ? "public " : "", schema, name, getDBString());
        }

        private string getUserSchema() {
            string rv = ds.getUserName();
            if (native_case)
                rv = rv.upr();
            return rv;
        }

        private string getDBString() {
            return sprintf("%s@%s", ds.getUserName(), ds.getDBName());
        }

        #! returns the schema name
        string getSchemaName() {
            return schema;
        }

        #! returns the data tablespace name for the table if any or @ref nothing if none is known
        *string getTablespaceName() {
            return tablespace;
        }

        #! returns any table comment or @ref nothing if none is known
        *string getComment() {
            return comment;
        }

        bool readOnly() {
            return readonly;
        }

        private hash getColumnOptions() {
            return OraColumnOptions;
        }

        private hash getColumnDescOptions() {
            return OraColumnDescOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getSelectOptions() {
            return OracleSelectOptions;
        }

        private getSelectWhereSqlUnlocked(reference sql, reference args, *hash qh, *hash jch, bool join = False, *hash ch, *hash psch) {
            AbstractTable::getSelectWhereSqlUnlocked(\sql, \args, qh, jch, join, ch, psch);
            # Oracle 12c+ supports limit (fetch) and offset
            if (ora_major >= 12)
                return;

            if (qh.limit && !qh.orderby) {
                if (!qh."where")
                    sql += " where ";
                else
                    sql += " and ";
                sql += sprintf("rownum <= %v", qh.limit);
                args += qh.limit;
                # insert optimizer hint
                int i = sql.find(" from ");
                # http://www.oracle.com/technetwork/issue-archive/2006/06-sep/o56asktom-086197.html
                # /*+ first_rows(n) */ is an optimizer hint that we want the first rows as fast as possible
                splice sql, i + 5, 0, sprintf(" /*+ first_rows(%d) */", qh.limit);
            }
        }

        private doSelectOrderByWithOffsetSqlUnlockedImpl(reference sql, reference args, *hash qh, *hash jch, *hash ch) {
            # Oracle 12c+ supports limit (fetch) and offset
            if (ora_major >= 12) {
                doSelectOrderBySqlUnlocked(\sql, \args, qh, jch, ch);

                if (qh.offset) {
                    sql += " offset %v rows";
                    args += qh.offset;
                }

                if (qh.limit) {
                    sql += " fetch next %v rows only";
                    args += qh.limit;
                }

                return;
            }

            list ce = getOrderByListUnlocked(qh, jch, ch);
            string sort = foldl $1 + ", " + $2, ce;
            # http://www.oracle.com/technetwork/issue-archive/2006/06-sep/o56asktom-086197.html
            # /*+ first_rows(n) */ is an optimizer hint that we want the first rows as fast as possible
            sql = sprintf("select * from (select /*+ first_rows(%d) */ a.*, rownum rnum from (%s order by %s%s) a where rownum <= %v) where rnum > %v", qh.limit, sql, sort, qh.desc ? " desc" : "");
            if (qh.offset)
                qh.limit += qh.offset;
            args += qh.limit;
            args += qh.offset ? qh.offset : 0;
        }

        #! processes a string for use in SQL select statements when there is a "limit" argument, but no "orderby" or "offset" arguments
        private doSelectLimitOnlyUnlockedImpl(reference sql, reference args, *hash qh) {
            if (!qh.limit)
                return;

            # Oracle 12c+ supports limit (fetch) and offset
            if (ora_major >= 12) {
                sql += " fetch next %v rows only";
                args += qh.limit;
                return;
            }

            # /*+ first_rows(n) */ is an optimizer hint that we want the first rows as fast as possible
            sql = sprintf("select * from (select /*+ first_rows(%d) */ a.*, rownum rnum from (%s) a where rownum <= %v)", qh.limit, sql);
            args += qh.limit;
        }

        private Columns describeImpl() {
            if (!tablespace)
                setTableInfoIntern();

            # get column descriptions
            *hash qh = ds.select("select col.column_name, data_type, data_length, data_precision, data_scale, nullable, data_default, char_length, char_used, comments from all_tab_columns" + (dblink ? "@" + dblink : "") + " col, all_col_comments" + (dblink ? "@" + dblink : "") + " com where col.owner = %v and col.table_name = %v and com.owner = col.owner and com.table_name = col.table_name and com.column_name = col.column_name order by column_id", schema.upr(), name.upr());
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y.%y in %y", schema, name, dsdesc);

            # now we have to find unvalidated but enabled not null constraints - because these cause the column to appear to be "nullable" when it really isn't
            # also we can't filter by search_condition, because it's a LONG, otherwise we could make a left join above :(
            *hash nnq = ds.select("select * from all_constraints" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v and generated = 'GENERATED NAME' and constraint_type = 'C' and status = 'ENABLED' and validated != 'VALIDATED'", schema.upr(), name.upr());
            hash cnh;
            context (nnq) {
                *string cn = (%search_condition =~ x/"([^"]+)" IS NOT NULL$/)[0];
                if (cn)
                    cnh{cn} = True;
            }

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                #if (row.column_name == "TAX_AMOUNT")
                #    printf("DBG: %y\n", row);
                *hash th = OraTypeMap.(row.data_type.lwr());
                int size = row.data_type == "NUMBER" && row.data_precision ? row.data_precision : row.data_length;
                switch (row.data_type) {
                    case "ROWID":
                    case "UROWID":
                    case "DATE":
                    case "BINARY_FLOAT":
                    case "BINARY_DOUBLE":
                    case =~ /^TIMESTAMP/:
                    case =~ /^INTERVAL/:
                    case "BFILE":
                    case "BLOB":
                    case "CLOB": size = 0; break;
                }

                # set default numeric precision to 0 if not given
                if (row.data_precision === NULL && row.data_type == "NUMBER") {
                    row.data_precision = 0;
                    row.data_scale = 0;
                }

                bool nullable = row.nullable == "Y" && !cnh{row.column_name};
                if (!native_case) {
                    row.column_name = row.column_name.lwr();
                    row.data_type = row.data_type.lwr();
                }
                trim row.data_default;

                bool char_used;
                if (row.char_used == "C") {
                    char_used = True;
                    size = row.char_length;
                }
                else
                    char_used = False;

                OracleColumn c;
                if (row.data_precision || row.data_type == "number")
                    c = new OracleNumberColumn(row.column_name, row.data_type, th.qore, row.data_precision, nullable, row.data_default, row.comments ? row.comments : NOTHING, row.data_length, row.data_scale);
                else
                    c = new OracleColumn(row.column_name, row.data_type, th.qore, size, nullable, row.data_default, row.comments ? row.comments : NOTHING, th.is_char, row.char_used == "C", row.data_length);

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private OraclePrimaryKey getPrimaryKeyImpl() {
            if (!tablespace)
                setTableInfoIntern();

            hash rv;

            # get primary key description
            *hash qh = ds.select("select cons.constraint_name, cols.column_name, cols.position, cons.status, cons.index_name from all_constraints" + (dblink ? "@" + dblink : "") + " cons, all_cons_columns" + (dblink ? "@" + dblink : "") + " cols where cols.owner = %v and cols.table_name = %v and cons.constraint_type = 'P' and cons.owner = cols.owner and cons.constraint_name = cols.constraint_name order by cols.position", schema.upr(), name.upr());
            if (!qh.constraint_name)
                return new OraclePrimaryKey();

            foreach string col in (qh.column_name) {
                string cn = native_case ? col : col.lwr();
                rv{cn} = columns{cn};
            }

            string pkname = qh.constraint_name[0];
            if (!native_case)
                pkname = pkname.lwr();

            OraclePrimaryKey pk(pkname, rv);
            # set the base index if present
            if (qh.index_name[0]) {
                if (!native_case)
                    qh.index_name[0] = qh.index_name[0].lwr();
                pk.setIndexBase(qh.index_name[0]);
            }
            return pk;
        }

        private Indexes getIndexesImpl() {
            if (!tablespace)
                setTableInfoIntern();

            hash rv;

            # get index description
            *hash qh = ds.select("select i.index_name, index_type, uniqueness, tablespace_name, constraint_name
 from all_indexes" + (dblink ? "@" + dblink : "") + " i left join all_constraints" + (dblink ? "@" + dblink : "") + " c on (i.index_name = c.index_name and i.owner = c.owner and i.table_name = c.table_name)
 where i.owner = %v and i.table_name = %v", schema.upr(), name.upr());
            if (qh.index_name) {
                hash ih;

                # get column info for all indexes in 1 query
                *hash iqh = ds.select("select c.index_name, c.column_name, e.column_expression from all_ind_columns" + (dblink ? "@" + dblink : "") + " c left join all_ind_expressions" + (dblink ? "@" + dblink : "") + " e on (c.table_owner = e.index_owner and c.index_name = e.index_name and c.table_name = e.table_name) where c.table_owner = %v and c.table_name = %v order by c.index_name, c.column_position", schema.upr(), name.upr());
                foreach hash row in (iqh.contextIterator()) {
                    if (!native_case)
                        map row.$1 = row.$1.lwr(), ("index_name", "column_name", "column_expression"), row.$1;
                    # process function indexes
                    if (row.column_expression) {
                        row.column_expression =~ s/"//g;
                        ih{row.index_name}{row.column_expression} = {};
                    }
                    else
                        ih{row.index_name}{row.column_name} = columns{row.column_name};
                }

                foreach hash row in (qh.contextIterator()) {
                    if (!native_case)
                        map row.$1 = row.$1.lwr(), ("index_name", "tablespace_name", "constraint_name"), row.$1;

                    # skip system indexes
                    if (!ih{row.index_name})
                        continue;
                    rv.(row.index_name) = new OracleIndex(row.index_name, row.uniqueness == "UNIQUE", ih{row.index_name}, row.index_type, row.tablespace_name);
                    if (row.constraint_name) {
                        *AbstractUniqueConstraint uk = findUniqueConstraintUnlocked(row.constraint_name);
                        if (uk) {
                            rv.(row.index_name).setSupportingConstraint(uk);
                            uk.setIndexBase(row.index_name);
                        }
                    }
                }

            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl(*hash opts) {
            if (!tablespace)
                setTableInfoIntern();

            hash ch;

            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, status from user_constraints" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v and constraint_type = 'R'", schema.upr(), name.upr());
            if (qh.status) {
                hash rv;
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case)
                        row.constraint_name = row.constraint_name.lwr();
                    rv.(row.constraint_name) = (
                        "enabled": row.status == "ENABLED",
                        );
                }
                qh = ds.select("select c.constraint_name, status, cols1.column_name source_column, cols1.position, cols2.table_name target_table, cols2.column_name target_column from all_constraints" + (dblink ? "@" + dblink : "") + " c, all_cons_columns" + (dblink ? "@" + dblink : "") + " cols1, all_cons_columns" + (dblink ? "@" + dblink : "") + " cols2 where c.owner = %v and c.table_name = %v and c.constraint_name = cols1.constraint_name and constraint_type = 'R' and c.r_constraint_name = cols2.constraint_name and cols1.position = cols2.position and cols1.owner = c.owner and cols2.owner = c.owner order by cols1.position", schema.upr(), name.upr());
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.constraint_name = row.constraint_name.lwr();
                        row.source_column = row.source_column.lwr();
                        row.target_column = row.target_column.lwr();
                        row.target_table = row.target_table.lwr();
                    }
                    reference c = \rv.(row.constraint_name);
                    #if (!columns.hasKey(row.source_column))# && c.target.columns.(row.target_column)) {
                    #    printf("ERROR: %y.%y ->  %y.%y (%y): %y\n", name, row.source_column, row.target_table, row.target_column, row.constraint_name, columns.keys());
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                foreach hash c in (rv.pairIterator()) {
                    # get a description of the target table's columns
                    Columns targ_columns = getReferencedTableColumnsUnlocked(c.value.target.table, opts.table_cache);
                    ForeignConstraintTarget fct(c.value.target.table, targ_columns.subset(c.value.target.columns.keys()));
                    ch.(c.key) = new OracleForeignConstraint(c.key, new Columns(c.value.columns), fct, c.value.enabled);
                }
            }

            return new ForeignConstraints(ch);
        }

        private Constraints getConstraintsImpl() {
            if (!tablespace)
                setTableInfoIntern();

            # get only user check constraints
            *hash qh = ds.select("select constraint_name, search_condition, status from all_constraints" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v and constraint_type = 'C' and generated != 'GENERATED NAME'", schema.upr(), name.upr());
            hash rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    row.constraint_name = row.constraint_name.lwr();
                rv.(row.constraint_name) = new OracleCheckConstraint(row.constraint_name, row.search_condition, row.status == "ENABLED");
            }

            Constraints c(rv);

            # now get unique constraints
            qh = ds.select("select c.constraint_name, status, cols.column_name, cols.position, status, c.index_name from all_constraints" + (dblink ? "@" + dblink : "") + " c, all_cons_columns cols where c.owner = %v and c.table_name = %v and c.constraint_name = cols.constraint_name and constraint_type = 'U' and cols.owner = c.owner and generated != 'GENERATED NAME' order by cols.position", schema.upr(), name.upr());
            delete rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("constraint_name", "column_name");
                reference ch = \rv.(row.constraint_name);
                if (!ch) {
                    ch = new OracleUniqueConstraint(row.constraint_name, {}, row.status == "ENABLED");
                    if (row.index_name)
                        ch.setIndexBase(row.index_name);
                }
                ch.add(row.column_name, columns{row.column_name});
            }

            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();

            return c;
        }

        private string getSelectSqlName(*hash qh) {
            if (!qh.partition)
                return getSqlName();
            return sprintf("%s partition (%s)", getSqlName(), qh.partition);
        }

        private Triggers getTriggersImpl() {
            if (!tablespace)
                setTableInfoIntern();

            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from all_triggers" + (dblink ? "@" + dblink : "") + " where owner = %v and table_name = %v", schema.upr(), name.upr());
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("trigger_name", "trigger_type", "triggering_event", "referencing_names");
                #printf("%y: %s\n", row.trigger_name, row.description);

                # replace newlines with spaces
                row.description =~ s/\n/ /g;
                trim row.description;

                # remove trigger name from description line
                row.description = regex_subst(row.description, "^.*" + row.trigger_name + ".", "", RE_Caseless);
                rv{row.trigger_name} = new OracleTrigger(row.trigger_name, row.description + "\n" + row.trigger_body, row.status == "ENABLED");
            }

            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map sprintf("  %s", $1.getCreateSql(self)), columns.iterator());
            sql += "\n)";

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        private *list getCreateMiscSqlImpl(*hash opt, bool cache) {
            if (cache)
                getColumnsUnlocked();
            return map AbstractDatabase::doCallback(opt, sprintf("comment on column %s.%s is %s", name, $1.name, getSqlValueImpl($1.comment)), AbstractDatabase::AC_Add, "column comment", $1.name, name), columns.iterator(), $1.comment;
        }

        private string getCreateSqlImpl(list l) {
            return OracleDatabase::getCreateSql(l);
        }

        private string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            if (opt.precision)
                return new OracleNumberColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable, opt.default_value, opt.comment, 0, opt.scale);
            return new OracleColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value, opt.comment, opt.local_def.is_char, opt.character_semantics, 0);
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new OraclePrimaryKey(cname, ch, opt.index_tablespace);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new OracleIndex(iname, enabled, ch, "normal", opt.index_tablespace);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new OracleForeignConstraint(cname, new Columns(ch), fct, True);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new OracleCheckConstraint(cname, src);
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt) {
            return new OracleUniqueConstraint(cname, ch, True, opt.index_tablespace);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new OracleTrigger(tname, src);
        }

        private bool tryInsertImpl(string sql, hash row) {
            try {
                ds.vexec(sql, row.values());
            }
            catch (hash ex) {
                if (ex.desc =~ /ORA-00001/)
                    return False;
                rethrow;
            }
            return True;
        }

        private *list getAlignSqlImpl(AbstractTable t, *hash opt) {
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return OraTypeMap;
        }

        private hash getIndexOptions() {
            return OracleIndexOptions;
        }

        private hash getConstraintOptions() {
            return OracleConstraintOptions;
        }

        private hash getTableCreationOptions() {
            return OracleTableCreationOptions;
        }

        private hash getAlignTableOptions() {
            return OracleAlignTableOptions;
        }

        #! returns the "where" operator map for this object
        private hash getWhereOperatorMap() {
            return OracleOpMap;
        }

        #! returns the column operator map for this object
        private hash getColumnOperatorMap() {
            return OracleCopMap;
        }

        #! returns the insert operator map for this object
        private hash getInsertOperatorMap() {
            return OracleIopMap;
        }

        #! returns a hash of valid pseudocolumns
        private *hash getPseudoColumnHash() {
            return OraclePseudoColumnHash;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(any v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_NUMBER:
                case NT_INT: return v.toString();

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "1" : "0";

                case NT_DATE: return sprintf("to_timestamp('%s', 'YYYYMMDDHH24MISSFF6')", v.format("YYYYMMDDHHmmSSus"));
            }
        }

        #! returns the column name for use in SQL strings; subclasses can return a special string in case the column name is a reserved word
        string getColumnSqlName(string col) {
            return OracleDatabase::OracleReservedWords{col.lwr()} ? ("\"" + col + "\"") : col;
        }

        #! returns a list of column names for use in SQL strings; subclasses can process the argument list in case a column name is a reserved word
        list getColumnSqlNames(softlist cols) {
            return map (OracleDatabase::OracleReservedWords{$1.lwr()} ? ("\"" + $1 + "\"") : $1), cols;
        }

        #! returns the base type of the underlying object (either \"table\" or \c "view")
        /**
            @since OracleSqlUtil 1.2
        */
        string getBaseType() {
            return m_isView ? "view" : "table";
        }

        #! Oracle always supports bulk merging
        code getBulkUpsertClosure(hash example_row, int upsert_strategy = AbstractTable::UpsertAuto) {
            return getUpsertClosure(example_row, upsert_strategy);
        }

        #! returns a closure for performing upserts; the upsert_strategy argument is ignored and a closure using an Oracle merge statement is returned
        code getUpsertClosure(hash row, int upsert_strategy = UpsertAuto) {
            Columns cols = checkUpsertRow(row, \upsert_strategy);

            # get update columns
            list updc = ();
            map updc += $1, row.keyIterator(), !cols.hasKey($1);
            # cannot use merge where only the join columns are present
            if (!updc)
                return getUpsertInsertOnly(cols, row);

            string sql = sprintf("merge into %s t using dual on (", getSqlName());
            sql += foldl $1 + " and " + $2, (map sprintf("%s=%v", $1), getColumnSqlNames(cols.keys()));
            sql += sprintf(") when not matched then insert (");
            sql += (foldl $1 + "," + $2, getColumnSqlNames(row.keys()));
            sql += ") values (";
            sql += (foldl $1 + "," + $2, (map "%v", row.keyIterator()));
            sql += sprintf(") when matched then update set ");

            # get update columns
            sql += (foldl $1 + "," + $2, (map sprintf("%s=%v", $1), getColumnSqlNames(updc)));

            #printf("sql: %s\n", sql);

            return int sub (hash crow) {
                list args = crow.(cols.keys()).values() + crow.values() + crow{updc}.values();
                #on_error printf("SQL: %s args: %y\n", sql, args);
                ds.vexec(sql, args);
                return UR_Verified;
            };
        }

        #! returns @ref Qore::True "True" because the oracle driver supports array binds / bulk DML operations
        bool hasArrayBind() {
            return True;
        }

        private *hash doReturningImpl(hash opt, reference sql, list args) {
            list l = ();
            foreach softstring k in (opt.returning) {
                *OracleColumn c = columns{k};
                if (!c)
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column for the \"returning\" clause (valid columns: %y)", name, k, columns.keys());
                l += k;
                args += c.qore_type ?* Type::String;
            }
            sql += sprintf(" returning %s into %s", (foldl $1 + "," + $2, l), (foldl $1 + "," + $2, (map ":" + $1, l)));

            return execData(opt, sql, args);
        }

        private bool emptyImpl() {
            return True;
        }

        private setupTableImpl(hash desc, *hash opt) {
        }

        #! returns @ref Qore::True "True" if the database links constraints to indexes (ie dropping the constraint drops the index, etc)
        private bool constraintsLinkedToIndexesImpl() {
            return False;
        }

        #! returns @ref Qore::True "True" if the database automatically creates a unique constraint when a unique index is created (ex: mysql)
        private bool uniqueIndexCreatesConstraintImpl() {
            return False;
        }

        #! returns @ref Qore::True "True" if the database support tablespaces
        private bool supportsTablespacesImpl() {
            return True;
        }

        #! db-specific copy actions
        private copyImpl(AbstractTable old) {
        }
    }
}
