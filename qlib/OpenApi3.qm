# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file OpenApi3.qm OpenApi3: https://swagger.io//

/*  OpenApi3.qm Copyright (C) 2024 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%new-style
%enable-all-warnings
%require-types
%strict-args

# make sure we have the required qore version
%requires qore >= 2.0

# try importing JSON and YAML modules
%try-module json
%define NoJson
%endtry

%try-module yaml
%define NoYaml
%endtry

%try-module xml
%define NoXml
%endtry

%requires(reexport) Mime >= 1.4
%requires(reexport) Util >= 1.3
%requires(reexport) HttpServerUtil >= 0.3.12
%requires(reexport) RestSchemaValidator >= 1.0
%requires(reexport) FileLocationHandler

%allow-weak-references

module OpenApi3 {
    version = "1.0";
    desc = "OpenApi3 module providing functionality for OpenApi 3 schema definitions";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage OpenApi3 module

    @tableofcontents

    @section openapi3intro OpenApi3 Module Introduction

    The %OpenApi3 module provides a <a href="https://swagger.io/">OpenApi 3 REST API validation API</a> to %Qore.

    The primary classes provided by this module:
    - @ref OpenApi3::OpenApi3Loader "OpenApi3Loader": provides static methods for loading %OpenApi3 schemas
    - @ref OpenApi3::OpenApi3Schema "OpenApi3Schema": the %OpenApi3 schema object for client/server REST API
      validation and example code and message generation

    This class is most often used in the <a href="../../RestClient/html/index.html">RestClient</a> and
    <a href="../../RestHandler/html/index.html">RestHandler</a> modules to register a
    <a href="https://swagger.io/">OpenApi 3</a> schema for automatic REST API validation.

    JSON and YAML serialization and deserialization are supported; XML is currently not supported.

    @section openapi3_usage OpenApi3 Usage

    @subsection openapi3_client OpenApi3 Client-Side Usage

    Use the \a openapi3 or \a validator options in the \c RestClient::constructor() call to use
    <a href="https://swagger.io/">OpenApi 3</a> REST schema validation on the client side with the \c RestClient
    class.

    To override the target URL specified in the <a href="https://swagger.io/">OpenApi3</a> schema, use the \c "url"
    option in the \c RestClient::constructor() call.

    To override the URI base path specified in the <a href="https://swagger.io/">OpenApi3</a> schema,
    get the <a href="https://swagger.io/">OpenApi3</a> schema object by calling
    \c RestClient::getValidator(), and then call
    @ref RestSchemaValidator::AbstractRestSchemaValidator::setBasePath() "AbstractRestSchemaValidator::setBasePath()"
    on the validator object.

    @par Client Example
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

# the RestClient module imports and reexports the OpenApi3 module automatically
%requires RestClient

# create the RestClient options with an OpenApi3 schema
hash<auto> opts = {
    "openapi3": ENV.SCHEMA_DIR + DirSep + "MySchema.yaml",
};

# there is no need to add the "url" option if the target URL provided by the schema is valid
# (otherwise you can override the target URL provided by the OpenApi3 schema by using the
# "url" option in the RestClient constructor options)
RestClient rc(opts);

# afterwards all REST calls made with the RestClient objects with automatic OpenApi3 2.0
# schema validation; do not include the OpenApi3 schema's basePath in the URI path in the
# requests
hash<auto> h = rc.get("get", "/some_api");
    @endcode

    @par Override Base Path Client Example
    @code{.py}
# create the RestClient options with an OpenApi3 schema
hash<auto> opts = (
    "openapi3": ENV.SCHEMA_DIR + DirSep + "MySchema.yaml",
);
RestClient rc(opts);
# get the OpenApi3Schema validator object
AbstractRestSchemaValidator schema = rc.getValidator();
# override the base path in requests
schema.setBasePath("/new/path");
    @endcode

    @subsection openapi3_server OpenApi3 Server-Side Usage

    Enforce <a href="https://swagger.io/">OpenApi3</a> REST API validation on the server side by passing a
    @ref OpenApi3::OpenApi3Schema "OpenApi3Schema" object to the \c RestHandler::constructor() call as in the
    following example.

    @par Server Example
    @code{.py}
%new-style
%strict-args
%require-types
%enable-all-warnings

%requires RestHandler
%requires OpenApi3

OpenApi3Schema openapi3 = OpenApi3Loader::fromFile(ENV.SCHEMA_DIR + DirSep + "MySchema.yaml");
RestHandler handler(NOTHING, openapi3);
    @endcode

    @section openapi3_relnotes OpenApi3 Module Release Notes

    @subsection openapi3_1_0 OpenApi3 v1.0
    - initial release of the %OpenApi3 module
*/

#! main namespace for all public %OpenApi3 declarations
public namespace OpenApi3 {
/** @defgroup ParseOptionFlags Parse Option Flags
    Options that determine which common errors are acceptable when parsing OpenApi3 schemas
*/
#/@{
#! parse options: all options
public const LM_ALL = 0;
#/@}

#! Valid integer type formats
public const ValidIntFormats = ("int32", "int64", "unix-time");
#! Valid number type formats
public const ValidNumberFormats = ("double", "float");
#! Valid string type formats
public const ValidStringFormats = ("binary", "byte", "date", "password", "unix-time");

#! A hash of valid integer type formats
public const ValidIntFormatsHash = map {$1: True}, ValidIntFormats;
#! A hash of valid number type formats
public const ValidNumberFormatsHash = map {$1: True}, ValidNumberFormats;
#! A hash of valid string type formats
public const ValidStringFormatsHash = map {$1: True}, ValidStringFormats;

%ifndef NoYaml
#! Yaml serialization
const YamlSerialization = {
    "serialize": \make_yaml(),
    "serialize_verbose": string sub (auto val) {return make_yaml(val, BlockStyle);},
    "deserialize": \parse_yaml(),
    "module": "yaml",
};
%endif

#! supported mime types for de/serializing data
public const MimeDataTypes = {
%ifndef NoJson
    MimeTypeJson: (
        "serialize": \make_json(),
        "serialize_verbose": string sub (auto val) {return make_json(val, JGF_ADD_FORMATTING);},
        "deserialize": \parse_json(),
        "module": "json",
    ),
%endif
%ifndef NoYaml
    # issue #3699: more YAML MIME types must be supported
    MimeTypeYaml: YamlSerialization,
    MimeTypeYamlRpc: YamlSerialization,
    "text/yaml": YamlSerialization,
    "application/yaml": YamlSerialization,
%endif
%ifndef NoXml
    MimeTypeXmlApp: (
        "serialize": \make_xml(),
        "serialize_verbose": string sub (auto val) {return make_xml(val, XGF_ADD_FORMATTING);},
        "deserialize": \parse_xml(),
        "module": "xml",
    ),
%endif
    # Content-Type: application/x-www-form-urlencoded
    MimeTypeFormUrlEncoded: (
        "serialize": \mime_get_form_urlencoded_string(),
        "serialize_verbose": \mime_get_form_urlencoded_string(),
        "deserialize": \mime_parse_form_urlencoded_string(),
    ),
    # Content-Type: multipart/form-data (handled manually)
    MimeTypeMultipartFormData: {},
};

#! modules available for data serialization and/or deserialization
public const SerializationModules = keys (map {$1.module: True}, MimeDataTypes.iterator(), $1.module);

#! MIME types for data serialization
public const MimeContentTypes = keys MimeDataTypes;

#! Valid transfer protocol schemes.
public const ValidSchemes = ("http", "https", "ws", "wss");
public const ValidSchemesHash = map {$1: True}, ValidSchemes;

#! Base class for the %OpenApi3 specification objects, wrapping the vendor extensions.
class ObjectBase {
    public {
        #! Allows extensions to the %OpenApi3 Schema.
        /**
            The field name MUST begin with \c x-, for example, \c x-internal-id.
            The value can be \c null, a primitive, an array or an object.
         */
        hash<auto> vendorExtensions;
    }

    #! Constructor.
    public constructor() {
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the object
     */
    public constructor(hash<auto> oh) {
        initialize(oh);
    }

    #! copy constructor
    constructor(ObjectBase other) {
        vendorExtensions = other.vendorExtensions;
    }

    #! Initialize.
    /**
        @param oh deserialized hash from the source schema description
    */
    public initialize(hash<auto> oh) {
        vendorExtensions = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^x-/;
    }
}

#! Base used by @ref HeaderObject and @ref SchemaObject
class SchemaBase {
    public {
        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *float maximum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *float minimum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *bool exclusiveMax;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *bool exclusiveMin;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.1.
        *int maxLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.2.
        *int minLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        *string pattern;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.2.
        *int maxItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.3.
        *int minItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.4.
        *bool uniqueItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1.
        /** @note OpenApi3 enums can be of any type, but we only support enums of simple types that can be converted
            to a string for fast lookups in a hash
        */
        hash<string, bool> enum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.1.
        *float multipleOf;
    }

    #! Constructor.
    /** @param obj_type the type of object
        @param oh deserialized hash from the source schema description
     */
    public constructor(string obj_type, hash<auto> oh) {
        optional_field(obj_type, oh, "maximum", (NT_FLOAT: True, NT_INT: True), \maximum);
        optional_field(obj_type, oh, "minimum", (NT_FLOAT: True, NT_INT: True), \minimum);
        optional_field(obj_type, oh, "exclusiveMaximum", NT_BOOLEAN, \exclusiveMax);
        optional_field(obj_type, oh, "exclusiveMinimum", NT_BOOLEAN, \exclusiveMin);
        optional_field(obj_type, oh, "maxLength", NT_INT, \maxLength);
        optional_field(obj_type, oh, "minLength", NT_INT, \minLength);
        optional_field(obj_type, oh, "pattern", NT_STRING, \pattern);
        optional_field(obj_type, oh, "maxItems", NT_INT, \maxItems);
        optional_field(obj_type, oh, "minItems", NT_INT, \minItems);
        optional_field(obj_type, oh, "uniqueItems", NT_BOOLEAN, \uniqueItems);
        optional_field(obj_type, oh, "enum", OpenApi3ListToAnySet, \enum);
        optional_field(obj_type, oh, "multipleOf", (NT_FLOAT: True, NT_INT: True), \multipleOf);
    }

    #! Copy constructor
    constructor(SchemaBase other) {
        self += map {$1: other.$1}, (
            "maximum", "minimum", "exclusiveMax", "exclusiveMin",
            "maxLength", "minLength", "pattern", "maxItems", "minItems",
            "uniqueItems", "enum", "multipleOf"), exists other.$1;
    }

    #! returns an example value for the given type
    private auto getExampleValue(string type, *string format) {
        if (enum) {
            auto rv = enum.firstKey();
            switch (type) {
                case "integer": {
                    rv = rv.toInt();
                    switch (format) {
                        case "unix-time":
                            rv = localtime(rv);
                            break;
                    }
                    break;
                }
                case "number": rv = (format && ValidNumberFormatsHash{format} ? rv.toFloat() : rv.toNumber()); break;
                case "boolean": rv = rv.toBool(); break;
                case "string": {
                    switch (format) {
                        case "byte": return parse_base64_string(rv);
                        case "date":
                        case "date-time":
                        default:
                            break;
                    }
                }
            }
            return rv;
        }
        switch (type) {
            case "string": {
                switch (format) {
                    case "byte":
                    case "binary": return <feedface>;
                    case "date": return 1987-05-23;
                    case "date-time": return 1987-05-23T07:45:30Z;
                    case "uuid": return "d242e639-4ed6-4930-a375-b139c13f89da";
                    default:
                        return "value";
                }
            }
            case "integer": {
                switch (format) {
                    case "unix-time": return 1726733382;
                }
                if (exists minimum)
                    return exclusiveMin ? minimum + 1 : minimum;
                if (exists maximum)
                    return exclusiveMax ? maximum - 1 : maximum;
                return 1;
            }
            case "number": {
                number rv;
                if (exists minimum)
                    rv = exclusiveMin ? minimum + 0.1 : minimum;
                else if (exists maximum)
                    rv = exclusiveMax ? maximum - 0.1 : maximum;
                else
                    rv = 1.1n;
                if (format && ValidNumberFormatsHash{format})
                    return rv.toFloat();
                return rv;
            }
            case "boolean":
                return True;
            case "null":
                return NOTHING;
            case "any": {
                return "any value";
            }
        }
    }

    #! validates the value against the schema definition
    private check(bool serialize, bool request, string type, *string format, *SchemaObject items, string path,
            string method, string name, reference<auto> value) {
        # accept a single value for an array (= one-element list)
        if (type == "array") {
            # convert to a list before checking
            if (exists value && value.typeCode() != NT_LIST) {
                value = (value,);
            }
            checkArrayParam(serialize, request, items, path, method, name, \value);
        } else {
            on_error rethrow $1.err, sprintf("%s (while checking parameter %y)", $1.desc, name);
            checkIntern(serialize, request, type, format, path, method, name, value, \value);
        }
    }

    private checkStringIntern(string path, string method, string name, string value) {
        # minLength and maxLength are based on the number of characters in the string, not bytes
        if (exists maxLength && value.length() > maxLength)
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y is too long (maxLength: %d, actual: %d)",
                    name, path, method, maxLength, value.length());
        if (exists minLength && value.length() < minLength)
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y is too short (minLength: %d, actual: %d)",
                    name, path, method, minLength, value.length());
        if (exists pattern && !value.regex(pattern))
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the parameter string pattern "
                    "(pattern: %y, value: %y)", name, path, method, pattern, value);
        if (enum && !enum{value})
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, "
                    "actual: %y)", name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, list<auto> v, reference<list> value) {
        if (type != "list" && type != "any")
            throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y is an array (%y), but "
                "the expected type is %y", name, path, method, v, type);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, hash<auto> v, reference<hash> value) {
        if (type != "file" && type != "any" && type != "object")
            throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y is an object (%y), but "
                "the expected type is %y", name, path, method, v, type);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, int v, reference<auto> value) {
        # NOTE: "number" also accepts "int"
        if (type == "number") {
            checkIntern(serialize, request, type, format, path, method, name, v.toNumber(), \value);
            return;
        }
        if (type != "integer" && type != "any")
            throwInvalidType(name, "integer", type, v);

        if (!serialize) {
            switch (format) {
                case "unix-time":
                    value = localtime(v);
                    break;
            }
        }

        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            } else {
                if (value > maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            } else {
                if (value < minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value})
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %d)",
                    name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, number v, reference<number> value) {
        checkInternNumber(serialize, request, type, format, path, method, name, v, \value);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, float v, reference<number> value) {
        checkInternNumber(serialize, request, type, format, path, method, name, v, \value);
    }

    private checkInternNumber(bool serialize, bool request, string type, *string format, string path, string method,
            string name, auto v, reference<auto> value) {
        if (type != "number" && type != "any")
            throwInvalidType(name, "number", type, v);
        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            } else {
                if (value > maximum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            } else {
                if (value < minimum)
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value}) {
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, "
                    "actual: %f)", name, path, method, keys enum, value);
        }

        switch (format) {
            case "float":
            case "double":
            case NOTHING:
                value = v.toFloat();
                break;

            default:
                throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y has an invalid format: %y; expecting (\"float\", "
                    "\"double\", or no value; value provided: %y)", name, path, method, format, value);
        }
    }

    #! converts binary values to strings for supported formats
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, binary v, reference value) {
        if (type != "string" && type != "any")
            throwInvalidType(name, "string", type, v);

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = v;
                    return;
                default:
                    throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: parameters %y: cannot serialize a binary value "
                        "to a string value with format %y", method.upr(), path, name, format);
            }
            checkStringIntern(path, method, name, value);
        }
    }

    #! validates string values
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, string v, reference<auto> value) {
        if (type != "string" && type != "any") {
            throwInvalidType(name, "string", type, v);
        }

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = binary(v);
                    break;
                case "date":
                case "date-time":
                    # issue #3847: with non-YAML serialization, this will always be a string
                    value = date(v);
                    break;
            }
        } else {
            switch (format) {
                # NOTE: deserializes to a binary object
                case "byte":
                    try {
                        value = parse_base64_string(v);
                    } catch (hash<ExceptionInfo> ex) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type %y "
                            "is invalid; value provided: %y (%s)", name, path, method, format, v, ex.desc);
                    }
                    break;
                # NOTE: deserializes to a binary object
                case "binary":
                    try {
                        value = binary(v);
                    } catch (hash<ExceptionInfo> ex) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type %y "
                            "is invalid; value provided: %y (%s)", name, path, method, format, v, ex.desc);
                    }
                    break;
                # NOTE: deserializes to a date/time value
                case "date":
                case "date-time":
                    try {
                        # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                        value = date(v);
                    } catch (hash<ExceptionInfo> ex) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of type %y "
                            "is invalid; value provided: %y (%s)", name, path, method, format, v, ex.desc);
                    }
                    break;
            }
        }
        if (value.typeCode() == NT_STRING) {
            checkStringIntern(path, method, name, value);
        }
    }

    #! converts dates to/from string or int values for supported formats
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, date v, reference<auto> value) {
        if (type != "string" && type != "any" && (type != "integer" || format != "unix-time"))
            throwInvalidType(name, "string", type, v);

        if (serialize) {
            if (type == "integer" && format == "unix-time") {
                value = v.getEpochSeconds();
            } else {
                switch (format) {
                    case "date":
                        # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                        value = v.format("YYYY-MM-DD");
                        break;
                    case "date-time":
                        # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                        if (v.milliseconds() != 0)
                            value = v.format("YYYY-MM-DDTHH:mm:SS.yZ");
                        else
                            value = v.format("YYYY-MM-DDTHH:mm:SSZ");
                        break;
                    default:
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: parameters %y: cannot serialize a date/time "
                            "value to a string value with format %y", method.upr(), path, name, format);
                }
                checkStringIntern(path, method, name, value);
            }
        }
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, bool v, reference<bool> value) {
        if (type != "boolean" && type != "any")
            throwInvalidType(name, "boolean", type, v);
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, nothing v, reference<nothing> value) {
        if (type != "null" && type != "any")
            throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y is null, but the "
                "expected type is %y", name, path, method, type);
    }

    #! validates the value against the schema definition
    private checkArrayParam(bool serialize, bool request, SchemaObject items, string path, string method, string name,
            reference<list<auto>> value) {
        if (exists maxItems && value.size() > maxItems) {
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y has too many items (maxItems: %d, actual: %d)",
                    name, path, method, maxItems, value.size());
        }
        if (exists minItems && value.size() < minItems) {
            throw "SCHEMA-VALIDATION-ERROR",
                sprintf("Parameter %y for path %y and method %y has too few items (minItems: %d, actual: %d)",
                    name, path, method, minItems, value.size());
        }

        if (!value) {
            return;
        }

        # check array element types
        if (!uniqueItems || items.type != "array") {
            # hash for checking uniqueness if uniqueItems is true
            hash<string, bool> h;
            foreach auto v in (\value) {
                items.check(serialize, request, path, method, name, \v);
                if (uniqueItems) {
                    if (h{v}) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: parameter value %y is duplicated in the "
                            "array", method, path, v);
                    }
                    h{v} = True;
                }
            }
        } else {
            # perform slow array uniqueness check
            list<auto> uniqueItems = ();
            foreach auto val in (\value) {
                items.check(serialize, request, path, method, name, \val);
                if (uniqueItems.contains(val)) {
                    throw "SCHEMA-VALIDATION-ERROR",
                        sprintf("%s %s: Array parameter %y does not have unique items",
                            method, path, name);
                }
                uniqueItems += val;
            }
        }
    }

    #! throws an \c SCHEMA-VALIDATION-ERROR exception
    static private throwInvalidType(string name, string actual, string expected, auto value) {
        throw "SCHEMA-VALIDATION-ERROR",
            sprintf("Parameter %y has invalid type %y (should be %y); value: %y", name, actual, expected, value);
    }

    #! Checks the value against the type
    /** @return True if the value is OK, False if not
    */
    static bool checkValueType(reference<auto> value, string type) {
        if (type == "any") {
            return True;
        }
        int vt = value.typeCode();

        # check for string values
        if (vt == NT_STRING) {
            if (type == "boolean") {
                if (value == "true") {
                    value = True;
                    return True;
                } else if (value == "false") {
                    value = False;
                    return True;
                }
            } else if (type == "int" && value =~ /^[0-9]+$/) {
                value = value.toInt();
                return True;
            }
        }

        # check for number values
        if (vt == NT_INT && type == "number") {
            value = value.toFloat();
            return True;
        }

        if ((vt == NT_BOOLEAN && type != "boolean") ||
            (vt == NT_INT && type != "integer") ||
            (vt == NT_FLOAT && type != "number") ||
            (vt == NT_STRING && (type != "string" && type != "file")) ||
            (vt == NT_LIST && type != "array")) {
            return False;
        }
        return True;
    }
}

#! Used for loading the %OpenApi3 definitions
public class OpenApi3Loader {
    #! Load %OpenApi3 definition from a string
    /**
        @param openapi3Specification <a href="https://swagger.io/">OpenApi3</a> API specification
        @param json whether the specification is in JSON or YAML format; if not given the source encoding will be
        detected automatically
        @param opts options as per @ref OpenApi3Options as follows:
        - \c compact_serialization (default @ref True "True"): (type *bool) optimize the size of serialized data
          strings
        - \c def_path: (type *string) the default path to use when retrieving external schema references
        - \c try_import: (type *code) a call reference or closure to be passed a string name for external schema
          references, must
          take a string argument (the resource name) and return a string (the resource data)
        - \c parse_flags: (type *int) a binary or combination of @ref ParseOptionFlags

        @throws JSON-MODULE-MISSING trying to parse a JSON %OpenApi3 specification with JSON module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %OpenApi3 specification with YAML module unavailable
    */
    static OpenApi3Schema fromString(string openapi3Specification, *bool json, *hash<auto> opts) {
        string ser;
        if (!exists json) {
            ser = OpenApi3Loader::detectSourceEncoding(openapi3Specification);
        } else {
            ser = json ? "json" : "yaml";
        }
        return new OpenApi3Schema(openapi3Specification, OpenApi3Loader::parseSchemaSource(openapi3Specification, ser),
            opts);
    }

    #! Load <a href="https://swagger.io/">OpenApi3</a> definition from a file.
    /**
        @param filepath path to the <a href="https://swagger.io/">OpenApi3</a> file
        @param opts options as per @ref OpenApi3Options as follows:
        - \c compact_serialization (default @ref True "True"): (type *bool) optimize the size of serialized data
          strings
        - \c def_path: (type *string) the default path to use when retrieving external schema references
        - \c try_import: (type *code) a call reference or closure to be passed a string name for external schema
          references, must
          take a string argument (the resource name) and return a string (the resource data)
        - \c parse_flags: (type *int) a binary or combination of @ref ParseOptionFlags

        @throws EMPTY-SCHEMA-FILE %OpenApi3 file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON %OpenApi3 specification with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %OpenApi3 specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML %OpenApi3 specification with the xml module unavailable
    */
    static OpenApi3Schema fromFile(string filepath, *hash<auto> opts) {
        string file_data = ReadOnlyFile::readTextFile(filepath);
        return new OpenApi3Schema(file_data, OpenApi3Loader::parseSchemaContent(filepath, file_data), opts);
    }

    #! Load <a href="https://swagger.io/">OpenApi3</a> definition from a URL or file path.
    /**
        @param url URL to the <a href="https://swagger.io/">OpenApi3</a> file; uses the
        @ref filelocationhandlerintro "FileLocationHandler" to load the file
        @param json whether the specification is in JSON or YAML format; if not given the source encoding will be
        detected automatically
        @param opts options as per @ref OpenApi3Options as follows:
        - \c compact_serialization (default @ref True "True"): (type *bool) optimize the size of serialized data
          strings
        - \c def_path: (type *string) the default path to use when retrieving external schema references
        - \c try_import: (type *code) a call reference or closure to be passed a string name for external schema
          references, must
          take a string argument (the resource name) and return a string (the resource data)
        - \c parse_flags: (type *int) a binary or combination of @ref ParseOptionFlags

        @throws EMPTY-SCHEMA-FILE %OpenApi3 file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON %OpenApi3 specification with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML %OpenApi3 specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML %OpenApi3 specification with the xml module unavailable
    */
    static OpenApi3Schema fromUrl(string url, *bool json, *hash<auto> opts) {
        if (!exists json) {
            if (url =~ /\.yaml$/i) {
                json = False;
            } else if (url =~ /\.json$/i) {
                json = True;
            }
        }
        on_error {
            rethrow $1.err, sprintf("%s (from URL %y)", $1.desc, get_safe_url(url));
        }
        return OpenApi3Loader::fromString(FileLocationHandler::getTextFileFromLocation(url), json, opts);
    }

    #! Load a schema definition from a file
    /**
        @param filepath path to the schema file
        @param str the file content to parse

        @throws EMPTY-SCHEMA-FILE schema file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON schema with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML schema specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML schema specification with the xml module unavailable
    */
    static hash<auto> parseSchemaContent(string filepath, string str) {
        if (!str)
            throw "EMPTY-SCHEMA-FILE", sprintf("%y: file is empty", filepath);

        string ser;
        string filename = basename(filepath);
        if (filename =~ /.*\.json$/i) {
            ser = "json";
        } else if (filename =~ /.*\.yaml$/i) {
            ser = "yaml";
        } else if (filename =~ /.*\.xml$/i) {
            ser = "xml";
        } else {
            ser = OpenApi3Loader::detectSourceEncoding(str);
        }

        return OpenApi3Loader::parseSchemaSource(str, ser);
    }

    #! parses the source encoding from the given string
    static hash<auto> parseSchemaSource(string str, string ser) {
        auto rv;
        switch (ser) {
            case "json": {
%ifdef NoJson
                throw "JSON-MODULE-MISSING", "Trying to parse a JSON schema, but the json module is unavailable";
%else
                rv = parse_json(str);
                break;
%endif
            }
            case "yaml": {
%ifdef NoYaml
                throw "YAML-MODULE-MISSING", "Trying to parse a YAML schema, but the yaml module is unavailable";
%else
                rv = parse_yaml(str);
                break;
%endif
            }
            case "xml": {
%ifdef NoXml
                throw "XML-MODULE-MISSING", "Trying to parse an XML schema, but the xml module is unavailable";
%else
                rv = parse_xml(str);
                break;
%endif
            }
        }
        if (rv.typeCode() != NT_HASH) {
            throw "OPENAPI3-SCHEMA-ERROR", sprintf("data of type %y provided for OpenAPI / OpenApi3 schema; expecting "
                "\"hash\"", rv.fullType());
        }
        return rv;
    }

    #! tries to determine the OpenApi3 schema source encoding automatically
    static string detectSourceEncoding(string str) {
        DataLineIterator it(str);
        while (it.next()) {
            string line = trim(it.getValue());
            if (line.size()) {
                if (line =~ /^<\?xml/) {
                    return "xml";
                } else if (line =~ /^([^{])+:/ || line =~ /^(---|%YAML)/ || line =~ /^\{[a-z0-9_]+:/) {
                    return "yaml";
                }
                return "json";
            }
        }
        return "json";
    }
}

#! Common class for objects that have parameters
public class ParameterGroup {
    public {
        #! A hash of parameters for this object
        /**
            Hash values are @ref ParameterObject "ParameterObjects"
        */
        hash<string, ParameterObject> parameters();

        #! Any query param with type "object"? (OpenAPI 3 compatible)
        string query_obj;
    }

    #! Adds a parameter to the group
    addParameter(ParameterObject p) {
        addParameter(p.name, p);
    }

    #! Adds a parameter to the group
    addParameter(string key, ParameterObject p) {
        if (p.in_loc == "query" && p.schema.type == "object") {
            if (exists query_obj) {
                throw "OPENAPI3-SCHEMA-ERROR", sprintf("Query parameter %y has already been defined with type "
                    "\"object\"; cannot define subsequent parameter %y with the same type", query_obj, key);
            }
            query_obj = key;
        }
        parameters{key} := p;
    }
}

#! OpenApi 3 components
public hashdecl ComponentInfo {
    #! Schemas
    hash<string, SchemaObject> schemas;

    #! Parameters
    ParameterGroup parameters();

    #! Response definitions that can be used across operations. This property does not define global responses for all operations.
    /**
        A hash of @ref ResponseObject objects. Keys are response names.
    */
    hash<string, ResponseObject> responses;

    #! Security scheme definitions that can be used across the specification.
    /**
        A hash of @ref SecuritySchemeObject objects. Keys are scheme names.
    */
    hash<string, SecuritySchemeObject> securitySchemes;
}

#! This is the root document object for the API specification. It combines what previously was the Resource Listing and API Declaration (version 1.2 and earlier) together into one document.
public class OpenApi3Schema inherits ObjectBase, AbstractRestSchemaValidator {
    public {
        #! <a href="https://swagger.io/">OpenApi3</a> Specification version being used.
        /**
            It can be used by the %OpenApi3 UI and other clients to interpret the
            API listing. The value MUST be \c "3.0" or \c "3.1".
        */
        string openapi3Spec;

        #! Required. Provides metadata about the API. The metadata can be used by the clients if needed.
        InfoObject info;

        #! Required. The available paths and operations for the API.
        PathsObject paths;

        #! The host (name or IP) serving the API.
        /**
            This MUST be the host only and does not include the scheme nor sub-paths.
            It MAY include a port. If the \c host is not included, the host serving
            the documentation is to be used (including the port).
            The host does not support path templating.
        */
        *string host;

        #! The base path on which the API is served, which is relative to the @ref OpenApi3Schema::host "host".
        /**
            If it is not included, the API is served directly under the \c host.
            The value MUST start with a leading slash (/).
            The \c basePath does not support path templating.
        */
        *string basePath;

        #! A set of MIME types (strings) the APIs can consume.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Key values MUST be Mime Types.
         */
        hash<string, bool> consumes;

        #! A set of MIME types (strings) the APIs can produce.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Key values MUST be Mime Types.
        */
        hash<string, bool> produces;

        #! An object to hold data types produced and consumed by operations.
        /**
            A hash of @ref SchemaObject objects. Keys are schema names.
        */
        hash<ComponentInfo> components();

        #! A declaration of which security schemes are applied for the API as a whole.
        /**
            The list of values describes alternative security schemes that can
            be used (that is, there is a logical OR between the security
            requirements). Individual operations can override this definition.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref OpenApi3Schema::securitySchemes "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
        */
        hash<string, softlist<string>> security;

        #! A list of @ref TagObject "tags" used by the specification with additional metadata.
        /**
            The order of the tags can be used to reflect on their order by the
            parsing tools. Not all tags that are used by the @ref OperationObject
            must be declared. The tags that are not declared may be organized
            randomly or based on the tools' logic. Each tag name in the list
            MUST be unique.

            Individual values in this list are of type @ref TagObject "TagObject".
        */
        list<TagObject> tags;

        #! Additional external documentation.
        *ExternalDocumentationObject externalDocs;

        #! OpenApi3Schema options
        const OpenApi3Options = (
            "compact_serialization": True,
            "def_path": True,
            "try_import": True,
            "parse_flags": True,
        );
    }

    private {
        #! if serialized data should be subject to compact serialization (default: @ref True "True")
        bool compact_serialization;

        #! the default path to use when retrieving external schema references
        *string def_path;

        #! a call reference or closure to be passed a string name for external schema references
        /** must take a string argument (the resource name) and return a string (the resource data)
        */
        *code try_import;

        #! the hash for the schema
        string hash_str;

        #! parse option flags
        *int opt_flags;

        #! maps name -> SHA1 hash of the config -> schema objects for recursive references
        hash<string, hash<string, SchemaObject>> so_map;
    }

    private:internal {
        #! the raw parsed definitions; used for resolving out-of-order references
        *hash<auto> source_definition_hash;
    }

    #! Builds the schema representation from the deserialized schema hash describing the root document object
    /**
        @param oh deserialized hash from the source schema description describing the root document object
        @param opts options as per @ref OpenApi3Options as follows:
        - \c compact_serialization (default @ref True "True"): (type *bool) optimize the size of serialized data
          strings
        - \c def_path: (type *string) the default path to use when retrieving external schema references
        - \c try_import: (type *code) a call reference or closure to be passed a string name for external schema
          references, must
          take a string argument (the resource name) and return a string (the resource data)
        - \c parse_flags: (type *int) a binary or combination of @ref ParseOptionFlags

        @throws OPENAPI3-OPTION-ERROR unsuported options in constructor
        @throws INVALID-OPENAPI3-VERSION invalid or missing OpenApi3 schema version
        @throws INVALID-FIELD-FORMAT field has an invalid format
        @throws INVALID-FIELD-TYPE field has an invalid type
        @throws INVALID-FIELD-VALUE field has an invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws SECURITY-ERROR inconsistent security information in schema
    */
    public constructor(string schema_source, hash<auto> oh, *hash<auto> opts) : ObjectBase(oh) {
        constructorIntern(schema_source, oh, opts);
    }

    #! Builds the schema representation from the deserialized schema hash describing the root document object
    /** @param logger the logger to use
        @param oh deserialized hash from the source schema description describing the root document object
        @param opts options as per @ref OpenApi3Options as follows:
        - \c compact_serialization (default @ref True "True"): (type *bool) optimize the size of serialized data
          strings
        - \c def_path: (type *string) the default path to use when retrieving external schema references
        - \c try_import: (type *code) a call reference or closure to be passed a string name for external schema
          references, must
          take a string argument (the resource name) and return a string (the resource data)
        - \c parse_flags: (type *int) a binary or combination of @ref ParseOptionFlags

        @throws OPENAPI3-OPTION-ERROR unsuported options in constructor
        @throws INVALID-OPENAPI3-VERSION invalid or missing OpenApi3 schema version
        @throws INVALID-FIELD-FORMAT field has an invalid format
        @throws INVALID-FIELD-TYPE field has an invalid type
        @throws INVALID-FIELD-VALUE field has an invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws SECURITY-ERROR inconsistent security information in schema
    */
    public constructor(LoggerInterface logger, string schema_source, hash<auto> oh, *hash<auto> opts)
            : ObjectBase(oh), AbstractRestSchemaValidator(logger)  {
        constructorIntern(schema_source, oh, opts);
    }

    #! common constructor implementation
    private constructorIntern(string schema_source, hash<auto> oh, *hash<auto> opts) {
        hash_str = digest("sha256", schema_source).toHex();

        # process options
        compact_serialization = remove opts.compact_serialization ?? True;
        def_path = remove opts.def_path;
        try_import = remove opts.try_import;
        opt_flags = remove opts.parse_flags;
        if (opts) {
            throw "OPENAPI3-OPTION-ERROR", sprintf("unknown options in OpenApi3Schema constructor: %y; known "
                "options: %y", keys opts, keys OpenApi3Options);
        }

        string obj_type = "OpenApi";
        if (!oh.hasKey("openapi"))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: 'openapi' field is missing", obj_type);
        if (oh.openapi.typeCode() == NT_STRING)
            openapi3Spec = oh.openapi;
        else if (oh.openapi.typeCode() == NT_FLOAT || oh.openapi.typeCode() == NT_INT)
            openapi3Spec = sprintf("%.1f", oh.openapi);
        else
            throw "INVALID-FIELD-TYPE",
                sprintf("%s Object: 'openapi' field has invalid type %y (should be string or float)", obj_type,
                    oh.openapi.type());
        {
            float v = openapi3Spec.toFloat();
            if (v < 3.0 || v >= 4.0)
                throw "INVALID-OPENAPI3-VERSION", sprintf("invalid schema version %y; expecting >= 3.0 or < 4.0",
                    openapi3Spec);
        }

        optional_field(obj_type, oh, "consumes", OpenApi3ListToStringSet, \consumes);

        optional_field(obj_type, oh, "produces", OpenApi3ListToStringSet, \produces);

        {
            optional_field(obj_type, oh.components, "schemas", NT_HASH, \source_definition_hash);
            map processDefinition($1.key, $1.value), source_definition_hash.pairIterator();
            # all definitions must be resolved now; delete the intermediate definition hash
            delete source_definition_hash;

            hash<auto> obj;
            optional_field(obj_type, oh.components, "parameters", NT_HASH, \obj);
            foreach hash<auto> item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "OpenApi3 Object: invalid parameter datatype: " + item.value.type();
                components.parameters.addParameter(item.key, ParameterObject::newParameter(item.key, item.value, self));
            }

            delete obj;
            optional_field(obj_type, oh.components, "responses", NT_HASH, \obj);
            foreach hash<auto> item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "OpenApi3 Object: invalid response datatype: " + item.value.type();
                components.responses{item.key} := ResponseObject::newResponse(item.key, item.value, self);
            }
        }

        {
            hash<auto> infoObj;
            required_field(obj_type, oh, "info", NT_HASH, \infoObj);
            info = new InfoObject(infoObj);
        }

        {
            hash<auto> pathsObj;
            required_field(obj_type, oh, "paths", NT_HASH, \pathsObj);
            paths = new PathsObject(pathsObj, self);
        }

        optional_field(obj_type, oh, "host", NT_STRING, \host);
        if (optional_field(obj_type, oh, "basePath", NT_STRING, \basePath)) {
            if (exists basePath && basePath[0] != "/")
                throw "INVALID-FIELD-FORMAT", "OpenApi3 Object: basePath does not begin with a slash: " + basePath;
            # make sure basePath never ends in a slash
            if (basePath =~ /\/$/) {
                splice basePath, -1;
            }
        }

        {
            hash<auto> obj;
            optional_field(obj_type, oh.components, "securitySchemes", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "OpenApi3 Object: invalid security definition datatype: " +
                        item.value.type();
                components.securitySchemes{item.key} = new SecuritySchemeObject(item.value);
            }
        }

        optional_field(obj_type, oh, "security", OpenApi3ListToHashOfStrings, \security);

        # verify security consistency
        if (security) {
            hash<auto> h = security - keys components.securitySchemes;
            if (h)
                throw "SECURITY-ERROR", sprintf("the following security schemes are not defined: %y", keys h);
        }

        {
            list<auto> lobj = ();
            optional_field(obj_type, oh, "tags", NT_LIST, \lobj);
            foreach auto val in (lobj) {
                if (val.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "OpenApi3 Object: invalid tag datatype: " + val.type();
                tags += new TagObject(val);
            }
        }

        {
            *hash<auto> extDocsObj;
            if (optional_field(obj_type, oh, "externalDocs", NT_HASH, \extDocsObj))
                externalDocs = new ExternalDocumentationObject(extDocsObj);
        }
    }

    *int getParseFlags() {
        return opt_flags;
    }

    *SchemaObject tryGetSchemaObject(string name, hash<auto> oh, reference<string> hash_str) {
        hash_str = sprintf("%y", oh).toSHA1();
        return so_map{name}{hash_str};
    }

    cacheSchemaObject(string name, string hash_str, SchemaObject so) {
        so_map{name}{hash_str} = so;
    }

    #! resolves a reference to a schema object
    /** @throw INVALID-REFERENCE invalid reference
    */
    SchemaObject resolveSchemaObject(string name, string refstr, hash<auto> oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return SchemaObject::newSchemaObject(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/components\/schemas\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y", name, refstr);
        string rstr = (refstr =~ x/^#\/components\/schemas\/(.*)$/)[0];
        *SchemaObject ref = components.schemas{rstr};
        if (!ref) {
            if (exists (*hash<auto> def = source_definition_hash{rstr})) {
                ref = processDefinition(rstr, def);
            } else {
                throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y (%y)", name, refstr);
            }
        }
        # get all non "x-" attributes
        *hash<auto> attr = map {$1.key: $1.value}, oh.pairIterator(), $1.key !~ /^x-/ && $1.key != "$ref";
        *hash<auto> xmlObj;
        # process additional attributes
        if (optional_field("OpenApi", attr, "xml", NT_HASH, \xmlObj)) {
            attr -= "xml";
            ref = ref.copy();
            ref.xml = new XmlObject(xmlObj);
        }
        # additional subling elements are ignored...
        return ref;
    }

    #! resolves a reference to a parameter
    /** @throw INVALID-REFERENCE invalid reference
    */
    ParameterObject resolveParameter(string name, string refstr, hash<auto> oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ParameterObject::newParameter(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/components\/parameters\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; expecting "
                "\"#/components/parameters/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/components\/parameters\/(.*)$/)[0];
        *ParameterObject ref = components.parameters.parameters{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; known parameter "
                "references: %y", name, refstr, keys components.parameters.parameters);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh,
                $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a response
    /** @throw INVALID-RESPONSE invalid response
    */
    ResponseObject resolveResponse(string name, string refstr, hash<auto> oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ResponseObject::newResponse(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/components\/responses\//)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; expecting "
                "\"#/components/responses/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/components\/responses\/(.*)$/)[0];
        *ResponseObject res = components.responses{rstr};
        if (!res)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; known response "
                "references: %y", name, refstr, keys components.responses);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-RESPONSE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh,
                $1 !~ /^x-/));
        return res;
    }

    #! returns a unique hash for the schema that can be used to compare schemas
    /** @return a unique hash for the schema that can be used to compare schemas

        @since OpenApi3 2.0
    */
    private string getHashImpl() {
        return hash_str;
    }

    #! returns the target URL for the schema
    /** @return the target URL for the schema

        @throws MISSING-TARGET-URL no target URL provided for the schema
    */
    private string getTargetUrlImpl() {
        return sprintf("%s://%s%s", "http", host, basePath);
    }

    #! processes a client-side REST request and returns a hash that can be used to make the outgoing client-side HTTP request
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body data
        @param headers any headers to include in the request; note that the \c Content-Type header should not be sent
        here as it will be overridden when the message is serialized
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then
        an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return a @ref RestSchemaValidator::RestRequestClientInfo "RestRequestClientInfo" hash with information about
        the request

        @throws SERIALIZATION-ERROR unsupported message body MIME type requested or missing serialization module
    */
    private hash<RestSchemaValidator::RestRequestClientInfo> processRequestImpl(string method, string path, auto body,
            *hash<auto> headers, *softlist<string> content_types) {
        return processRequestIntern(method, path, body, headers, content_types, compact_serialization);
    }

    #! processes and parses a client request and returns the deserialized message body (if any)
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param http_body the serialized message body
        @param headers a reference to the hash of HTTP headers received; any default header values to be assumed by
        the server for the request will be added here

        @return a @ref RestSchemaValidator::RestRequestServerInfo hash of request information

        @throw DESERIALIZATION-ERROR the path does not match the basePath, the request body could not be deserialized
        or the \c Content-Type is missing or it is invalid for the operation
    */
    private hash<RestSchemaValidator::RestRequestServerInfo> parseRequestImpl(string method, string path,
            *data http_body, reference<hash> headers) {
        auto body;
        # deserialize body according to Content-Type
        if (exists http_body) {
            if (!headers.hasKey("content-type"))
                throw "DESERIALIZATION-ERROR", "message includes body but is missing Content-Type header";
            if (headers."content-type" =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h =
                    MultiPartFormDataMessage::parseMessage(headers."content-type", http_body.toString());
                body = map {$1.key: $1.value.body}, h.pairIterator();
            } else {
                *hash<auto> conf = MimeDataTypes{headers."content-type"};
                if (!conf) {
                    body = http_body;
                } else {
                    *code ds = conf.deserialize;
                    if ((conf."module" == "json" || conf."module" == "yaml") && http_body.encoding() != "UTF-8") {
                        http_body = force_encoding(http_body, "UTF-8");
                    }
                    try {
                        auto any_body = ds(http_body);
                        if (exists any_body) {
                            body = any_body;
                        }
                    } catch (hash<ExceptionInfo> ex) {
                        rethrow "DESERIALIZATION-ERROR", sprintf("%s: %s", ex.err, ex.desc);
                    }
                }
            }
        }

        # path must be absolute for matching to work correctly
        if (path !~ /^\//)
            path = "/" + path;

        # remove basePath if present; note that "basePath" must always have a leading / if set
        fixPath(\path);

        hash<UriQueryInfo> h = parse_uri_query(path);
        method = method.lwr();
        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        op.parseRequest(pio, \h, \body, \headers);
        return <RestRequestServerInfo>{
            "path": h.method,
            "query": h.params,
            "path_args": h.path_params,
            "body": body,
        };
    }

    #! processes a REST response with a serialized message body, validates any response data against schema definitions if possible
    /** @param method the HTTP method of the original request
        @param path the URI path of the original request (without query arguments)
        @param code the HTTP response code
        @param response_body the response body data (if any)
        @param headers HTTP headers to include in the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then
        an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return an HttpResponseInfo hash for the response

        @throw ACCEPT-ERROR the response body could not be serialized because the client does not accept a supported
        type
        @throw SERIALIZATION-ERROR the response body could not be serialized due to an error

        @note <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>RFC 2616 section 14</a>: If an Accept
        header field is present, and if the server cannot send a response which is acceptable according to the
        combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.  To ensure this
        happens, if an Accept error of this nature occurs in this call, an \c "ACCEPT-ERROR" must be thrown
    */
    private hash<HttpResponseInfo> processResponseImpl(string method, string path, int code, auto response_body,
            *hash<auto> headers, *softlist<string> content_types) {
        return processResponseIntern(method, path, code, response_body, headers, content_types,
            compact_serialization);
    }

    #! parses and validates the response from the server and returns a hash of the processed info
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the original request (without any query arguments)
        @param code the HTTP response code
        @param response_body the HTTP response body data (if any)
        @param hdr as hash of HTTP headers received

        @return a @ref RestSchemaValidator::RestResponseClientInfo hash describing the response

        @throw DESERIALIZATION-ERROR the response body could not be deserialized or had an invalid \c Content-Type
    */
    private hash<RestSchemaValidator::RestResponseClientInfo> parseResponseImpl(string method, string path, int code,
            *data response_body, hash<auto> hdr) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        hash<RestResponseClientInfo> rv((
            "code": code,
            "hdr": hdr,
        ));

        *string content = hdr."content-type" ?? hdr."Content-Type";

        # deserialize body according to Content-Type
        if (exists response_body && content) {
            if (content =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h =
                    MultiPartFormDataMessage::parseMessage(hdr."content-type", response_body.toString());
                rv.body = map {$1.key: $1.value.body}, h.pairIterator();
                content = MimeTypeMultipartFormData;
            } else {
                *hash<auto> conf = MimeDataTypes{content};
                *code ds = conf.deserialize;
                # if the content-type is unknown, then assume it is a type that cannot be deserialized
                # the validity of the type is checked below in any case
                try {
                    if ((conf."module" == "json" || conf."module" == "yaml") && response_body.encoding() != "UTF-8") {
                        response_body = force_encoding(response_body, "UTF-8");
                    }
                    rv.body = ds ? ds(response_body) : response_body;
                } catch (hash<ExceptionInfo> ex) {
                    rethrow "DESERIALIZATION-ERROR", sprintf("%s: %s", ex.err, ex.desc), ex.arg + {
                        "response-body": response_body,
                    };
                }
            }
        }

        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, \rv.body, \mime_types, False);

        if (content && !mime_types{content})
            throw "DESERIALIZATION-ERROR", sprintf("%s %s: content type %y is not accepted by this operation; "
                "accepted content types: %y", method.upr(), path, content, keys mime_types);

        return rv;
    }

    #! removes the base path from the beginning of the path, if present
    private fixPath(reference<string> path) {
        # ensure that path is absolute
        if (path !~ /^\//) {
            path = "/" + path;
        }
        # issue #4087: remove the base path if it matches the prefix of the path
        if (basePath) {
            if (!path.comparePartial(basePath)) {
                splice path, 0, basePath.length();
            }
        }
    }

    #! returns a hash of URI paths as keys with values as lists of supported HTTP methods
    /** @return a hash of URI paths as keys with values as lists of supported HTTP methods
    */
    private hash<string, list<string>> getPathOperationHashImpl() {
        return paths.getPathOperationHash();
    }

    #! returns the base path prefix for all requests in this schema
    /** @return the base path prefix for all requests in this schema

        @note if none is set, then \c "/" is returned
    */
    private string getBasePathImpl() {
        return basePath ?? "/";
    }

    #! overrides the basePath value
    /** @param basePath the new base path value; use an empty string here to clear the basePath
    */
    private setBasePathImpl(string basePath) {
        # remove any trailing '/'s from path
        basePath =~ s/\/+$//;
        if (basePath.val()) {
            # ensure that basePath starts with a '/'
            if (basePath !~ /^\//) {
                basePath = "/" + basePath;
            }
            self.basePath = basePath;
        } else {
            remove self.basePath;
        }
    }

    #! returns example Qore code for the given request
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the request

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given request message
    */
    private hash<RestQoreExampleCodeInfo> getQoreExampleRequestImpl(string method, string path) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        return op.getQoreExampleRequest(method, path, pio, self);
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the request
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown

        @return a @ref RestSchemaValidator::RestExampleRequestInfo "RestExampleRequestInfo" hash of example message information for the given request
    */
    private hash<RestSchemaValidator::RestExampleRequestInfo> getExampleRequestImpl(string method, string path,
            *softlist<string> content_types) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        auto body;
        hash<RestExampleRequestInfo> rv = op.getExampleRequest(method, path, pio, self, \body);
        if (exists body) {
            # serialize example body
            hash<RestRequestClientInfo> req = processRequestIntern(method, path, body, rv.hdr, content_types, False);
            rv.hdr."Content-Type" = req.content;
            if (req.response_content) {
                rv.hdr.Accept = foldl $1 + "," + $2, req.response_content;
            }
            rv.body = req.body;
        }

        return rv;
    }

    #! returns example Qore code for the given response
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given response message
    */
    private hash<RestQoreExampleCodeInfo> getQoreExampleResponseImpl(string method, string path, int code) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        return op.getQoreExampleResponse(method, path, code);
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown

        @return a @ref RestSchemaValidator::RestExampleResponseInfo "RestExampleResponseInfo" hash giving example response message info
    */
    private hash<RestExampleResponseInfo> getExampleResponseImpl(string method, string path, int code,
            *softlist<string> content_types) {
        # remove basePath if present
        fixPath(\path);

        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        auto body;
        hash<RestExampleResponseInfo> rv = op.getExampleResponse(method, path, code, \body);
        if (exists body) {
            # serialize example body
            hash<HttpResponseInfo> res = processResponseIntern(method, path, code, body, rv.hdr, content_types, False);
            rv += res.("code", "hdr", "body");
        }

        return rv;
    }

    #! retrieves external references
    /** @throw INVALID-REFERENCE invalid reference
    */
    private hash<auto> getExternalReference(string refstr) {
        (string ext_ref, *string int_ref) = (refstr =~ x/([^#]+)(?:#\/(.*))/);

        #! get file content
        string content;

        if (try_import)
            content = call_function(try_import, ext_ref);
        else {
            # do environment variable substitution
            map ext_ref = replace(ext_ref, "\$" + $1, ENV.$1), (ext_ref =~ x/\$(\w+)/g);
            # derive target file name if def_path is set and the reference is not an absolute path
            if (def_path && !absolute_path(ext_ref))
                ext_ref = def_path + DirSep + ext_ref;
            content = ReadOnlyFile::readTextFile(ext_ref);
        }

        hash<auto> h = OpenApi3Loader::parseSchemaContent(ext_ref, content);
        if (int_ref) {
            if (!h.hasKey(int_ref))
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but "
                    "internal reference %y is not available; known internal references: %y", refstr, ext_ref,
                    content.size(), int_ref, keys h);
            if (h{int_ref}.typeCode() != NT_HASH)
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but "
                    "internal reference %y is not a hash; got type %y instead", refstr, ext_ref, content.size(),
                    int_ref, h{int_ref}.type());
            return h{int_ref};
        }
        return h;
    }

    #! returns a data provider object for this connection
    /** @param rest the \c RestClient object to make the connection

        @return a data provider object for this connection, if supported by any REST schema validator object
    */
    private AbstractDataProvider getDataProviderImpl(HTTPClient rest) {
        # to avoid circular dependencies, this object loads the OpenApi3DataProvider and creates the data provider
        # object dynamically
        load_module("OpenApi3DataProvider");
        return create_object("OpenApi3DataProvider", self, rest);
    }

    #! Allows the time zone locale to be set for serialization / deserialization
    /** @param tz the time zone locale to set

        @since OpenApi3 2.0.10
    */
    private setTimeZoneLocaleImpl(*TimeZone tz) {
        set_thread_tz(tz);
    }

    #! Returns the time zone locale used for serialization / deserialization
    /** @return the time zone locale to set

        @since OpenApi3 2.0.10
    */
    private *TimeZone getTimeZoneLocaleImpl() {
        return get_thread_tz();
    }

    #! processes a client-side REST request and returns a hash that can be used to make the outgoing client-side HTTP request
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body data
        @param headers any headers to include in the request; note that the \c Content-Type header should not be sent
        here as it will be overridden when the message is serialized
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then
        an exception is thrown; if this argument is not present, then json is preferred over yaml
        @param compact_serialization overrides the internal \c compact_serialization flag

        @return a @ref RestSchemaValidator::RestRequestClientInfo "RestRequestClientInfo" hash with information about
        the request

        @throws SERIALIZATION-ERROR unsupported path, message body MIME type requested, or missing serialization module
    */
    private:internal hash<RestSchemaValidator::RestRequestClientInfo> processRequestIntern(string method, string path,
            auto body, *hash<auto> headers, *softlist<string> content_types, bool compact_serialization) {
        # remove basePath if present
        fixPath(\path);

        hash<UriQueryInfo> h = parse_uri_query(path);

        # find path item object and operation
        method = method.lwr();
        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        # perform validation
        hash<string, bool> mime_types;
        op.validateRequest(True, pio, \h, \body, \headers, \mime_types);

        hash<RestRequestClientInfo> rv((
            "uri_path": h.method,
        ));

        if (op.produces) {
            rv.response_content = keys op.produces;
        }

        # add the basePath to the request
        if (exists basePath) {
            rv.uri_path = h.method = basePath + (h.method =~ /^\// ? "" : "/") + h.method;
        }

        # rebuild URI query after processing
        if (h.params) {
            string query_arg_separator = (path =~ x/([;&])/)[0] ?? ";";
            rv.uri_path = make_uri_query(cast<hash<UriQueryInfo>>(h), query_arg_separator);
        }

        if (!body) {
            return rv;
        }

        if (!exists content_types) {
            # if the request has already set \c Content-Type header, we assume
            # that the body is in the right format
            if (checkRequestContentTypeHeader(\rv, body, headers)) {
                return rv;
            }

            # otherwise we continue with the default content types
            content_types = MimeContentTypes;
        }

        foreach string content in (content_types) {
            if (!mime_types{content})
                continue;
            if (content == MimeTypeMultipartFormData) {
                # only send binary values with a "filename" attribute
                hash<string, hash<FormDataMessageInfo>> parts =
                    cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>({
                        "name": $1.key,
                        "hdr": {"Content-Type": MimeTypeText},
                        "body": remove body{$1.key},
                    } + ($1.value.typeCode() == NT_BINARY ? {"filename": $1.key} : NOTHING))}, body.pairIterator());
                hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                return rv += {
                    "body": mh.body,
                    "content": mh.hdr."Content-Type",
                };
            }
            if (MimeDataTypes{content}) {
                return rv += {
                    "body": compact_serialization
                        ? MimeDataTypes{content}.serialize(body)
                        : MimeDataTypes{content}.serialize_verbose(body),
                    "content": content,
                };
            }
        }

        # check if the \c Content-Type header is already set
        if (checkRequestContentTypeHeader(\rv, body, headers)) {
            return rv;
        }

        if (content_types == MimeContentTypes) {
            throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; available MIME type(s): "
                "%y; available serialization modules: %y", method.upr(), path, mime_types, SerializationModules);
        } else {
            throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; requested MIME type(s): "
                "%y; available MIME types: %y; available serialization modules: %y", method.upr(), path,
                content_types, mime_types, SerializationModules);
        }
    }

    #! processes a REST response with a serialized message body, validates any response data against schema definitions if possible
    /** @param method the HTTP method of the original request
        @param path the URI path of the original request (without query arguments)
        @param code the HTTP response code
        @param response_body the response body data (if any)
        @param headers HTTP headers to include in the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then
        an exception is thrown; if this argument is not present, then json is preferred over yaml
        @param compact_serialization allows the \a compact_serialization property to be overridden

        @return an HttpResponseInfo hash for the response

        @throw ACCEPT-ERROR the response body could not be serialized because the client does not accept a supported
        type
        @throw SERIALIZATION-ERROR the response body could not be serialized due to an error

        @note <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html>RFC 2616 section 14</a>: If an Accept
        header field is present, and if the server cannot send a response which is acceptable according to the
        combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.  To ensure this
        happens, if an Accept error of this nature occurs in this call, an \c "ACCEPT-ERROR" must be thrown
    */
    private:internal hash<HttpResponseInfo> processResponseIntern(string method, string path, int code,
            auto response_body, *hash<auto> headers, *softlist<string> content_types, bool compact_serialization) {
        # find path item object and operation
        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        # perform validation
        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, \response_body, \mime_types);

        hash<HttpResponseInfo> rv((
            "code": code,
            "hdr": headers,
        ));

        if (exists response_body) {
            if (!exists content_types) {
                # no content types mean "accept: */*" header was sent with the request
                # so, if the response has already set \c Content-Type header, we assume
                # that the body is in the right format
                if (checkResponseContentTypeHeader(\rv, response_body, headers))
                    return rv;

                if (checkResponseTextPlain(\rv, response_body, mime_types, NOTHING))
                    return rv;

                # otherwise we continue with the default content types
                content_types = MimeContentTypes;
            }

            if (checkResponseTextPlain(\rv, response_body, mime_types, content_types))
                return rv;

            # there are content_types -> test them one by one
            list<string> mimeTypeKeys = keys mime_types;
            foreach string content in (content_types) {
                # test for the special asterisk case
                if (content == "*/*") {
                    if (checkResponseContentTypeHeader(\rv, response_body, headers))
                        return rv;
                }

                # test if the content type contains asterisk and generate regex for it
                bool asteriskCt = (content.find("*") != -1);
                *string ctRegex = replace(content, "*", ".*");

                # check that the content type is valid for the response
                if (asteriskCt) {
                    *list<auto> mt = map $1, mimeTypeKeys, $1.regex(ctRegex);
                    if (!mt)
                        continue;
                } else if (!mime_types{content})
                    continue;

                # check for multipart-form-data case
                if (content == MimeTypeMultipartFormData) {
                    if (response_body.typeCode() != NT_HASH)
                        throw "SERIALIZATION-ERROR", sprintf("response to %s %s: cannot serialize type %y to MIME "
                            "type %y; expecting \"hash\"", method.upr(), path, response_body.type(), content);
                    hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {
                        $1.key: cast<hash<FormDataMessageInfo>>((
                            "name": $1.key,
                            "filename": $1.key,
                            "hdr": ("Content-Type": MimeTypeText),
                            "body": $1.value,
                        ))}, response_body.pairIterator());

                    hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                    return rv += (
                        "body": mh.body,
                        "hdr": rv.hdr + {"Content-Type": mh.hdr."Content-Type"},
                    );
                }

                # check the default set of mime types
                if (asteriskCt) {
                    *list mt = map $1, MimeContentTypes, $1.regex(ctRegex);
                    if (mt && mt.size()) {
                        string mimeType = mt[0];
                        return rv += (
                            "body": compact_serialization ? MimeDataTypes{mimeType}.serialize(response_body) :
                                MimeDataTypes{mimeType}.serialize_verbose(response_body),
                            "hdr": rv.hdr + ("Content-Type": mimeType),
                        );
                    }
                } else if (MimeDataTypes{content}) {
                    return rv += (
                        "body": compact_serialization ? MimeDataTypes{content}.serialize(response_body) :
                            MimeDataTypes{content}.serialize_verbose(response_body),
                        "hdr": rv.hdr + ("Content-Type": content),
                    );
                }

                # check if the \c Content-Type header is already set
                if (checkResponseContentTypeHeader(\rv, response_body, headers)) {
                    return rv;
                }
            }

            # none of the content types was ok
            if (content_types == MimeContentTypes)
                throw "ACCEPT-ERROR", sprintf("response to %s %s: message body cannot be serialized; available MIME "
                    "type(s) for this call: %y; available serialization modules: %y", method.upr(), path, mime_types,
                    SerializationModules), ("types": mime_types);
            else
                throw "ACCEPT-ERROR", sprintf("response to %s %s: message body cannot be serialized; requested MIME "
                    "type(s): %y; available MIME types for this call: %y; available serialization modules: %y",
                    method.upr(), path, content_types, mime_types, SerializationModules), ("types": mime_types);
        }

        return rv;
    }

    #! Check if the headers contain a content-type header and if so, modify the request hash
    /** @param resp request hash
        @param body request body data (if any)
        @param headers HTTP headers to include in the request

        @return whether the headers contained a \c Content-Type header and the rv was modified

        @note if there are more \c Content-Type headers, then @ref False is returned and request is not modified
    */
    private:internal bool checkRequestContentTypeHeader(reference<hash<RestRequestClientInfo>> req, auto body,
            *hash<auto> headers) {
        # quickly return if body is not in data format
        if (body.typeCode() != NT_BINARY && body.typeCode() != NT_STRING)
            return False;

        # try to find \c Content-Type header
        *list<string> ct = map $1, keys headers, $1 =~ /content-type/i;

        # if found and it's not one of the default ones, use it
        if (ct && ct.size() == 1 && !MimeDataTypes{headers{ct[0]}}) {
            req.body = body;
            req.content = headers{ct[0]};
            return True;
        }
        return False;
    }

    #! Check if the headers contain a content-type header and if so, modify the response hash
    /** @param resp response hash
        @param body response body data (if any)
        @param headers HTTP headers to include in the response

        @return whether the headers contained a \c Content-Type header and the rv was modified

        @note if there are more \c Content-Type headers, then @ref False is returned and response is not modified
    */
    private:internal bool checkResponseContentTypeHeader(reference<hash<HttpResponseInfo>> resp, auto body,
            *hash<auto> headers) {
        # quickly return if body is not in data format
        if (body.typeCode() != NT_BINARY && body.typeCode() != NT_STRING)
            return False;

        # try to find \c Content-Type header
        *list<string> ct = map $1, keys headers, $1 =~ /content-type/i;

        # if found, use it and don't serialize the body
        if (ct && ct.size() == 1) {
            resp.body = body;
            resp.hdr = resp.hdr + ("Content-Type": remove resp.hdr{ct[0]});
            return True;
        }
        return False;
    }

    #! Check if the response body can be sent as text/plain and if so, modify the response hash.
    /** @param resp response hash
        @param body response body data (if any)
        @param mime_types MIME types produced by the operation
        @param content_types content types accepted by the client

        @return whether the response body can be sent as text/plain and the \c resp was modified
    */
    private:internal bool checkResponseTextPlain(reference<hash<HttpResponseInfo>> resp, auto body,
            hash<string, bool> mime_types, *list<auto> content_types) {
        # quickly return if body is not string
        if (body.typeCode() != NT_STRING)
            return False;

        # return if text/plain is not allowed for this operation
        if (!mime_types."text/plain")
            return False;

        if (content_types) {
            # check that text/plain is accepted as a response
            *hash<string, bool> ctypesHash = map {$1 : True}, content_types;
            if (ctypesHash."text/plain" || ctypesHash."*/*" || ctypesHash."text/*") {
                resp.body = body;
                resp.hdr."Content-Type" = "text/plain";
                return True;
            }
            return False;
        }

        resp.body = body;
        resp.hdr."Content-Type" = "text/plain";
        return True;
    }

    #! Processes a schema definition
    private:internal SchemaObject processDefinition(string key, auto value) {
        if (value.typeCode() != NT_HASH)
            throw "INVALID-FIELD-TYPE", sprintf("OpenApi3 Object: invalid definition datatype %y (val %y) for key %y",
                value.type(), value, key);
        return components.schemas{key} := SchemaObject::newSchemaObject(key, value, self);
    }
}

#! The object provides metadata about the API. The metadata can be used by the clients if needed, and can be presented in the %OpenApi3-UI for convenience.
public class InfoObject inherits ObjectBase {
    public {
        #! Required. The title of the application.
        string title;

        #! A short description of the application. GFM syntax can be used for rich text representation.
        *string desc;

        #! The Terms of Service for the API.
        *string termsOfService;

        #! Required. Provides the version of the application API (not to be confused with the specification version).
        string version;

        #! The contact information for the exposed API.
        *ContactObject contact;

        #! The license information for the exposed API.
        *LicenseObject license;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing metadata about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string obj_type = "Info";
        required_field(obj_type, oh, "title", NT_STRING, \title);
        required_field(obj_type, oh, "version", NT_STRING, \version);
        optional_field(obj_type, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(obj_type, oh, "termsOfService", NT_STRING, \termsOfService);

        *hash<auto> contactObj;
        if (optional_field(obj_type, oh, "contact", NT_HASH, \contactObj))
            contact = new ContactObject(contactObj);

        *hash<auto> licenseObj;
        if (optional_field(obj_type, oh, "license", NT_HASH, \licenseObj))
            license = new LicenseObject(licenseObj);
    }
}

#! Contact information for the exposed API.
public class ContactObject inherits ObjectBase {
    public {
        #! The identifying name of the contact person/organization.
        *string name;

        #! The URL pointing to the contact information. MUST be in the format of a URL.
        *string url;

        #! The email address of the contact person/organization. MUST be in the format of an email address.
        *string email;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing contact information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string obj_type = "Contact";
        optional_field(obj_type, oh, "name", NT_STRING, \name);
        optional_field(obj_type, oh, "url", NT_STRING, \url);
        optional_field(obj_type, oh, "email", NT_STRING, \email);
    }
}

#! License information for the exposed API.
public class LicenseObject inherits ObjectBase {
    public {
        #! Required. The license name used for the API.
        string name;

        #! A URL to the license used for the API. MUST be in the format of a URL.
        *string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing license information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string obj_type = "License";
        required_field(obj_type, oh, "name", NT_STRING, \name);
        optional_field(obj_type, oh, "url", NT_STRING, \url);
    }
}

#! Holds the relative paths to the individual endpoints.
/**
    The path is appended to the @ref OpenApi3Schema::basePath "basePath" in order to construct the full URL.
    The Paths may be empty, due to ACL constraints.

    This class stores a tree or a component of a path for path matching, supports wildcard matching
 */
public class PathComponent {
    private {
        #! path prefix
        string pfx;

        #! current component name
        string name;

        #! if there is a wildcard to a PathComponent
        *PathComponent wildcard;

        #! the PathItemObject associated with this path (if any)
        *PathItemObject pio;

        #! hash of non-wildcard paths to the next level
        hash<string, PathComponent> paths;
    }

    #! creates the object
    constructor(hash<auto> oh, string pfx, OpenApi3Schema openapi3) {
        self.pfx = pfx;
        name = "/";
        foreach hash<auto> h in (oh.pairIterator()) {
            if (!pfx.val() && h.key !~ /^\//)
                throw "INVALID-FIELD-FORMAT", sprintf("Paths Object: root path %y does not begin with a slash", h.key);
            list<string> l = h.key.split("/");
            shift l;
            add(h.key, l, 0, h.value, openapi3);
        }
    }

    #! private constructor
    private constructor(string full_path, list<auto> l, int offset, hash<auto> oh) {
        list<auto> l0 = l;
        splice l0, offset + 1;
        pfx = l0.join("/");
        name = l[offset - 1];
    }

    #! adds a component or a Path Item Object to the tree
    private add(string full_path, list<auto> l, int offset, hash<auto> oh, OpenApi3Schema openapi3) {
        #printf("PathComponent::add(): pfx: %y name: %y: %y l: %y offset: %y\n", pfx, name, full_path, l, offset);
        if (offset == l.size()) {
            if (pio)
                throw "INVALID-PATH-COMPONENT", sprintf("cannot terminate path %y twice", full_path);
            pio = new PathItemObject(full_path, oh, openapi3);
            return;
        }

        PathComponent next;
        string key = l[offset];
        if (key =~ /^{/)
            next = wildcard ?? (wildcard = new PathComponent(full_path, l, offset + 1, oh));
        else
            next = paths{key} ?? (paths{key} = new PathComponent(full_path, l, offset + 1, oh));

        next.add(full_path, l, offset + 1, oh, openapi3);
    }

    #! returns either a PathItemObject for the path
    /** @throw SCHEMA-VALIDATION-ERROR the path could not be matched or has no API definition
    */
    PathItemObject match(list<auto> path) {
        *PathItemObject rv = tryMatch(path);
        if (!rv)
            throw "SCHEMA-VALIDATION-ERROR", sprintf("path %y is valid but has no API definition", path.join("/"));
        return rv;
    }

    #! returns either a PathItemObject for the path
    /** @throw SCHEMA-VALIDATION-ERROR the path could not be matched or has no API definition
    */
    *PathItemObject tryMatch(list<auto> path) {
        PathComponent w = self;
        for (int i = 1; i < path.size(); ++i) {
            *PathComponent next = w.paths{path[i]} ?? w.wildcard;
            if (!next) {
                if (w.paths) {
                    throw "SCHEMA-VALIDATION-ERROR", sprintf("path component %y cannot be matched in %y; expected "
                        "one of: %y", path[i], path.join("/"), keys w.paths);
                } else {
                    throw "SCHEMA-VALIDATION-ERROR", sprintf("path component %y cannot be matched in %y", path[i],
                        path.join("/"));
                }
            }
            w = next;
        }
        return w.pio;
    }

    #! returns a hash of URI paths as keys with values as lists of supported HTTP methods
    /** @return a hash of URI paths as keys with values as lists of supported HTTP methods
    */
    getPathOperationHash(reference<hash<string, list<string>>> h) {
        if (pio)
            h{pfx} = pio.getMethods();
        map $1.getPathOperationHash(\h), paths.iterator();
        if (wildcard)
            wildcard.getPathOperationHash(\h);
    }
}

#! This class stores the path tree for URI path matching
public class PathsObject inherits ObjectBase {
    private {
        #! the tree of path components for path matching with wildcards
        PathComponent paths;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing paths to schema endpoints
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
     */
    public constructor(hash<auto> oh, OpenApi3Schema openapi3) : ObjectBase(oh) {
        paths = new PathComponent(oh, "", openapi3);
    }

    #! matches a URI path with a PathItemObject
    /** @throw INVALID-PATH the path could not be matched
    */
    PathItemObject match(string path) {
        if (!path.equalPartial("/")) {
            path = "/" + path;
        }
        # strip query from path before matching
        path =~ s/\?.*//g;
        return paths.match(path.split("/"));
    }

    #! matches a URI path with a PathItemObject
    /** @throw INVALID-PATH the path could not be matched
    */
    *PathItemObject tryMatch(string path) {
        if (!path.equalPartial("/")) {
            path = "/" + path;
        }
        return paths.tryMatch(path.split("/"));
    }

    #! returns a hash of URI paths as keys with values as lists of supported HTTP methods
    /** @return a hash of URI paths as keys with values as lists of supported HTTP methods
    */
    hash<string, list<string>> getPathOperationHash() {
        hash<string, list<string>> rv();
        paths.getPathOperationHash(\rv);
        return rv;
    }
}

#! Describes the operations available on a single path.
/**
    A Path Item may be empty, due to ACL constraints. The path itself is still
    exposed to the documentation viewer but they will not know which operations
    and parameters are available.
 */
public class PathItemObject inherits ObjectBase, ParameterGroup {
    public {
        #! Allows for an external definition of this path item.
        /**
            The referenced structure MUST be in the format of a @ref PathItemObject.
            If there are conflicts between the referenced definition and this
            PathItem's definition, the behavior is undefined.
         */
        *string ref;

        #! The body parameter, if defined
        ParameterObject body;
    }

    private {
        #! A hash of @ref OperationObject "OperationObjects" correspoding to different methods.
        /**
            Keys are lowercase method names, with possible values being:
            - \c "get"
            - \c "put"
            - \c "post"
            - \c "delete"
            - \c "options"
            - \c "head"
            - \c "patch"
         */
        hash<string, OperationObject> operations;
    }

    #! Constructor.
    /**
        @param path the URI path for the object
        @param oh deserialized hash from the source schema description describing the operations available on a single path
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, hash<auto> oh, OpenApi3Schema openapi3) : ObjectBase(oh) {
        string obj_type = "Path Item";
        optional_field(obj_type, oh, "$ref", NT_STRING, \ref);

        *hash opObj;
        if (optional_field(obj_type, oh, "get", NT_HASH, \opObj))
            operations.get = new OperationObject(path, "get", opObj, openapi3);

        delete opObj;
        if (optional_field(obj_type, oh, "put", NT_HASH, \opObj))
            operations.put = new OperationObject(path, "put", opObj, openapi3);

        delete opObj;
        if (optional_field(obj_type, oh, "post", NT_HASH, \opObj))
            operations.post = new OperationObject(path, "post", opObj, openapi3);

        delete opObj;
        if (optional_field(obj_type, oh, "delete", NT_HASH, \opObj))
            operations."delete" = new OperationObject(path, "delete", opObj, openapi3);

        delete opObj;
        if (optional_field(obj_type, oh, "options", NT_HASH, \opObj))
            operations.options = new OperationObject(path, "options", opObj, openapi3);

        delete opObj;
        if (optional_field(obj_type, oh, "head", NT_HASH, \opObj))
            operations.head = new OperationObject(path, "head", opObj, openapi3);

        delete opObj;
        if (optional_field(obj_type, oh, "patch", NT_HASH, \opObj))
            operations.patch = new OperationObject(path, "patch", opObj, openapi3);

        *list params;
        if (optional_field(obj_type, oh, "parameters", NT_LIST, \params)) {
            foreach auto param in (params) {
                if (param.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Path Item Object: 'parameters' list value has invalid type %y",
                            param.type());
                ParameterObject p := ParameterObject::newParameter(
                    sprintf("%d/%d", $# + 1, params.lsize()), param, openapi3
                );
                if (p.in_loc == "body") {
                    if (body)
                        throw "INVALID-FIELD-VALUE", sprintf("path %y: more than one \"body\" parameter provided",
                            path);
                    body := p;
                } else {
                    addParameter(p);
                }
            }
        }
    }

    #! returns the operation object for the given method
    /** @param path the path to be used in any error message
        @param method the HTTP method name

        @return the OperationObject corresponding to the arguments

        @throws INVALID-METHOD the given path does not have any operation defined for the given method
    */
    OperationObject getOperation(string method, string path) {
        *OperationObject op = operations{method};
        if (!op)
            throw "INVALID-METHOD", sprintf("%s %s: no operation defined for this path; known methods: %y",
                method.upr(), path, keys operations), keys operations;
        return op;
    }

    #! returns a list of HTTP methods supported by this object
    /** @return a list of HTTP methods supported by this object
    */
    softlist getMethods() {
        return keys operations;
    }
}

#! Describes a single API operation on a path.
public class OperationObject inherits ObjectBase, ParameterGroup {
    public {
        #! the URI path for the operation
        string path;

        #! the HTTP method for the operation
        string method;

        #! A list of tags (strings or @ref TagObject "TagObjects") for API documentation control.
        /**
            Tags can be used for logical grouping of operations by resources or any other qualifier.
         */
        list tags;

        #! A short summary of what the operation does.
        *string summary;

        #! A verbose explanation of the operation behavior. GFM syntax can be used for rich text representation.
        *string desc;

        #! Declares this operation to be deprecated.
        /**
            Usage of the declared operation should be refrained.
            Default value is \c false.
         */
        bool deprec = False;

        #! Additional external documentation for this operation.
        *ExternalDocumentationObject externalDocs;

        #! Unique string used to identify the operation.
        /**
            The id MUST be unique among all operations described in the API.
            Tools and libraries MAY use the operationId to uniquely identify
            an operation, therefore, it is recommended to follow common
            programming naming conventions.
         */
        *string operationId;

        #! A list of MIME types (strings) the operation can consume.
        /**
            This overrides the @ref OpenApi3Schema::consumes "consumes" definition
            at the %OpenApi3 Object. An empty value MAY be used to clear the global definition.
            Key values MUST be Mime Types.
         */
        hash<string, bool> consumes;

        #! A hash of MIME types (strings) the operation can produce.
        /**
            This overrides the @ref OpenApi3Schema::produces "produces" definition
            at the %OpenApi3 Object. An empty value MAY be used to clear the global definition.
            Key values MUST be Mime Types.
         */
        hash<string, bool> produces;

        #! formData parameter; if defined for this operation, body parameter will be excluded
        hash<string, ParameterObject> formData;

        #! The body parameter, if defined
        ParameterObject body;

        #! Required. The list of possible responses as they are returned from executing this operation.
        ResponsesObject responses;

        #! A declaration of which security schemes are applied for this operation.
        /**
            The list of values describes alternative security schemes that can be
            used (that is, there is a logical OR between the security requirements).
            This definition overrides any declared top-level @ref OpenApi3Schema::security "security".
            To remove a top-level security declaration, an empty array can be used.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref OpenApi3Schema::securitySchemes "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
         */
        list<hash<string, list<string>>> security;
    }

    #! Constructor.
    /** @param path the path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the operation
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, string method, hash<auto> oh, OpenApi3Schema openapi3) : ObjectBase(oh) {
        self.path = path;
        self.method = method.upr();
        string obj_type = "Operation";
        *list<auto> tagsObj;
        if (optional_field(obj_type, oh, "tags", NT_LIST, \tagsObj)) {
            foreach auto tag in (tagsObj) {
                if (tag.typeCode() == NT_STRING) {
                    tags += tag;
                } else if (tag.typeCode() == NT_HASH) {
                    tags += new TagObject(tag);
                } else {
                    error("INVALID-FIELD-TYPE", "'tags' list value has invalid type %y; expecting \"hash\" or "
                        "\"string\"", tag.fullType());
                }
            }
        }

        on_error rethrow $1.err, sprintf("%s (operation \"%s %s\")", $1.desc, method.upr(), path);

        optional_field(obj_type, oh, "summary", NT_STRING, \summary);
        optional_field(obj_type, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(obj_type, oh, "deprecated", NT_BOOLEAN, \deprec);

        *hash extDocsObj;
        if (optional_field(obj_type, oh, "externalDocs", NT_HASH, \extDocsObj)) {
            externalDocs = new ExternalDocumentationObject(extDocsObj);
        }

        optional_field(obj_type, oh, "operationId", NT_STRING, \operationId);
        # TODO check operationId uniqueness as per docs

        # use the global "consumes" definition if none is defined on the operation
        if (!optional_field(obj_type, oh, "consumes", OpenApi3ListToStringSet, \consumes) && openapi3.consumes) {
            consumes = openapi3.consumes;
        }

        # use the global "produces" definition if none is defined on the operation
        if (!optional_field(obj_type, oh, "produces", OpenApi3ListToStringSet, \produces) && openapi3.produces) {
            produces = openapi3.produces;
        }
        {
            list listObj;
            optional_field(obj_type, oh, "parameters", NT_LIST, \listObj);
            foreach auto p in (listObj) {
                if (p.typeCode() != NT_HASH) {
                    error("INVALID-FIELD-TYPE", "invalid 'parameters' list value datatype %y; expecing \"hash\"",
                        p.fullType());
                }
                ParameterObject param := ParameterObject::newParameter(sprintf("%d/%d", $# + 1,
                    listObj.lsize()), p, openapi3);
                if (param.in_loc == "body") {
                    body := param;
                } else if (param.in_loc == "formData") {
                    formData{param.name} = param;
                } else {
                    addParameter(param);
                }
            }
        }

        {
            hash responsesObj;
            required_field(obj_type, oh, "responses", NT_HASH, \responsesObj);
            responses = new ResponsesObject(path, self.method, responsesObj, openapi3);
        }

        {
            list securityList;
            optional_field(obj_type, oh, "security", NT_LIST, \securityList);
            foreach auto val in (securityList) {
                if (val.typeCode() != NT_HASH) {
                    error("INVALID-FIELD-TYPE", "invalid 'security' list value datatype %y; expecting \"hash\"",
                        val.fullType());
                }
                hash<auto> h = val;
                foreach hash<auto> it in (h.pairIterator()) {
                    if (it.value.typeCode() != NT_LIST) {
                        error("INVALID-FIELD-TYPE", "invalid Security Requirement Object value type %y (should be a "
                            "list of hashes)", val.fullType());
                    }
                    if ((map True, it.value, $1.typeCode() != NT_STRING).size()) {
                        error("INVALID-FIELD-TYPE", "invalid Security Requirement Object value type %y (should be a "
                            "list of hashes with list values)", val.fullType());
                    }
                }
            }
            if (securityList) {
                security = cast<list<hash<string, list<string>>>>(securityList);
            }
        }
    }

    #! Processes a generated request
    *data getRequestBody(PathItemObject pio, auto body, reference<hash<auto>> headers) {
        *ParameterObject body_po = self.body ?? pio.body;
        if (body_po) {
            body_po.check(True, True, path, method, "body", \body);
        } else if (formData) {
            map $1.value.check(True, True, path, method, "formData." + $1.key, \body{$1.key}),
                formData.pairIterator();
        } else if (body) {
            error("SCHEMA-VALIDATION-ERROR", "No message body is accepted; body keys passed: %y", keys body);
        }

        if (!exists body) {
            return;
        }

        # get content type
        if (!consumes) {
            throw "SERIALIZATION-ERROR", sprintf("%s %s: API supports no serialization types but a \"body\" "
                "parameter is present", method.upr(), path);
        }
        string ct = consumes.firstKey();

        if (ct == MimeTypeMultipartFormData) {
            hash<string, hash<FormDataMessageInfo>> parts =
                cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>({
                    "name": $1.key,
                    "filename": $1.key,
                    "hdr": {"Content-Type": MimeTypeText},
                    "body": $1.value,
                })}, body.pairIterator());

            hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
            headers."Content-Type" = mh.hdr."Content-Type";
            return mh.body;
        }

        if (MimeDataTypes{ct}) {
            headers."Content-Type" = ct;
            return MimeDataTypes{ct}.serialize(body);
        }

        throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; available MIME type(s): %y; "
            "available serialization modules: %y", method.upr(), path, keys consumes, SerializationModules);
    }

    #! processes a REST API client-side request to the operation
    /** @param serialize if request arguments should be processed for serialization (client-side) or not (server-side)
        @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the deserialized HTTP message body data
        @param headers a reference to a hash of HTTP headers
        @param mime_types a reference to a hash of valid mime types for the operation

        @throws SCHEMA-VALIDATION-ERROR invalid parameter name or location, missing parameter and parameter has no
        default value
    */
    validateRequest(bool serialize, PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<auto> body,
            reference<hash> headers, *reference<hash<string, bool>> mime_types) {
        # check query parameters
        *string query_obj = self.query_obj ?? pio.query_obj;
        if (exists query_obj) {
            h.params{query_obj} = map {$1: remove h.params{$1}}, keys h.params, !parameters{$1} && !pio.parameters{$1};
        }

        foreach string key in (keys h.params) {
            # find URI parameter object
            *ParameterObject po = parameters{key} ?? pio.parameters{key};
            if (!po) {
                if (exists (*string op = (query_obj ?? pio.query_obj))) {
                    h.params{op}{key} = remove h.params{key};
                } else {
                    error("SCHEMA-VALIDATION-ERROR", "No query parameter named %y defined for this path and method; "
                        "known query parameters: %y", key, keys (parameters + pio.parameters));
                }
            }
            if (po.in_loc != "query") {
                error("SCHEMA-VALIDATION-ERROR", "invalid parameter %y given in the URI query; expected location %y",
                    key, po.in_loc);
            }

            po.check(serialize, True, path, method, key, \h.params{key});
        }
        # when serializing query args of type hash (OpenAPI 3+ compatibility), merge the object's keys back into the
        # hash
        if (exists query_obj && serialize) {
            h.params = remove h.params{query_obj};
        }

        # check header parameters
        foreach string key in (keys headers) {
            # find URI parameter object
            *ParameterObject po = parameters{key} ?? pio.parameters{key};
            # extra headers are OK
            if (!po || po.in_loc != "header") {
                continue;
            }

            po.check(serialize, True, path, method, key, \headers{key});
        }

        # check body parameters
        {
            *ParameterObject body_po = self.body ?? pio.body;
            if (body_po) {
                body_po.check(serialize, True, path, method, "body", \body);
            } else if (formData) {
                foreach hash<auto> i in (formData.pairIterator()) {
                    i.value.check(serialize, True, path, method, "formData." + i.key, \body{i.key});
                }
            } else if (body) {
                error("SCHEMA-VALIDATION-ERROR", "No message body is accepted; body keys passed: %y", keys body);
            }
        }

        # check path parameters
        foreach string param in (path =~ x/{([^}]+)}/g) {
            *ParameterObject po = parameters{param} ?? pio.parameters{param};
            if (!po) {
                error("SCHEMA-VALIDATION-ERROR", "No path parameter named %y defined for this path and method; "
                    "known parameters: %y", param, keys (parameters + pio.parameters));
            }

            string pattern = replace(path, "{" + param + "}", "(.*)");
            pattern =~ s/^\//\/?/;
            auto val = regex_extract(h.method, pattern)[0];

            # convert string to actual type
            switch (po.schema.type) {
                case "integer":
                    val = val.toInt();
                    break;

                case "number":
                    val = val.toNumber();
                    break;

                case "boolean":
                    val = parse_boolean(val);
                    break;
            }

            po.check(False, True, path, method, param, \val);
            h.path_params{param} = val;
        }

        # check for missing required parameters
        checkMissingParams(h, headers, body, parameters);
        checkMissingParams(h, headers, body, pio.parameters, parameters);

        if (consumes) {
            mime_types = consumes;
        }
    }

    #! parses and processes a REST request on the server side
    /** @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the deserialized HTTP message body data
        @param headers a reference to a hash of HTTP headers

        @throw DESERIALIZATION-ERROR invalid content-type
        @throws INVALID-PARAMETER-NAME invalid parameter name
        @throws INVALID-PARAMETER-LOCATION invalid parameter location
        @throws MISSING-PARAMETER missing parameter and parameter has no default value
    */
    parseRequest(PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<auto> body, reference<hash> headers) {
        # validate message
        hash<string, bool> mime_types();
        validateRequest(False, pio, \h, \body, \headers, \mime_types);

        # check content-type
        if (exists body && mime_types) {
            string content = headers."content-type" ?? headers."Content-Type";
            int pos = content.find(";");
            if (pos != -1)
                content = content.substr(0, pos);
            if (!mime_types{content})
                throw "DESERIALIZATION-ERROR", sprintf("%s: invalid Content-Type: %y; valid MIME types: %y", h.method,
                    content, mime_types);
        }

        # set default parameter values
        doDefaultParams(\h, \headers, \body, parameters);
        doDefaultParams(\h, \headers, \body, pio.parameters, parameters);
    }

    #! validates a response against the response definition, if any
    validateResponse(string method, string path, PathItemObject pio, int http_code, reference<auto> response_body,
            reference<hash<string, bool>> mime_types, bool deserialize = True) {
        *ResponseObject res = getResponse(http_code);
        if (res.schema) {
            res.schema.check(deserialize, False, path, method, "response body", \response_body);
        } else if (exists res && exists response_body) {
            error("SCHEMA-VALIDATION-ERROR", "Response code %y to %s %y should not have any body", http_code, method,
                path);
        }

        if (produces) {
            mime_types = produces;
        }
    }

    #! returns example Qore code for the given request
    /** @param method the HTTP method (in lower case)
        @param path the URI path of the request
        @param pio the PathItemObject corresponding to the URI path
        @param openapi3 the schema object itself

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore code to generate the given request message
    */
    hash<RestQoreExampleCodeInfo> getQoreExampleRequest(string method, string path, PathItemObject pio, OpenApi3Schema openapi3) {
        hash<RestQoreExampleCodeInfo> rv();

        #! URI query arguments
        hash<auto> query;
        #! headers
        hash<auto> headers;

        getQoreExampleParams(\query, \headers, parameters);
        getQoreExampleParams(\query, \headers, pio.parameters, parameters);

        if (query)
            path = make_uri_query(cast<hash<UriQueryInfo>>({"method": path, "params": query}));

        rv.example = sprintf("RestClient client((\"url\": %y));\n", openapi3.getTargetUrl());

        #! get example message body
        *ParameterObject body_po = body ?? pio.body;
        if (body_po)
            rv.example += body_po.getQoreExample(\rv);

        rv.example += "hash<auto> info;\n";
        if (headers) {
            rv.example += "hash<auto> hdr = (\n";
            rv.example += foldl $1 + "\n" + $2, (map sprintf("    %y: %y,", $1.key, $1.value), headers.pairIterator());
            rv.example += "\n);\n";
        }

        rv.example += sprintf("hash<auto> res = rest.%s", method.lwr());
        rv.example += sprintf("(%y, ", path);
        # body
        rv.example += body_po ? "rest_body, " : "NOTHING, ";
        # info reference
        rv.example += "\\info";
        # headers
        if (headers)
            rv.example += ", hdr";
        rv.example += ");\n";

        return rv;
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method (in lower case)
        @param path the URI path of the request
        @param pio the PathItemObject corresponding to the URI path
        @param openapi3 the schema object itself
        @param rbody the output example body value, if any

        @return a @ref RestSchemaValidator::RestExampleRequestInfo "RestExampleRequestInfo" hash of example message
        information for the given request
    */
    hash<RestSchemaValidator::RestExampleRequestInfo> getExampleRequest(string method, string path,
            PathItemObject pio, OpenApi3Schema openapi3, reference rbody) {
        hash<RestExampleRequestInfo> rv();

        #! URI query arguments
        hash<auto> query;

        getQoreExampleParams(\query, \rv.hdr, parameters);
        getQoreExampleParams(\query, \rv.hdr, pio.parameters, parameters);

        rv.request_uri = sprintf("%s %s HTTP/1.1", method.upr(),
            make_uri_query(cast<hash<UriQueryInfo>>({"method": path, "params": query})));

        #! get example message body
        *ParameterObject body_po = body ?? pio.body;
        if (body_po)
            rbody = body_po.getExampleValue();

        return rv;
    }

    #! returns example Qore code for the given response
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response

        @return a @ref RestSchemaValidator::RestQoreExampleCodeInfo "RestQoreExampleCodeInfo" hash giving example Qore
        code to generate the given response message
    */
    hash<RestQoreExampleCodeInfo> getQoreExampleResponse(string method, string path, int code) {
        hash<RestQoreExampleCodeInfo> rv();

        *ResponseObject res = getResponse(code);
        if (res.schema)
            rv.example = res.schema.getQoreExample(\rv, "body", True);

        rv.example += sprintf("return RestHandler::makeResponse(%d%s);\n", code, rv.example ? ", body" : "");

        return rv;
    }

    #! returns a hash of example message information for the given request
    /** @param method the HTTP method of the original request (case insensitive)
        @param path the URI path of the original request
        @param code the HTTP response code of the response
        @param body the output example body value, if any

        @return a @ref RestSchemaValidator::RestExampleResponseInfo "RestExampleResponseInfo" hash giving example
        response message info
    */
    hash<RestExampleResponseInfo> getExampleResponse(string method, string path, int code, reference<auto> body) {
        hash<RestExampleResponseInfo> rv();

        *ResponseObject res = getResponse(code);
        if (res.schema)
            body = res.schema.getExampleValue();

        return rv;
    }

    private getQoreExampleParams(reference<hash<auto>> query, reference<hash<auto>> headers,
            hash<string, ParameterObject> parameters, *hash<string, ParameterObject> child_params) {
        foreach hash<auto> ph in (parameters.pairIterator()) {
            # don't check if child params already checked or if it's the single message body param
            if (child_params{ph.key} || ph.value.in_loc == "body" || ph.value.in_loc == "formData")
                continue;
            switch (ph.value.in_loc) {
                case "query":
                    query{ph.key} = ph.value.getExampleValue();
                    break;
                case "header":
                    headers{ph.key} = ph.value.getExampleValue();
                    break;
            }
        }
    }

    #! add default parameters
    private doDefaultParams(reference<hash<UriQueryInfo>> h, reference<hash> headers, reference<auto> body,
            hash<string, ParameterObject> parameters, *hash<string, ParameterObject> child_params) {
        foreach hash<auto> ph in (parameters.pairIterator()) {
            # don't check if child params already checked or if it's the single message body param
            if (child_params{ph.key} || ph.value.in_loc == "body")
                continue;
            if (exists (auto val = ph.value.getDefaultValue())) {
                switch (ph.value.in_loc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            h.params{ph.key} = val;
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            headers{ph.key} = val;
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            body{ph.key} = val;
                        break;
                    # NOTE: default "path" values are not possible, "body" is handled specially
                }
            }
        }
    }

    #! checks for missing params
    private checkMissingParams(hash<UriQueryInfo> h, *hash<auto> headers, auto body,
            hash<string, ParameterObject> parameters, *hash<string, ParameterObject> child_params) {
        foreach hash<auto> ph in (parameters.pairIterator()) {
            # don't check if child params already checked
            if (child_params{ph.key} || ph.value.in_loc == "body")
                continue;
            if (ph.value.required) {
                switch (ph.value.in_loc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            error("SCHEMA-VALIDATION-ERROR", "request is missing required query parameter %y",
                                ph.key);
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            error("SCHEMA-VALIDATION-ERROR", "request is missing required header parameter %y",
                                ph.key);
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            error("SCHEMA-VALIDATION-ERROR", "request is missing required formData parameter %y",
                                ph.key);
                        break;
                    # NOTE: missing path parameters are not possible (path would not be matched in the first place)
                    #       "body" is handled specially
                }
            }
        }
    }

    #! returns the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    /** @return the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    */
    private *ResponseObject getResponse(int code) {
        return responses.responses{code} ?? responses.defaultResp;
    }

    #! raises an exception with context information
    private error(string err, string fmt, ...) {
        throw err, sprintf("%s %s Operation Object: %s", method.upr(), path, vsprintf(fmt, argv));
    }
}

#! Allows referencing an external resource for extended documentation.
public class ExternalDocumentationObject inherits ObjectBase {
    public {
        #! A short description of the target documentation. GFM syntax can be used for rich text representation.
        *string desc;

        #! Required. The URL for the target documentation. Value MUST be in the format of a URL.
        string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing a reference to external documentation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string obj_type = "External Documentation";
        required_field(obj_type, oh, "url", NT_STRING, \url);
        optional_field(obj_type, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Base class for ParameterObject and HeaderObject
public class ParameterBase inherits ObjectBase {
    public {
        #! Required. The name of the parameter. Parameter names are case sensitive
        /**
            - If @ref ParameterObject::in_loc "in_loc" is \c "path", the \c name
                field MUST correspond to the associated path segment from the
                \c "path" field in the @ref OpenApi3::PathsObject.
            - For all other cases, the name corresponds to the parameter name
                used based on the @ref ParameterObject::in_loc "in_loc" property.
        */
        string name;

        #! Required. The location of the parameter
        /**
            Possible values are \c "query", \c "header", \c "path", \c "formData" or \c "body".
        */
        string in_loc;

        #! A brief description of the parameter
        /** This could contain examples of use

            CommonMark syntax MAY be used for rich text representation
        */
        *string desc;

        #! Describes how the parameter value will be serialized depending on the type of the parameter value
        /** Default values (based on value of in):
            - for query - form
            - for path - simple
            - for header - simple
            - for cookie - form
        */
        *string style;

        #! Explode when rendering
        /** When this is true, parameter values of type array or object generate separate parameters for each value of
            the array or key-value pair of the map. For other types of parameters this property has no effect. When
            style is form, the default value is true. For all other styles, the default value is false.
        */
        bool explode;

        #! Allow reserved characters without percent encoding
        /** Determines whether the parameter value SHOULD allow reserved characters, as defined by RFC3986
            :/?#[]@!$&'()*+,;= to be included without percent-encoding. This property only applies to parameters with
            an in value of query. The default value is false.
        */
        bool allowReserved;

        #! Determines whether this parameter is mandatory
        /**
            If the parameter is @ref ParameterObject::in_loc "in" "path",
            this property is \b required and its value MUST be \c true.
            Otherwise, the property MAY be included and its default value is \c false.
        */
        bool required = False;

        #! Content media type, if present
        *string content;

        #! Media type object for 'content'
        #MediaType media;

        #! The schema defining the type used for the parameter
        SchemaObject schema;

        #! Valid style values
        const StyleMap = {
            "matrix": True,
            "label": True,
            "form": True,
            "simple": True,
            "spaceDelimited": True,
            "pipeDelimited": True,
            "deepObject": True,
        };

        #! Default style values based on the location
        const DefaultStyles = {
            "query": "form",
            "path": "simple",
            "header": "simple",
            "cookie": "form",
        };

        #! Valid Styles per location
        const LocStyleMap = {
            "cookie": {
                "form": True,
            },
            "header": {
                "simple": True,
            },
            "path": {
                "matrix": True,
                "label": True,
                "simple": True,
            },
            "query": {
                "form": True,
                "spaceDelimited": True,
                "pipeDelimited": True,
                "deepObject": True,
            },
        };
    }

    private {
        static hash<string, ParameterBase> cache;
    }

    #! Creates the object
    public constructor(hash<auto> oh) : ObjectBase(oh) {
    }

    #! Copy the object
    copy(ParameterObject old) {
        addToCache(self);
    }

    #! Parse the parameter data
    private parseData(hash<auto> oh, OpenApi3Schema openapi3) {
        string obj_type = sprintf("%s parameter", in_loc);
        on_error rethrow $1.err, sprintf("%s (%s %y)", $1.desc, obj_type, name);

        optional_field(obj_type, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        if (in_loc == "path") {
            required_field(obj_type, oh, "required", NT_BOOLEAN, \required);
            if (!required) {
                throw "INVALID-PARAMETER", sprintf("Path parameter %y has 'required: false'", name);
            }
        } else {
            optional_field(obj_type, oh, "required", NT_BOOLEAN, \required);
        }

        hash<auto> schemaObj;
        if (optional_field(obj_type, oh, "schema", NT_HASH, \schemaObj)) {
            schema := SchemaObject::newSchemaObject(name, schemaObj, openapi3, True);
        }

        if (optional_field(obj_type, oh, "style", NT_STRING, \style)) {
            if (!StyleMap{style}) {
                throw "INVALID-STYLE", sprintf("Style %y is invalid; known styles: %y", style, keys StyleMap);
            }
            if (!LocStyleMap{in_loc}{style}) {
                throw "INVALID-STYLE", sprintf("Style %y is invalid for location %y; valid styles for this "
                    "location: %y", style, in_loc, keys LocStyleMap{in_loc});
            }
        } else if (exists (*string s = DefaultStyles{in_loc})) {
            style = s;
        }

        if (!optional_field(obj_type, oh, "explode", NT_BOOLEAN, \explode) && style == "form") {
            explode = True;
        }

        if (in_loc == "query") {
            optional_field(obj_type, oh, "allowReserved", NT_BOOLEAN, \allowReserved);
        }

        hash<auto> content;
        if (optional_field(obj_type, oh, "content", NT_HASH, \content)) {
            if (content.size() != 1) {
                throw "INVALID-CONTENT", sprintf("%s has %d 'content' entries; must have only 1", obj_type,
                    content.size());
            }
            self.content = content.firstKey();
            # TODO FIXME: add content media type processing
            #media = new MediaTypeObject(content.firstValue());
        }
        if (!schemaObj && !content) {
            throw "INVALID-PARAMETER", sprintf("%s parameter is missing both \"schema\" and \"content\"; at least "
                "one is required", name);
        }

        addToCache(self);
    }

    #! Adds an ParameterObject to the cache
    static private addToCache(ParameterBase obj) {
        cache{obj.uniqueHash()} = obj;
    }

    #! Removes an ParameterObject from the cache
    static private removeFromCache(ParameterBase obj) {
        remove cache{obj.uniqueHash()};
    }
}

#! Describes a single operation parameter
/**
    A unique parameter is defined by a combination of a @ref ParameterObject::name "name"
    and @ref ParameterObject::in_loc "location".

    There are five possible parameter types:
    - Path: Used together with Path Templating, where the parameter value is
        actually part of the operation's URL. This does not include the host or
        base path of the API. For example, in <tt>/items/{itemId}</tt>, the path
        parameter is \c itemId.
    - Query: Parameters that are appended to the URL. For example, in <tt>/items?id=###</tt>,
        the query parameter is \c id.
    - Header: Custom headers that are expected as part of the request.
    - Body: The payload that's appended to the HTTP request. Since there can only
        be one payload, there can only be one body parameter. The name of the
        body parameter has no effect on the parameter itself and is used for
        documentation purposes only. Since Form parameters are also in the payload,
        body and form parameters cannot exist together for the same operation.
    - Form: Used to describe the payload of an HTTP request when either
        <tt>application/x-www-form-urlencoded</tt>, <tt>multipart/form-data</tt>
        or both are used as the content type of the request (in %OpenApi3's definition,
        the \c consumes property of an operation). This is the only parameter
        type that can be used to send files, thus supporting the file type.
        Since form parameters are sent in the payload, they cannot be declared
        together with a body parameter for the same operation. Form parameters
        have a different format based on the content-type used (for further details,
        consult http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4):
        - <tt>application/x-www-form-urlencoded</tt> - Similar to the format
          of Query parameters but as a payload. For example,
          <tt>foo=1&bar=openapi3</tt> - both foo and bar are form parameters.
          This is normally used for simple parameters that are being transferred.
        - <tt>multipart/form-data</tt> - each parameter takes a section in
          the payload with an internal header. For example, for the header
          <tt>Content-Disposition: form-data; name="submit-name"</tt> the name
          of the parameter is \c submit-name. This type of form parameters
          is more commonly used for file transfers.
 */
public class ParameterObject inherits ParameterBase {
    public {
        #! Sets the ability to pass empty-valued parameters
        /**
            This is valid only for query parameters and allows sending a parameter with an empty value. Default value
            is false. If style is used, and if behavior is n/a (cannot be serialized), the value of allowEmptyValue
            SHALL be ignored. Use of this property is NOT RECOMMENDED, as it is likely to be removed in a later
            revision.
        */
        bool allowEmptyValue = False;

        const ParameterLocations = {
            "body": True,
            "query": True,
            "path": True,
            "header": True,
            "formData": True,
        };
    }

    #! Constructor
    /**
        @param oh deserialized hash from the source schema description decscribing a single parameter

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    public constructor(hash<auto> oh, OpenApi3Schema openapi3) : ParameterBase(oh) {
        required_field("parameter", oh, "name", NT_STRING, \name);
        required_field("parameter", oh, "in", NT_STRING, \in_loc);
        if (!ParameterLocations{in_loc}) {
            throw "INVALID-FIELD-VALUE", sprintf("parameter %y: invalid location (\"in\") value: %y", name, oh."in");
        }
        if (in_loc == "query") {
            optional_field(in_loc + " parameter", oh, "allowEmptyValue", NT_BOOLEAN, \allowEmptyValue);
        }
        parseData(oh, openapi3);
    }

    #! Processes the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference<auto> value) {
        # issue #2369 ignore the parameter if it's not required
        if (!exists value && !required) {
            return;
        }

        on_error rethrow $1.err, sprintf("%s (while checking %s parameter)", $1.desc, self.name);

        # issue #2388 ensure that query parameters are converted to their target type first
        if (in_loc == "query") {
            switch (schema.type) {
                case "integer": {
                    if (value.typeCode() == NT_STRING) {
                        if (value =~ /[0-9]{4}-[0-9]{2}-[0-9]{2}(T[0-2][0-9]:[0-5][0-9]:[0-5][0-9])?/) {
                            value = date(value).getEpochSeconds();
                        } else {
                            if (value !~ /^([+-])?[0-9]+$/) {
                                throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of "
                                    "type \"integer\" is invalid; value provided: %y", name, path, method, value);
                            }
                            value = value.toInt();
                        }
                    }
                    break;
                }
                case "number":
                    if (value.typeCode() == NT_STRING) {
                        value = value.toNumber();
                    }
                    break;
                case "string":
                    switch (schema.format) {
                        case "date":
                        case "date-time":
                            try {
                                value = date(value);
                            } catch (hash<ExceptionInfo> ex) {
                                throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of "
                                    "type \"date\" is invalid; value provided: %y (%s)", name, path, method, value,
                                    ex.desc);
                            }
                            break;
                        case "binary":
                            try {
                                value = binary(value);
                            } catch (hash<ExceptionInfo> ex) {
                                throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of "
                                    "type \"binary\" is invalid; value provided: %y (%s)", name, path, method, value,
                                    ex.desc);
                            }
                            break;
                        case "byte":
                            try {
                                value = parse_base64_string(value);
                            } catch (hash<ExceptionInfo> ex) {
                                throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y of "
                                    "type \"binary\" is invalid; value provided: %y (%s)", name, path, method, value,
                                    ex.desc);
                            }
                            break;
                    }
                    break;
                case "boolean":
                    value = parse_boolean(value);
                    break;
                case "array":
                    switch (value.typeCode()) {
                        case NT_STRING:
                            value = value.split(",");
                            break;
                        case NT_LIST:
                            break;
                        default:
                            value = exists value ? (value,) : ();
                            break;
                    }
                    break;
            }
        } else if (in_loc == "path" && !value && path) {
            # if we have a path and a missing value then ignore the missing value
            return;
        }
        schema.check(serialize, request, path, method, name, \value);
        if (!exists value && !allowEmptyValue) {
            throw "SCHEMA-VALIDATION-ERROR", sprintf("%s Parameter %y for path %y and method %y has empty value",
                self.name, name, path, method);
        }
    }

    #! Generates Qore example code for a REST API call
    string getQoreExample(reference<hash<RestQoreExampleCodeInfo>> rv) {
        return schema.getQoreExample(\rv, "rest_body", True);
    }

    #! Returns the default value of the parameter
    auto getDefaultValue() {
        return schema.defaultVal;
    }

    # Returns an example value for a REST API call
    auto getExampleValue() {
        return schema.getExampleValue();
    }

    #! gets a concrete instance of an ParameterObject
    static ParameterObject newParameter(string name, hash<auto> oh, OpenApi3Schema openapi3) {
        on_error rethrow $1.err, sprintf("%s (while processing parameter %y)", $1.desc, name);
        if (oh.hasKey("$ref")) {
            return openapi3.resolveParameter(name, oh."$ref", oh);
        }
        return new ParameterObject(oh, openapi3);
    }
}

#! contains the possible responses for an operation
public class ResponsesObject inherits ObjectBase {
    public {
        # The documentation of responses other than the ones declared for specific HTTP response codes.
        /**
            It can be used to cover undeclared responses.
         */
        ResponseObject defaultResp;

        # A hash mapping HTTP status codes to @ref ResponseObject "ResponseObjects".
        /**
            Any HTTP status code can be used as the property name (one property
            per HTTP status code). Describes the expected response for that HTTP status code.
         */
        hash<string, ResponseObject> responses;
    }

    #! Constructor.
    /**
        @param path the URI path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the responses for an operation
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws EMPTY-RESPONSES no responses given
     */
    public constructor(string path, string method, hash<auto> oh, OpenApi3Schema openapi3) : ObjectBase(oh) {
        string obj_type = "Responses";
        *hash defaultObj;
        if (optional_field(obj_type, oh, "default", NT_HASH, \defaultObj))
            defaultResp := ResponseObject::newResponse("default", defaultObj, openapi3);

        *hash r = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^[0-9]+$/;
        foreach hash resp in (r.pairIterator()) {
            if (resp.value.typeCode() != NT_HASH)
                throw "INVALID-FIELD-TYPE", sprintf("%s %s: Responses Object: response has invalid type %y", method,
                    path, resp.value.type());
            responses{resp.key} := ResponseObject::newResponse(resp.key, resp.value, openapi3);
        }

        if (responses.empty() && !defaultObj)
            throw "EMPTY-RESPONSES", sprintf("%s %s: no valid responses provided for operation", method, path);
    }
}

#! Describes a single response from an API Operation.
public class ResponseObject inherits ObjectBase {
    public {
        #! Required. A short description of the response. GFM syntax can be used for rich text representation.
        string desc;

        #! A definition of the response structure.
        /**
            It can be a primitive, an array or an object. If this field does not exist,
            it means no content is returned as part of the response. As an extension
            to the @ref SchemaObject "SchemaObject", its root \c type value may also
            be \c "file". This SHOULD be accompanied by a relevant \c produces mime-type.
         */
        *SchemaObject schema;

        #! A hash of headers that are (can be) sent with the response.
        /**
            A hash of @ref HeaderObject objects. Keys are header names.
         */
        hash<auto> headers;

        #! A hash of example response messages.
        /**
            A hash of example responses in the form of <tt>Example Object</tt>.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#exampleObject
            Keys MUST be one of the Operation @ref OperationObject::produces "produces"
            values (either implicit or inherited). The value SHOULD be an example
            of what such a response would look like.
         */
        hash examples;
    }

    private {
        static hash<string, ResponseObject> cache;
    }

    #! private constructor; use newResponse() instead
    /**
        @param key the response code for error reporting
        @param oh deserialized hash from the source schema description describing a single response for an API operation
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string key, hash<auto> oh, OpenApi3Schema openapi3) : ObjectBase(oh) {
        string obj_type = key + " Response";
        required_field(obj_type, oh, "description", NT_STRING, \desc);

        *hash<auto> schemaObj;
        if (optional_field(obj_type, oh, "schema", NT_HASH, \schemaObj))
            schema := SchemaObject::newSchemaObject("response_" + key, schemaObj, openapi3);

        *hash<auto> headersObj;
        if (optional_field(obj_type, oh, "headers", NT_HASH, \headersObj))
            headers = map {$1.key: new HeaderObject($1.key, $1.value, openapi3)}, headersObj.pairIterator();

        optional_field(obj_type, oh, "examples", NT_HASH, \examples);
        # TODO keys should be Operation 'produces' values

        addToCache(self);
    }

    copy(ResponseObject old) {
        addToCache(self);
    }

    #! returns a new ResponseObject corresponding to the schema definition passed
    /**
        @param key the response code for the response
        @param oh deserialized hash from the source schema description describing a single response for an API
        operation
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    static ResponseObject newResponse(string key, hash<auto> oh, OpenApi3Schema openapi3) {
        if (oh.hasKey("$ref"))
            return openapi3.resolveResponse(key, oh."$ref", oh);
        return new ResponseObject(key, oh, openapi3);
    }

    #! Adds a ResponseObject to the cache
    static private addToCache(ResponseObject obj) {
        cache{obj.uniqueHash()} = obj;
    }

    #! Removes a ResponseObject from the cache
    static private removeFromCache(ResponseObject obj) {
        remove cache{obj.uniqueHash()};
    }
}

#! describes a single HTTP header
public class HeaderObject inherits ParameterBase {
    #! Constructor
    /**
        @param oh deserialized hash from the source schema description describing a single HTTP header
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string name, hash<auto> oh, OpenApi3Schema openapi3) : ParameterBase(oh) {
        self.name = name;
        in_loc = "header";
        if (oh.hasKey("in")) {
            throw "HEADER-ERROR", sprintf("Header %y must not specify the 'in' keyword (%y)", name, oh."in");
        }
        parseData(oh, openapi3);
    }
}

#! Allows adding metadata to a single tag that is used by the @ref OperationObject. It is not mandatory to have a TagObject per tag used there.
public class TagObject inherits ObjectBase {
    public {
        #! Required. The name of the tag.
        string name;

        #! A short description for the tag. GFM syntax can be used for rich text representation.
        *string desc;

        #! Additional external documentation for this tag.
        *ExternalDocumentationObject externalDocs;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a metadata tag associated with an operation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string obj_type = "Tag";
        required_field(obj_type, oh, "name", NT_STRING, \name);
        optional_field(obj_type, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        *hash extDocsObj;
        if (optional_field(obj_type, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);
    }
}

#! defines an object in a schema
public class SchemaObject inherits ObjectBase, SchemaBase {
    public {
        #! the name of this object for documentation and example purposes
        string name;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.2.
        /**
            MUST be either a string or an array (list). If it's an array,
            it's elements MUST be strings and MUST be unique.
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string title;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string desc;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.1.
        *SchemaObject items;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        auto defaultVal;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.1.
        *int maxProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.2.
        *int minProperties;

        #! extension that allows types to be nullable
        /** the OpenAPI specification 2.0 otherwise does not allow for nullable types
        */
        bool nullable = False;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be an object. Each value of this object MUST be an object,
            and each object MUST be a valid JSON Schema (@ref SchemaObject).
         */
        hash<string, SchemaObject> properties;

        #! extention to allow properties to be nullable
        hash<string, bool> nullable_properties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be a bool or an object. If it is an object, it MUST also be
            a valid JSON Schema (@ref SchemaObject).
         */
        auto additionalProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.3.
        /**
            Set of strings. Must have at least one element.
         */
        hash<string, bool> required;

        #! Adds support for polymorphism.
        /**
            The discriminator is the schema property name that is used to
            differentiate between other schemas that inherit this schema.
            The property name used MUST be defined at this schema and it MUST
            be in the @ref SchemaObject::required "required" property list.
            When used, the value MUST be the name of this schema or any schema
            that inherits it.

            While composition offers model extensibility, it does not imply
            a hierarchy between the models. To support polymorphism, OpenApi3
            adds the support of the \c discriminator field. When used,
            the \c discriminator will be the name of the property used to decide
            which schema definition is used to validate the structure of the model.
            As such, the \c discriminator field MUST be a required field.
            The value of the chosen property has to be the friendly name given to
            the model under the \c definitions property. As such, inline schema
            definitions, which do not have a given id, \e cannot be used in polymorphism.
         */
        *string discriminator;

        #! Relevant only for Schema \c "properties" definitions. Declares the property as "read only".
        /**
            Declares the property as "read only". This means that it MAY be sent
            as part of a response but MUST NOT be sent as part of the request.
            Properties marked as \c readOnly being \c true SHOULD NOT be in the
            @ref SchemaObject::required "required" list of the defined schema.
            Default value is \c false.
         */
        bool readOnly = False;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.3.
        /**
            List of @ref SchemaObject "SchemaObjects"; MUST have at least one element.

            %OpenApi3 allows combining and extending model definitions using the
            \c allOf property of JSON Schema, in effect offering model composition.
            \c allOf takes in an array of object definitions that are validated
            independently but together compose a single object.
         */
        list<SchemaObject> allOf();

        #! This MAY be used only on properties schemas. It has no effect on root schemas.
        /**
            Adds Additional metadata to describe the XML representation format of this property.

            The \c xml property allows extra definitions when translating the
            JSON definition to XML. The @ref XmlObject contains additional
            information about the available options.
         */
        *XmlObject xml;

        #! Additional external documentation for this schema.
        *ExternalDocumentationObject externalDocs;

        #! A free-form property to include an example of an instance for this schema.
        auto example;

        #! valid scalar types
        const ScalarTypes = (
            "string": True,
            "number": True,
            "integer": True,
            "boolean": True,
            "array": True,
        );

        #! valid reference types
        const ReferenceTypes = ScalarTypes + (
            "object": True,
        );
    }

    private {
        static hash<string, SchemaObject> cache;
    }

    #! private constructor; use newSchemaObject() instead
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param openapi3 the REST schema for resolving references
        @param hash_str the unique hash for the value being parsed
        @param require_items require items for arrays

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    private constructor(string name, hash<auto> oh, OpenApi3Schema openapi3, *string hash_str, *bool require_items)
            : ObjectBase(oh), SchemaBase("Schema", oh) {
        self.name = name;
        # add static map reference
        openapi3.cacheSchemaObject(name, hash_str ?? sprintf("%y", oh).toSHA1(), self);
        string obj_type = "Schema";

        if (optional_field(obj_type, oh, "type", NT_STRING, \type)) {
            if (!ReferenceTypes{type})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid schema type value passed: %y; "
                    "expected one of: %y", name, type, keys ReferenceTypes);
            if (type == "array" && (require_items || exists oh.items)) {
                items := newSchemaObject("items", oh.items ?? {"type": "object"}, openapi3);
            }

            if (oh.hasKey("default")) {
                defaultVal = oh."default";
                SchemaObject::checkValueType(\defaultVal, type, items);
            }
        } else if (oh.properties) {
            type = "object";
        } else {
            type = "any";
        }

        # check for x-nullable
        optional_field(obj_type, oh, "x-nullable", NT_BOOLEAN, \nullable);

        if (optional_field(obj_type, oh, "format", NT_STRING, \format)) {
            # unrecognized format values should be ignored
            if (!format.val()) {
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object: invalid %y type empty \"format\" value passed",
                    type);
            }
        }

        optional_field(obj_type, oh, "title", NT_STRING, \title);
        optional_field(obj_type, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        if (optional_field(obj_type, oh, "maxProperties", NT_INT, \maxProperties)) {
            checkObjectProperty(name, "maxProperties");
            if (maxProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'maxProperties' field less than 0", name);
        }
        if (optional_field(obj_type, oh, "minProperties", NT_INT, \minProperties)) {
            checkObjectProperty(name, "minProperties");
            if (minProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'minProperties' field less than 0", name);
        }

        {
            hash props;
            if (optional_field(obj_type, oh, "properties", NT_HASH, \props)) {
                checkObjectProperty(name, "properties");
                foreach string k in (keys props) {
                    auto val = props{k};
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'properties' field is not a hash of "
                            "Schema Objects (got type %y; expecting \"hash\": %y)", name, val.fullType(), val);
                    properties{k} := SchemaObject::newSchemaObject(k, val, openapi3);
                    if (!properties{k}.nullable && val."x-nullable") {
                        nullable_properties{k} = True;
                    }
                }
            } else {
                additionalProperties = True;
            }
        }

        if (optional_field(obj_type, oh, "additionalProperties", (NT_BOOLEAN: True, NT_HASH: True),
            \additionalProperties)) {
            checkObjectProperty(name, "additionalProperties");
            if (additionalProperties.typeCode() == NT_HASH)
                additionalProperties := SchemaObject::newSchemaObject("additionalProperties", additionalProperties,
                    openapi3);
        }

        # process "required"
        if (optional_field(obj_type, oh, "required", OpenApi3ListToStringSet, \required)) {
            if (!required)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'required' is an empty list", name);
            # make sure all required properties are defined
            if (!additionalProperties && (*list<string> missing = keys (required - keys properties))) {
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: the following required properties are not "
                    "defined: %y", name, missing);
            }
        }

        if (optional_field(obj_type, oh, "discriminator", NT_STRING, \discriminator)) {
            if (!required{discriminator})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: 'discriminator' field value not in the "
                    "'required' list", name);
        }

        optional_field(obj_type, oh, "readOnly", NT_BOOLEAN, \readOnly);

        {
            *list allOfList;
            if (optional_field(obj_type, oh, "allOf", NT_LIST, \allOfList)) {
                if (allOfList.size() < 1)
                    throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'allOf' is an empty list", name);
                foreach auto val in (allOfList) {
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-TYPE", sprintf("Schema Object %y: invalid 'allOf' list value "
                            "datatype: %y", name, val.type());
                    allOf[allOf.size()] := SchemaObject::newSchemaObject(name + "AllOf", val, openapi3);
                }
            }
        }

        *hash xmlObj;
        if (optional_field(obj_type, oh, "xml", NT_HASH, \xmlObj))
            xml = new XmlObject(xmlObj);

        *hash extDocsObj;
        if (optional_field(obj_type, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);

        if (oh.hasKey("example"))
            example = oh.example;

        addToCache(self);
    }

    copy(SchemaObject old) {
        addToCache(self);
    }

    #! returns example Qore code for the object
    string getQoreExample(reference<hash<RestQoreExampleCodeInfo>> rv, string name, bool decl) {
        string typestr = get_qore_type(self.name, type, format, items);
        if (type == "array") {
            if (decl)
                return sprintf("%s %s(%s,);\n", typestr, name, items.getQoreExample(\rv, name, False));
            else
                return sprintf("(%s,)", items.getQoreExample(\rv, self.name, False));
        }

        if (type != "object") {
            auto val = getExampleValue();
            string example;
            switch (val.typeCode()) {
                case NT_DATE:
                    example = val.format("YYYY-MM-DDTHH:mm:SS.xxZ");
                    break;
                case NT_BINARY:
                    example = sprintf("<%s>", val.toHex());
                    break;
                default:
                    example = sprintf("%y", val);
                    break;
            }
            if (decl)
                return sprintf("%s %s = %s;\n", typestr, name, example);
            return example;
        }

        if (properties) {
            string str = sprintf("hashdecl %s {\n", self.name);
            foreach hash h in (properties.pairIterator()) {
                str += sprintf("    %s %s", get_qore_type(h.value.name, h.value.type, h.value.format, h.value.items), h.key);
                if (exists h.value.defaultVal)
                    str += sprintf(" = %y", h.value.defaultVal);
                str += ";\n";
            }
            str += "}\n";
            rv.hashdecls{self.name} = str;
        }

        string str;
        if (properties) {
            if (decl)
                str = sprintf("hash<%s> %s(", self.name, name);
            else
                str = sprintf("new hash<%s>(", self.name);

            str += "{\n";
            foreach hash<auto> h in (properties.pairIterator()) {
                string pstr;
                if (h.value.type == "string" && (h.value.format =~ /date(-time)?/))
                    pstr = sprintf("%y: date(%s)", h.key, h.value.getQoreExample(\rv, h.key, False));
                else
                    pstr = sprintf("%y: %s", h.key, h.value.getQoreExample(\rv, h.key, False));
                # add 4 spaces to the beginning of each line
                str += foldl $1 + "\n" + $2, (map "    " + $1, pstr.split("\n"));
                str += ",\n";
            }
            str += "})";
        } else if (additionalProperties instanceof SchemaObject) {
            string ptype = get_qore_type(additionalProperties.name, additionalProperties.type,
                additionalProperties.format, additionalProperties.items);
            if (decl)
                str = sprintf("hash<string, %s> %s()", ptype, name);
            else
                str = sprintf("new hash<string, %s>()", ptype);
        }
        if (decl)
            str += ";\n";
        return str;
    }

    # returns an example value for a REST API call
    auto getExampleValue() {
        if (exists example)
            return example;
        if (exists defaultVal)
            return defaultVal;

        if (type == "object") {
            return map {$1.key: $1.value.getExampleValue()}, properties.pairIterator();
        }

        if (type == "array") {
            return (items.getExampleValue(),);
        }

        return SchemaBase::getExampleValue(type, format);
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference<auto> value) {
        if (request && readOnly)
            throw "SCHEMA-VALIDATION-ERROR", sprintf("%s %s: property %y is read-only and therefore cannot be "
                "included in a request", method.upr(), path, name);
        if (!exists value && nullable) {
            return;
        }

        SchemaBase::check(serialize, request, type, format, items, path, method, name, \value);
    }

    private checkObjectProperty(string name, string prop) {
        if (type != "object") {
            throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: %y cannot be given on an object of type %y",
                name, prop, type);
        }
    }

    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, nothing v, reference<nothing> value) {
        if (type != "null" && type != "any" && !nullable) {
            throw "SCHEMA-VALIDATION-ERROR", sprintf("Parameter %y for path %y and method %y is null, but the "
                "expected type is %y", name, path, method, type);
        }
    }

    #! validates a schema object against a value
    private checkIntern(bool serialize, bool request, string type, *string format, string path, string method,
            string name, hash<auto> v, reference<hash<auto>> value) {
        if (type != "object" && type != "any") {
            throwInvalidType(name, "object", type, v);
        }

        # check "allOf" schemas, if any
        map $1.checkIntern(serialize, request, type, NOTHING, path, method, name, v, \value), allOf;

        /*
            If additionalProperties is set to true, any number of additionalProperties may be present of any data
            type.
            If additionalProperties is a schema, additional properties (beyond what are defined in ‘properties’) are
            allowed and must match the schema
        */
        # check properties in this schema definition
        if (additionalProperties !== True && type != "any") {
            # issue #4825: write the hash keys to another hash in case values need to change type
            hash<auto> nv;
            foreach string key in (keys value) {
                *SchemaObject prop = properties{key};
                if (!prop) {
                    if (additionalProperties instanceof SchemaObject) {
                        prop = additionalProperties;
                    }
                    if (!prop) {
                        throw "SCHEMA-VALIDATION-ERROR", sprintf("property %y is not valid for object %y "
                            "(value: %y); valid properties: %y",  key, name, value, keys properties);
                    }
                }
                if (exists value{key} || (required{key} && !nullable_properties{key})) {
                    nv{key} += value{key};
                    prop.check(serialize, request, path, method, key, \nv{key});
                }
            }
            if (nv) {
                value = nv;
            }
        }
        # check for missing required properties
        if (*list<string> missing = keys (required - keys value)) {
            throw "SCHEMA-VALIDATION-ERROR", sprintf("object %y: missing required properties: %y (have: %y)", name,
                missing, keys (required - missing));
        }
        #printf("SchemaObject::checkIntern() %y type: %y val: %y self: %N\n", name, type, value, self);
    }

    #! validates default values
    private static checkValueType(reference<auto> value, string type, *SchemaObject items, *string loc) {
        int vt = value.typeCode();
        if (type == "array") {
            if (vt != NT_LIST)
                throw "INVALID-FIELD-TYPE", sprintf("Schema Object: 'default' value%s has invalid type %y (expecting "
                    "schema type %y)", loc, value.type(), type);
            SchemaObject::checkValueType(\value[0], items.type, items.items, loc + "[0]");
        }
        if (!SchemaBase::checkValueType(\value, type)) {
            throw "INVALID-FIELD-TYPE", sprintf("Schema Object: 'default' value%s has invalid type %y (val: %y) "
                "(expecting schema type %y)", loc, value.type(), value, type);
        }
    }

    #! returns a SchemaObject for the schema definition; resolves references
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param openapi3 the REST schema for resolving references

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    static SchemaObject newSchemaObject(string name, hash<auto> oh, OpenApi3Schema openapi3, *bool require_items) {
        string refstr;
        if (optional_field("Schema", oh, "$ref", NT_STRING, \refstr))
            return openapi3.resolveSchemaObject(name, refstr, oh);

        string hash_str;
        *SchemaObject rv = openapi3.tryGetSchemaObject(name, oh, \hash_str);
        if (rv) {
            return rv;
        }
        return new SchemaObject(name, oh, openapi3, hash_str, require_items);
    }

    #! throws an \c "INVALID-FIELD-TYPE" exception
    /** @throws INVALID-FIELD-TYPE due to a type error in the call
    */
    static SchemaObject newSchemaObject(string name, auto error, OpenApi3Schema openapi3) {
        throw "INVALID-FIELD-TYPE", sprintf("invalid field type %y for key %y; expecting \"hash\"", error.type(),
            name);
    }

    #! Adds a SchemaObject to the cache
    static private addToCache(SchemaObject obj) {
        cache{obj.uniqueHash()} = obj;
    }

    #! Removes a SchemaObject from the cache
    static private removeFromCache(SchemaObject obj) {
        remove cache{obj.uniqueHash()};
    }
}

#! A metadata object that allows for more fine-tuned XML model definitions.
/**
    When using arrays, XML element names are not inferred (for singular/plural
    forms) and the @ref XmlObject::name "name" property should be used to add that information.
    See examples for expected behavior.
 */
public class XmlObject inherits ObjectBase {
    public {
        #! Replaces the name of the element/attribute used for the described schema property.
        /**
            When defined within the \c items, it will affect
            the name of the individual XML elements within the list.
            When defined alongside \c type being \c array (outside the \c items),
            it will affect the wrapping element and only if \c wrapped is \c true.
            If \c wrapped is \c false, it will be ignored.
         */
        *string name;

        #! The URL of the namespace definition. Value SHOULD be in the form of a URL.
        *string ns;

        #! The prefix to be used for the @ref XmlObject::name "name".
        *string prefix;

        #! Declares whether the property definition translates to an attribute instead of an element. Default value is \c false.
        bool attribute = False;

        #! MAY be used only for an array definition. Signifies whether the array is wrapped (for example, \c &lt;books&gt;&lt;book/&gt;&lt;book/&gt;&lt;/books&gt;) or unwrapped (\c &lt;book/&gt;&lt;book/&gt;).
        /**
            Default value is \c false. The definition takes effect only when
            defined alongside \c type being \c array (outside the \c items).
         */
        bool wrapped = False;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing XML model definitions

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string obj_type = "XML";
        optional_field(obj_type, oh, "name", NT_STRING, \name);
        optional_field(obj_type, oh, "namespace", NT_STRING, \ns);
        optional_field(obj_type, oh, "prefix", NT_STRING, \prefix);
        optional_field(obj_type, oh, "attribute", NT_BOOLEAN, \attribute);
        optional_field(obj_type, oh, "wrapped", NT_BOOLEAN, \wrapped);
    }
}

#! Allows the definition of a security scheme that can be used by the operations.
/**
    Supported schemes are basic authentication, an API key (either as a header
    or as a query parameter) and OAuth2's common flows (implicit, password,
    application and access code).
 */
public class SecuritySchemeObject inherits ObjectBase {
    public {
        #! Required. The type of the security scheme. Valid values are \c "basic", \c "apiKey" or \c "oauth2".
        string type;

        #! A short description for security scheme.
        *string desc;

        #! The name of the header or query parameter to be used.
        /**
            Required when type is \c "apiKey".
         */
        *string name;

        #! The location of the API key. Valid values are \c "query" or \c "header".
        /**
            Required when type is \c "apiKey".
         */
        *string in_loc;

        #! The flow used by the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            Valid values are \c "implicit", \c "password", \c "application" or \c "accessCode".
         */
        *string flow;

        #! The authorization URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is \c "implicit" or \c "accessCode".
         */
        *string authorizationUrl;

        #! The token URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is one of \c "password", \c "application" or \c "accessCode".
         */
        *string tokenUrl;

        #! The available scopes for the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            A hash in the form of <tt>Scopes Object</tt> mapping scope names to short descriptions of them.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#scopesObject
            Keys are scope names. Values are short string descriptions.
         */
        *ScopesObject scopes;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a security schema that can be used by REST API operations

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FLOW invalid OAuth2 flow value
        @throws INVALID-APIKEY-LOCATION invalid 'in' (location) value
        @throws INVALID-SCHEME-TYPE invalid security scheme type; see @ref SecuritySchemeObject::type "type"
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        string obj_type = "Security Scheme";
        required_field(obj_type, oh, "type", NT_STRING, \type);
        if (type == "apiKey") {
            required_field(obj_type, oh, "name", NT_STRING, \name);
            required_field(obj_type, oh, "in", NT_STRING, \in_loc);
            if (in_loc != "query" && in_loc != "header")
                throw "INVALID-APIKEY-LOCATION", "Security Scheme Object: invalid 'in' (location) value passed: " + in_loc;
        } else if (type == "oauth2") {
            required_field(obj_type, oh, "flow", NT_STRING, \flow);
            if (flow == "accessCode") {
                required_field(obj_type, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
                required_field(obj_type, oh, "tokenUrl", NT_STRING, \tokenUrl);
            } else if (flow == "application" || flow == "password") {
                required_field(obj_type, oh, "tokenUrl", NT_STRING, \tokenUrl);
            } else if (flow == "implicit") {
                required_field(obj_type, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
            } else {
                throw "INVALID-FLOW", "Security Scheme Object: invalid OAuth2 flow value passed: " + flow;
            }

            hash scopesObj;
            required_field(obj_type, oh, "scopes", NT_HASH, \scopesObj);
            scopes = new ScopesObject(scopesObj);
        } else if (type != "basic") {
            throw "INVALID-SCHEME-TYPE", "Security Scheme Object: invalid security scheme type passed: " + type;
        }
        optional_field(obj_type, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Lists the available scopes for an OAuth2 security scheme.
public class ScopesObject inherits ObjectBase {
    public {
        #! Maps between a name of a scope to a short description of it (as the value of the property).
        /**
            Hash of string values.
         */
        hash<string, string> fields;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the available scopes for an OAuth2
        security scheme

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash<auto> oh) : ObjectBase(oh) {
        foreach hash item in (oh.pairIterator()) {
            if (item.key !~ /^x-/) { # if not vendor extension
                if (item.value.typeCode() != NT_STRING) {
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Scopes Object: %y field has invalid type %y, instead of 'string'",
                            item.key, item.value.type());
                }
                fields{item.key} = item.value;
            }
        }
    }
}
}

# private namespace for internal definitions
namespace Priv {
    # a set of string values
    const OpenApi3ListToStringSet = -1;
    # a set of any type that can be converted to a string
    const OpenApi3ListToAnySet = -2;
    const OpenApi3ListToHashOfStrings = -3;

    const TypeMap = (
        NT_INT: "int",
        NT_STRING: "string",
        NT_FLOAT: "float",
        NT_LIST: "list",
        NT_HASH: "hash",
        NT_NOTHING: "nothing",
        NT_BOOLEAN: "bool",
        OpenApi3ListToStringSet: "list<string>",
        OpenApi3ListToAnySet: "list<auto>",
    );

    #! Check and assign a required field.
    /**
        @param obj_type type of object (e.g. "External Documentation")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    sub required_field(string obj_type, hash<auto> oh, string name, int typeCode, reference<auto> target, *int opt_flags) {
        if (!oh.hasKey(name))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object%s: %y field is missing; fields present: %y", obj_type,
                oh.name ? sprintf(" %y", oh.name) : "", name, keys oh);
        auto val = oh{name};
        check_type_code(obj_type, oh, name, val, typeCode, opt_flags);
        get_value(obj_type, name, typeCode, val, \target);
    }

    #! Check and assign a required field.
    /**
        @param obj_type type of object (e.g. "External Documentation")
        @param oh Object hash
        @param name field name
        @param typeCodes possible field typeCodes
        @param target where to assign the field's value

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    sub required_field(string obj_type, hash<auto> oh, string name, hash<string, bool> typeCodes, reference<auto> target) {
        if (!oh.hasKey(name))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object%s: %y field is missing; fields present: %y", obj_type,
                oh.name ? sprintf(" %y", oh.name) : "", name, keys oh);
        auto val = oh{name};

        if (!typeCodes{val.typeCode()})
            throw "INVALID-FIELD-TYPE", sprintf("%s Object%s: %y field has invalid type %y (val: %y)", obj_type,
                oh.name ? sprintf(" %y", oh.name) : "", name, val.type(), val);
        get_value(obj_type, name, val.typeCode(), val, \target);
    }

    #! Check and assign a field.
    /**
        @param obj_type type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string obj_type, *hash<auto> oh, string name, int typeCode, reference<auto> target,
            *int opt_flags) {
        if (!oh || !oh.hasKey(name))
            return False;
        auto val = oh{name};
        if (check_type_code(obj_type, oh, name, val, typeCode, opt_flags)) {
            return False;
        }
        get_value(obj_type, name, typeCode, val, \target);
        return True;
    }

    #! Check and assign a field.
    /**
        @param obj_type type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCodes possible field typeCodes
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string obj_type, *hash<auto> oh, string name, hash<string, bool> typeCodes,
            reference<auto> target) {
        if (!oh || !oh.hasKey(name))
            return False;
        auto val = oh{name};
        if (!typeCodes{val.typeCode()})
            throw "INVALID-FIELD-TYPE", sprintf("%s Object%s: %y field has invalid type %y (val: %y)", obj_type,
                oh.name ? sprintf(" %y", oh.name) : "", name, val.type(), val);
        get_value(obj_type, name, val.typeCode(), val, \target);
        return True;
    }

    #! verifies the type of a field
    *bool sub check_type_code(string obj_type, hash<auto> oh, string name, auto val, int typeCode, *int opt_flags) {
        int vtc = val.typeCode();
        if ((typeCode == OpenApi3ListToStringSet || typeCode == OpenApi3ListToAnySet
            || typeCode == OpenApi3ListToHashOfStrings) && vtc == NT_LIST)
            return;
        if (vtc != typeCode) {
            throw "INVALID-FIELD-TYPE", sprintf("%s Object%s: %y field has invalid type %y (val: %y); expecting %y",
                obj_type, oh.name ? sprintf(" %y", oh.name) : "", name, val.type(), val, TypeMap{typeCode});
        }
    }

    #! assigns a value to a field
    sub get_value(string obj_type, string name, int typeCode, auto val, reference<auto> target) {
        if (typeCode == OpenApi3ListToStringSet) {
            foreach auto v in (val) {
                if (v.typeCode() != NT_STRING)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in list value has type %y "
                        "(val: %y); expecting \"string\"", obj_type, name, $# + 1, val.size(), v.type(), v);
                target{v} = True;
            }
        } else if (typeCode == OpenApi3ListToAnySet) {
            foreach auto v in (val) {
                if (!v.strp())
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in list value has type %y which "
                        "cannot be converted to a string; the OpenApi3 module only supports types that can be "
                        "converted to a string for this field", obj_type, name, $# + 1, val.size(), v.type());
                target{v} = True;
            }
        } else if (typeCode == OpenApi3ListToHashOfStrings) {
            foreach auto v in (val) {
                int pos = $# + 1;
                if (v.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has type %y; expecting "
                        "\"hash\"", obj_type, name, pos, val.size(), v.type());
                if (v.size() > 1)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has a hash with more than "
                        "one key: %y; expecting a hash with a single key", obj_type, name, pos, val.size(), v);
                string key = v.firstKey();
                if (target.hasKey(key))
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d has duplicate key %y", obj_type,
                        name, pos, val.size(), key);
                foreach auto fv in (v.firstValue()) {
                    if (fv.typeCode() != NT_STRING)
                        throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in %y list value has "
                            "type %y in position %d/%d; expecting \"string\"", obj_type, name, pos, val.size(), key,
                            fv.type(), $# + 1, fv.lsize());
                }
                target += v;
            }
        } else
            target = val;
    }

    #! returns the Qore type for the given schema type
    string sub get_qore_type(string name, string type, *string format, *SchemaObject items) {
        switch (type) {
            case "array": return sprintf("list<%s>", get_qore_type(items.name, items.type, items.format, items.items));
            case "integer": {
                switch (format) {
                    case "unix-time":
                        return "date";
                }
                return "int";
            }
            case "boolean": return "bool";
            case "number": return format && ValidNumberFormatsHash{format} ? "float" : "number";
            case "string": {
                switch (format) {
                    case "byte":
                    case "binary":
                        return "binary";
                    case "date":
                    case "date-time":
                        return "date";
                }
                return "string";
            }
            case "null": return "nothing";
            case "object": return sprintf("hash<%s>", name);
        }
        return sprintf("unknown<%s = %s>", name, type);
    }
}
