/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  ql_string.qpp

  Qore Programming Language

  Copyright (C) 2003 - 2015 David Nichols

  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

  Note that the Qore library is released under a choice of three open-source
  licenses: MIT (as above), LGPL 2+, or GPL 2+; see README-LICENSE for more
  information.
*/

#include <qore/Qore.h>
#include <qore/intern/ql_string.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

static int fix_num(QoreString& tmp, const QoreString& fmt, ExceptionSink* xsink) {
   qore_offset_t off = fmt.getByteOffset(1, xsink);
   //printd(5, "fix_num tmp: '%s' fmt: '%s' off: %lld\n", tmp.getBuffer(), fmt.getBuffer(), off);
   if (*xsink)
      return -1;
   if (off < 0)
      return 0;

   // replace all thousands separators with nothing
   QoreString t(fmt.getBuffer(), off, fmt.getEncoding());
   tmp.replaceAll(t.getBuffer(), "");

   if (fmt.size() <= (qore_size_t)off)
      return 0;

   t.clear();
   if (t.concat(fmt, 1, 1, xsink))
      return -1;

   if (t.size() == 1 && t[0] == '.')
      return 0;

   off = tmp.bindex(t.getBuffer(), 0);
   if (off < 0)
      return 0;

   tmp.replace(off, t.size(), ".");
   return 0;
}

// finds the last occurrence of needle in haystack at or before position pos
// pos must be a non-negative valid byte offset in haystack
/*
static int rindex_simple_intern(const char* haystack, int hlen, const char* needle, int nlen, int pos) {
   // if the offset does not allow for the needle string to be present, then adjust
   if ((pos + nlen) > hlen) {
      pos = hlen - nlen;
      if (pos < 0)
	 return -1;
   }

   while (pos != -1) {
      if (!strncmp(haystack + pos, needle, nlen))
	 return pos;
      pos--;
   }
   return -1;
}
*/

static const char* memstr(const char* str, const char* pattern, qore_size_t pl, qore_size_t len) {
   while (true) {
      const char* p = (const char* )memchr(str, pattern[0], len);
      if (!p)
	 return 0;

      //printd(5, "memstr() pattern=%s str=%p p=%p len=%d pl=%d remaining=%d (%c %c %c)\n", pattern, str, p, len, pl, len-(p-str), p[1], p[2], p[3]);

      // if there is not enough string left for the pattern, then return
      if ((len - (p - str)) < pl)
	 return 0;

      bool found = true;
      for (qore_size_t i = 1; i < pl; ++i) {
	 if (pattern[i] != p[i]) {
	    len -= (p - str + 1);
	    str = p + 1;
	    found = false;
	    break;
	 }
      }
      if (!found)
	 continue;
     
      // found
      //printd(5, "memstr() got it! p=%p\n", p);
      return p;
   }
   return 0;
}

static void split_add_element(QoreListNode* l, const char* str, unsigned len, const QoreEncoding *enc) {
   if (enc)
      l->push(new QoreStringNode(str, len, enc));
   else {
      BinaryNode* b = new BinaryNode;
      b->append(str, len);
      l->push(b);
   }
}

QoreListNode* split_intern(const char* pattern, qore_size_t pl, const char* str, qore_size_t sl, const QoreEncoding *enc, bool with_separator) {
   QoreListNode* l = new QoreListNode();
   const char* ostr = str;
   while (const char* p = memstr(str, pattern, pl, sl - (str - ostr))) {
      split_add_element(l, str, p - str + (with_separator ? pl : 0), enc);
      str = p + pl;
   }
   // add last field if there is data remaining
   if (sl - (str - ostr))
      split_add_element(l, str, sl - (str - ostr), enc);

   return l;
}

QoreListNode* split_with_quote(const QoreString* sep, const QoreString* str, const QoreString* quote, bool trim_unquoted, ExceptionSink* xsink) {
   // convert pattern encoding to string if necessary
   TempEncodingHelper pat(sep, str->getEncoding(), xsink);
   if (*xsink)
      return 0;

   // convert quote to string if necessary
   TempEncodingHelper tquote(quote, str->getEncoding(), xsink);
   if (*xsink)
      return 0;

   //printd(5, "split_with_quote() sep: %s str: %s quote: %s trim_unquoted: %d\n", pat->getBuffer(), str->getBuffer(), tquote->getBuffer(), trim_unquoted);

   if (!tquote->strlen() || tquote->strlen() > sep->strlen())
      return split_intern(pat->getBuffer(), pat->strlen(), str->getBuffer(), str->strlen(), str->getEncoding());

   ReferenceHolder<QoreListNode> l(new QoreListNode, xsink);
   const char* ostr = str->getBuffer();
   qore_size_t sl = str->strlen();
   const char* tpattern = pat->getBuffer();
   qore_size_t pl = pat->strlen();

   const char* ststr = ostr;

   // remaining byte length
   qore_size_t len = sl;

   while (len > 0) {
      // see if the field begins with the quote string
      // and if the remaining string length is at least big enough for two quote strings
      if ((tquote->strlen() * 2) <= len
          && !memcmp(tquote->getBuffer(), ststr, tquote->strlen())) {
         // advance pointer past quote
         ststr += tquote->strlen();
         // find next quote character, ignore escaped quotes
         const char* tstr = ststr;
         const char* p;
         while (true) {
            p = memstr(tstr, tquote->getBuffer(), tquote->strlen(), len);
            if (!p) {
               xsink->raiseException("SPLIT-ERROR", "cannot find closing quote '%s' in field "QSD, tquote->getBuffer(), l->size() + 1);
               return 0;
            }
            if (p == tstr)
               break;
            if (*(p - 1) != '\\')
               break;
            tstr = p + 1;
         }
         // optimistically add the field to the list
         l->push(new QoreStringNode(ststr, p - ststr, sep->getEncoding()));

         ststr = p + tquote->strlen();
         // see if we are at the end of the string
         len = sl + (ostr - ststr);

         if (!len)
            break;

         // or a separator string comes next
         if (len < pl || memcmp(tpattern, ststr, pl)) {
            xsink->raiseException("SPLIT-ERROR", "separator pattern '%s' does not follow end quote in field "QSD, tpattern, l->size());
            return 0;
         }
         ststr += pl;
         len -= pl;
         continue;
      }

      const char* p = memstr(ststr, tpattern, pl, sl - (ststr - ostr));
      if (!p) {
         QoreStringNode* se = new QoreStringNode(ststr, sl - (ststr - ostr), sep->getEncoding());
         if (trim_unquoted)
            se->trim();
         l->push(se);
         break;
      }

      QoreStringNode* se = new QoreStringNode(ststr, p - ststr, sep->getEncoding());
      if (trim_unquoted)
         se->trim();
      l->push(se);
      len -= (p - ststr);
      ststr = p + pl;
   }

   return l.release();
}

QoreStringNode* join_intern(const QoreStringNode* p0, const QoreListNode* l, int offset, ExceptionSink* xsink) {
   SimpleRefHolder<QoreStringNode> str(new QoreStringNode(p0->getEncoding()));

   for (unsigned i = offset; i < l->size(); i++) {
      const AbstractQoreNode* p = l->retrieve_entry(i);
      if (p) {
	 QoreStringValueHelper t(p, p0->getEncoding(), xsink);	 
	 if (*xsink)
	    return 0;

	 str->concat(*t);
      }
      if (i < (l->size() - 1))
	 str->concat(p0);
   }

   return str.release();
}

QoreStringNode* format_float_intern(const QoreString& fmt, double num) {
   int decimals = 0, neg = 1, len;
   int64 tr, bi, mi, th, val;
   char thousands_sep, decimal_sep = '.', chr[40], str[40], dec[20];

   len = fmt.strlen();
   if ((len != 1) && (len != 3))
      return new QoreStringNode;

   thousands_sep = fmt.getBuffer()[0];
   if (len == 3) {
      decimal_sep = fmt.getBuffer()[1];
      decimals = atoi(fmt.getBuffer() + 2);
   }

   if (num < 0) {
      neg = -1;
      num *= -1;
   }
   val = (int64)num;
   if (len == 3) {
      num -= (double)val;
      sprintf(chr, "%%.%df", decimals);
      sprintf(dec, chr, num);
   }
   tr = val / 1000000000000ll;
   val -= tr * 1000000000000ll;
   bi = val / 1000000000ll;
   val -= bi * 1000000000ll;
   mi = val / 1000000ll;
   val -= mi * 1000000ll;
   th = val / 1000ll;
   val -= th * 1000ll;
   //printd(0, "tr=%lld bi=%lld mi=%lld th=%lld val=%lld\n", tr, bi, mi, th, val);

   if (tr) {
      if (len == 3)
         //sprintf(str, "%lld%c%03lld%c%03lld%c%03lld%c%03lld%c%s",
         sprintf(str, QLLD "%c" QLLDx(03) "%c" QLLDx(03) "%c" QLLDx(03) "%c" QLLDx(03) "%c%s",
               neg * tr, thousands_sep,
               bi, thousands_sep,
               mi, thousands_sep,
               th, thousands_sep,
               val, decimal_sep,
               dec + 2);
      else
         //sprintf(str, "%lld%c%03lld%c%03lld%c%03lld%c%03lld",
         sprintf(str, QLLD "%c" QLLDx(03) "%c" QLLDx(03) "%c" QLLDx(03) "%c" QLLDx(03),
               neg * tr, thousands_sep,
               bi, thousands_sep,
               mi, thousands_sep,
               th, thousands_sep,
               val);
   }
   else if (bi)
      if (len == 3)
         //sprintf(str, "%lld%c%03lld%c%03lld%c%03lld%c%s",
         sprintf(str, QLLD "%c" QLLDx(03) "%c" QLLDx(03) "%c" QLLDx(03) "%c%s",
               neg * bi, thousands_sep,
               mi, thousands_sep,
               th, thousands_sep,
               val, decimal_sep,
               dec + 2);
      else
         //sprintf(str, "%lld%c%03lld%c%03lld%c%03lld",
         sprintf(str, QLLD "%c" QLLDx(03) "%c" QLLDx(03) "%c" QLLDx(03),
               neg * bi, thousands_sep, mi, thousands_sep,
               th, thousands_sep, val);
   else if (mi)
      if (len == 3)
         //sprintf(str, "%lld%c%03lld%c%03lld%c%s", neg * mi, thousands_sep,
         sprintf(str, QLLD "%c" QLLDx(03) "%c" QLLDx(03) "%c%s", neg * mi, thousands_sep,
               th, thousands_sep, val, decimal_sep, dec + 2);
      else
         //sprintf(str, "%lld%c%03lld%c%03lld", neg * mi, thousands_sep,
         sprintf(str, QLLD "%c" QLLDx(03) "%c" QLLDx(03), neg * mi, thousands_sep,
               th, thousands_sep, val);
   else if (th)
      if (len == 3)
         //sprintf(str, "%lld%c%03lld%c%s", neg * th, thousands_sep,
         sprintf(str, QLLD "%c" QLLDx(03) "%c%s", neg * th, thousands_sep,
               val, decimal_sep,
               dec + 2);
      else
         //sprintf(str, "%lld%c%03lld", neg * th, thousands_sep, val);
         sprintf(str, QLLD "%c" QLLDx(03), neg * th, thousands_sep, val);
   else
      if (len == 3)
         //sprintf(str, "%lld%c%s", neg * val, decimal_sep, &dec[2]);
         sprintf(str, QLLD "%c%s", neg * val, decimal_sep, &dec[2]);
      else
         //sprintf(str, "%lld", neg * val);
         sprintf(str, QLLD, neg * val);

   return new QoreStringNode(str);
}

/** @defgroup regex_constants Regular Expression Constants
    The constants in this group can be combined with @ref bitwise_or_operator "binary or" to give regular expression options
    for the regex(), regex_subst(), and regex_extract() functions.
 */
//@{
//! Ignores case when matching regular expressions, equivalent to <tt>/i</tt>
const RE_Caseless = PCRE_CASELESS;

//! makes a dot (.) match a newline character, equivalent to /s
const RE_DotAll = PCRE_DOTALL;

//! ignores whitespace characters and enables comments prefixed by #, equivalent to <tt>/x</tt>
const RE_Extended = PCRE_EXTENDED;

//! makes start-of-line (^) or end-of-line ($) match after or before any newline in the subject string, equivalent to <tt>/m</tt>
const RE_MultiLine = PCRE_MULTILINE;

//! replace all matches globally in the string or extract all occurrences of the pattern(s) in the string, equivalent to <tt>/g</tt>
const RE_Global = QRE_GLOBAL;
//@}

/** @defgroup string_functions String Functions

    @section string_formatting String Formatting
    String formatting in %Qore is based on c-style "printf" string formatting.

    There are three types of objects in the format string:
    - Plain characters, which are copied as-is to the output string
    - Escape characters, which are converted and copied to the output string
    - Format specifications for arguments to be included in the output string, which are preceded by the percent sign \c "%"

    @note The percent sign \c "%" always starts a format specification unless it is followed by another \c "%" sign, in this case only one \c "%" is output (ie \c "%%" in the format string is output as a single \c "%")

    @subsection format_specification 

    After the \c "%" sign, there can be zero or more formatting flags as in the following table:

    <b>Printf Formatting Flags</b>
    |!Flag|!Description
    |\c -|left-justify the field
    |\c +|include the sign for the number (+ or -)
    |\c 0|use zero left padding rather than space padding
    |<em>space</em>|use space padding

    Then a field width specifier can optionally be given as a string of digits specifying the length of the field. With "field" functions (function names preceded by \c "f_"), these width specifiers are hard limits; that is; arguments longer than the width specified are truncated to the specified width.

    For floating-point arguments, a precision specifier may be given by including a period "." and another digit string, which indicates the number of digits to appear after the decimal point.

    Then the format character is given as follows:

    <b>Printf Formatting Characters</b>
    |!Character|!Description
    |\c s|string
    |\c d|Integer, output in base 10 format
    |\c f|Literal floating point value
    |\c F|Literat floating point value
    |\c a|Hexadecimal floating-point output with lower-case \c "0x" and \c "abcdef"
    |\c A|Hexadecimal floating-point output with upper-case \c "0X" and \c "ABCDEF"
    |\c g|compact floating-point output using a lower-case \c "e" for exponential output when necessary
    |\c G|compact floating-point output using an upper-case \c "E" for exponential output when necessary
    |\c n|Any %Qore value, formatted as a string, without any line breaks
    |\c N|Any %Qore value, formatted as a string, with line breaks and whitespace formatting for complex objects
    |\c x|Integer, output in base 16 (hexadecimal) format with lower-case a-f
    |\c X|Integer, output in base 16 (hexadecimal) format with upper-case A-F
    |\c y|Any %Qore value, formatted as a pseudo-YAML string, without any line breaks; this format option is similar to \c "%n", but uses a YAML-like format.  Note that the output is not guaranteed to be parsed by the yaml module's parseYAML() function; it is for display purposes only; to get real YAML functionality, use the yaml module.

    @anchor string_escape_chars
    <b>String Escape Characters</b>
    |!Escape Characters|!Description
    |\c \\n|a newline character
    |\c \\r|a carriage-return character
    |\c \\t|a tab character
    |\c \\b|a backspace character
    |\c \\f|a form-feed character
    |\c \\<em>num</em>|an 8-bit character whose value is the 1, 2, or 3 digit octal number \a num
    |\c \\\"|a double-quote character (\c \")
 */
//@{

//! Returns the length in characters for the string passed
/** Note that the byte length may differ from the character length with multi-byte @ref character_encoding "character encodings". To get the byte length of a string, see strlen().

    @param str the string to return the character length of

    @return the length in characters for the string passed

    @par Example:
    @code
my int $len = length($str);
    @endcode

    @note
    - this operation has <i>O(n)</i> complexity if called on a string with a multi-byte @ref character_encoding "character encoding", otherwise it is <i>O(1)</i>
    - equivalent to <string>::length()

    @see
    - strlen()
    - <string>::strlen()
    - <string>::size()
 */
int length(softstring str) [flags=CONSTANT] {
   return str->length();
}

//! Returns the number of bytes in the binary object passed as an argument
/** This variant of the function accepting a binary object as an argument works identically to the @ref elements "elements operator"

    @param bin the binary object to return the size of

    @return the number of bytes in the binary object

    @par Example:
    @code
my int $nbytes = length($bin);
    @endcode
 */
int length(binary bin) [flags=CONSTANT] {
   return bin->size();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing length() [flags=RUNTIME_NOOP] {
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
int length(any[doc] arg) [flags=NOOP] {
   return 0;
}

//! Returns the length in bytes of the string argument
/** Note that the byte length may differ from the character length with multi-byte @ref character_encoding "character encodings". For the character length of a string, see length().

    @param str the string to return the byte length of

    @return the length in bytes for the string passed

    @par Example:
    @code
my int $size = strlen($str);
    @endcode

    @note equivalent to <string>::strlen() and <string>::size()

    @see
    - length()
    - <string>::length()
 */
int strlen(softstring str) [flags=CONSTANT] {
   return str->strlen();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing strlen() [flags=RUNTIME_NOOP] {
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
int strlen(any[doc] arg) [flags=NOOP] {
   return 0;
}

//! Returns a string in all lower-case characters based on the argument passed
/** @par Example:
    @code
my string $lwr = tolower($str);
    @endcode

    This function operates on a very wide range of non-ASCII characters using a Unicode lookup table for mapping Latin, Cyrillic, Greek, Armenian, Georgian, etc characters.

    @param str a string to process

    @return a string in all lower-case characters based on the argument passed

    @note
    - equivalent to <string>::lwr(string)

    @see
    - <string>::lwr()
    - <string>::upr()
    - toupper()

    @since %Qore 0.8.8 this function operates on a wide range of characters and is no longer limited to ASCII characters
 */
string tolower(string str) [flags=CONSTANT] {
   SimpleRefHolder<QoreStringNode> rv(new QoreStringNode(str->getEncoding()));
   if (do_tolower(*(*rv), *str, xsink))
      return 0;

   return rv.release();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing tolower() [flags=RUNTIME_NOOP] {
}

//! Returns a string in all upper-case characters based on the argument passed
/** @par Example:
    @code
my string $upr = toupper($str);
    @endcode

    This function operates on a very wide range of non-ASCII characters using a Unicode lookup table for mapping Latin, Cyrillic, Greek, Armenian, Georgian, etc characters.

    @param str a string to process

    @return a string in all upper-case characters based on the argument passed

    @note
    - equivalent to <string>::upr(string)

    @see
    - <string>::lwr()
    - <string>::upr()
    - tolower()

    @since %Qore 0.8.8 this function operates on a wide range of characters and is no longer limited to ASCII characters
 */
string toupper(string str) [flags=CONSTANT] {
   SimpleRefHolder<QoreStringNode> rv(new QoreStringNode(str->getEncoding()));
   if (do_toupper(*(*rv), *str, xsink))
      return 0;

   return rv.release();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing toupper() [flags=RUNTIME_NOOP] {
}

//! Returns a portion of a string starting from an integer offset
/** Arguments can be negative, giving offsets from the end of the string. All offsets are character positions, not byte positions.

    @param str The string to process
    @param start The starting character for the substring where the first character is at offset 0; if the offset is negative, it designates the number of characters from the end of the string.  If the offset is 0, then the entire string is returned.

    @return the substring of the string starting from an integer character offset; the rest of the string is returned after this offset; an empty string is returned if the argument cannot be satisfied

    @par Example:
    @code
# get the last 10 characters of a string
my string $substr = substr($str, -10);
    @endcode

    @throw INVALID-ENCODING this exception could be thrown if a character offset calculation fails due to invalid encoding of multi-byte character data

    @note equivalent to <string>::substr(softint)
 */
string substr(softstring str, softint start) [flags=RET_VALUE_ONLY] {
   QoreStringNode* rv = str->substr(start, xsink);
   if (!rv)
      rv = new QoreStringNode(str->getEncoding());
   return rv;
}

//! Returns a portion of a string starting from an integer offset, with a length parameter
/** Arguments can be negative, giving offsets from the end of the string. All offsets are character positions, not byte positions.

    @param str The string to process
    @param start The starting character for the substring where the first character is at offset 0; if the offset is negative, it designates the number of characters from the end of the string
    @param len The maximum number of characters to copy; if this value is negative, the rest of the string from \a start will be copied to the substring, except without - \a len characters from the end of the string

    @return the substring of the string according to the arguments passed; an empty string is returned if the argument cannot be satisfied

    @par Example:
    @code
# get a substring 10 characters into the string except omitting the last 2 characters of the string
my string $substr = substr($str, 10, -2);
    @endcode

    @throw INVALID-ENCODING this exception could be thrown if a character offset calculation fails due to invalid encoding of multi-byte character data

    @note equivalent to <string>::substr(softint, softint)
 */
string substr(softstring str, softint start, softint len) [flags=RET_VALUE_ONLY] {
   QoreStringNode* rv = str->substr(start, len, xsink);
   if (!rv)
      rv = new QoreStringNode(str->getEncoding());
   return rv;
}

//! Returns a portion of a binary object starting from an integer offset
/** Arguments can be negative, giving offsets from the end of the data.

    @param b The binary object to process
    @param start The starting byte for the portion of the binary object where the first byte is at offset 0; if the offset is negative, it designates the number of bytes from the end of the data

    @return the portion of the binary data argument starting from an integer byte offset; the rest of the data is returned after this offset

    @par Example:
    @code
# get the last 10 bytes
my binary $b1 = substr($b, -10);
    @endcode

    @note equivalent to <binary>::substr(softint)

    @since %Qore 0.8.8
 */
binary substr(binary b, softint start) [flags=CONSTANT] {
   BinaryNode* b1 = new BinaryNode;
   b->substr(*b1, start);
   return b1;
}

//! Returns a portion of a binary object starting from an integer offset, with a length parameter
/** Arguments can be negative, giving offsets from the end of the data.

    @param b The binary object to process
    @param start The starting byte for the portion of the binary object where the first byte is at offset 0; if the offset is negative, it designates the number of bytes from the end of the data
    @param len The maximum number of bytes to copy; if this value is negative, the rest of the data from \a start will be copied to the return value, except without - \a len bytes from the end of the data

    @return the portion of the binary data argument according to the arguments passed

    @par Example:
    @code
# get a binary object 10 characters into the data except omitting the last 2 bytes
my binary $b1 = substr($b, 10, -2);
    @endcode

    @note equivalent to <binary>::substr(softint, softint)

    @since %Qore 0.8.8
 */
binary substr(binary b, softint start, softint len) [flags=CONSTANT] {
   BinaryNode* b1 = new BinaryNode;
   b->substr(*b1, start, len);
   return b1;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing substr() [flags=NOOP] {
}

//! Retrieves the character position of a substring within a string
/** The \a pos argument and the return value are in character positions; byte offsets may differ from the character offsets with multi-byte @ref character_encoding "character encodings".

    @param str the string to search in
    @param substr the substring to find in \a str; if the @ref character_encoding "character encoding" of this string does not match \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding" before processing
    @param pos the starting character position for the search

    @return the character position of a substring within a string, -1 is returned if the substring is not found

    @par Example:
    @code
my int $i = index($str, $substr);
if ($i == -1)
    printf("could not find %y in %y\n", $substr, $str);
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion
    @throw INVALID-ENCODING this exception could be thrown if a character offset calculation fails due to invalid encoding of multi-byte character data

    @note equivalent to <string>::find(softstring, softint)

    @see 
    - <string>::rfind(softstring, softint)
    - rindex(softstring, softstring, softint)
    - bindex(softstring, softstring, softint)
    - brindex(softstring, softstring, softint)
 */
int index(softstring str, softstring substr, softint pos = 0) [flags=RET_VALUE_ONLY] {
   return str->index(*substr, pos, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
int index() [flags=RUNTIME_NOOP] {
   return -1;
}

//! Retrieves the byte position of a substring within a string
/** The \a pos argument and the return value are in byte positions; byte offsets may differ from the character offsets with multi-byte @ref character_encoding "character encodings".

    @param str the string to search in
    @param substr the substring to find in \a str
    @param pos the starting character position for the search

    @return the byte position of a substring within a string, -1 is returned if the substring is not found

    @par Example:
    @code
my int $i = bindex($str, $substr);
if ($i == -1)
    printf("could not find %y in %y\n", $substr, $str);
    @endcode

    @note no character encoding conversions are made by this function even if the string arguments have different @ref character_encoding "character encodings"

    @see 
    - <string>::find(softstring, softint)
    - <string>::rfind(softstring, softint)
    - index(softstring, softstring, softint)
    - rindex(softstring, softstring, softint)
    - brindex(softstring, softstring, softint)
 */
int bindex(softstring str, softstring substr, softint pos = 0) [flags=CONSTANT] {
   return str->bindex(*substr, (qore_offset_t)pos);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
int bindex() [flags=RUNTIME_NOOP] {
   return -1;
}

//! Retrieves the character position of a substring within a string, starting the search from the end of the string
/** The \a pos argument and the return value are in character positions; byte offsets may differ from the character offsets with multi-byte @ref character_encoding "character encodings".

    @param str the string to search in
    @param substr the substring to find in \a str; if the @ref character_encoding "character encoding" of this string does not match \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding" before processing
    @param pos the starting character position for the search, -1 means start from the end of the string

    @return the character position of a substring within a string, -1 is returned if the substring is not found

    @par Example:
    @code
my int $i = rindex($str, $substr);
if ($i == -1)
    printf("could not find %y in %y\n", $substr, $str);
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion
    @throw INVALID-ENCODING this exception could be thrown if a character offset calculation fails due to invalid encoding of multi-byte character data

    @note equivalent to <string>::rfind(softstring, softint)

    @see
    - <string>::find(softstring, softint)
    - index(softstring, softstring, softint)
    - bindex(softstring, softstring, softint)
    - brindex(softstring, softstring, softint)
 */
int rindex(softstring str, softstring substr, softint pos = -1) [flags=RET_VALUE_ONLY] {
   return str->rindex(*substr, (qore_offset_t)pos, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
int rindex() [flags=RUNTIME_NOOP] {
   return -1;
}

//! Retrieves the byte position of a substring within a string, starting the search from the end of the string
/** The \a pos argument and the return value are in byte positions; byte offsets may differ from the character offsets with multi-byte @ref character_encoding "character encodings".

    @param str the string to search in
    @param substr the substring to find in \a str
    @param pos the starting character position for the search, -1 means start from the end of the string

    @return the byte position of a substring within a string, -1 is returned if the substring is not found

    @par Example:
    @code
my int $i = brindex($str, $substr);
if ($i == -1)
    printf("could not find %y in %y\n", $substr, $str);
    @endcode

    @note no character encoding conversions are made by this function even if the string arguments have different @ref character_encoding "character encodings"

    @see
    - <string>::find(softstring, softint)
    - <string>::rfind(softstring, softint)
    - index(softstring, softstring, softint)
    - bindex(softstring, softstring, softint)
    - rindex(softstring, softstring, softint)
 */
int brindex(softstring str, softstring substr, softint pos = -1) [flags=CONSTANT] {
   return str->brindex(*substr, (qore_offset_t)pos);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
int brindex() [flags=RUNTIME_NOOP] {
   return -1;
}

//! Gives the numeric value of the given byte in the string passed; if no string is passed or the offset is after the end of the string, -1 is returned
/** 
    @param str the string containing the byte to be retrieved
    @param offset the byte offset of the byte to be retrieved

    @return the numeric value of the given byte in the string passed; if the offset is after the end of the string or negative, -1 is returned

    @par Example:
    @code
my int $i = ord($str);
    @endcode

    @note ord() only works on byte offsets and returns byte values
 */
int ord(softstring str, softint offset = 0) [flags=CONSTANT] {
   if (offset < 0 || (qore_size_t)offset >= str->strlen())
      return -1;

   return str->getBuffer()[offset];
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
int ord() [flags=RUNTIME_NOOP] {
   return 0;
}

//! Returns a string containing a single ASCII character represented by the numeric value passed
/** @param val the byte value of the character; only the least-significant byte is used
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string containing a single ASCII character represented by the numeric value passed

    @par Example:
    @code
my string $char = chr(13);
    @endcode

    @since %Qore 0.8.5 the encoding argument is supported
 */
string chr(softint val, *string encoding) [flags=CONSTANT] {
   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   QoreStringNode* rv = new QoreStringNode(qe);
   rv->concat((char)val);
   return rv;
}

//! This function variant returns a string with a single ASCII NULL ('\\0'); it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** @return a string with a single ASCII NULL ('\\0')
 */
string chr(any[doc] arg) [flags=NOOP] {
   return new QoreStringNode('\0');
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing chr() [flags=RUNTIME_NOOP] {
}

//! Splits a string into a list of components based on a separator string
/** 
    @param sep the separator string; if the separator string is not found in the string to split, then a list with only one element containing the entire string argument is returned'; if this string has a different @ref character_encoding "character encoding" than \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding"
    @param str the string to split
    @param with_separator include the separator string in every element

    @return a list of each component of a string separated by a separator string, with the separator removed; the separator pattern will not be included in the elements of the list returned unless the \a with_separator argument is @ref True
    
    @par Example:
    @code
my list $list = split(":", "some:text:here"); # returns ("some", "text", "here")
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion

    @note equivalent to <string>::split(string, bool)
 */
list split(string sep, string str, bool with_separator = False) [flags=RET_VALUE_ONLY] {
   // convert pattern encoding to string if necessary
   TempEncodingHelper temp(sep, str->getEncoding(), xsink);
   if (*xsink)
      return 0;
   
   return split_intern(temp->getBuffer(), temp->strlen(), str->getBuffer(), str->strlen(), str->getEncoding(), with_separator);
}

//! Splits a string into a list of components based on a separator string and a quote character
/** The quote character can appear as the first part of a field, in which case it is assumed to designate the entire field. If instances of the quote character are found in the field preceded by a backquote character (\c "\"), then these quote characters are included as part of the field's text and not treated as quote characters

    @param sep the separator string; if the separator string is not found in the string to split, then a list with only one element containing the entire string argument is returned'; if this string has a different @ref character_encoding "character encoding" than \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding"
    @param str the string to split
    @param quote the quote character
    @param trim_unquoted remove leading and trailing whitespace from unquoted fields

    @return a list of each component of a string separated by a separator string, with the separator and any enclosing quote characters removed

    @par Example:
    @code
my list $list = split(",", "some,'text with spaces',here", "'"); # returns ("some", "text with spaces", "here")
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion
    @throw SPLIT-ERROR field missing closing quote character; extra text following quoted field

    @note equivalent to <string>::split(string, string)

    @since %Qore 0.8.6 the \c trim_unquoted parameter was added
 */
list split(string sep, string str, string quote, bool trim_unquoted = False) [flags=RET_VALUE_ONLY] {
   return split_with_quote(sep, str, quote, trim_unquoted, xsink);
}

//! Returns a list of binary objects representing each component of the binary object separated by the bytes identified by the separator argument, with the separator removed
/** 
    @param data the binary object to separate
    @param sep the bytes that separate the fields

    @return a list of binary objects representing each component of the binary object separated by the bytes identified by the separator argument, with the separator removed
    
    @par Example:
    @code
my list $l = split($sep, $bin);
    @endcode

    @note equivalent to <binary>::split(binary)
 */
list split(binary sep, binary data) [flags=CONSTANT] {
   return split_intern((const char*)sep->getPtr(), sep->size(), (const char*)data->getPtr(), data->size(), 0);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
list split() [flags=RUNTIME_NOOP] {
   return new QoreListNode;
}

//! Returns a string describing the character encoding of the string argument passed
/** 
    @param str the string to get the encoding for

    @return a string describing the character encoding of the string argument passed

    @par Example:
    @code
my string $enc = get_encoding($str);
    @endcode

    @note equivalent to <string>::encoding()
 */
string get_encoding(string str) [flags=CONSTANT] {
   return new QoreStringNode(str->getEncoding()->getCode());
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing get_encoding() [flags=RUNTIME_NOOP] {
}

//! Performs explicit string character encoding conversions
/** 
    @param str the string to convert
    @param encoding the encoding for the return value

    @return a string corresponding to the string argument converted to the encoding given

    @par Example:
    @code
my string $enc = convert_encoding($str, "iso-8859-1");
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion
 */
string convert_encoding(string str, string encoding) [flags=RET_VALUE_ONLY] {
   return str->convertEncoding(QEM.findCreate(encoding), xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing convert_encoding() [flags=RUNTIME_NOOP] {
}

//! Returns the first string argument tagged with the character encoding given as the second argument; does not actually change the string data
/** Use only in the case that a string is tagged with the wrong encoding, for example, if a string from a @ref Qore::File "File" object has a different encoding than the @ref Qore::File "File" object.

    @param str the string to be returned
    @param encoding the encoding to tag the return value with

    @return the first string argument tagged with the character encoding given as the second argument; does not actually change the string data

    @par Example:
    @code
my string $nstr = force_encoding($str, "iso-8859-1");
    @endcode
 */
string force_encoding(string str, string encoding) [flags=CONSTANT] {
   return new QoreStringNode(str->getBuffer(), str->strlen(), QEM.findCreate(encoding));
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing force_encoding() [flags=RUNTIME_NOOP] {
}

//! Returns @ref True if the regular expression matches the string passed, otherwise returns @ref False
/** Strings are converted to UTF-8 for pattern-matching; if any invalid encodings are encountered, an ENCODING-CONVERSION-ERROR is raised

    @param str the string to test
    @param regex the regular expression pattern
    @param options regular expression options; see @ref regex_constants for possible values

    @return @ref True if the regular expression matches the string passed, otherwise returns @ref False

    @par Example:
    @code
my bool $b = regex("hello", "^hel"); # returns True
    @endcode

    @throw REGEX-COMPILATION-ERROR There was an error compiling the regular expression
    @throw REGEX-OPTION-ERROR the option argument contains invalid option bits
    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if an encoding error is encountered when converting the given strings to UTF-8

    @note equivalent to <string>::regex(string, int)

    @see @ref qore_regex for more information about regular expression support in Qore
 */
bool regex(string str, string regex, int options = 0) [flags=RET_VALUE_ONLY] {
   QoreRegexNode qr(*regex, options, xsink);
   if (*xsink)
      return 0;

   return qr.exec(str, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing regex() [flags=RUNTIME_NOOP] {
}

//! Returns a string with patterns substituted according to the arguments passed
/** Strings are converted to UTF-8 for pattern-matching; if any invalid encodings are encountered, an ENCODING-CONVERSION-ERROR is raised

    @param str the source string for substitution
    @param regex the regular expression pattern string
    @param subst the pattern for substitution; use \c $1, \c $2, etc for patterns in parentheses in the \a regex argument
    @param options regular expression options; see @ref regex_constants for possible values

    @return a string with patterns substituted according to the arguments passed

    @par Example:
    @code
regex_subst("hello there", "^(.*) there$", "you $1"); #returns "you hello"
    @endcode

    @par Example of global replacement:
    @code
my $content = "123
123
123";

printf("%s\n", regex_subst($content, "123", "456", Qore::RE_Global));

resulting in:
456
456
456
    @endcode

    @throw REGEX-COMPILATION-ERROR There was an error compiling the regular expression
    @throw REGEX-OPTION-ERROR the option argument contains invalid option bits
    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if an encoding error is encountered when converting the given strings to UTF-8

    @see 
    - replace()
    - @ref qore_regex for more information about regular expression support in Qore
 */
string regex_subst(string str, string regex, string subst, int options = 0) [flags=RET_VALUE_ONLY] {
   bool global;
   if (options & QRE_GLOBAL) {
      global = true;
      options &= 0xffffffff;
   }
   else
      global = false;

   RegexSubstNode qrs(regex, (int)options, xsink);
   if (*xsink)
      return 0;

   if (global)
      qrs.setGlobal();
   return qrs.exec(str, subst, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing regex_subst() [flags=RUNTIME_NOOP] {
}

//! Returns a list of substrings in a string based on matching patterns defined by a regular expression
/** Strings are converted to UTF-8 for pattern-matching; if any invalid encodings are encountered, an ENCODING-CONVERSION-ERROR is raised

    @param str the string to process
    @param regex the regular expression to use for matching, elements should be given in parentheses
    @param options regular expression options; see @ref regex_constants for possible values

    @return a list of substrings in a string based on matching patterns defined by a regular expression or @ref nothing if no match was made

    @par Example:
    @code
my *list $rv = regex_extract("ns:element", "(\\w+):(\\w+)");
    @endcode

    @throw REGEX-COMPILATION-ERROR There was an error compiling the regular expression
    @throw REGEX-OPTION-ERROR the option argument contains invalid option bits
    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if an encoding error is encountered when converting the given strings to UTF-8

    @note equivalent <string>::regexExtract(string, int)

    @see @ref qore_regex for more information about regular expression support in Qore

    @since %Qore 0.8.8 this function accepts the @ref Qore::RE_Global option to extract all occurrences of the pattern(s) in a string
 */
*list regex_extract(string str, string regex, int options = 0) [flags=RET_VALUE_ONLY] {
   QoreRegexNode qr(*regex, options, xsink);
   if (*xsink)
      return 0;

   return qr.extractSubstrings(str, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing regex_extract() [flags=RUNTIME_NOOP] {
}

//! Replaces all occurrences of a substring in a string with another string
/** 
    @param str the string to process
    @param source the substring to replace; if this string has a different @ref character_encoding "character encoding" than \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding"
    @param target the replacement value for \a source; if this string has a different @ref character_encoding "character encoding" than \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding"
    @param start the starting character position in the source for the replacement where the first character is at position 0 (may not be the same as the byte position for multibyte @ref character_encoding "character encodings")
    @param end the ending character position in the source for the replacement where the first character is at position 0 (may not be the same as the byte position for multibyte @ref character_encoding "character encodings"; that negative numbers mean to use the entire string)

    @return a string with all occurrences of \a source replaced with \a target

    @par Example:
    @code
my string $str = replace("hello there", "there", "you"); # returns "hello you"
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion

    @note no regular expressions are used in this function, only direct replacements

    @see regex_subst()
 */
string replace(string str, string source, string target, int start = 0, int end = -1) [flags=RET_VALUE_ONLY] {
   const QoreEncoding *ccs = str->getEncoding();

   TempEncodingHelper t1(source, ccs, xsink);
   if (*xsink)
      return 0;

   if (t1->empty() || !end || (end > 0 && end < start))
      return str->refSelf();

   TempEncodingHelper t2(target, ccs, xsink);
   if (*xsink)
      return 0;

   QoreStringNode* nstr = new QoreStringNode(ccs);   

   const char* cstr, *pattern;
   cstr = str->getBuffer();
   pattern = t1->getBuffer();
   int plen = strlen(pattern);

   if (start) {
      const char* cn = cstr + str->size();
      qore_size_t i = ccs->getByteLen(cstr, cn, start, xsink);
      cstr = cn;
      if (*xsink || (i == str->size()))
         return 0;

      cstr += i;
   }

   if (end > 0) {
      const char* cn = cstr + str->size();
      qore_size_t i = ccs->getByteLen(cstr, cn, end, xsink);
      cstr = cn;
      if (*xsink || i == str->size())
         return 0;

      cstr += i;
   }

   while (const char* p = strstr(cstr, pattern)) {
      //printd(5, "str=%p p=%p '%s' '%s'->'%s'\n", cstr, p, cstr, pattern, t1->getBuffer());
      if ((end > 0) && (p - str->getBuffer() + plen) > end)
         break;

      if (p != cstr)
	 nstr->concat(cstr, p - cstr);
      nstr->concat(*t2);

      cstr = p + plen;
   }
   // add last field
   if (*cstr)
      nstr->concat(cstr);
   
   return nstr;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing replace() [flags=RUNTIME_NOOP] {
}

//! Creates a string from separator string and a list of arguments
/** 
    @param str the separator string
    @param ... the list of arguments to join; each argument will be converted to a string if necessary to be concatenated to the return value string; additionally if any string argument has a different @ref character_encoding "character encoding" than \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding" before concatentation to the return value string

    @return a string created from a list and a seperator string, each element in the list will be present in the return value separated by the separator string

    @par Example:
    @code
my string $str = join(":", "a", "b", "c"); # returns "a:b:c"
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion
 */
string join(string str, ...) [flags=RET_VALUE_ONLY] {
   return join_intern(str, args, 1, xsink);
}

//! Creates a string from separator string and a list of arguments
/** 
    @param str the separator string
    @param l the list of arguments to join; each argument will be converted to a string if necessary to be concatenated to the return value string; additionally if any string argument has a different @ref character_encoding "character encoding" than \a str, then it will be converted to <em>str</em>'s @ref character_encoding "character encoding" before concatentation to the return value string

    @return a string created from a list and a separator string, each element in the list will be present in the return value separated by the separator string; the string returned with have the same @ref character_encoding "character encoding" as \a str

    @par Example:
    @code
my string $str = join(":", ("a", "b", "c")); # returns "a:b:c"
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if the string arguments have different @ref character_encoding "character encodings" and an error occurs during encoding conversion

    @note equivalent to <list>::join(string)
 */
string join(string str, list l) [flags=RET_VALUE_ONLY] {
   return join_intern(str, l, 0, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing join() [flags=RUNTIME_NOOP] {
}

//! Removes the trailing end-of-line indicator (\c "\n" or \c "\r\n") from a string and returns the new string (also see the @ref chomp "chomp operator")
/** If no EOL indicator is present in the string, this function simply returns the original string unmodified.

    @param str the string to process

    @return the new string with any end-of-line character(s) removed

    @par Example:
    @code
my string $line = chomp("hello\n"); # returns "hello"
    @endcode

    @see the @ref chomp "chomp operator"
 */
string chomp(string str) [flags=CONSTANT] {
   QoreStringNode* rv = str->copy();
   rv->chomp();
   return rv;
}

//! Removes the trailing end-of-line indicator (\c "\n" or \c "\r\n") from a reference to a string and returns the new string (also see the @ref chomp "chomp operator")
/** This variant accepts variable references, in which case it will modify the string in place and also return the modified string

    @param str a reference to an lvalue continaing the string value to process; if the lvalue does not have a string value @ref nothing is returned

    @return the string as modified

    @par Example:
    @code
chomp(\$str);
    @endcode
 */
*string chomp(reference str) {
   QoreTypeSafeReferenceHelper ref(str, xsink);
   if (!ref || ref.getType() != NT_STRING)
      return 0;

   QoreStringNode* rv = reinterpret_cast<QoreStringNode* >(ref.getUnique(xsink));
   if (*xsink)
      return 0;

   rv->chomp();
   return rv->refSelf();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing chomp() [flags=RUNTIME_NOOP] {
}

//! Removes byte characters from the start and end of a string and returns the new string (also see the @ref trim "trim operator")
/** By default (if the second argument is omitted or passed as an empty string) the following whitespace byte characters are removed: \c " ", \c "\n", \c "\r", \c "\t", \c "\v" (vertical tab, ASCII 11), and \c "\0" (null character). To trim other characters, pass a string as the second argument specifying the byte characters to be removed.

    @param str the string to trim
    @param chars the characters to trim from the start and end of the string (default:  \c " ", \c "\n", \c "\r", \c "\t", \c "\v" (vertical tab, ASCII 11), and \c "\0" (null character))

    @return the trimmed string

    @par Example:
    @code
my string $tstr = trim($str);
    @endcode

    @bug it is not possible to trim multi-byte characters from strings using this function; each byte is treated as a character.  No encoding conversions are done even if the \a chars argument has a different @ref character_encoding "character encoding" than the \a str argument.
 */
string trim(string str, *string chars) [flags=CONSTANT] {
   const char* tchars = chars && chars->strlen() ? chars->getBuffer() : 0;
   QoreStringNode* rv = str->copy();
   rv->trim(tchars);
   return rv;
}

//! Removes byte characters from the start and end of a reference to an lvalue containing a string and returns string after processing (also see the @ref trim "trim operator")
/** By default (if the second argument is omitted or passed as an empty string) the following whitespace byte characters are removed: \c " ", \c "\n", \c "\r", \c "\t", \c "\v" (vertical tab, ASCII 11), and \c "\0" (null character). To trim other characters, pass a string as the second argument specifying the byte characters to be removed.

    This variant accepts variable references, in which case it will modify the string in place and also return the modified string.

    @param str a reference to an lvalue continaing the string value to process; if the lvalue does not have a string value @ref nothing is returned
    @param chars the characters to trim from the start and end of the string (default:  \c " ", \c "\n", \c "\r", \c "\t", \c "\v" (vertical tab, ASCII 11), and \c "\0" (null character))

    @return the trimmed string

    @par Example:
    @code
trim(\$str);
    @endcode

    @bug it is not possible to trim multi-byte characters from strings using this function; each byte is treated as a character.  No encoding conversions are done even if the \a chars argument has a different @ref character_encoding "character encoding" than the \a str argument.
 */
*string trim(reference str, *string chars) {
   QoreTypeSafeReferenceHelper ref(str, xsink);
   if (!ref || ref.getType() != NT_STRING)
      return 0;

   QoreStringNode* rv = reinterpret_cast<QoreStringNode* >(ref.getUnique(xsink));
   if (*xsink)
      return 0;

   const char* tchars = chars && chars->strlen() ? chars->getBuffer() : 0;
   rv->trim(tchars);
   return rv->refSelf();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing trim() [flags=RUNTIME_NOOP] {
}

//! Returns a truncated string with no more than the given number of bytes and optionally converted to a specific @ref character_encoding "character encoding"
/** 
    @param str the string to truncate
    @param len the maximum byte length of the string
    @param encoding if given, the string returned will be returned in the given encoding, otherwise the encoding of \ str is used for the return value

    @return the string truncated to be no longer than the given byte length in the @ref character_encoding "character encoding" given (or in the original string's @ref character_encoding "character encoding" if no \a encoding argument was passed to the function); if the string has a multi-byte @ref character_encoding "character encoding", this function will guarantee that the returned string ends on a valid character (in this case the byte length of the string could be less than the limit given)

    @par Example:
    @code
my string $column = trunc_str($str, 80, $dsp.getOSEncoding());
    @endcode

    @throw ENCODING-CONVERSION-ERROR this exception could be thrown if an explicit @ref character_encoding "character encoding" was given and an error occurs during encoding conversion
 */
string trunc_str(softstring str, softint len, *string encoding) [flags=RET_VALUE_ONLY] {
   const QoreEncoding *enc = encoding ? QEM.findCreate(encoding) : str->getEncoding();
   if (len <= 0)
      return new QoreStringNode(enc);

   TempEncodingHelper tmp(str, enc, xsink);
   if (!tmp)
      return 0;

   if (tmp->strlen() <= (qore_size_t)len) {
      len = tmp->strlen();
      return new QoreStringNode(tmp.giveBuffer(), len, len + 1, enc);
   }

   if (!enc->isMultiByte())
      return new QoreStringNode(tmp->getBuffer(), len, enc);

   // find position of last character fitting in len bytes
   const char* p = tmp->getBuffer();
   int64 sl = 0;
   while (true) {
      qore_size_t size = enc->getCharLen(p, len - sl);
      if ((sl + size) > (qore_size_t)len)
	 break;
      sl += size;
      p += size;
   }

   return new QoreStringNode(tmp->getBuffer(), sl, enc);
}

//! Returns a new string with a repeated string element and optionally removing trailing characters
/** 
    @param str the string element to repeat in the return value string
    @param smul the number of times the element should repeat
    @param offset the number of characters that should be removed from the end of the string after processing

    @par Example:
    @code
my string $ret = strmul("%s,", 3, 1); # returns "%s,%s,%s"
    @endcode

    @throw STRMUL-ERROR \a offset is < 0 or \a smul < 1
 */
string strmul(softstring str, softint smul, *softint offset) [flags=RET_VALUE_ONLY] {
   if (offset < 0) {
      xsink->raiseException("STRMUL-ERROR", "Offset argument has to be >= 0; value: "QSD, offset);
      return 0;
   }
   
   if (smul < 1) {
      xsink->raiseException("STRMUL-ERROR", "Multiple argument has to be > 0; value: "QSD, smul);
      return 0;
   }

   QoreStringNodeHolder ret(new QoreStringNode(str));
   while (smul != 1) {
      ret->concat(str);
      --smul;
   }
   
   if (offset) {
      if (offset > (int64)ret->length()) {
         xsink->raiseException("STRMUL-ERROR", "Offset ("QLLD") is greater than string length (%d)", offset, ret->length());
         return 0;
      }
      ret->splice(ret->length() - offset, xsink);
      if (*xsink)
         return 0;
   }
       
   return ret.release();
}

//! Returns a string of a formatted number according to a number argument and a format string
/** @param fmt the format string has the following format:\n
    <em>\<thousands_separator\></em><tt>[</tt><em>\<decimal_separator\>\<decimals\></em><tt>]</tt>\n
    where:\n
    - \a thousands_separator and \a decimal_separator are single ASCII characters defining the thousands and decimal separator characters respectively, and
    - \a decimals is a single digit defining how may decimals should appear after the decimal point
    @param num the number to format

    @return a string of a formatted number according to a number argument and a format string; if the format string does not follow the given format, then an empty string is returned

    @par Example:
    @code
my string $nstr = format_number(".,3", -48392093894.2349); # returns "-48.392.093.894,235"
    @endcode

    @see <float>::format()
 */
string format_number(string fmt, softfloat num) [flags=CONSTANT] {
   return format_float_intern(*fmt, num);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing format_number() [flags=RUNTIME_NOOP] {
}

//! Reverses a string and returns the new string
/** Works properly on strings with multi-byte @ref character_encoding "character encodings" as well (such as UTF-8)

    @param str the string to reverse

    @return a string with all characters in reverse order

    @par Example:
    @code
my string $ns = reverse($str);
    @endcode

    @see reverse(list)
*/
string reverse(softstring str) [flags=CONSTANT] {
   return str->reverse();
}

//! Outputs a string to standard output with no formatting
/** 
    @param ... each of the arguments passed to this function will be output literally with no output formatting

    @par Example:
    @code
print("hello\n");
    @endcode

    @see printf() for a function that allows for formatted output
 */
nothing print(...) [dom=TERMINAL_IO] {
   if (!args)
      return 0;

   for (unsigned i = 0; i < args->size(); i++)
      print_node(stdout, get_param(args, i));
   return 0;
}

//! Returns a formatted string based on a @ref string_formatting "format string" and other arguments; enforces field widths on arguments larger than the given field width
/** 
    This function will truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param ... the argument(s) corresponding to format specifiers in the format string

    @return a formatted string corresponding to the arguments given

    @par Example:
    @code
my string $str = f_sprintf("%5s", "a long string"); # will return "a lon"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - sprintf() for a similar function that does not enforce field widths
 */
string f_sprintf(string[doc] fmt, ...) [flags=CONSTANT] {
   return q_sprintf(args, 1, 0, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
string f_sprintf() [flags=NOOP] {
   return null_string();
}

//! Returns a formatted string based on a @ref string_formatting "format string" and other arguments; does not enforce field widths on arguments larger than the given field width
/** 
    This function will not truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param ... the argument(s) corresponding to format specifiers in the format string

    @return a formatted string corresponding to the arguments given

    @par Example:
    @code
my string $str = sprintf("%5s", "a long string"); # will return "a long string"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - f_sprintf() for a similar function that enforces field widths
 */
string sprintf(string[doc] fmt, ...) [flags=CONSTANT] {
   return q_sprintf(args, 0, 0, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
string sprintf() [flags=NOOP] {
   return null_string();
}

//! Returns a formatted string based on a @ref string_formatting "format string" and other arguments given as a list after the format string; enforces field widths on arguments larger than the given field width
/** 
    This function will truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param varg the argument(s) corresponding to format specifiers in the format string

    @return a formatted string corresponding to the arguments given

    @par Example:
    @code
my string $str = f_vsprintf("%5s %3d\n", ("a lon", 500)); # will return "a lon 500"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - vsprintf() for a similar function that does not enforce field widths

    @since %Qore 0.8.4
 */
string f_vsprintf(string[doc] fmt, any[doc] varg) [flags=CONSTANT] {
   return q_vsprintf(args, 1, 0, xsink);
}

//! Returns a formatted string based on a @ref string_formatting "format string" and other arguments given as a list after the format string; does not enforce field widths on arguments larger than the given field width
/** 
    This function will not truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param varg the argument(s) corresponding to format specifiers in the format string

    @return a formatted string corresponding to the arguments given

    @par Example:
    @code
my string $str = vsprintf("%5s %3d\n", ("a long string", 5000)); # will return "a long string 5000"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - f_vsprintf() for a similar function that enforces field widths
 */
string vsprintf(string[doc] fmt, any[doc] varg) [flags=CONSTANT] {
   return q_vsprintf(args, 0, 0, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
string vsprintf() [flags=NOOP] {
   return null_string();
}

//! Outputs the string passed to standard output, using the first argument as a @ref string_formatting "format string"; enforces field widths on arguments larger than the given field width
/** 
    This function will truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param ... the argument(s) corresponding to format specifiers in the format string

    @return the formatted string output corresponding to the arguments given

    @par Example:
    @code
f_printf("%5s", "a long string"); # will print out "a lon"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - printf() for a similar function that does not enforce field widths
 */
string f_printf(string[doc] fmt, ...) [dom=TERMINAL_IO] {
   AbstractQoreNode* node;
   print_node(stdout, node = q_sprintf(args, 1, 0, xsink));
   return node;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
string f_printf() [flags=NOOP] {
   return null_string();
}

//! Outputs the string passed to standard output, using the first argument as a @ref string_formatting "format string"; does not enforce field widths on arguments larger than the given field width
/** 
    This function will not truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param ... the argument(s) corresponding to format specifiers in the format string

    @return the formatted string output corresponding to the arguments given

    @par Example:
    @code
printf("%5s", "a long string"); # will print out "a long string"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - f_printf() for a similar function that enforces field widths
 */
string printf(string[doc] fmt, ...) [dom=TERMINAL_IO] {
   AbstractQoreNode* node;
   print_node(stdout, node = q_sprintf(args, 0, 0, xsink));
   return node;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
string printf() [flags=NOOP;dom=TERMINAL_IO] {
   return null_string();
}

//! Outputs the string passed to standard output, using the first argument as a @ref string_formatting "format string" and a second argument giving a list or a single argument to the format string; enforces field widths on arguments larger than the given field width
/** 
    This function will truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param varg the argument(s) corresponding to format specifiers in the format string

    @return the formatted string output corresponding to the arguments given

    @par Example:
    @code
f_vprintf("%5s %3d", ("a long string", 5000)); # will print out "a lon 500"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - vprintf() for a similar function that does not enforce field widths

    @since %Qore 0.8.4
 */
string f_vprintf(string[doc] fmt, any[doc] varg) [dom=TERMINAL_IO] {
   AbstractQoreNode* node;
   print_node(stdout, node = q_vsprintf(args, 1, 0, xsink));
   return node;
}

//! Outputs the string passed to standard output, using the first argument as a @ref string_formatting "format string" and a second argument giving a list or a single argument to the format string; does not enforce field widths on arguments larger than the given field width
/** 
    This function will not truncate output longer than any field width given in the @ref string_formatting "format string"

    @param fmt the @ref string_formatting "format string"
    @param ... the argument(s) corresponding to format specifiers in the format string

    @return the formatted string output corresponding to the arguments given

    @par Example:
    @code
vprintf("%5s %3d", ("a long string", 5000)); # will print out "a long string 5000"
    @endcode

    @see
    - @ref string_formatting for information on the formatting string
    - f_vprintf() for a similar function that enforces field widths
 */
string vprintf(string[doc] fmt, ...) [dom=TERMINAL_IO] {
   AbstractQoreNode* node;
   print_node(stdout, node = q_vsprintf(args, 0, 0, xsink));
   return node;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
string vprintf() [flags=NOOP] {
   return null_string();
}

//! Flushes output to the console output with print(), printf(), etc
/** 
    @par Example:
    @code
flush();
    @endcode
 */
nothing flush() [dom=TERMINAL_IO] {
   fflush(stdout);
}

//! tries to parse a string value as a boolean
/** @par Example:
    @code
my bool $b = parse_boolean($str);
    @endcode

    @param str case-insensitive \c "on", \c "true", \c "enable*", \c "yes", \c "y" are @ref Qore::True "True", the rest is interpreted as a number where 0 is @ref Qore::False "False", everything else is  @ref Qore::True "True"

    @return a boolean value according to the parsed argument

    @since Qore 0.8.12 \c "y" is also parsed as @ref Qore::True "True"
 */
bool parse_boolean(string str) [flags=CONSTANT] {
   return q_parse_bool(str->getBuffer());
}

//! returns the first value passed as a boolean
/** @par Example:
    @code
my bool $b = parse_boolean($i);
    @endcode

    @return the first value passed as a boolean
 */
bool parse_boolean(...) [flags=CONSTANT] {
   const AbstractQoreNode* p = get_param(args, 0);
   return p ? p->getAsBool() : false;
}

//! returns a number corresponding to the string and the argument, giving the format
/** @par Example:
    @code
my number $n = parse_number("1.150.200,55", ".,");
    @endcode

    @param str the string to parse
    @param the format of the number in the string, consisting of two characters, the first for the thousands separator, the second for the decimal point (ex: \c ".," for amny European locales)

    @return the number value represented by the string

    @since %Qore 0.8.11.1
*/
number parse_number(string str, string fmt) [flags=RET_VALUE_ONLY] {
   TempEncodingHelper tfmt(fmt, str->getEncoding(), xsink);
   if (*xsink)
      return 0;

   QoreString tmp(*str);
   if (fix_num(tmp, **tfmt, xsink))
      return 0;

   return new QoreNumberNode(tmp.getBuffer());
}

//! returns a number corresponding to the string and the argument, giving the format
/** @par Example:
    @code
my number $n = parse_number("1.150.200,55", ".,");
    @endcode

    @param str the string to parse
    @param the format of the number in the string, consisting of two characters, the first for the thousands separator, the second for the decimal point (ex: \c ".," for amny European locales)

    @return the number value represented by the string

    @since %Qore 0.8.11.1
*/
float parse_float(string str, string fmt) [flags=RET_VALUE_ONLY] {
   TempEncodingHelper tfmt(fmt, str->getEncoding(), xsink);
   if (*xsink)
      return 0;

   QoreString tmp(*str);
   if (fix_num(tmp, **tfmt, xsink))
      return 0;

   return strtod(tmp.getBuffer(), 0);
}
//@}
