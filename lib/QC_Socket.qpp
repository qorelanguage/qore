/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  QC_Socket.qpp

  Socket class definition

  Qore Programming Language

  Copyright (C) 2003 - 2014 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/QC_Socket.h>
#include <qore/intern/ssl_constants.h>
#include <qore/intern/QC_Queue.h>

#include <errno.h>
#include <string.h>

static void hash_set_int_key(QoreHashNode& h, int k, const char* str) {
   char buf[15];
   sprintf(buf, "%d", k);
   h.setKeyValue(buf, new QoreStringNode(str), 0);
}

static QoreHashNode* get_network_address_family_map() {
   QoreHashNode* rv = new QoreHashNode;

   hash_set_int_key(*rv, AF_INET, "AF_INET");
   hash_set_int_key(*rv, AF_INET6, "AF_INET6");
   hash_set_int_key(*rv, AF_UNIX, "AF_UNIX");
   hash_set_int_key(*rv, AF_UNSPEC, "AF_UNSPEC");

   return rv;
}

static int64 checkOpenResult(int rc, const char *method_name, ExceptionSink *xsink) {
   if (*xsink)
      return 0;
   if (rc == -2) {
      xsink->raiseException("SOCKET-NOT-OPEN", "socket must be open before Socket::%s() call", method_name);
      return 0;
   }
   return rc;
}

/** @defgroup x509_verification_constants X.509 Verification Constants
    These are string contants for values returned by the following methods:
    - FtpClient::verifyPeerCertificate()
    - HTTPClient::verifyPeerCertificate()
    - Socket::verifyPeerCertificate()
*/
//@{ 
//! Verification OK
const X509_V_OK = "X509_V_OK";

//! Unable to get issuer certificate
const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT = "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT";

//! Unable to get certificate CRL
const X509_V_ERR_UNABLE_TO_GET_CRL = "X509_V_ERR_UNABLE_TO_GET_CRL";

//! Unable to decrypt certificate's signature. This means that the actual signature value could not be determined rather than it not matching the expected value; this is only meaningful for RSA
const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = "X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE";

//! Unable to decrypt CRL's signature
const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = "X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE";

//! Unable to decode issuer public key (SubjectPublicKeyInfo)
const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = "X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY";

//! Certificate signature failure; the signature of the certificate is invalid
const X509_V_ERR_CERT_SIGNATURE_FAILURE = "X509_V_ERR_CERT_SIGNATURE_FAILURE";

//! CRL signature failure; the signature of the certificate is invalid
const X509_V_ERR_CRL_SIGNATURE_FAILURE = "X509_V_ERR_CRL_SIGNATURE_FAILURE";

//! Certificate is not yet valid
const X509_V_ERR_CERT_NOT_YET_VALID = "X509_V_ERR_CERT_NOT_YET_VALID";

//! Certificate has expired
const X509_V_ERR_CERT_HAS_EXPIRED = "X509_V_ERR_CERT_HAS_EXPIRED";

//! CRL is not yet valid
const X509_V_ERR_CRL_NOT_YET_VALID = "X509_V_ERR_CRL_NOT_YET_VALID";

//! CRL has expired
const X509_V_ERR_CRL_HAS_EXPIRED = "X509_V_ERR_CRL_HAS_EXPIRED";

//! Format error in certificate's notBefore field (invalid time)
const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD";

//! Format error in certificate's notAfter field (invalid time)
const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = "X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD";

//! Format error in CRL's lastUpdate field (invalid time)
const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = "X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD";

//! Format error in CRL's nextUpdate field (invalid time)
const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = "X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD";

//! Out of memory error
const X509_V_ERR_OUT_OF_MEM = "X509_V_ERR_OUT_OF_MEM";

//! Certificate is self-signed and cannot be found in the trusted list
const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT = "X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT";

//! Self signed certificate in certificate chain
const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN = "X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN";

//! Unable to get local issuer certificate. This normally means the list of trusted certificates is not complete
const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY";

//! Unable to verify the first certificate
const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = "X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE";

//! Certificate chain too long
const X509_V_ERR_CERT_CHAIN_TOO_LONG = "X509_V_ERR_CERT_CHAIN_TOO_LONG";

//! Certificate has been revoked
const X509_V_ERR_CERT_REVOKED = "X509_V_ERR_CERT_REVOKED";

//! Invalid CA certificate
const X509_V_ERR_INVALID_CA = "X509_V_ERR_INVALID_CA";

//! The basicConstraints pathlength parameter has been exceeded
const X509_V_ERR_PATH_LENGTH_EXCEEDED = "X509_V_ERR_PATH_LENGTH_EXCEEDED";

//! The certificate cannot be used for the specified purpose
const X509_V_ERR_INVALID_PURPOSE = "X509_V_ERR_INVALID_PURPOSE";

//! Root CA is not marked as trusted for the specified purpose
const X509_V_ERR_CERT_UNTRUSTED = "X509_V_ERR_CERT_UNTRUSTED";

//! Root CA is marked to reject the specified purpose
const X509_V_ERR_CERT_REJECTED = "X509_V_ERR_CERT_REJECTED";

//! The current candidate issuer certificate was rejected because its subject name did not match the issuer name of the current certificate
const X509_V_ERR_SUBJECT_ISSUER_MISMATCH = "X509_V_ERR_SUBJECT_ISSUER_MISMATCH";

//! The current candidate issuer certificate was rejected because its subject key identifier was present and did not match the authority key identifier of the current certificate
const X509_V_ERR_AKID_SKID_MISMATCH = "X509_V_ERR_AKID_SKID_MISMATCH";

//! Issuer name and serial number of candidate certificate do not match the authority key identifier of the current certificate
const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH = "X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH";

//! The keyUsage extension does not permit certificate signing
const X509_V_ERR_KEYUSAGE_NO_CERTSIGN = "X509_V_ERR_KEYUSAGE_NO_CERTSIGN";

//! Verification failure
const X509_V_ERR_APPLICATION_VERIFICATION = "X509_V_ERR_APPLICATION_VERIFICATION";

//! maps from varification strings to verification code descriptions
const X509_VerificationReasons = (
   "X509_V_OK": "OK",
   "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT": "Unable to get issuer certificate",
   "X509_V_ERR_UNABLE_TO_GET_CRL": "Unable to get certificate CRL",
   "X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE": "Unable to decrypt certificate's signature. This means that the actual signature value could not be determined rather than it not matching the expected value; this is only meaningful for RSA",
   "X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE": "Unable to decrypt CRL's signature",
   "X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY": "Unable to decode issuer public key (SubjectPublicKeyInfo)",
   "X509_V_ERR_CERT_SIGNATURE_FAILURE": "Certificate signature failure; the signature of the certificate is invalid",
   "X509_V_ERR_CRL_SIGNATURE_FAILURE": "CRL signature failure; the signature of the certificate is invalid",
   "X509_V_ERR_CERT_NOT_YET_VALID": "Certificate is not yet valid",
   "X509_V_ERR_CERT_HAS_EXPIRED": "Certificate has expired",
   "X509_V_ERR_CRL_NOT_YET_VALID": "CRL is not yet valid",
   "X509_V_ERR_CRL_HAS_EXPIRED": "CRL has expired",
   "X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD": "Format error in certificate's notBefore field (invalid time)",
   "X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD": "Format error in certificate's notAfter field (invalid time)",
   "X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD": "Format error in CRL's lastUpdate field (invalid time)",
   "X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD": "Format error in CRL's nextUpdate field (invalid time)",
   "X509_V_ERR_OUT_OF_MEM": "Out of memory error",
   "X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT": "Certificate is self-signed and cannot be found in the trusted list",
   "X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN": "Self signed certificate in certificate chain",
   "X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY": "Unable to get local issuer certificate. This normally means the list of trusted certificates is not complete",
   "X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE": "Unable to verify the first certificate",
   "X509_V_ERR_CERT_CHAIN_TOO_LONG": "Certificate chain too long",
   "X509_V_ERR_CERT_REVOKED": "Certificate has been revoked",
   "X509_V_ERR_INVALID_CA": "Invalid CA certificate",
   "X509_V_ERR_PATH_LENGTH_EXCEEDED": "The basicConstraints pathlength parameter has been exceeded",
   "X509_V_ERR_INVALID_PURPOSE": "The certificate cannot be used for the specified purpose",
   "X509_V_ERR_CERT_UNTRUSTED": "Root CA is not marked as trusted for the specified purpose",
   "X509_V_ERR_CERT_REJECTED": "Root CA is marked to reject the specified purpose",
   "X509_V_ERR_SUBJECT_ISSUER_MISMATCH": "The current candidate issuer certificate was rejected because its subject name did not match the issuer name of the current certificate",
   "X509_V_ERR_AKID_SKID_MISMATCH": "The current candidate issuer certificate was rejected because its subject key identifier was present and did not match the authority key identifier of the current certificate",
   "X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH": "Issuer name and serial number of candidate certificate do not match the authority key identifier of the current certificate",
   "X509_V_ERR_KEYUSAGE_NO_CERTSIGN": "The keyUsage extension does not permit certificate signing",
   "X509_V_ERR_APPLICATION_VERIFICATION": "Verification failure",
   );
//@}

/** @defgroup network_address_family_constants Network Address Family Constants
    These are the possible network address family constants
*/
//@{
//! IPv4 address family
const AF_INET = AF_INET;

//! IPv6 address family
const AF_INET6 = AF_INET6;

//! UNIX domain address family (UNIX socket files)
const AF_UNIX = AF_UNIX;

#ifndef AF_LOCAL
#define AF_LOCAL AF_UNIX
#endif

//! POSIX synonym for AF_UNIX
const AF_LOCAL = AF_LOCAL; 

//! unspecified address family
const AF_UNSPEC = AF_UNSPEC;

//! mapping from @ref network_address_family_constants to string codes
const AFMap = qore(get_network_address_family_map());

//! mapping from network address family string codes to @ref network_address_family_constants
const AFStrMap = (
   "AF_INET": AF_INET,
   "AF_INET6": AF_INET6,
   "AF_UNIX": AF_UNIX,
   "AF_LOCAL": AF_UNIX,
   "AF_UNSPEC": AF_UNSPEC,
   );

//@}

/** @defgroup network_address_information_constants Network Address Information Constants
    These are the possible network address information constants for the getaddrinfo() function;
    if any of these constants are not defined on the current platform, they will be assigned to 0 in %Qore
*/
//@{
#ifndef AI_ADDRCONFIG
#define AI_ADDRCONFIG 0
#endif
#ifndef AI_ALL
#define AI_ALL 0
#endif
#ifndef AI_CANONNAME
#define AI_CANONNAME 0
#endif
#ifndef AI_NUMERICHOST
#define AI_NUMERICHOST 0
#endif
#ifndef AI_NUMERICSERV
#define AI_NUMERICSERV 0
#endif
#ifndef AI_PASSIVE
#define AI_PASSIVE 0
#endif
#ifndef AI_V4MAPPED
#define AI_V4MAPPED 0
#endif

//! if this bit is set, addresses of each family are returned only if they are configured on the system
const AI_ADDRCONFIG = AI_ADDRCONFIG;

//! If this bit is set along with AI_V4MAPPED then all matching IPv6 and IPv4 addresses are returned
const AI_ALL = AI_ALL;

//! If this bit is set, then getaddrinfo() will return the canonical name of the hostname in the \c "canonname" key of the first element returned
const AI_CANONNAME = AI_CANONNAME;

//! If this bit is set, then the host is assumed to be an address and no hostname lookup will be preformed
const AI_NUMERICHOST = AI_NUMERICHOST;

//! If this bit is set, then the service is assumed to be a numeric port string, and no service lookup will be performed
/** If the AI_NUMERICSERV bit is set, then any service name string supplied will be treated as a numeric port string. Otherwise, a \c QOREADDRINFO-GETINFO-ERROR exception will be thrown due to the \c EAI_NONAME error raised internally. This bit prevents any type of name resolution service (for example, NIS+) from being invoked (this constant is operating system dependent; it is not available on all operating systems; for example, it is not available on Solaris 8).

 */
const AI_NUMERICSERV = AI_NUMERICSERV;

//! If this bit is set, then the returned information should be usable for a call to Socket::bind()
/** In this case, if the hostname is not given, then the return value will be usable for binding on all addresses for the given family.  

    If the AI_PASSIVE bit is not set, the returned socket address structure will be ready for use in a call to Socket::connect().

    The IP address portion of the socket address structure will be set to the loopback address if hostname is @ref nothing and AI_PASSIVE is not set.
*/
const AI_PASSIVE = AI_PASSIVE;

//! If this bit is set, getaddrinfo() will return IPv4-mapped IPv6 addresses on finding no matching IPv6 addresses/
/** The AI_V4MAPPED flag is ignored unless family is AF_INET6
 */
const AI_V4MAPPED = AI_V4MAPPED;
//@}

/** @defgroup protocol_constants Network Protocol Constants
    These are the possible network protocol constants
*/
//@{
//! for the UDP protocol
const IPPROTO_UDP = IPPROTO_UDP;

//! for the TCP protocol
const IPPROTO_TCP = IPPROTO_TCP;
//@}

/** @defgroup socket_type_constants Socket Type Constants
    These are the possible socket type constants
*/
//@{
//! for sequenced, reliable, two-way connection-based byte streams (the default)
const SOCK_STREAM = SOCK_STREAM;

//! for datagrams (connectionless, unreliable messages of a fixed (typically small) maximum length
const SOCK_DGRAM = SOCK_DGRAM;

//! raw socket interface, only available to the superuser, untested
const SOCK_RAW = SOCK_RAW;
//@}

//! The Socket class allows %Qore programs safe access to network sockets
/** @note This class is not available with the @ref PO_NO_NETWORK parse option.

    Non-blocking socket I/O can be performed by appending a timeout value in milliseconds all Socket methods performing I/O operations, or by using the Socket::isDataAvailable() method with a timeout value in milliseconds (1000 ms = 1 second). Note that as with all %Qore functions and methods accepting a timeout value, relative date/time values can be given instead of integers to make the source more readable, for example:

    @code
    my bool $rc = $socket.isDataAvailable(1250ms); # times out in 1.25 seconds
    @endcode

    Socket objects can automatically convert character encodings if desired when sending string data with Socket::send(). Use the Socket::setEncoding() method to set the character encoding for the socket. If a character encoding is set, and string data is read with the Socket::recv() method, then it will be tagged with the encoding of the socket as well.

    Client applications should call Socket::connect() to connect to a remote port or a UNIX domain socket (socket file on the local server). However, if the remote end is expecting a TLS/SSL connection, use Socket::connectSSL() instead.

    Server applications should call Socket::bind(), Socket::listen(), and Socket::accept() in this order to accept incoming connections. Normally a new thread should be started after the Socket::accept() call to handle the new connection in a separate thread (Socket::accept() returns a new Socket object for the accepted connection).

    To support TLS/SSL server connections, first set the certificate and private key with the Socket::setCertificate() and Socket::setPrivateKey() methods (see the SSLCertificate Class and the SSLPrivateKey Class for more information on the parameters required for these methods). Then Socket::acceptSSL() should be called after the socket is in a listening state to accept client connections and negotiate a TLS/SSL connection.

    This class supports posting events to a @ref Qore::Thread::Queue "Queue". See @ref event_handling for more information.

    The events raised by this object are listed in the following table:

    @anchor socket_events
    <b>Socket Events</b>
    |!Name|!Description
    |@ref EVENT_PACKET_READ|Raised when a network packet is received.
    |@ref EVENT_PACKET_SENT|Raised when a network packet is sent.
    |@ref EVENT_CHANNEL_CLOSED|Raised when a socket is closed.
    |@ref EVENT_DELETED|Raised when the object being monitored is deleted.
    |@ref EVENT_HOSTNAME_LOOKUP|Raised when a hostname lookup is attempted.
    |@ref EVENT_HOSTNAME_RESOLVED|Raised when a hostname lookup is resolved.
    |@ref EVENT_HTTP_SEND_MESSAGE|Raised when an HTTP message is sent.
    |@ref EVENT_HTTP_MESSAGE_RECEIVED|Raised when an HTTP message is received.
    |@ref EVENT_CONNECTING|Raised right before a socket connection attempt is made.
    |@ref EVENT_CONNECTED|Raised when the socket connection has been established.
    |@ref EVENT_START_SSL|Raised when socket SSL negotiation starts.
    |@ref EVENT_SSL_ESTABLISHED|Raised when SSL communication has been negotiated and established.

    @anchor socket_info_hash
    <b>Socket Information Hash</b>
    |!Key|!Description
    |\c hostname|The interface name if available (ex: \c "localhost"; note that this key is not present when retrieving information about UNIX sockets)
    |\c hostname_desc|A descriptive string giving the hostname and the address family if the hostname is available (ex: \c "ipv6[localhost]"; note that this key is not present when retrieving information about UNIX sockets)
    |\c address|A string giving the address (ex: \c "::ffff:0.0.0.0")
    |\c address_desc|A descriptive string giving the address and the address family (ex: \c "ipv6[::ffff:0.0.0.0]")
    |\c port|An integer port number if available (note that this key is not present when retrieving information about UNIX sockets)
    |\c family|The network address family (see @ref network_address_family_constants)
    |\c familystr|A string describing the network address family (ex: \c "ipv4")
 */
qclass Socket [public_members=*string source,*string source_host; flags=unsetPublicMemberFlag; arg=QoreSocketObject* s; dom=NETWORK];

//! Creates the socket object
/** @par Example:
    @code my Socket $sock(); @endcode
 */
Socket::constructor() {
   self->setPrivate(CID_SOCKET, new QoreSocketObject);
}

//! Creates a new Socket object, not based on the source being copied
/** @par Example:
    @code my Socket $newsock = $sock.copy(); @endcode
 */
Socket::copy() {
   self->setPrivate(CID_SOCKET, new QoreSocketObject);
}

//! Connects to a remote port (if the string has a format "host:port") or UNIX domain socket file with an optional timeout value with a millisecond resolution
/** Connects the socket to a remote (or local) port or UNIX domain socket file, for network (ipv4 and ipv6) connections, accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: \c 20s). If any errors occur, an exception is thrown.

    @par Examples:
    @code# connect to ipv4 adress 192.168.1.45 port 8080 with a 30 second timeout
$sock.connect("192.168.1.45:8080", 30s);@endcode
    @code# connect to ipv6 adress 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 10 second timeout
$sock.connect("[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", 10s);@endcode
    @code# connect to localhost using ipv6 (::1) port 80 with a 10 second timeout
$sock.connect("[localhost]:80", 15s);@endcode
    @code# connect to UNIX domain socket file "/tmp/socket"
$sock.connect("/tmp/socket");@endcode

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED

    @param target The target address interpreted with the following rules:
    - If a colon appears in the string, the string will be assumed to be a \c "hostname:port" specification to connect to; where \c "port" can also be a service name (ex: \c "example.com:https")
    - If the string contains no colon, the socket will try to connect to a UNIX domain socket file on the local filesystem with the given name.
    - Enclose ipv6 addresses in square brackets (ex: \c "[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", will connect to port 80 on the given ipv6 address); also if a hostname is enclosed in square brackets, it will be resolved as an ipv6 address (ex: \c "[localhost]:80" will connect to port \c 80 on \c ::1, assuming \c "localhost" can be resolved to the ipv6 loopback address on the system).
    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, a \c "SOCKET-CONNECT-ERROR" exception is thrown. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc).

    @see Socket::connectUNIX(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectUNIXSSL()
 */
nothing Socket::connect(string target, timeout timeout_ms = -1) {
   s->connect(target->getBuffer(), timeout_ms, xsink);
}

//! Connects to the given host and port with an optional timeout value with a millisecond resolution
/** Connects the socket to a remote (or local) port; accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: \c 20s). If any errors occur, an exception is thrown.

    Do not use square brackets to designate ipv6 addresses with this method; just give the address in its normal form (ex: \c "2001:0db8:85a3:0000:0000:8a2e:0370:7334").

    @par Examples:
    @code# connect to ipv4 address 192.168.1.45 port 8080 with a 30 second timeout
$sock.connectINET("192.168.1.45", 8080, 30s);@endcode
    @code# connect to ipv6 address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 20 second timeout
$sock.connectINET("2001:0db8:85a3:0000:0000:8a2e:0370:7334", 80, 20s);@endcode

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED

    @param host The host name or IP address to connect to
    @param service The service name (ex: \c "http" or port number (given as or converted to a string) to connect to
    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, a \c "SOCKET-CONNECT-ERROR" exception is thrown. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)
    @param family The address family to use to connect to the remote socket; see @ref network_address_family_constants
    @param socktype The type of socket; see @ref socket_type_constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc)

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectUNIXSSL()
 */
nothing Socket::connectINET(string host, softstring service, timeout timeout_ms = -1, softint family = AF_UNSPEC, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectINET2(host->getBuffer(), service->getBuffer(), family, socktype, protocol, timeout_ms, xsink);
}

//! Connects to a UNIX domain socket file
/** Connects the socket to the given UNIX domain socket file; if any errors occur, an exception is thrown

    @par Example:
    @code # connect to UNIX domain socket file "/tmp/socket"
$sock.connectUNIX("/tmp/socket"); @endcode

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED

    @param path The socket will try to connect to a UNIX domain socket file on the local filesystem with the given name
    @param socktype The type of socket; see @ref socket_type_constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the socket

    @see Socket::connect(), Socket::connectINET(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectUNIXSSL()

    @note UNIX domain sockets are not available on native Windows ports
 */
nothing Socket::connectUNIX(string path, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectUNIX(path->getBuffer(), socktype, protocol, xsink);
}

//! Connects to a remote socket and attempts to establish a TLS/SSL connection; accepts an optional timeout value with a millisecond resolution
/** Connects to a remote socket and attempts to establish a TLS/SSL connection, for network (INET) connections, accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: \c 20s). If any errors occur, an exception is thrown.

    Enclose ipv6 addresses in square brackets (ex: \c "[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", will connect to port 80 on the given ipv6 address); also if a hostname is enclosed in square brackets, it will be resolved as an ipv6 adress (ex: \c "[localhost]:80" will connect to port \c 80 on \c ::1, assuming \c "localhost" can be resolved to the ipv6 loopback address on the system).

    @par Examples:
    @code # connect to ipv4 adress 192.168.1.45 port 8080 with a 30 second timeout
$sock.connectSSL("192.168.1.45:8080", 30s); @endcode
    @code # connect to ipv6 adress 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 10 second timeout
$sock.connectSSL("[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", 10s); @endcode
    @code # connect to localhost using ipv6 (::1) port 80 with a 10 second timeout
$sock.connectSSL("[localhost]:80", 15s); @endcode
    @code # connect to UNIX domain socket file "/tmp/socket"
$sock.connectSSL("/tmp/socket"); @endcode

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @param target The target address interpreted with the following rules:
    - If a colon appears in the string, the string will be assumed to be a \c "hostname:port" specification to connect to; where \c "port" can also be a service name (ex: \c "example.com:https")
    - If the string contains no colon, the socket will try to connect to a UNIX domain socket file on the local filesystem with the given name.
    - Enclose ipv6 addresses in square brackets (ex: \c "[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", will connect to port 80 on the given ipv6 address); also if a hostname is enclosed in square brackets, it will be resolved as an ipv6 address (ex: \c "[localhost]:80" will connect to port \c 80 on \c ::1, assuming \c "localhost" can be resolved to the ipv6 loopback address on the system).
    @param timeout_ms if a timeout value is passed and the connection takes longer to establish than the timeout, an exception is thrown. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc)
    @throw SOCKET-SSL-ERROR An error occurred establishing the TLS/SSL connection

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectUNIXSSL(), Socket::connectINETSSL(), and Socket::connectINET()
 */
nothing Socket::connectSSL(string target, timeout timeout_ms = -1) {
   s->connectSSL(target->getBuffer(), timeout_ms, xsink);
}

//! Connects to the given host and port and attempts to establish a TLS/SSL connection; accepts an optional timeout value with a millisecond resolution
/** Connects the socket to a remote (or local) port and attempts to establish a TLS/SSL connection; accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: \c 20s). If any errors occur, an exception is thrown.
    
    Do not use square brackets to designate ipv6 addresses with this method; just give the address in its normal form (ex: \c "2001:0db8:85a3:0000:0000:8a2e:0370:7334").

    @par Examples:
    @code # connect to 192.168.1.45 port 8080 with a 30 second timeout
$sock.connectINETSSL("192.168.1.45", 8080, 30s); @endcode
    @code # connect to ipv6 address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 20 second timeout
$sock.connectINETSSL("2001:0db8:85a3:0000:0000:8a2e:0370:7334", 80, 20s); @endcode

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @param host The host name or IP address to connect to
    @param service The service name (ex: \c "http" or port number (given as or converted to a string) to connect to
    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, a \c "SOCKET-CONNECT-ERROR" exception is thrown. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)
    @param family The address family to use to connect to the remote socket; see @ref network_address_family_constants
    @param socktype The type of socket; see @ref socket_type_constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc)
    @throw SOCKET-SSL-ERROR An error occurred establishing the TLS/SSL connection

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINET(), and Socket::connectUNIXSSL()
 */
nothing Socket::connectINETSSL(string host, softstring service, timeout timeout_ms = -1, softint family = AF_UNSPEC, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectINET2SSL(host->getBuffer(), service->getBuffer(), family, socktype, protocol, timeout_ms, xsink);
}

//! Connects to the given UNIX domain socket file and attempts to establish a TLS/SSL connection
/** Connects the socket to a UNIX domain socket file and attempts to establish a TLS/SSL connection. If any errors occur, an exception is thrown.

    @par Example:
    @code # connect to UNIX domain socket file "/tmp/socket"
$sock.connectUNIXSSL("/tmp/socket"); @endcode

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @param path The socket will try to connect to a UNIX domain socket file on the local filesystem with the given name
    @param socktype The type of socket; see @ref socket_type_constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the socket
    @throw SOCKET-SSL-ERROR An error occurred establishing the TLS/SSL connection

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectINET()

    @note UNIX domain sockets are not available on native Windows ports
 */
nothing Socket::connectUNIXSSL(string path, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectUNIXSSL(path->getBuffer(), socktype, protocol, xsink);
}

//! Opens and binds the socket to a port, interface and port (if the $bind_to string has a format "host:port"), or UNIX domain socket file. 
/** If the second parameter is @ref True, then the socket will set the \c SO_REUSEADDR option, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state). 

    If any errors occur a non-zero error code is returned.

    This method tries to automatically pick the appropriate address family from the arguments; note that a hostname or address in square brackets (ex: \c "[localhost]") will be looked up and bound as an IPv6 address; additionally, the method recognizes ipv6 addresses by embedded colons (:) in the address string and binds them as such.

    Internally, the getaddrinfo() function is used to look up bind addresses; internal \c bind() operations are tried in sequence for each address returned; as soon as a bind operation is successful, the method returns. If none of the addresses can be bound, then an error code is returned.

    @par Example:
    @code # bind to a UNIX socket on the local system and reuse the address, check return code
if ($sock.bind("/tmp/my-socket", True))
    throw "BIND-ERROR", strerror(); @endcode

    @param str If a colon appears in the string, the string will be assumed to be a \c "bind_address:port" specification, and the port on the named IP address will be bound, otherwise, if the string contains no colon, the socket will be bound to a UNIX domain socket file on the local filesystem with the given name.  Note that a hostname or address in square brackets (ex: \c "[localhost]") will be looked up and bound as an IPv6 address; additionally, the method recognizes ipv6 addresses by embedded colons (:) in the address string (if surrounded by square brackets) and binds them as such.
    @param reuseaddr If this optional argument evaluates to @ref True, the \c SO_REUSEADDR option will be set on the socket, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state); note that this only applies to IPv4 (@ref AF_INET) and IPv6 (@ref AF_INET6) sockets; this option is ignored for UNIX (@ref AF_UNIX) sockets.
    
    @see Socket::bindINET() and Socket::bindUNIX()

    @note UNIX domain sockets are not available on native Windows ports
*/
int Socket::bind(string str, softbool reuseaddr = False) {
   return s->bind(str->getBuffer(), reuseaddr);
}

//! Opens and binds the socket to an INET port on all interfaces 
/** If the second parameter is @ref True, then the socket will set the \c SO_REUSEADDR option, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state). 

    If any errors occur a non-zero error code is returned.

    @par Example:
    @code # bind to port 80 on all interfaces on the local system and reuse the address, check return code
if ($sock.bind(80, True))
    throw "BIND-ERROR", strerror(); @endcode
    
    @param port A port number to bind to on all interfaces
    @param reuseaddr If this optional argument evaluates to @ref True, the \c SO_REUSEADDR option will be set on the socket, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state)
    
    @see Socket::bindINET() and Socket::bindUNIX()
*/
int Socket::bind(int port, softbool reuseaddr = False) {
   return s->bind(port, reuseaddr);
}

//! Opens and binds the socket to the given UNIX domain socket file as given by the filename argument. If any errors occur, an exception is thrown
/** Opens and binds the socket to the given UNIX domain socket file as given by the filename argument. Note that the socket file is automatically deleted in the destructor when a UNIX socket is closed. If any errors occur, an exception is thrown.

    @par Example:
    @code # bind to UNIX domain socket file "/tmp/socket"
$sock.bindUNIX("/tmp/socket"); @endcode

    @param path The path of the UNIX domain socket to create and bind to
    @param socktype the type of socket; see Socket Type Constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol the protocol number for the socket; use 0 for the default protocol

    @throw SOCKET-BIND-ERROR Error opening socket for bind; error binding on socket

    @see Socket::bind() and Socket::bindINET()

    @note UNIX domain sockets are not available on native Windows ports
 */
nothing Socket::bindUNIX(string path, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->bindUNIX(path->getBuffer(), socktype, protocol, xsink);
}

//! Opens and binds the socket to the given IPv4 or IPv6 interface (or if no interface is given, then to all interfaces on the local system) and port (the port number will be derived from the service name if a numeric port number is not given)
/** Opens and binds the socket to a port, interface and port (if the interface string has a format \c "host:port"), or UNIX domain socket file (if no port or service name appears in the bind string). If the second parameter is @ref True, then the socket will set the \c SO_REUSEADDR option, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state).

    Internally, the getaddrinfo() function is used to look up bind addresses; internal bind() operations are tried in sequence for each address returned; as soon as a bind operation is successful, the method returns. If none of the addresses can be bound, then an error code is returned.

    If any errors occur, an exception is thrown.

    @par Examples:
    @code # bind to port 80 on all interfaces on the local system and reuse the address
$sock.bindINET(NOTHING, 80, True); @endcode
    @code # bind to interface 192.168.2.23 port 8080 and do not reuse the address
$sock.bindINET("192.168.2.23", 8080); @endcode
    @code # bind to localhost port 8080 with ipv6 and do not reuse the address
$sock.bindINET("localhost", 8080, False, AF_INET6); @endcode
    @code # bind to ipv6 host address fe80::21c:42ff:fe00:8, port 1001, reuse the address
$sock.bindINET("fe80::21c:42ff:fe00:8", 1001, True); @endcode

    @param iface the host name or IP address to bind to
    @param service the service name (ex: "http" or port number (given as or converted to a string) to bind to
    @param reuseaddr if this optional argument evaluates to True, the \c SO_REUSEADDR option will be set on the socket, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state)
    @param family the address family to use to bind; see Network Address Family Constants; \c AF_UNSPEC means to try all possible addres families
    @param socktype the type of socket; see @ref socket_type_constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol the protocol number for the socket; use 0 for the default protocol

    @throw SOCKET-BIND-ERROR Both hostname and service name are empty or not set; error opening socket for bind; error binding on socket.
    @throw QOREADDRINFO-GETINFO-ERROR error looking up either nodename or servicename (or not known)

    @see Socket::bind() and Socket::bindUNIX()
 */
nothing Socket::bindINET(*string iface, *softstring service, softbool reuseaddr = False, softint family = AF_UNSPEC, softint socktype = SOCK_STREAM, softint protocol = 0) {
   if ((!iface || iface->empty())
       && (!service || service->empty())) {
      xsink->raiseException("SOCKET-BIND-ERROR", "both interace (first parameter) and service (second parameter) were either not present or empty strings; at least one of the first 2 parameters must be present for a successful call to Socket::bindINET()");
      return 0;
   }

   s->bindINET(iface ? iface->getBuffer() : 0, service ? service->getBuffer() : 0, reuseaddr, family, socktype, protocol, xsink);
   return 0;
}

//! Accepts connections on a listening socket
/** Accepts connections on a listening socket; if any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    @par Example:
    @code my Socket $new_socket = $sock.accept(); @endcode

    @return a new Socket object is returned for the new connection

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection

    @see Socket::acceptSSL(), Socket::listen(), Socket::getPeerInfo()
 */
Socket Socket::accept() {
   QoreSocketObject *n = s->accept(-1, xsink);
   if (!n) {
      assert(*xsink);
      return 0;
   }

   assert(n);

   // ensure that a socket object is returned (and not a subclass)
   QoreObject *ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   my_socket_priv::setAccept(*n, ns);

   return ns;
}

//! Accepts connections on a listening socket (see Socket::listen()) accepting a timeout value with a millisecond resolution
/** If any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    @par Example:
    @code my *Socket $new_socket = $sock.accept(30s); @endcode

    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, then @ref nothing is returned.Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return If no connection is accepted within the timeout period, then @ref nothing is returned, otherwise a Socket object for the new connection is returned.

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection 

    @see Socket::acceptSSL(), Socket::listen(), Socket::getPeerInfo()
 */
*Socket Socket::accept(timeout timeout_ms) {
   QoreSocketObject *n = s->accept(timeout_ms, xsink);
   if (!n)
      return 0;

   // ensure that a socket object is returned (and not a subclass)
   QoreObject *ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   my_socket_priv::setAccept(*n, ns);

   return ns;
}

//! Accepts connections on a listening socket and attempts to negotiate a TLS/SSL connection
/** Accepts connections on a listening socket and attempts to negotiate a TLS/SSL connection; if any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    @par Example:
    @code my Socket $new_socket = $sock.acceptSSL(); @endcode

    @return When a new connection is accepted and a TLS/SSL session has been successfully negotiated, a new Socket object is returned for the new connectio

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection

    @see Socket::accept(), Socket::listen(), Socket::getPeerInfo()
 */
Socket Socket::acceptSSL() {
   QoreSocketObject *n = s->acceptSSL(-1, xsink);
   if (!n) {
      assert(*xsink);
      return 0;
   }

   // ensure that a socket object is returned (and not a subclass)
   QoreObject *ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   my_socket_priv::setAccept(*n, ns);
   
   return ns;
}

//! Accepts connections on a listening socket and attempts to negotiate a TLS/SSL connection accepting a timeout value with a millisecond resolution
/** If any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    @par Example:
    @code my *Socket $new_socket = $sock.acceptSSL(30s); @endcode

    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, then @ref nothing is returned. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return If no connection is accepted within the timeout period, then @ref nothing is returned, otherwise a Socket object for the new connection is returned.

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection 

    @see Socket::acceptSSL(), Socket::listen(), Socket::getPeerInfo()
 */
*Socket Socket::acceptSSL(timeout timeout_ms) {
   QoreSocketObject* n = s->acceptSSL(timeout_ms, xsink);
   if (!n)
      return 0;

   // ensure that a socket object is returned (and not a subclass)
   QoreObject* ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   my_socket_priv::setAccept(*n, ns);
   
   return ns;
}

//! Listens for connections on a bound socket; sets the socket in a listening state
/** Listens for new connections on a bound socket.

    @par Example:
    @code $sock.listen(); @endcode

    @param backlog the size of the queue for pending connections

    @return Returns 0 for success, -1 for error

    @throw SOCKET-NOT-OPEN The socket is not bound

    @since %Qore 0.8.8 the \a backlog parameter was added
 */
int Socket::listen(int backlog = 20) {
   return checkOpenResult(s->listen((int)backlog), "listen", xsink);
}

//! Sends binary data over the socket; if any errors occur, an exception is thrown
/**
    @par Example:
    @code
$sock.send($data, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param bin Sends the binary data over the socket
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see
    - Socket::sendBinary()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::send2() except for the return value

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error like Socket::send2(); this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::send(binary bin, int timeout_ms = -1) {
   return s->send(bin, timeout_ms, xsink);
}

//! Sends string data over the socket; string data is converted to the socket's encoding if necessary; if any errors occur, an exception is thrown
/** String data will be converted to the encoding set for the socket if necessary.

    @par Example:
    @code
$sock.send($str, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param str sends the string data over the socket without the trailing null ('\0') character; the string's encoding is converted to the socket's encoding if necessary
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see
    - Socket::sendBinary2()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::send2() except for the return value

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error like Socket::send2(); this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::send(string str, timeout timeout_ms = -1) {
   return s->send(str, timeout_ms, xsink);
}

//! Sends string data over the socket without converting the string to the socket's encoding, but instead is sent exactly as-is; if any errors occur, an exception is thrown
/**
    @par Example:
    @code
$sock.sendBinary($str);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param str string data to be sent (without any conversion to the socket's encoding) over the socket without the trailing null ('\0') character
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see Socket::send2()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::sendBinary2() except for the return value

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error like Socket::send2(); this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendBinary(string str, timeout timeout_ms = -1) {
   return s->send(str->getBuffer(), str->strlen(), timeout_ms, xsink);
}

//! Sends binary data over the socket; if any errors occur, an exception is thrown
/**
    @par Example:
    @code
$sock.sendBinary2($data);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param bin Sends the binary data over the socket
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see Socket::send2()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::sendBinary2() except for the return value

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error like Socket::send2(); this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendBinary(binary bin, timeout timeout_ms = -1) {
   return s->send(bin, timeout_ms, xsink);
}

//! Sends binary data over the socket; if any errors occur, an exception is thrown
/** 
    @par Example:
    @code
$sock.send2($data);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param bin Sends the binary data over the socket
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see
    - Socket::sendBinary2()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::send() except for the lack of a return value (since errors cause exceptions to be thrown, no return value is necessary)

    @since %Qore 0.8.4
 */
nothing Socket::send2(binary bin, timeout timeout_ms = -1) {
   s->send(bin, timeout_ms, xsink);
}

//! Sends string data over the socket; string data is converted to the socket's encoding if necessary; if any errors occur, an exception is thrown
/** String data will be converted to the encoding set for the socket if necessary.

    @par Example:
    @code
$sock.send2($str);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param str sends the string data over the socket without the trailing null ('\0') character; the string's encoding is converted to the socket's encoding if necessary
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see
    - Socket::sendBinary2()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::send() except for the lack of a return value (since errors cause exceptions to be thrown, no return value is necessary)

    @since %Qore 0.8.4
 */
nothing Socket::send2(string str, timeout timeout_ms = -1) {
   s->send(str, timeout_ms, xsink);
}

//! Sends string data over the socket without converting the string to the socket's encoding, but instead is sent exactly as-is; if any errors occur, an exception is thrown
/** 
    @par Example:
    @code
$sock.sendBinary2($str);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param str string data to be sent (without any conversion to the socket's encoding) over the socket without the trailing null ('\0') character
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see Socket::send2()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::sendBinary() except for the lack of a return value (since errors cause exceptions to be thrown, no return value is necessary)

    @since %Qore 0.8.4
 */
nothing Socket::sendBinary2(string str, timeout timeout_ms = -1) {
   s->send(str->getBuffer(), str->strlen(), timeout_ms, xsink);
}

//! Sends binary data over the socket; if any errors occur, an exception is thrown
/** 
    @par Example:
    @code
$sock.sendBinary2($data);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param bin Sends the binary data over the socket
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @see Socket::send2()

    @note this method is as of %Qore 0.8.6+ equivalent to Socket::sendBinary() except for the lack of a return value (since errors cause exceptions to be thrown, no return value is necessary)

    @since %Qore 0.8.4
 */
nothing Socket::sendBinary2(binary bin, timeout timeout_ms = -1) {
   s->send(bin, timeout_ms, xsink);
}

//! Sends a 1-byte integer over the socket
/** If any errors occur, an exception is thrown

    @par Example:
    @code
$sock.sendi1($val, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant byte will be sent
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error; this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendi1(softint i = 0, timeout timeout_ms = -1) {
   return s->sendi1((char)i, timeout_ms, xsink);
}

//! Sends a 2-byte (16-bit) integer in big-endian format (network byte order) over the socket
/** If any errors occur, an exception is thrown

    @par Example:
    @code
$sock.sendi2($val, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 2 bytes will be sent
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected    
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error; this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendi2(softint i = 0, timeout timeout_ms = -1) {
   return s->sendi2((short)i, timeout_ms, xsink);
}

//! Sends a 4-byte (32-bit) integer in big-endian format (network byte order) over the socket
/** If any errors occur, an exception is thrown

    @par Example:
    @code
$sock.sendi4($val, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 4 bytes will be sent
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected    
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error; this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendi4(softint i = 0, timeout timeout_ms = -1) {
   return s->sendi4((int)i, timeout_ms, xsink);
}

//! Sends an 8-byte (64-bit) integer in big-endian format (network byte order) over the socket
/** If any errors occur, an exception is thrown

    @par Example:
    @code
$sock.sendi8($val, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param i the integer to send
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected    
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error; this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendi8(softint i = 0, timeout timeout_ms = -1) {
   return s->sendi8(i, timeout_ms, xsink);
}

//! Sends a 2-byte (16-bit) integer in little-endian format over the socket
/** If any errors occur, an exception is thrown

    @par Example:
    @code
$sock.sendi2LSB($val, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 2 bytes will be sent
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected    
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error; this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendi2LSB(softint i = 0, timeout timeout_ms = -1) {
   return s->sendi2LSB((short)i, timeout_ms, xsink);
}

//! Sends a 4-byte (32-bit) integer in little-endian format over the socket
/** If any errors occur, an exception is thrown

    @par Example:
    @code
$sock.sendi4LSB($val, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 4 bytes will be sent
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected    
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error; this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendi4LSB(softint i = 0, timeout timeout_ms = -1) {
   return s->sendi4LSB((int)i, timeout_ms, xsink);
}

//! Sends an 8-byte (64-bit) integer in little-endian format over the socket
/** If any errors occur, an exception is thrown

    @par Example:
    @code
$sock.sendi8LSB($val, 20s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT

    @param i the integer to send
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection; the timeout value is the longest value that a single send() operation can take with non-blocking I/O. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return always returns 0 for backwards compatibility; if an error occurs, an exception is thrown

    @throw SOCKET-NOT-OPEN The socket is not connected    
    @throw SOCKET-TIMEOUT a single send() operation exceeded the given timeout period
    @throw SOCKET-SEND-ERROR an error occurred sending the socket data
    @throw SOCKET-SSL-ERROR there was an SSL error while writing data to the socket

    @since %Qore 0.8.6 this method takes a timeout value and throws exceptions on error; this change was
    made because it was not possible to catch SSL errors with this method with the previous implementation
 */
int Socket::sendi8LSB(softint i = 0, timeout timeout_ms = -1) {
   return s->sendi8LSB(i, timeout_ms, xsink);
}

//! Receives data from the socket and returns a string tagged with the Socket's character encoding
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my string $data = $sock.recv(-1); # read all data available
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ
    
    @param size the amount of data to read in bytes; to read until the remote closes the connection, use -1; a value of 0 means to read all data currently available or available up until the timeout period (if non-negative)
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return the data read, returned as a string tagged with the Socket's character encoding

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection.
    @throw SOCKET-RECV-ERROR there was an error receiving the data.
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see
    - Socket::setEncoding()
    - Socket::recvBinary()
 */
string Socket::recv(softint size = 0, timeout timeout_ms = -1) {
   return size > 0 ? s->recv(size, timeout_ms, xsink) : s->recv(timeout_ms, xsink);
}

//! Receives data from the socket and returns a binary object
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my binary $data = $sock.recvBinary(-1); # read all data available
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ
    
    @param size the amount of data to read in bytes; to read until the remote closes the connection, use -1; a value of 0 means to read all data currently available or available up until the timeout period (if non-negative)
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return the data read, returned as a binary object

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection.
    @throw SOCKET-RECV-ERROR there was an error receiving the data.
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recv()
 */
binary Socket::recvBinary(softint size = 0, timeout timeout_ms = -1) {
   return size > 0 ? s->recvBinary(size, timeout_ms, xsink) : s->recvBinary(timeout_ms, xsink);
}

//! Receives a 1-byte signed integer from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi1();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 1-byte signed integer read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvu1()
 */
int Socket::recvi1(timeout timeout_ms = -1) {
   char b;
   s->recvi1(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 2-byte (16-bit) signed integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi2();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 2-byte signed integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvu2(), Socket::recvi2LSB(), Socket::recvu2LSB()
 */
int Socket::recvi2(timeout timeout_ms = -1) {
   short b;
   s->recvi2(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 4-byte (32-bit) signed integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi4();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 4-byte signed integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvu4(), Socket::recvi4LSB(), Socket::recvu4LSB()
 */
int Socket::recvi4(timeout timeout_ms = -1) {
   int b;
   s->recvi4(timeout_ms, &b, xsink);
   return b;
}

//! Receives an 8-byte (64-bit) signed integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi8();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 8-byte signed integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi8LSB()
 */
int Socket::recvi8(timeout timeout_ms = -1) {
   int64 b;
   s->recvi8(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 2-byte (16-bit) signed integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi2LSB();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 2-byte signed integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi2(), Socket::recvu2(), Socket::recvu2LSB()
 */
int Socket::recvi2LSB(timeout timeout_ms = -1) {
   short b;
   s->recvi2LSB(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 4-byte (32-bit) signed integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi4LSB();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 4-byte signed integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi4(), Socket::recvu4(), Socket::recvu4LSB()
 */
int Socket::recvi4LSB(timeout timeout_ms = -1) {
   int b;
   s->recvi4LSB(timeout_ms, &b, xsink);
   return b;
}

//! Receives an 8-byte (64-bit) signed integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi8LSB();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 8-byte signed integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi8()
 */
int Socket::recvi8LSB(timeout timeout_ms = -1) {
   int64 b;
   s->recvi8LSB(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 1-byte unsigned integer from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvu1();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 1-byte unsigned integer read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi1()
 */
int Socket::recvu1(timeout timeout_ms = -1) {
   unsigned char b;
   s->recvu1(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 2-byte (16-bit) unsigned integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvu2();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 2-byte unsigned integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi2(), Socket::recvi2LSB(), Socket::recvu2LSB()
 */
int Socket::recvu2(timeout timeout_ms = -1) {
   unsigned short b;
   s->recvu2(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 4-byte (32-bit) unsigned integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvu4();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 4-byte unsigned integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi4(), Socket::recvi4LSB(), Socket::recvu4LSB()
 */
int Socket::recvu4(timeout timeout_ms = -1) {
   unsigned int b;
   s->recvu4(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 2-byte (16-bit) unsigned integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvi2LSB();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 2-byte unsigned integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi2(), Socket::recvu2(), Socket::recvi2LSB()
 */
int Socket::recvu2LSB(timeout timeout_ms = -1) {
   unsigned short b;
   s->recvu2LSB(timeout_ms, &b, xsink);
   return b;
}

//! Receives a 4-byte (32-bit) unsigned integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    @par Example:
    @code
my int $val = $sock.recvu4LSB();
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return The 4-byte unsigned integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi4(), Socket::recvu4(), Socket::recvi4LSB()
 */
int Socket::recvu4LSB(timeout timeout_ms = -1) {
   unsigned b;
   s->recvu4LSB(timeout_ms, &b, xsink);
   return b;
}

//! Sends an HTTP message with a method and user-defined headers given as a hash and an optional message body
/** Creates a properly-formatted HTTP message and sends it over the Socket.
    To send a string without converting the encoding to the Socket's encoding, convert the string to a binary object using the binary() function and use the variant of this method that takes a binary object for the data argument.

    @par Example:
    @code
$sock.sendHTTPMessage("POST", "/RPC2", "1.1", ("Content-Type" : "text/xml"), $xml);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param method the HTTP method name to send (i.e. POST, HEAD, etc)
    @param path the path component of the URL
    @param http_version the HTTP protocol version (\c "1.0" or \c "1.1")
    @param headers a hash of additional headers to send (key-value pairs)
    @param body if present (and does not have a length of zero), the body to be sent with the message (if present, the \c "Content-Length" header will be automatically set); string data will be automatically converted to the Socket's encoding if necessary
    @param info An optional reference to an lvalue that can accept a hash that will be used as an output variable with the following hash key:
    - \c request-uri: The request URI as sent in the output message
    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR Send failed
    @throw SOCKET-SSL-ERROR there was an error sending SSL data

    @see Socket::sendHTTPResponse(), Socket::readHTTPHeader()
 */
nothing Socket::sendHTTPMessage(string method, string path, string http_version, hash headers, *string body, *reference info, timeout timeout_ms = -1) {
   TempEncodingHelper tmp_data;
   if (body && !tmp_data.set(body, s->getEncoding(), xsink))
      return 0;

   OptHashRefHelper ohrh(info, xsink);
   s->sendHTTPMessage(xsink, *ohrh, method->getBuffer(), path->getBuffer(), http_version->getBuffer(), headers, body ? tmp_data->getBuffer() : 0, body ? tmp_data->strlen() : 0, QORE_SOURCE_SOCKET, timeout_ms);
}

//! Sends an HTTP message with a method and user-defined headers given as a hash and an optional message body
/** Creates a properly-formatted HTTP message and sends it over the Socket

    @par Example:
    @code
$sock.sendHTTPMessage("POST", "/RPC2", "1.1", ("Content-Type" : "text/xml"), $xml);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param method the HTTP method name to send (i.e. POST, HEAD, etc)
    @param path the path component of the URL
    @param http_version the HTTP protocol version (\c "1.0" or \c "1.1")
    @param headers a hash of additional headers to send (key-value pairs)
    @param body if it does not have a length of zero, the body to be sent with the message (if present, the \c "Content-Length" header will be automatically set)
    @param info An optional reference to an lvalue that can accept a hash that will be used as an output variable with the following hash key:
    - \c request-uri: The request URI as sent in the output message
    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SEND-ERROR Send failed
    @throw SOCKET-SSL-ERROR there was an error sending SSL data

    @see Socket::sendHTTPResponse(), Socket::readHTTPHeader()
 */
nothing Socket::sendHTTPMessage(string method, string path, string http_version, hash headers, binary body, *reference info, timeout timeout_ms = -1) {
   OptHashRefHelper ohrh(info, xsink);
   s->sendHTTPMessage(xsink, *ohrh, method->getBuffer(), path->getBuffer(), http_version->getBuffer(), headers, body->getPtr(), body->size(), QORE_SOURCE_SOCKET, timeout_ms);
}

//! Sends an HTTP message with a method and user-defined headers given as a hash and an optional message body
/** Creates a properly-formatted HTTP message and sends it over the Socket

    @par Example:
    @code
$sock.sendHTTPMessageWithCallback($send_callback, "POST", "/RPC2", "1.1", ("Content-Type" : "text/xml"));
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param scb The callback giving the chunked HTTP data to send; this callback must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be sent or simply @ref nothing which will close the chunked message
    @param method the HTTP method name to send (i.e. POST, HEAD, etc)
    @param path the path component of the URL
    @param http_version the HTTP protocol version (\c "1.0" or \c "1.1")
    @param headers a hash of additional headers to send (key-value pairs)
    @param info An optional reference to an lvalue that can accept a hash that will be used as an output variable with the following hash key:
    - \c request-uri: The request URI as sent in the output message
    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SEND-ERROR Send failed
    @throw SOCKET-SSL-ERROR there was an error sending SSL data

    @see Socket::sendHTTPResponse(), Socket::readHTTPHeader()

    @since %Qore 0.8.10
 */
nothing Socket::sendHTTPMessageWithCallback(code scb, string method, string path, string http_version, hash headers, *reference info, timeout timeout_ms = -1) {
   OptHashRefHelper ohrh(info, xsink);
   s->sendHTTPMessageWithCallback(xsink, *ohrh, method->getBuffer(), path->getBuffer(), http_version->getBuffer(), headers, *scb, QORE_SOURCE_SOCKET, timeout_ms);
}

//! Sends an HTTP response with user-defined headers given as a hash and an optional message body
/** Creates a properly-formatted HTTP response message and sends it over the Socket (must already be connected).  If any errors occur, an exception is raised.
    To send a string without converting the encoding to the Socket's encoding, convert the string to a binary object using the binary() function and use the variant of this method that takes a binary object for the data argument.

    @par Example:
    @code
$sock.sendHTTPResponse(200, "OK", "1.1", ("Connection":"Keep-Alive"));
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param status_code the HTTP status code to send (i.e. \c 200, \c 404, etc)
    @param status_desc the descriptive text for the status code.
    @param http_version the HTTP protocol version (normally \c "1.0" or \c "1.1", however this method allows any string to be sent)
    @param headers a hash of additional headers to send (key-value pairs)
    @param body if present (and does not have a length of zero), the body to be sent with the message (if present, the \c "Content-Length" header will be automatically set); string data will be automatically converted to the Socket's encoding if necessary
    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-SENDHTTPRESPONSE-STATUS-ERROR raised if the status_code (first argument) is < 100 or > 599
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SEND-ERROR send failed
 */
nothing Socket::sendHTTPResponse(softint status_code, string status_desc, string http_version, hash headers, *string body, timeout timeout_ms = -1) {
   if (status_code < 100 || status_code >= 600) {
      xsink->raiseException("SOCKET-SENDHTTPRESPONSE-STATUS-ERROR", "expecting valid HTTP status code between 100 and 599 as first parameter of Socket::sendHTTPResponse() call, got value %d instead", status_code);
      return 0;
   }

   TempEncodingHelper tmp_data;
   if (body && !tmp_data.set(body, s->getEncoding(), xsink))
      return 0;

   s->sendHTTPResponse(xsink, status_code, status_desc->getBuffer(), http_version->getBuffer(), headers, body ? tmp_data->getBuffer() : 0, body ? tmp_data->strlen() : 0, QORE_SOURCE_SOCKET, timeout_ms);
}

//! Sends an HTTP response with user-defined headers given as a hash and a message body as literal binary data
/** Creates a properly-formatted HTTP response message and sends it over the Socket (must already be connected).  If any errors occur, an exception is raised.

    @par Example:
    @code
$sock.sendHTTPResponse(200, "OK", "1.1", ("Connection":"Keep-Alive"), $bin);
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param status_code the HTTP status code to send (i.e. \c 200, \c 404, etc)
    @param status_desc the descriptive text for the status code.
    @param http_version the HTTP protocol version (normally \c "1.0" or \c "1.1", however this method allows any string to be sent)
    @param headers a hash of additional headers to send (key-value pairs)
    @param body if the binary object given does not have a length of zero, the body to be sent with the message (if present, the \c "Content-Length" header will be automatically set)
    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-SENDHTTPRESPONSE-STATUS-ERROR raised if the status_code (first argument) is < 100 or > 599
    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SEND-ERROR send failed
 */
nothing Socket::sendHTTPResponse(softint status_code, string status_desc, string http_version, hash headers, binary body, timeout timeout_ms = -1) {
   if (status_code < 100 || status_code >= 600) {
      xsink->raiseException("SOCKET-SENDHTTPRESPONSE-STATUS-ERROR", "expecting valid HTTP status code between 100 and 599 as first parameter of Socket::sendHTTPResponse() call, got value %d instead", status_code);
      return 0;
   }

   s->sendHTTPResponse(xsink, status_code, status_desc->getBuffer(), http_version->getBuffer(), headers, body ? body->getPtr() : 0, body ? body->size() : 0, QORE_SOURCE_SOCKET, timeout_ms);
}

//! Sends an HTTP response with user-defined headers given as a hash and a message body as literal binary data
/** Creates a properly-formatted HTTP response message and sends it over the Socket (must already be connected).  If any errors occur, an exception is raised.

    @par Example:
    @code
$sock.sendHTTPResponseWithCallback($send_callback, 200, "OK", "1.1", ("Connection":"Keep-Alive"));
    @endcode

    @par Events:
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param scb The callback giving the chunked HTTP data to send; this callback must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be sent or simply @ref nothing which will close the chunked message
    @param status_code the HTTP status code to send (i.e. \c 200, \c 404, etc)
    @param status_desc the descriptive text for the status code.
    @param http_version the HTTP protocol version (normally \c "1.0" or \c "1.1", however this method allows any string to be sent)
    @param headers a hash of additional headers to send (key-value pairs)
    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been sent or the remote end closes the connection. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-SENDHTTPRESPONSE-STATUS-ERROR raised if the status_code (first argument) is < 100 or > 599
    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SEND-ERROR send failed

    @since %Qore 0.8.10
 */
nothing Socket::sendHTTPResponseWithCallback(code scb, softint status_code, string status_desc, string http_version, hash headers, timeout timeout_ms = -1) {
   if (status_code < 100 || status_code >= 600) {
      xsink->raiseException("SOCKET-SENDHTTPRESPONSE-STATUS-ERROR", "expecting valid HTTP status code between 100 and 599 as second parameter of Socket::sendHTTPResponseWithCallback() call, got value %d instead", status_code);
      return 0;
   }

   s->sendHTTPResponseWithCallback(xsink, status_code, status_desc->getBuffer(), http_version->getBuffer(), headers, *scb, QORE_SOURCE_SOCKET, timeout_ms);
}

//! Retuns a hash representing the data in the HTTP header read, or, if the data cannot be parsed as an HTTP header, then an exception is thrown, and the data read is returned as a string in the \c arg key of the exception hash
/** If any errors occur reading from the socket or if invalid HTTP data is received, an exception is raised. Accepts an optional timeout value in milliseconds.

    @par Example:
    @code
my hash $ans = $sock.readHTTPHeader(10s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ, @ref EVENT_HTTP_MESSAGE_RECEIVED

    @param timeout_ms The timeout in milliseconds (1/1000 second). If no timeout or if a negative timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection.  If a timeout occurs, a \c "SOCKET-TIMEOUT" exception is raised. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)
    @param info An optional reference to an lvalue that can accept a hash that will be used as an output variable with one of the following two keys:
    - \c request-uri: (only set when parsing a request header) gives the request URI in an HTTP request
    - \c response-uri: (only set when parsing a response header) gives the response URI in an HTTP response    
    - \c body-content-type: this is the  \c "Content-Type" header without any charset declaration
    - \c charset: if there is a charset declaration in the \c "Content-Type" header, the value is returned in this key
    - \c close: (only set when parsing a request header) set to @ref Qore::True "True" if the connection should be closed after responding, @ref Qore::False "False" if not; see notes below about how this value is calculated
    - \c accept-charset: this key will be set to an appropriate value from any \c "Accept-Charset" header; if any of \c "*", \c "utf8", or \c "utf-8" are present, then this will be set to \c "utf8", otherwise it will be set to the first requested character encoding in the list
    - \c accept-encoding: this key will be set to a list of values from any \c "Accept-Encoding" header

    @return a hash of headers (where each header key is converted to lower-case) also including the following keys giving additional information about the HTTP header received:
    - \c http_version: a string giving the HTTP version set in the header
    - \c status_code: (HTTP responses only) an integer giving the status code
    - \c status_message: (HTTP responses only) if present in an HTTP response, this key will be set to the message after the status code
    - \c method: (HTTP requests only) a string giving the HTTP method (i.e. \c "GET", \c "POST", etc)
    - \c path: (HTTP requests only) a string giving the path in a request without any decoding; use decode_url() to decode if necessary

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end closed the connection without sending any data
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT The data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received, in the case of invalid header info received, the \c arg key of the exception hash will have the invalid data received

    @note
    - if the header claims a certain character encoding via a \c charset declaration in the \c "Content-Type" header, the Socket's @ref character_encoding "character encoding" is automatically set accordingly
    - <a href="http://tools.ietf.org/html/rfc2616#section-3.7.1">RFC 2616 3.7.1</a>: if no encoding is specified, then set \c "iso-8859-1"
    - <a href="http://tools.ietf.org/html/rfc2068#section-19.7.1">RFC 2068 19.7.1</a>: Persistent connections in HTTP/1.0 must be explicitly negotiated as they are not the default behavior
    - <a href="http://tools.ietf.org/html/rfc1945#section-1.3">RFC 1945 1.3</a>: Except for experimental applications, current practice requires that the connection be established by the client prior to each request and closed by the server after sending the response.
    - the conclusion is that server applications MUST close the connection when a request is received by an HTTP 1.0 client without an explicit request to keep the connection open

    @since 
    - %Qore 0.8.4 this method always returns a hash and raises a \c SOCKET-HTTP-ERROR if invalid HTTP data is received
    - %Qore 0.8.8 added the \c close, \c charset, \c body-content-type, and \c accept-charset info keys as well as the encoding handling based on the detected charset
 */
hash Socket::readHTTPHeader(timeout timeout_ms = -1, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   return s->readHTTPHeader(xsink, *ohrh, timeout_ms);
}

//! Retuns a string representing the data in the HTTP header read (reads until \c "\r\n\r\n")
/** If any errors occur reading from the socket, an exception is raised. Accepts an optional timeout value in milliseconds.

    @par Example:
    @code
my string $str = $sock.readHTTPHeaderString(10s);
    @endcode

    @par Events:
    @ref EVENT_PACKET_READ

    @param timeout_ms The timeout in milliseconds (1/1000 second). If no timeout or if a negative timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection.  If a timeout occurs, a \c "SOCKET-TIMEOUT" exception is raised. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return a string representing the header data read

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end closed the connection without sending any data
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT The data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR maximum header size was exceeded

    @since %Qore 0.8.8
 */
string Socket::readHTTPHeaderString(timeout timeout_ms = -1) {
   return s->readHTTPHeaderString(xsink, timeout_ms);
}

//! Reads in an HTTP message body sent in chunked transfer encoding and returns it with any footers received as a string in the \c "body" key of a hash (including footers received)
/** If any errors are encountered, an exception is raised

    @par Example:
    @code
my hash $ans = $sock.readHTTPChunkedBody(20s);
    @endcode

    @par Events:
    @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED

    @param timeout_ms The timeout in milliseconds (1/1000 second). If no timeout or if a negative timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection.  If a timeout occurs, a \c "SOCKET-TIMEOUT" exception is raised. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return a hash of any HTTP footers received (with footer keys converted to lower case), with the body returned in the \c "body" key as a string in the Socket's encoding

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end has closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT The data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw READ-HTTP-CHUNK-ERROR negative value given for chunk size by server
 */
hash Socket::readHTTPChunkedBody(timeout timeout_ms = -1) {
   // when rc = -3 it's a timeout, but rv will be NULL anyway, so we do nothing
   return s->readHTTPChunkedBody(timeout_ms, xsink);
}

//! Reads in an HTTP message body sent in chunked transfer encoding and returns it with any footers received as a binary object in the \c "body" key of a hash (including footers received)
/** If any errors are encountered, an exception is raised

    @par Example:
    @code
my hash $ans = $sock.readHTTPChunkedBodyBinary(20s);
    @endcode

    @par Events:
    @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED

    @param timeout_ms The timeout in milliseconds (1/1000 second). If no timeout or if a negative timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection.  If a timeout occurs, a \c "SOCKET-TIMEOUT" exception is raised. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return a hash of any HTTP footers received (with footer keys converted to lower case), with the body returned in the \c "body" key as a binary object

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end has closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT The data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw READ-HTTP-CHUNK-ERROR negative value given for chunk size by server
 */
hash Socket::readHTTPChunkedBodyBinary(timeout timeout_ms = -1) {
   // when rc = -3 it's a timeout, but rv will be NULL anyway, so we do nothing
   return s->readHTTPChunkedBodyBinary(timeout_ms, xsink);
}

//! Reads in an HTTP message body sent in chunked transfer encoding and returns it with any footers received as a string in the \c "body" key of a hash (including footers received)
/** If any errors are encountered, an exception is raised

    @par Example:
    @code
my hash $ans = $sock.readHTTPChunkedBodyWithCallback($recv_callback, 20s);
    @endcode

    @par Events:
    @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED

    @param rcb The receive callback for the data received; first this method is called with a hash of the message headers, and then with any message body; if a chunked HTTP message is received, then the callback is called once for each chunk; when the message has been received, then the receive callback is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
    - \c "data": the string or binary data
    - \c "chunked": True if the data was received with chunked transfer encoding, False if not
    .
    Header or trailer data is placed in a hash with the following keys:
    - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
    - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
    @param timeout_ms The timeout in milliseconds (1/1000 second). If no timeout or if a negative timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection.  If a timeout occurs, a \c "SOCKET-TIMEOUT" exception is raised. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end has closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT The data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw READ-HTTP-CHUNK-ERROR negative value given for chunk size by server

    @since %Qore 0.8.10
 */
Socket::readHTTPChunkedBodyWithCallback(code rcb, timeout timeout_ms = -1) {
   s->readHTTPChunkedBodyWithCallback(*rcb, self, timeout_ms, xsink);
}

//! Reads in an HTTP message body sent in chunked transfer encoding and returns it with any footers received as a string in the \c "body" key of a hash (including footers received)
/** If any errors are encountered, an exception is raised

    @par Example:
    @code
my hash $ans = $sock.readHTTPChunkedBodyBinaryWithCallback($recv_callback, 20s);
    @endcode

    @par Events:
    @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED

    @param rcb The receive callback for the data received; first this method is called with a hash of the message headers, and then with any message body; if a chunked HTTP message is received, then the callback is called once for each chunk; when the message has been received, then the receive callback is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
    - \c "data": the string or binary data
    - \c "chunked": True if the data was received with chunked transfer encoding, False if not
    .
    Header or trailer data is placed in a hash with the following keys:
    - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
    - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
    @param timeout_ms The timeout in milliseconds (1/1000 second). If no timeout or if a negative timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection.  If a timeout occurs, a \c "SOCKET-TIMEOUT" exception is raised. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end has closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT The data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw READ-HTTP-CHUNK-ERROR negative value given for chunk size by server

    @since %Qore 0.8.10
 */
Socket::readHTTPChunkedBodyBinaryWithCallback(code rcb, timeout timeout_ms = -1) {
   s->readHTTPChunkedBodyBinaryWithCallback(*rcb, self, timeout_ms, xsink);
}

//! Closes an open socket
/** Also deletes the UNIX domain socket file if it was created by a call to Socket::bind(). Returns 0 for success, -1 for error; in this case check errno() for the error number

    @par Example:
    @code
if ($sock.close())
    stderr.printf("Error closing socket: %s\n", strerror(errno()));
    @endcode

    @par Events:
    @ref EVENT_CHANNEL_CLOSED

    @return 0 for success, -1 for error; in this case check errno() for the error number
 */
int Socket::close() {
   return s->close();
}

//! Ensures that a socket will be closed even if the file descriptor is shared with other processes (for example, after a call to fork())
/** Does not throw any exceptions; returns an error code in case of an error

    @par Example:
    @code
if ($sock.shutdown())
    stderr.printf("Error calling Socket::shutdown(): %s\n", strerror(errno()));
    @endcode

    @return 0 for success, -1 for error; in this case check errno() for the error number
 */
int Socket::shutdown() {
   return s->shutdown();
}

//! Shuts down the SSL connection on a secure connection
/** If any errors occur, an exception is raised

    @par Example:
    @code
$sock.shutdownSSL();
    @endcode

    @throw SOCKET-SSL-ERROR an error occurred shutting down the TLS/SSL connection
 */
nothing Socket::shutdownSSL() {
   s->shutdownSSL(xsink);
}

//! Returns the port number of the socket for INET sockets
/** @par Example:
    @code
my int $port = $sock.getPort();
    @endcode

    @return the port number for an INET connection, -1 if no INET connection has been established
 */
int Socket::getPort() [flags=CONSTANT] {
   return s->getPort();
}

//! Returns the socket file descriptor number
/** @par Example:
    @code
my int $sock = $sock.getSocket();
    @endcode

    @return the socket file descriptor number or -1 if the socket is not open
 */
int Socket::getSocket() [flags=CONSTANT] {
   return s->getSocket();
}

//! sets the send timeout as a socket option
/** Returns 0 for success, -1 for error (check errno() for the actual error in this case)

    @par Example:
    @code
if ($sock.setSendTimeout(20s))
    printf("error setting timeout on socket: %s\n", strerror(errno()));
    @endcode

    @param timeout_ms the send timeout to set with a resolution of milliseconds

    @return 0 for success, -1 for error (check errno() for the actual error in this case)
 */
int Socket::setSendTimeout(timeout timeout_ms) {
   return s->setSendTimeout(timeout_ms);
}

//! sets the receive timeout as a socket option
/** Returns 0 for success, -1 for error (check errno() for the actual error in this case)

    @par Example:
    @code
if ($sock.setRecvTimeout(20s))
    printf("error setting timeout on socket: %s\n", strerror(errno()));
    @endcode

    @param timeout_ms the receive timeout to set with a resolution of milliseconds; Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return 0 for success, -1 for error (check errno() for the actual error in this case)
 */
int Socket::setRecvTimeout(timeout timeout_ms) {
   return s->setRecvTimeout(timeout_ms);
}

//! Returns the send timeout socket option value as an integer in milliseconds
/** @par Example:
    @code
my int $to = $sock.getSendTimeout();
    @endcode

    @return the send timeout socket option value as an integer in milliseconds
 */
int Socket::getSendTimeout() [flags=CONSTANT] {
   return s->getSendTimeout();
}

//! Returns the receive timeout socket option value as an integer in milliseconds
/** @par Example:
    @code
my int $to = $sock.getRecvTimeout();
    @endcode

    @return the receive timeout socket option value as an integer in milliseconds
 */
int Socket::getRecvTimeout() [flags=CONSTANT] {
   return s->getRecvTimeout();
}

//! Returns the @ref character_encoding "character encoding" for the socket
/** @return the @ref character_encoding "character encoding" for the socket
 */
string Socket::getEncoding() [flags=CONSTANT] {
   return new QoreStringNode(s->getEncoding()->getCode());
}

//! Sets the @ref character_encoding "character encoding" for the socket
/** @param encoding the @ref character_encoding "character encoding" for the socket  
 */
nothing Socket::setEncoding(string encoding) {
   s->setEncoding(QEM.findCreate(encoding));
}

//! Returns the @ref character_encoding "character encoding" for the socket
/** A method synonym for Socket::getEncoding(), kept for backwards-compatibility
    @return the @ref character_encoding "character encoding" for the socket
 */
string Socket::getCharset() [flags=CONSTANT] {
   return new QoreStringNode(s->getEncoding()->getCode());
}
//! Sets the @ref character_encoding "character encoding" for the socket
/** A method synonym for Socket::setEncoding(), kept for backwards-compatibility
    @param encoding The @ref character_encoding "character encoding" for the socket
 */
nothing Socket::setCharset(string encoding) {
   s->setEncoding(QEM.findCreate(encoding));
}

//! Returns @ref True or @ref False depending on whether there is data to be read on the socket
/** With a timeout of zero this method returns immediately and can be used for non-blocking polling the socket for data (can also be used to poll for new connections before Socket::accept()).

    @par Example:
    @code
my bool $b = $sock.isDataAvailable();
    @endcode

    @param timeout_ms an optional timeout in milliseconds (1/1000 second); if no timeout is given, the method returns immediately; Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return @ref True if data is available on the Socket within the timeout period, @ref False if not

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end closed the connection without sending any data
 */
bool Socket::isDataAvailable(timeout timeout_ms = 0) {
   return s->isDataAvailable(xsink, (int)timeout_ms);
}

//! Returns @ref True or @ref False depending on whether all the data has been written to the socket
/** With a timeout of zero this method returns immediately.

    @par Example:
    @code
my bool $b = $sock.isWriteFinished();
    @endcode

    @param timeout_ms an optional timeout in milliseconds (1/1000 second); if no timeout is given, the method returns immediately; Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)

    @return @ref True if the send action completes within the timeout period, @ref False if not

    @throw SOCKET-NOT-OPEN The socket is not connected
    @throw SOCKET-CLOSED The remote end closed the connection without sending any data
 */
bool Socket::isWriteFinished(timeout timeout_ms = 0) {
   return s->isWriteFinished(xsink, (int)timeout_ms);
}

//! Returns @ref True if the socket is open
/** @par Example:
    @code
my bool $b = $sock.isOpen();
    @endcode

    @return @ref True if the socket is open, @ref False if not
 */
bool Socket::isOpen() [flags=CONSTANT] {
   return s->isOpen();
}

//! Returns the name of the cipher for an encrypted connection or @ref nothing if a secure connection has not been established
/** @par Example:
    @code
my *string $str = $sock.getSSLCipherName();
    @endcode

    @return the name of the cipher for an encrypted connection or @ref nothing if a secure connection has not been established
 */
*string Socket::getSSLCipherName() [flags=CONSTANT] {
   const char *str = s->getSSLCipherName();
   return str ? new QoreStringNode(str) : 0;
}

//! Returns the version string of the cipher for an encrypted connection or @ref nothing if a secure connection has not been established
/** @par Example:
    @code
my *string $str = $sock.getSSLCipherVersion();
    @endcode

    @return the version string of the cipher for an encrypted connection or @ref nothing if a secure connection has not been established
 */
*string Socket::getSSLCipherVersion() [flags=CONSTANT] {
   const char *str = s->getSSLCipherVersion();
   return str ? new QoreStringNode(str) : 0;
}

//! Returns @ref True if the connection is a secure TLS/SSL connection
/** @par Example:
    @code
my bool $b = $sock.isSecure();
    @endcode

    @return @ref True if the connection is encrypted, @ref False if not
 */
bool Socket::isSecure() [flags=CONSTANT] {
   return s->isSecure();
}

//! Returns a string code giving the result of verifying the remote certificate or @ref nothing if an encrypted connection is not currently established
/** @par Example:
    @code
my *string $str = $sock.verifyPeerCertificate();
    @endcode

    @return A string code giving the result of verifying the peer's certificate. No value is returned if a secure connection has not been established.  The set of possible return values is made up of the keys of the @ref X509_VerificationReasons hash. This hash can also be used to generate a textual description of the verification result.
 */
*string Socket::verifyPeerCertificate() [flags=CONSTANT] {
   const char *c = getSSLCVCode(s->verifyPeerCertificate());
   return c ? new QoreStringNode(c) : 0;
}

//! Sets the X.509 certificate to use for negotiating encrypted connections
/** @par Example:
    @code
$sock.setCertificate($cert);
    @endcode

    @param cert This must be an SSLCertificate object
 */
nothing Socket::setCertificate(SSLCertificate[QoreSSLCertificate] cert) {
   // pass reference from QoreObject::getReferencedPrivateData() to QoreSocketObject::setCertificate()
   s->setCertificate(cert);
}

//! Sets the X.509 certificate to use for negotiating encrypted connections from the PEM-encoded string representing the X.509 certificate
/** @par Example:
    @code
$sock.setCertificate($cert_string);
    @endcode

    @param cert_pem the PEM-encoded string representing the X.509 certificate
 */
nothing Socket::setCertificate(string cert_pem) {
   SimpleRefHolder<QoreSSLCertificate> cert(new QoreSSLCertificate(cert_pem, xsink));
   if (*xsink)
      return 0;

   // QoreSocketObject::setCertificate() takes over ownership of certificate reference
   s->setCertificate(cert.release());
}

//! Sets the X.509 certificate to use for negotiating encrypted connections from the DER-encoded binary object representing the X.509 certificate
/** @par Example:
    @code
$sock.setCertificate($cert_der);
    @endcode

    @param cert_der the DER-encoded binary object representing the X.509 certificate
 */
nothing Socket::setCertificate(binary cert_der) {
   SimpleRefHolder<QoreSSLCertificate> cert(new QoreSSLCertificate(cert_der, xsink));
   if (*xsink)
      return 0;

   // QoreSocketObject::setCertificate() takes over ownership of certificate reference
   s->setCertificate(cert.release());
}

//! Sets the private key to use for negotiating encrypted connections along with the X.509 certificate
/** @par Example:
    @code
$sock.setPrivateKey($key);
    @endcode

    @param key the private key for the X.509 certificate to use when establishing TLS/SSL encrypted connections
 */
nothing Socket::setPrivateKey(SSLPrivateKey[QoreSSLPrivateKey] key) {
   // pass reference from QoreObject::getReferencedPrivateData() to QoreSocketObject::setPrivateKey()
   s->setPrivateKey(key);
}

//! Sets the private key to use for negotiating encrypted connections along with the X.509 certificate from a PEM-encoded string representing the private key and an optional password
/** @par Example:
    @code
$sock.setPrivateKey($key_pem, $password);
    @endcode

    @param key_pem the PEM-encoded string representing the private key for the X.509 certificate to use when establishing TLS/SSL encrypted connections
    @param pass the password for the private key, if needed
 */
nothing Socket::setPrivateKey(string key_pem, *string pass) {
   SimpleRefHolder<QoreSSLPrivateKey> key(new QoreSSLPrivateKey(key_pem, pass ? pass->getBuffer() : 0, xsink));
   if (*xsink)
      return 0;

   s->setPrivateKey(key.release());
}

//! Sets the private key to use for negotiating encrypted connections along with the X.509 certificate from a DER-encoded binary object representing the private key
/** @par Example:
    @code
$sock.setPrivateKey($key_der);
    @endcode

    @param key_der the DER-encoded binary object representing the private key for the X.509 certificate to use when establishing TLS/SSL encrypted connections
 */
nothing Socket::setPrivateKey(binary key_der) {
   SimpleRefHolder<QoreSSLPrivateKey> key(new QoreSSLPrivateKey(key_der, xsink));
   if (*xsink)
      return 0;

   s->setPrivateKey(key.release());
}

//! Removes any @ref Qore::Thread::Queue "Queue" object from the Socket object so that @ref socket_events "socket events" are no longer added to the @ref Qore::Thread::Queue "Queue"
/** @par Example:
    @code
$sock.setEventQueue();
    @endcode

    @see @ref event_handling for more information
 */
nothing Socket::setEventQueue() {
   s->setEventQueue(0, xsink);
}

//! Sets a @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"
/** @par Example:
    @code
$sock.setEventQueue($queue);
    @endcode

    @param queue the @ref Qore::Thread::Queue "Queue" object to receive @ref socket_events "socket events"; note that the Queue passed cannot have any maximum size set or a QUEUE-ERROR will be thrown

    @throw QUEUE-ERROR the Queue passed has a maximum size set

    @see @ref event_handling for more information
 */
nothing Socket::setEventQueue(Queue[Queue] queue) {
   ReferenceHolder<Queue> q(queue, xsink);
   if (queue->getMax() != -1) {
      xsink->raiseException("QUEUE-ERROR", "the Queue object passed as a maximum size of %d entr%s, which could cause internal I/O to freeze in the Socket object if used; use a Queue object with no maximum size for I/O monitoring", queue->getMax(), queue->getMax() == 1 ? "y" : "ies");
      return 0;
   }
   // pass reference from QoreObject::getReferencedPrivateData() to function
   s->setEventQueue(q.release(), xsink);
}

//! Sets the boolean \c TCP_NODELAY setting for the socket
/** When this setting is @ref True, then data will be immediately sent out over the socket, when it is @ref False, then data transmission may be delayed to be packaged with other data for the same target.

    Delayed data transmissions may cause problems when the sender immediately closes the socket after sending data; in this case the receiver may not get the data even though the send succeeded.

    Note that if no value is given to the method, the argument will be assumed to be @ref True, and output buffering will be turned off for the socket.

    @par Example:
    @code
if ($sock.setNoDelay(True))
    printf("error setting TCP_NODELAY: %s\n", strerror(errno()));
    @endcode

    @param nd the boolean \c TCP_NODELAY setting for the socket

    @return 0 for success, non-zero for errors; to get error information, see errno() and strerror()

    @see Socket::getNoDelay()
 */
int Socket::setNoDelay(bool nd = True) {
   return s->setNoDelay(nd);
}

//! Returns the \c TCP_NODELAY setting for the socket
/** @par Example:
    @code
my bool $b = $sock.getNoDelay();
    @endcode

    @return the \c TCP_NODELAY setting for the socket

    @see Socket::setNoDelay() for a description of the \c TCP_NODELAY setting
 */
bool Socket::getNoDelay() [flags=CONSTANT] {
   return s->getNoDelay();
}

//! Returns a @ref socket_info_hash "hash of information" about the remote end for connected sockets
/** If the socket is not connected, an exception is thrown

    @par Example:
    @code
my hash $h = $sock.getPeerInfo();
    @endcode

    @param host_lookup do a lookup of the hostname; if this is @ref Qore::False "False" then \c "hostname" and \c "hostname_desc" are not present in the response hash

    @return a @ref socket_info_hash "hash of information" about the remote end for connected sockets

    @throw SOCKET-GETPEERINFO-ERROR Socket is not open or error in getpeername()

    @since %Qore 0.8.8 added the \a host_lookup parameter
 */
hash Socket::getPeerInfo(bool host_lookup = True) {
   return s->getPeerInfo(xsink, host_lookup);
}

//! Returns information about the local socket as a hash
/** If the socket is not open, an exception is thrown

    @par Example:
    @code
my hash $h = $sock.getSocketInfo();
    @endcode

    @param host_lookup do a lookup of the hostname; if this is @ref Qore::False "False" then \c "hostname" and \c "hostname_desc" are not present in the response hash

    @return a @ref socket_info_hash "hash of information" about the remote end for connected sockets

    @throw SOCKET-GETSOCKETINFO-ERROR Socket is not open or error in getsockname()

    @since %Qore 0.8.8 added the \a host_lookup parameter
 */
hash Socket::getSocketInfo(bool host_lookup = True) {
   return s->getSocketInfo(xsink, host_lookup);
}

//! Upgrades a client socket connection to a TLS/SSL connection
/** @par Example:
    @code
$sock.upgradeClientToSSL();
    @endcode
 */
nothing Socket::upgradeClientToSSL() {
   s->upgradeClientToSSL(xsink);
}

//! Upgrades a server socket connection to a TLS/SSL connection
/** @par Example:
    @code
$sock.upgradeServerToSSL();
    @endcode
 */
nothing Socket::upgradeServerToSSL() {
   s->upgradeServerToSSL(xsink);
}

//! Removes any warning @ref Qore::Thread::Queue "Queue" object from the Socket
/** @par Example:
    @code
$sock.clearWarningQueue();
    @endcode

    @see Socket::setWarningQueue()

    @since %Qore 0.8.9
 */
nothing Socket::clearWarningQueue() {
   s->clearWarningQueue(xsink);
}

//! Sets a @ref Qore::Thread::Queue "Queue" object to receive socket warnings
/** @par Example:
    @code
$sock.setWarningQueue(5000, 5000, $queue, "socket-1");
    @endcode

    @param warning_ms the threshold in milliseconds for individual socket actions (send, receive, connect), if exceeded, a socket warning is placed on the warning queue with the following keys:
    - \c "type": a string with the constant value \c "SOCKET-OPERATION-WARNING"
    - \c "operation": a string giving the operation that caused the warning (ex: \c "connect")
    - \c "us": an integer giving the number of microseconds for the operation
    - \c "timeout": an integer giving the warning threshold in microseconds 
    - \c "arg": if any \c "arg" argument is passed to the @ref Qore::Socket::setWarningQueue() "Socket::setWarningQueue()" method, it will be included in the warning hash here 
    @param warning_bs value in bytes per second; if any call has performance below this threshold, a socket warning is placed on the warning queue with the following keys:
    - \c "type": a string with the constant value \c "SOCKET-THROUGHPUT-WARNING"
    - \c "dir": either \c "send" or \c "recv" depending on the direction of the data flow
    - \c "bytes": the amount of bytes sent
    - \c "us": an integer giving the number of microseconds for the operation
    - \c "bytes_sec": a float giving the transfer speed in bytes per second
    - \c "threshold": an integer giving the warning threshold in bytes per second
    - \c "arg": if any \c "arg" argument is passed to the @ref Qore::Socket::setWarningQueue() "Socket::setWarningQueue()" method, it will be included in the warning hash here 
    @param queue the @ref Qore::Thread::Queue "Queue" object to receive warning events
    @param arg an optional argument to be placed in the \c "arg" key in each warning hash (could be used to identify the socket for example)
    @param min_ms the minimum transfer time with a resolution of milliseconds for a transfer to be eligible for triggering a warning; transfers that take less than this period of time are not eligible for raising a warning

    @throw QUEUE-ERROR the Queue passed has a maximum size set
    @throw SOCKET-SETWARNINGQUEUE-ERROR at least one of \a warning_ms and \a warning_bs must be > 0

    @see Socket::clearWarningQueue()

    @since %Qore 0.8.9
 */
nothing Socket::setWarningQueue(int warning_ms, int warning_bs, Queue[Queue] queue, any arg, timeout min_ms = 1s) {
   ReferenceHolder<Queue> q(queue, xsink);
   if (queue->getMax() != -1) {
      xsink->raiseException("QUEUE-ERROR", "the Queue object passed as a maximum size of %d entr%s, which could cause internal I/O to freeze in the Socket object if used; use a Queue object with no maximum size for I/O monitoring", queue->getMax(), queue->getMax() == 1 ? "y" : "ies");
      return 0;
   }
   // pass reference from QoreObject::getReferencedPrivateData() to function
   s->setWarningQueue(xsink, warning_ms, warning_bs, q.release(), arg ? arg->refSelf() : 0, min_ms);
}

//! Returns performance statistics for the socket
/** @par Example:
    @code
my hash $h = $sock.getUsageInfo();
    @endcode

    @return a hash with the following keys:
    - \c "bytes_sent": an integer giving the total amount of bytes sent
    - \c "bytes_recv": an integer giving the total amount of bytes received
    - \c "us_sent": an integer giving the total number of microseconds spent sending data
    - \c "us_recv": an integer giving the total number of microseconds spent receiving data
    - \c "arg": (only if warning values have been set with @ref Qore::Socket::setWarningQueue() "Socket::setWarningQueue()") the optional argument for warning hashes
    - \c "timeout": (only if warning values have been set with @ref Qore::Socket::setWarningQueue() "Socket::setWarningQueue()") the warning timeout in microseconds
    - \c "min_throughput": (only if warning values have been set with @ref Qore::Socket::setWarningQueue() "Socket::setWarningQueue()") the minimum warning throughput in bytes/sec

    @since %Qore 0.8.9

    @see Socket::clearStats()
 */
hash Socket::getUsageInfo() [flags=CONSTANT] {
   return s->getUsageInfo();
}

//! Clears performance statistics
/** @par Example:
    @code
$sock.clearStats();
    @endcode

    @since %Qore 0.8.9

    @see Socket::getUsageInfo()
*/
Socket::clearStats() {
   s->clearStats();
}

//! returns True if the socket is still connected, and a HTTP header was read indicating chunked transfer encoding, but no chunked body has been read yet
/** @par Example:
    @code
my bool $b = $sock.pendingHttpChunkedBody();
    @endcode

    @since %Qore 0.8.10
*/
bool Socket::pendingHttpChunkedBody() {
   return s->pendingHttpChunkedBody();
}
