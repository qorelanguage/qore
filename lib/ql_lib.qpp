/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  ql_lib.qpp

  Qore Programming Language

  Copyright (C) 2003 - 2015 David Nichols

  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

  Note that the Qore library is released under a choice of three open-source
  licenses: MIT (as above), LGPL 2+, or GPL 2+; see README-LICENSE for more
  information.
*/

#include <qore/Qore.h>
#include <qore/intern/ql_lib.h>
#include <qore/intern/ExecArgList.h>
#include <qore/intern/QoreSignal.h>
#include <qore/minitest.hpp>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/param.h>
#include <unistd.h>
#ifdef HAVE_GRP_H
#include <grp.h>
#endif

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#endif

#include <time.h>

#ifdef HAVE_GLOB_H
#include <glob.h>
#else
#include <qore/intern/glob.h>
#endif

#ifdef HAVE_SYS_TYPES
#include <sys/types.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef SIGHUP
#define SIGHUP 0
#endif

#define MAX_GIDS 100

extern bool threads_initialized;

#ifdef DEBUG_TESTS
// Unsorted unit tests are put here
#  include "tests/ReferenceHolder_tests.cpp"
#endif

AbstractQoreNode* missing_function_error(const char* func, ExceptionSink* xsink) {
   QoreString have(func);
   have.toupr();
   return xsink->raiseException("MISSING-FEATURE-ERROR", "this system does not implement %s(); for maximum portability use the constant Option::HAVE_%s to check if this function is implemented before calling", func, have.getBuffer());
}

AbstractQoreNode* missing_function_error(const char* func, const char* opt, ExceptionSink* xsink) {
   return xsink->raiseException("MISSING-FEATURE-ERROR", "this system does not implement %s(); for maximum portability use the constant Option::HAVE_%s to check if this function is implemented before calling", func, opt);
}

#ifdef DEBUG_X
static AbstractQoreNode* runQoreTests(const QoreListNode* args, ExceptionSink* xsink) {
   minitest::result res = minitest::execute_all_tests();
   if (res.all_tests_succeeded) {
      printf("Qore runtime: %d tests succeeded\n", res.sucessful_tests_count);
      return 0;
   }

   return xsink->raiseException("A Qore test failed", "Qore test in file %s, line %d threw an exception.",
                                res.failed_test_file, res.failed_test_line);
}

static AbstractQoreNode* runRecentQoreTests(const QoreListNode* args, ExceptionSink* xsink) {
   minitest::result res = minitest::test_last_changed_files(3); // 3 last modified files
   if (res.all_tests_succeeded) {
      printf("Qore runtime: %d recent tests succeeded\n", res.sucessful_tests_count);
      return 0;
   }

   return xsink->raiseException("A Qore test failed", "Qore test in file %s, line %d threw an exception.",
                                res.failed_test_file, res.failed_test_line);
}
namespace {
TEST() {
  // just an example of empty test
}
}
#endif

/** @defgroup library_functions Library Functions
    Library functions

    @section host_information_hash Host Information Hash
    |!Key|!Type|!Description
    |\c name|@ref string_type|The official fully-qualified name of the host
    |\c aliases|@ref list_type of @ref string_type|Any hostname aliases for the host
    |\c typename|@ref string_type|The type of network address (either \c "ipv4" or \c "ipv6")
    |\c type|@ref int_type|One of the @ref network_address_family_constants (either Qore::AF_INET or Qore::AF_INET6) corresponding to the type of network addresses given
    |\c len|@ref int_type|The length of the addresses in bytes when represented in binary form
    |\c addresses|@ref list_type of @ref string_type|All addresses corresponding to the host; the list should have at least 1 element

    @section address_information_hash Address Information Hash
    |!Key|!Type|!Description
    |\c address|@ref string_type|A valid address of the host, for example: \c "::1".
    |\c address_desc|@ref string_type|A descriptive string of the address containing the address family, for example: \c "ipv6[::1]"
    |\c family|@ref int_type|The network address family; see Network Address Family Constants.
    |\c familystr|@ref string_type|A descriptive string for the network address family, for example: \c "ipv6".
    |\c addrlen|@ref int_type|The length of the internal network address data structure (not normally needed in %Qore but provided anyway)
    |[\c port]|@ref int_type|The port number corresponding to the service (if applicable)
 */
//@{
//! Exits the program with the return code passed (this function does not return)
/** @param rc the return code for the process (0 = no error; success)

    @par Example:
    @code
exit(0);
    @endcode

    @see abort()
 */
nothing exit(softint rc = 0) [dom=PROCESS] {
   qore_exit_process(rc);
}

//! Aborts the current program (this function does not return)
/** This function causes the current process to terminate abnormally; a core dump or crash report may be generated if enabled

    @par Example:
    @code
abort();
    @endcode

    @see exit()
 */
nothing abort() [dom=PROCESS] {
   threads_initialized = false;
   abort();
}

//! Replaces the current process image with another; this function does not return
/** @param command the executable to execute and any command-line arguments; the command is executed internally by a call to execvp() (3)

    @par Example:
    @code
exec("/usr/bin/xterm -bg black -fg white -sb -sl 2000");
    @endcode
 */
nothing exec(string command) [dom=EXTERNAL_PROCESS,PROCESS] {
   ExecArgList exec_args(command->getBuffer());
   execvp(exec_args.getFile(), exec_args.getArgs());

   xsink->raiseErrnoException("EXEC-ERROR", errno, "execvp() failed in child process for target '%s'", exec_args.getFile());
}

//! executes a command and returns the exit code of the process
/** @par Platform Availability:
    @ref Qore::Option::HAVE_SYSTEM

    @param command the command to execute with %system() (3)

    @return the exit code of the process executed

    @par Example:
    @code
int rc = system("ls -l");
    @endcode

    @see
    - backquote()
    - @ref backquote_operator "the backquote operator"
 */
int system(string command) [dom=EXTERNAL_PROCESS] {
#if defined(HAVE_FORK) && defined(HAVE_SIGNAL_HANDLING)
   // on platforms with fork(2) and signal handling, we need to fork, enable all signals, then execvp()
   pid_t pid;
   if (!(pid = fork())) {
      // enable all signals
      sigset_t mask;
      sigemptyset(&mask);
      sigprocmask(SIG_SETMASK, &mask, 0);

      // exec pgm like system(): sh -c "command"
      execl("/bin/sh", "sh", "-c", command->getBuffer(), NULL);
      fprintf(stderr, "execvp() failed in child process for target '/bin/sh' with error code %d: %s\n", errno, strerror(errno));
      exit(-1);
      //qore_exit_process(-1);
   }
   if (pid == -1)
      return -1;

   // wait for child to exit
   int status;
   wait(&status);
   return WIFEXITED(status) ? WEXITSTATUS(status) : -1;
#elif defined(HAVE_SYSTEM)
   return system(command->getBuffer());
#else
   return missing_function_error("system", xsink);
#endif
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing system() [flags=RUNTIME_NOOP;dom=EXTERNAL_PROCESS] {
}

//! Returns the real user ID of the current process
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @return the real user ID of the current process

    @par Example:
    @code
my int $uid = getuid();
    @endcode
 */
int getuid() [dom=EXTERNAL_INFO] {
#ifdef HAVE_GETUID
   return getuid();
#else
   return missing_function_error("getuid", "UNIX_USERMGT", xsink);
#endif
}

//! Returns the effective user ID of the current process
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @return the effective user ID of the current process

    @par Example:
    @code
my int $euid = geteuid();
    @endcode
 */
int geteuid() [dom=EXTERNAL_INFO] {
#ifdef HAVE_GETEUID
   return getuid();
#else
   return missing_function_error("geteuid", "UNIX_USERMGT", xsink);
#endif
}

//! Returns the real group ID of the current process
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @return the real group ID of the current process

    @par Example:
    @code
my int $gid = getgid();
    @endcode
 */
int getgid() [dom=EXTERNAL_INFO] {
#ifdef HAVE_GETGID
   return getgid();
#else
   return missing_function_error("getgid", "UNIX_USERMGT", xsink);
#endif
}

//! Returns the effective group ID of the current process
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @return the effective group ID of the current process

    @par Example:
    @code
my int $egid = getegid();
    @endcode
 */
int getegid() [dom=EXTERNAL_INFO] {
#ifdef HAVE_GETEGID
   return getgid();
#else
   return missing_function_error("getegid", "UNIX_USERMGT", xsink);
#endif
}

//! returns a list of group IDs that the user is a member of
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @par Example:
    @code
my list $l = getgroups();
    @endcode

    @return a list of group IDs that the user is a member of

    @since %Qore 0.8.11.1
*/
list getgroups() [dom=EXTERNAL_INFO] {
#ifdef HAVE_GETGROUPS
   gid_t l[MAX_GIDS];

   int n = getgroups(MAX_GIDS, l);
   if (n == -1)
      return xsink->raiseErrnoException("GETGROUPS-ERROR", errno, "error calling getgroups()");

   QoreListNode* rv = new QoreListNode;
   for (int i = 0; i < n; ++i)
      rv->push(new QoreBigIntNode(l[i]));
   return rv;
#else
   missing_function_error("getgroups", "UNIX_USERMGT", xsink);
#endif
}

//! sets the list of supplementary group IDs for the current process
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @par Example:
    @code
setgroups($l);
    @endcode

    @param gids a list of supplementary group IDs for the current process

    @since %Qore 0.8.11.1
*/
nothing setgroups(softlist gids) [dom=PROCESS] {
#ifdef HAVE_SETGROUPS
   if (gids->empty())
      return QoreValue();

#ifdef HAVE_LOCAL_VARIADIC_ARRAYS_X
   gid_t l[gids->size()];
#else
   gid_t* l = (gid_t*)malloc(sizeof(gid_t) * gids->size());
   if (!l) {
      xsink->outOfMemory();
      return QoreValue();
   }
   ON_BLOCK_EXIT(free, l);
#endif
   for (qore_size_t i = 0, e = gids->size(); i < e; ++i) {
      const AbstractQoreNode* n = gids->retrieve_entry(i);
      l[i] = n ? n->getAsInt() : 0;
   }
   if (setgroups(gids->size(), l))
      xsink->raiseErrnoException("SETGROUPS-ERROR", errno, "error calling setgroups()");
#else
   missing_function_error("setgroups", "UNIX_USERMGT", xsink);
#endif
}

//! Causes the current thread to sleep for a certain number of seconds
/** @param seconds The amount of time in seconds to sleep; integer arguments are interpreted literally as a number of seconds to sleep, however a @ref relative_dates "relative date/time value" can be given instead of an integer to make the source more readable (ex: \c 5s), however as this function only supports a resolution of 1 second, milliseconds and microseconds are ignored if passed in a @ref relative_dates "relative date/time value"

    @return should always return 0 for success

    @par Example:
    @code
sleep(10s);
    @endcode

    @see usleep() for a similar function supporting microsecond resolution
 */
int sleep(softint seconds) [dom=PROCESS] {
   if (!seconds)
      return 0;

   return qore_usleep(seconds * 1000000ll);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing sleep() [flags=RUNTIME_NOOP;dom=PROCESS] {
}

//! Causes the current thread to sleep for a certain number of microseconds
/** @param usecs The amount of time in microseconds to sleep; integer arguments are interpreted literally as a number of microseconds to sleep

    @return should always return 0 for success

    @par Example:
    @code
usleep(5000);
    @endcode

    @see sleep() for a similar function supporting second resolution

    @note both sleep() and usleep() are implemented internally by calls to nanosleep() (2) if available on the current platform, otherwise both are implemented by calls to usleep() (3)
 */
int usleep(softint usecs) [dom=PROCESS] {
   if (!usecs)
      return 0;

   return qore_usleep(usecs);
}

//! Causes the current thread to sleep for a certain number of microseconds
/** @param d A time value giving the amount of time in microseconds to sleep; this should be a @ref relative_dates "relative date/time value" to make the source more readable (ex: \c 250ms)

    @return should always return 0 for success

    @par Example:
    @code
usleep(250ms);
    @endcode

    @see sleep() for a similar function supporting second resolution

    @note both sleep() and usleep() are implemented internally by calls to nanosleep() (2) if available on the current platform, otherwise both are implemented by calls to usleep() (3)
 */
int usleep(date d) [dom=PROCESS] {
   return qore_usleep(d->getRelativeMicroseconds());
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing usleep() [flags=RUNTIME_NOOP;dom=PROCESS] {
}

//! Returns the PID (process ID) of the current process
/** @return the PID (process ID) of the current process

    @par Example:
    @code
my int $pid = getpid();
    @endcode
 */
int getpid() [flags=RET_VALUE_ONLY;dom=EXTERNAL_INFO] {
   return getpid();
}

//! Returns the PID (process ID) of the parent process of the current process
/** @par Platform Availability:
    @ref Qore::Option::HAVE_GETPPID

    @return the PID (process ID) of the parent process of the current process

    @par Example:
    @code
my int $ppid = HAVE_GETPPID ? getppid() : -1;
    @endcode
 */
int getppid() [flags=RET_VALUE_ONLY;dom=EXTERNAL_INFO] {
#ifdef HAVE_GETPPID
   return getppid();
#else
   return missing_function_error("getppid", xsink);
#endif
}

//! Creates a copy of the current process with a new PID; returns 0 in the child process; returns the child's PID in the parent process
/** This function will throw an \c ILLEGAL-FORK exception if more than one thread is running

    @par Platform Availability:
    @ref Qore::Option::HAVE_FORK

    @return 0 in the child process; returns the child's PID in the parent process; if an error occurs, then -1 is returned, in this case no child process was started and the error number can be retrieved with the errno() function

    @par Example:
    @code
my int $pid;
if ($pid = fork())
    printf("child has PID %d\n", $pid);
    @endcode

    @throw ILLEGAL-FORK Cannot fork if more than one thread is running

    @note
    - after a fork(), the only safe call is @ref exec(), many system calls are not async-signal safe, including pthread_create() which is
      used to start new threads.
    - the %Qore process will crash if unsafe operations are called after a fork()
    - the signal-handling thread cannot be reliably started on many platforms (ex: FreeBSD) after a fork(), therefore signal handling
      is disabled in the child process after a fork()
    - on Darwin (OS/X) threading primitives are unusable in the child process after a fork()
 */
int fork() [dom=PROCESS] {
#ifdef HAVE_FORK
#ifdef HAVE_SIGNAL_HANDLING
   int QORE_THREAD_LIMIT = 1 + (QSM.thread_running ? 1 : 0);
#else
#define QORE_THREAD_LIMIT 1
#endif
   if (thread_list.getNumThreads() > (unsigned)(QORE_THREAD_LIMIT))
      return xsink->raiseException("ILLEGAL-FORK", "cannot fork() when other threads are running");

#ifdef HAVE_SIGNAL_HANDLING
   // we may not fork from within a signal handler
   if (QSM.thread_running && gettid() == QSM.gettid())
      return xsink->raiseException("ILLEGAL-FORK", "cannot fork() within a signal handler");

   // stop signal handling thread and make sure it can't be restarted until fork is done
   QSM.preFork();
#endif

   //printd(5, "stopped signal thread, about to fork pid %d\n", getpid()); fflush(stdout);
   int pid = fork();

#ifdef HAVE_SIGNAL_HANDLING
   // release signal handler lock
   QSM.postFork(!pid, xsink);
#endif

   return pid;
#else
   return missing_function_error("fork", xsink);
#endif
}

//! Sends a signal to a process, if no signal number is given, then Qore::SIGHUP is sent by default
/** @par Platform Availability:
    @ref Qore::Option::HAVE_KILL

    @param pid the pid argument can have the following interpretations:
    - <tt>\> 0</tt>: the signal is sent to the process ID given
    - \c 0: the signal is sent to all processes whose group ID is equal to the process group ID of the sender, and for which the process has permission
    - \c -1: if the user has super-user privileges, the signal is sent to all processes excluding system processes and the process sending the signal.  If the user is not the super user, the signal is sent to all processes with the same uid as the user, excluding the process sending the signal.  No error is returned if any process could be signaled.
    @param sig the @ref signal_constants "signal number" to send to the process or processes

    @return 0 means success (no error), or -1 meaning an error occurred; in this case check errno() for the error

    @par Example:
    @code
if (kill($pid, SIGTERM))
    printf("error sending signal to pid %d: %s\n", $pid, strerror());
    @endcode
 */
int kill(softint pid, softint sig = SIGHUP) [dom=EXTERNAL_PROCESS] {
#ifdef HAVE_KILL
   return kill(pid, sig);
#else
   return missing_function_error("kill", xsink);
#endif
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing kill() [flags=RUNTIME_NOOP;dom=EXTERNAL_PROCESS] {
}

//! Returns a random 64-bit integer number
/** This function uses the C library function random() to generate the number if available on the current platform, otherwise uses %rand().

    @return a random 64-bit integer number

    @par Example:
    @code
my int $num = rand();
    @endcode

    @see srand() for a function to seed the random number generator
 */
int rand() [flags=CONSTANT] {
#ifdef HAVE_RANDOM
   // return a random 64-bit integer by calling random() twice
   return random() | (((int64)random()) << 32);
#else
   return rand() | (((int64)rand()) << 32);
#endif
}

//! Seeds the random number generator with the integer passed
/** This function uses the C library function srandom() if available on the current platform, otherwise uses %srand()

    @param seed the seed for the random number generator (only the least-significant 32-bits are used)

    @par Example:
    @code
srand(now());
    @endcode
 */
nothing srand(softint seed) [dom=PROCESS] {
#ifdef HAVE_RANDOM
   srandom((int)seed);
#else
   srand((int)seed);
#endif
   return QoreValue();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing srand() [flags=RUNTIME_NOOP;dom=PROCESS] {
}

//! Returns the hostname of the system
/** @return the hostname of the system

    @par Example:
    @code
my string $host = gethostname();
    @endcode
 */
string gethostname() [flags=CONSTANT;dom=EXTERNAL_INFO] {
   char buf[HOSTNAMEBUFSIZE + 1];

   if (gethostname(buf, HOSTNAMEBUFSIZE))
      return xsink->raiseErrnoException("GETHOSTNAME-ERROR", errno, "gethostname() failed");
   return new QoreStringNode(buf);
}

//! Returns the error code of the last error that occurred in the current thread
/** @return the error code of the last error that occurred in the current thread (see @ref error_constants for possible error code values)

    @par Example:
    @code
if (unlink($path))
    printf("%s: %s\n", $path, strerror(errno()));
    @endcode

    @see strerror() for a function that gives the string description for the error number returned by this function
 */
int errno() {
   return errno;
}

//! Returns the string corresponding to the error code passed (generally retrieved with errno())
/** @param err the error code to retrieve the description for (generally provided by errno())

    @return the string corresponding to the error code passed; if the error code is unknown, then a string like \c "Unknown error: -1" is returned

    @par Example:
    @code
if (unlink($path))
    printf("%s: %s\n", $path, strerror(errno()));
    @endcode
 */
string strerror(softint err) [flags=CONSTANT] {
   return q_strerror(err);
}

//! Returns the string corresponding to the last error that occurred in the current thread
/** @return the string corresponding to the last error that occurred in the current thread

    @par Example:
    @code
if (unlink($path))
    printf("%s: %s\n", $path, strerror());
    @endcode

    @since %Qore 0.8.4 this variant of the function automatically uses the last error value for the current thread
 */
string strerror() [flags=CONSTANT] {
   return q_strerror(errno);
}

//! Returns a string giving the last element of a file path (meant to be the filename)
/** @param path the path to process

    @return a string giving the last element of the given file path (meant to be the filename)

    @par Example:
    @code
my string $fn = basename("/usr/local/bin/file_name");
    @endcode

    @see dirname()
 */
string basename(string path) [flags=CONSTANT] {
   char* p = q_basename(path->getBuffer());
   int len = strlen(p);
   return new QoreStringNode(p, len, len + 1, path->getEncoding());
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing basename() [flags=RUNTIME_NOOP] {
}

//! Returns a string giving the path up to a file but not the filename itself
/** @param path the path to process

    @return a string giving the path up to a file but not the filename itself; if no directory separator characters can be found in the path, \c "." is returned (meaning the current directory)

    @par Example:
    @code
my string $dir = dirname("/usr/local/bin/file_name");
    @endcode

    @see basename()
 */
string dirname(string path) [flags=CONSTANT] {
   char* p = q_dirname(path->getBuffer());
   int len = strlen(p);
   return new QoreStringNode(p, len, len + 1, path->getEncoding());
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing dirname() [flags=RUNTIME_NOOP] {
}

//! Changes the process user ID according to the argument passed
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @param uid the user ID to set

    @return 0 if no error occurred; -1 if an error occurred, in which case errno() and/or strerror() can be used to retrieve the error

    @par Example:
    @code
if (setuid($uid))
    printf("setuid %d: %s\n", $uid, strerror());
    @endcode
 */
int setuid(softint uid) [dom=PROCESS] {
#ifdef HAVE_SETUID
   return setuid((int)uid);
#else
   return missing_function_error("setuid", "UNIX_USERMGT", xsink);
#endif
}

//! Changes the effective process user ID according to the argument passed
/** @par Platform Availability:
    @ref Qore::Option::HAVE_SETEUID

    @param uid the user ID to set

    @return 0 if no error occurred; -1 if an error occurred, in which case errno() and/or strerror() can be used to retrieve the error

    @par Example:
    @code
if (seteuid($uid))
    printf("seteuid %d: %s\n", $uid, strerror());
    @endcode
 */
int seteuid(softint uid) [dom=PROCESS] {
#ifdef HAVE_SETEUID
   return seteuid((int)uid);
#else
   return missing_function_error("seteuid", xsink);
#endif
}

//! Changes the process group ID according to the argument passed
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @param gid the group ID to set

    @return 0 if no error occurred; -1 if an error occurred, in which case errno() and/or strerror() can be used to retrieve the error

    @par Example:
    @code
if (setgid($gid))
    printf("setgid %d: %s\n", $gid, strerror());
    @endcode
 */
int setgid(softint gid) [dom=PROCESS] {
#ifdef HAVE_SETGID
   return setgid((int)gid);
#else
   return missing_function_error("setgid", "UNIX_USERMGT", xsink);
#endif
}

//! Changes the process effective group ID according to the argument passed
/** @par Platform Availability:
    @ref Qore::Option::HAVE_UNIX_USERMGT

    @param gid the group ID to set

    @return 0 if no error occurred; -1 if an error occurred, in which case errno() and/or strerror() can be used to retrieve the error

    @par Example:
    @code
if (setegid($gid))
    printf("setegid %d: %s\n", $gid, strerror());
    @endcode
 */
int setegid(softint gid) [dom=PROCESS] {
#ifdef HAVE_SETEGID
   return setegid((int)gid);
#else
   return missing_function_error("setegid", xsink);
#endif
}

//! Creates a new session lead by the calling process
/** The calling process is the session leader of the new session, is the process group leader of a new process group and has no controlling terminal. The calling process is the only process in either the session or the process group.

    @return Upon successful completion, the setsid() function returns the value of the process group ID of the new process group, which is the same as the process ID of the calling process; if an error occurs, setsid() returns -1 and errno() and/or strerror() can be used to check the error.

    @par Example:
    @code
if (setsid() == -1)
    printf("setsid(): %s\n", strerror());
    @endcode
 */
int setsid() [dom=PROCESS] {
#ifdef HAVE_SETSID
   return setsid();
#else
   return missing_function_error("setsid", xsink);
#endif
}

//! Returns the first address corresponding to the hostname passed as an argument or @ref nothing if the lookup fails
/** @param name the name to look up

    @return the first address corresponding to the hostname passed as an argument or @ref nothing if the lookup fails

    @par Example:
    @code
my *string $addr = gethostbyname($host);
if (!exists $host)
    printf("address lookup on %y failed; hostname unknown\n", $host);
    @endcode

    @see gethostbyname_long() for a version of this function that returns all host information, including all hostname aliases and all addresses
 */
*string gethostbyname(string name) [flags=CONSTANT;dom=EXTERNAL_INFO] {
   return q_gethostbyname_to_string(name->getBuffer());
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing gethostbyname() [flags=RUNTIME_NOOP] {
}

//! Returns the official hostname corresponding to the network addressed passed as an argument
/** If the address family is invalid or the address string is not a valid address for the given family a \c GETHOSTBYADDR-ERROR exception will be thrown.

    @param addr the address to look up
    @param type the network address family; see @ref network_address_family_constants for valid values

    @return the official hostname corresponding to the network addressed passed as an argument

    @par Example:
    @code
my *string $hostname = gethostbyaddr("192.168.0.33");
if (!exists $hostname)
    printf("address lookup on 192.168.0.33 failed\n", $host);
    @endcode

    @throw GETHOSTBYADDR-ERROR invalid address for the given family or invalid address family

    @see gethostbyaddr_long() for a version of this function that returns all host information, including all hostname aliases and all addresses
 */
*string gethostbyaddr(string addr, softint type = AF_INET) [flags=CONSTANT;dom=EXTERNAL_INFO] {
   return q_gethostbyaddr_to_string(xsink, addr->getBuffer(), type);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing gethostbyaddr() [flags=RUNTIME_NOOP] {
}

//! Returns @ref host_information_hash "a hash" representing all host and address information corresponding to the hostname passed as an argument
/**
    @param name the name to look up

    @return @ref host_information_hash "a hash" representing all host and address information corresponding to the hostname passed as an argument

    @par Example:
    @code
my *hash $ah = gethostbyname_long($host);
if (!exists $host)
    printf("address lookup on %y failed; hostname unknown\n", $host);
    @endcode

    @see gethostbyname() for a version of this function that returns just the first network address corresponding to the hostname
 */
*hash gethostbyname_long(string name) [flags=CONSTANT;dom=EXTERNAL_INFO] {
   return q_gethostbyname_to_hash(name->getBuffer());
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing gethostbyname_long() [flags=RUNTIME_NOOP] {
}

//! Returns @ref host_information_hash "a hash" representing all host and address information corresponding to the address and address type passed as arguments
/** If the address family is invalid or the address string is not a valid address for the given family a \c GETHOSTBYADDR-ERROR exception will be thrown.

    @param addr the address to look up
    @param type the network address family; see @ref network_address_family_constants for valid values

    @return @ref host_information_hash "a hash" representing all host and address information corresponding to the address and address type passed as arguments

    @par Example:
    @code
my *hash $ah = gethostbyaddr_long("192.168.0.33");
if (!exists $ah)
    printf("address lookup on 192.168.0.33 failed\n", $host);
    @endcode

    @throw GETHOSTBYADDR-ERROR invalid address for the given family or invalid address family

    @see gethostbyaddr() for a simpler version of this function that returns just a single hostname for the address
 */
*hash gethostbyaddr_long(string addr, softint type = AF_INET) [flags=CONSTANT;dom=EXTERNAL_INFO] {
   return q_gethostbyaddr_to_hash(xsink, addr->getBuffer(), type);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/**
 */
nothing gethostbyaddr_long() [flags=RUNTIME_NOOP] {
}

//! Returns a list of @ref address_information_hash for the given node name or string address; if no lookup can be performed then an exception is thrown
/** Either node or service may be @ref nothing but not both or a \c QOREADDRINFO-GETINFO-ERROR exception will be thrown

    @param node The host name or node name to look up
    @param service The service name to look up to a port number
    @param family The @ref network_address_family_constants "address family" for the lookup, must be one of Qore::AF_INET, Qore::AF_INET6, or Qore::AF_UNSPEC, meaning to return all possible addresses
    @param flags see @ref network_address_information_constants for possible values to be combined with @ref bitwise_or_operator "binary or"

    @return a list of @ref address_information_hash for the given node name or string address; if no lookup can be performed then an exception is thrown

    @par Example:
    @code
my list $l = getaddrinfo("localhost");
    @endcode

    @throw QOREADDRINFO-GETINFO-ERROR nodename nor servname provided, or not known
 */
list getaddrinfo(*string node, *softstring service, softint family = AF_UNSPEC, softint flags = 0) [flags=RET_VALUE_ONLY;dom=EXTERNAL_INFO] {
   return q_getaddrinfo_to_list(xsink, node ? node->getBuffer() : 0, service ? service->getBuffer() : 0, (int)family, (int)flags);
}

//! closes all possible file descriptors; useful in "daemon" processes that may have inherited open file descriptors
/** @par Platform Availability:
    @ref Qore::Option::HAVE_CLOSE_ALL_FD

    @param strd if @ref Qore::True "True" then also stdin, stdout, and stderr are closed, otherwise fds > 2 are closed

    @par Example:
    @code
close_all_fd();
    @endcode

    @note if there are file descriptors open by Qore when this function is called, this function will also close those file descriptors; normally this function should only be used when starting a new process after a fork() and exec() to close any inherited descriptors, for example
 */
nothing close_all_fd(*softbool strd) [dom=PROCESS] {
#if defined(HAVE_UNISTD_H) && defined(_SC_OPEN_MAX)
   int start = strd ? 0 : 2;
   // get max file descriptor
   int max = (int)sysconf(_SC_OPEN_MAX);
   printd(5, "close_all_fd() start: %d max: %d\n", start, max);

   for (;start < max; ++start)
      close(start);
#else
   missing_function_error("close_all_fd", xsink);
#endif // HAVE_UNISTD
}
//@}
