/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  ql_crypto.qpp

  Qore Programming Language

  Copyright (C) 2003 - 2015 David Nichols

  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

  Note that the Qore library is released under a choice of three open-source
  licenses: MIT (as above), LGPL 2+, or GPL 2+; see README-LICENSE for more
  information.
*/

#include <qore/Qore.h>
#include <qore/intern/ql_crypto.h>

#include <stdio.h>
#include <stdlib.h>

#define QCRYPTO_DECRYPT 0
#define QCRYPTO_ENCRYPT 1

// NOTE: the trailing null ('\0') is not included when encrypting strings or calculating digests

// default initialization vector
static unsigned char def_iv[] = { 0, 0, 0, 0, 0, 0, 0, 0 };

/*
#define MD2_ERR "MD2-DIGEST-ERROR"
#define MD4_ERR "MD4-DIGEST-ERROR"
#define MD5_ERR "MD5-DIGEST-ERROR"
#define SHA_ERR "SHA-DIGEST-ERROR"
#define SHA1_ERR "SHA1-DIGEST-ERROR"
static const char SHA224_ERR[] = "SHA224-DIGEST-ERROR";
static const char SHA256_ERR[] = "SHA256-DIGEST-ERROR";
static const char SHA384_ERR[] = "SHA384-DIGEST-ERROR";
static const char SHA512_ERR[] = "SHA512-DIGEST-ERROR";
#define DSS_ERR "DSS-DIGEST-ERROR"
#define DSS1_ERR "DSS1-DIGEST-ERROR"
static const char MDC2_ERR[] = "MDC2-DIGEST-ERROR";
#define RIPEMD160_ERR "RIPEMD160-DIGEST-ERROR"
*/

class CryptoHelper : public BaseHelper {
private:
   unsigned char *iv, *output;
   int output_len;
   const QoreEncoding* qe;

   DLLLOCAL const char *getOrdinal(int n) {
      assert(n > 0 && n <= 3);
      return n == 1 ? "first" : (n == 2 ? "second" : "third");
   }

   DLLLOCAL void setKey(const QoreValueList *args, int n) {
      assert(n > 0 && n <= 3);
      const QoreValue pt = get_param_value(args, n);
      if (pt.getType() == NT_STRING) {
	 const QoreStringNode* str = pt.get<const QoreStringNode>();
	 key[n - 1] = (unsigned char*)str->getBuffer();
	 keylen[n - 1] = str->strlen();
	 return;
      }

      const BinaryNode* b = pt.get<const BinaryNode>();
      key[n - 1] = (unsigned char*)b->getPtr();
      keylen[n - 1] = b->size();
   }

   DLLLOCAL void setEncoding(const QoreValueList* args, int n) {
      QoreValue qv = get_param_value(args, n);
      qe = qv.getType() == NT_STRING ? QEM.findCreate(qv.get<const QoreStringNode>()) : QCS_DEFAULT;
   }

   // set the initialization vector (used with hard typing)
   DLLLOCAL int setIV(const char *err, const QoreValue pt, ExceptionSink *xsink) {
      assert(!pt.isNothing());
      if (pt.getType() == NT_STRING) {
	 const QoreStringNode* str = pt.get<const QoreStringNode>();
	 if (str->strlen() < 8) {
	    xsink->raiseException(err, "the input vector must be at least 8 bytes long (%d bytes passed)", str->strlen());
	    return -1;
	 }
	 iv = (unsigned char*)str->getBuffer();
	 return 0;
      }

      assert(pt.getType() == NT_BINARY);
      const BinaryNode* b = pt.get<const BinaryNode>();
      if (b->size() < 8) {
	 xsink->raiseException(err, "the input vector must be at least 8 bytes long (%d bytes passed)", b->size());
	 return -1;
      }
      iv = (unsigned char*)b->getPtr();
      return 0;
   }

public:
   unsigned char *key[3];
   int keylen[3];

   DLLLOCAL CryptoHelper() : iv(0), output(0), output_len(0), qe(QCS_DEFAULT) {
   }

   DLLLOCAL ~CryptoHelper() {
      if (output)
	 free(output);
   }

   DLLLOCAL BinaryNode *getBinary() {
      BinaryNode *b = new BinaryNode(output, output_len);
      output = 0;
      return b;
   }

   DLLLOCAL QoreStringNode *getString(const QoreEncoding *enc = QCS_DEFAULT) {
      // create the string
      QoreStringNode *str = new QoreStringNode((char *)output, output_len, output_len, enc);
      // add trailing '\0'
      str->terminate(output_len);

      output = 0;
      return str;
   }

   DLLLOCAL int setSingleKey(const char *err, const QoreValueList *params, ExceptionSink *xsink, bool has_encoding = false) {
      if (setIV(err, get_param_value(params, 2), xsink))
	 return -1;

      setInput(get_param_value(params, 0));
      setKey(params, 1);
      if (has_encoding)
	 setEncoding(params, 2);
      return 0;
   }

   DLLLOCAL int doCipher(const EVP_CIPHER *type, const char *cipher, int do_crypt, ExceptionSink *xsink) {
      const char *err = (do_crypt ? "ENCRYPT-ERROR" : "DECRYPT-ERROR");

      EVP_CIPHER_CTX ctx;
      EVP_CIPHER_CTX_init(&ctx);
      EVP_CipherInit_ex(&ctx, type, 0, 0, 0, do_crypt);
      if (key[0]) {
	 if (keylen[0] > EVP_MAX_KEY_LENGTH)
	    keylen[0] = EVP_MAX_KEY_LENGTH;

	 if (!EVP_CIPHER_CTX_set_key_length(&ctx, keylen[0]) || !EVP_CipherInit_ex(&ctx, 0, 0, key[0], iv, -1)) {
	    xsink->raiseException(err, "error setting %s key length=%d", cipher, keylen[0]);
	    EVP_CIPHER_CTX_cleanup(&ctx);
	    return -1;
	 }
      }

      // we allocate 1 byte more than we need in case we return as a string so we can terminate it
      output = (unsigned char *)malloc(sizeof(char) * (input_len + (EVP_MAX_BLOCK_LENGTH * 2)));

      if (!EVP_CipherUpdate(&ctx, output, &output_len, input, input_len)) {
	 xsink->raiseException(err, "error %scrypting %s block", do_crypt ? "en" : "de", cipher);
	 EVP_CIPHER_CTX_cleanup(&ctx);
	 return -1;
      }

      int tmplen;
      // Buffer passed to EVP_EncryptFinal() must be after data just encrypted to avoid overwriting it.
      if (!EVP_CipherFinal_ex(&ctx, output + output_len, &tmplen)) {
	 xsink->raiseException(err, "error %scrypting final %s block", do_crypt ? "en" : "de", cipher);
	 EVP_CIPHER_CTX_cleanup(&ctx);
	 return -1;
      }

      EVP_CIPHER_CTX_cleanup(&ctx);
      output_len += tmplen;
      //printd(5, "cipher_intern() %s: in=%p (%d) out=%p (%d)\n", cipher, buf, len, cbuf, *size);
      return 0;
   }

   DLLLOCAL int checkKeyLen(const char *err, int n, int len, ExceptionSink *xsink) {
      if (keylen[n] < len) {
	 xsink->raiseException(err, "key length is not %d bytes long (%d bytes)", len, keylen[n]);
	 return -1;
      }
      keylen[n] = len;
      return 0;
   }

/*
   DLLLOCAL int setDESKey(int n, ExceptionSink *xsink) {
      // force odd parity
      //DES_set_odd_parity((DES_cblock *)key[n]);
      // populate the schedule structure
      //DES_set_key_unchecked((DES_cblock *)key[n], schedule);
      //key[n] = (unsigned char *)schedule;
      return 0;
   }
*/
};

AbstractQoreNode* missing_openssl_feature(const char *f, ExceptionSink *xsink) {
   return xsink->raiseException("MISSING-FEATURE-ERROR", "the openssl library version that qore was compiled with did not support the %s algorithm; for maximum portability, check Option::HAVE_%s before calling this function", f, f);
}

//! @qppinit: SimpleRefHolder<BinaryNode> DefaultIV(new BinaryNode); DefaultIV->append(def_iv, 8);
//! @qppval: Qore::DefaultIV=DefaultIV->refSelf()

/** @defgroup cryptographic_constants Crytographic Contants
    Cryptographic constants
 */
//@{
//! The default initialization vector is simply a 8-byte string of nulls
const DefaultIV = <0000000000000000>;
//@}

/** @defgroup cryptographic_functions Crytographic Functions
    %Qore's cryptography support is provided by the OpenSSL library. Each of the encryption and decryption functions in this section accept an optional initialization vector, which is data used as initial input for the first block in chained encryption algorithms. Subsequent blocks take input from the last block encrypted/decrypted. If an initialization vector is not supplied, a default value of 8 zero bytes will be used (see @ref Qore::DefaultIV).

    See also:
        - @ref digest_functions
        - @ref hmac_functions
        - @ref cryptographic_constants

    Some functions require fixed-length keys, and some allow the use of variable-length keys. For functions requiring fixed-length keys any excess bytes are ignored. The same applies to initialization vector arguments.

    The following is an example of a function that uses \c /dev/random on UNIX to read in a random key for use with encryption functions:

    @code{.py}
# read a key from /dev/random and return the key
binary sub get_key(int size) {
    # throw an exception if an invalid key size was passed
    if (!size || size < 0)
        throw "GET-KEY-ERROR", sprintf("invalid size = %n", size);
    File f();
    # File::open2() will throw an exception if /dev/random cannot be opened for reading
    f.open2("/dev/random");
    return f.readBinary(size);
}
    @endcode
 */
//@{

//! Returns a binary object of a random key for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a>
/** @return a binary object of a random key for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a>

    @par Example:
    @code{.py}
binary bin = des_random_key();
    @endcode
 */
binary des_random_key() [flags=CONSTANT] [flags=CONSTANT] {
   DES_cblock *db = (DES_cblock *)malloc(sizeof(DES_cblock));
   DES_random_key(db);
   return new BinaryNode(db, sizeof(DES_cblock));
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.counterpane.com/blowfish.html">blowfish algorithm</a>
/** @param data the data to be encrypted
    @param key a variable-length key (recommended 16 bytes or more)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = blowfish_encrypt_cbc(data, key);
    @endcode

    @throw BLOWFISH-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary blowfish_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("BLOWFISH-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_bf_cbc(), "blowfish", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.counterpane.com/blowfish.html">blowfish algorithm</a> and returns a binary object of the decrypted data
/** @param data the data to be decrypted
    @param key a variable-length key (recommended 16 bytes or more)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = blowfish_decrypt_cbc(data, key);
    @endcode

    @throw BLOWFISH-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary blowfish_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("BLOWFISH-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_bf_cbc(), "blowfish", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.counterpane.com/blowfish.html">blowfish algorithm</a> and returns a string of the decrypted data
/** @param data the data to be decrypted
    @param key a variable-length key (recommended 16 bytes or more)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string str = blowfish_decrypt_cbc_to_string(data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw BLOWFISH-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string blowfish_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("BLOWFISH-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_bf_cbc(), "blowfish", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using an 8-byte key
/** @param data the data to be encrypted
    @param key the encryption key must be at least 8 bytes long (only the first 8 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = des_encrypt_cbc(data, key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary des_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 8, xsink)
       || ch.doCipher(EVP_des_cbc(), "DES", QCRYPTO_ENCRYPT, xsink))
	    return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using an 8-byte key
/** @param data the data to be decrypted
    @param key the decryption key must be at least 8 bytes long (only the first 8 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = des_decrypt_cbc(data, key);
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary des_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 8, xsink)
       || ch.doCipher(EVP_des_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
	    return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using an 8-byte key
/** @param data the data to be decrypted
    @param key the decryption key must be at least 8 bytes long (only the first 8 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string bin = des_decrypt_cbc_to_string(data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string des_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 8, xsink)
       || ch.doCipher(EVP_des_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
	    return QoreValue();

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the two-key triple DES algorithm using two eight-byte keys (set by a single 16-byte key argument)
/** @param data the data to be encrypted
    @param key the encryption key must be at least 16 bytes long (only the first 16 bytes will be used for the two 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = des_ede_encrypt_cbc(data, key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary des_ede_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 16, xsink)
       || ch.doCipher(EVP_des_ede_cbc(), "DES", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the two-key triple DES algorithm using two eight-byte keys (set by a single 16-byte key argument)
/** @param data the data to be decrypted
    @param key the decryption key must be at least 16 bytes long (only the first 16 bytes will be used for the two 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = des_ede_decrypt_cbc(data, key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary des_ede_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 16, xsink)
       || ch.doCipher(EVP_des_ede_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the two-key triple DES algorithm using two eight-byte keys (set by a single 16-byte key argument)
/** @param data the data to be decrypted
    @param key the decryption key must be at least 16 bytes long (only the first 16 bytes will be used for the two 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string bin = des_ede_decrypt_cbc_to_string(data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string des_ede_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 16, xsink)
       || ch.doCipher(EVP_des_ede_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the three-key triple <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using three 8-byte keys (set by a single 24-byte key argument) and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key the encryption key must be at least 24 bytes long (only the first 24 bytes will be used for the three 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = des_ede3_encrypt_cbc(data, key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary des_ede3_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_des_ede3_cbc(), "DES", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the three-key triple <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using three 8-byte keys (set by a single 24-byte key argument) and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used for the three 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = des_ede3_decrypt_cbc(data, key);
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary des_ede3_decrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_des_ede3_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the three-key triple <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using three 8-byte keys (set by a single 24-byte key argument) and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used for the three 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string bin = des_ede3_decrypt_cbc_to_string(data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string des_ede3_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_des_ede3_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://www.rsasecurity.com/">DESX algorithm</a> using a 24-byte key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key the encryption key must be at least 24 bytes long (only the first 24 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = desx_encrypt_cbc(data, key);
    @endcode

    @throw DESX-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DESX-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary desx_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DESX-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DESX-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_desx_cbc(), "DESX", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://www.rsasecurity.com/">DESX algorithm</a> using a 24-byte key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = desx_decrypt_cbc(data, key);
    @endcode

    @throw DESX-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DESX-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary desx_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DESX-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.checkKeyLen("DESX-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_desx_cbc(), "DESX", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://www.rsasecurity.com/">DESX algorithm</a> using a 24-byte key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
string str = desx_decrypt_cbc_to_string(data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw DESX-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DESX-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string desx_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("DESX-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.checkKeyLen("DESX-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_desx_cbc(), "DESX", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
}

//! Encrypts data using the Alleged <a href="http://en.wikipedia.org/wiki/RC4">RC4 cipher algorithm</a>, which should be compatible with RSA's RC4(tm) algorithm using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = rc4_encrypt(data, key);
    @endcode

    @throw RC4-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary rc4_encrypt(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("RC4-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc4(), "rc4", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the Alleged <a href="http://en.wikipedia.org/wiki/RC4">RC4 cipher algorithm</a>, which should be compatible with RSA's RC4(tm) algorithm using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = rc4_decrypt(data, key);
    @endcode

    @throw RC4-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary rc4_decrypt(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("RC4-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc4(), "rc4", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the Alleged <a href="http://en.wikipedia.org/wiki/RC4">RC4 cipher algorithm</a>, which should be compatible with RSA's RC4(tm) algorithm using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string str = rc4_decrypt_to_string(encrypted_data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw RC4-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string rc4_decrypt_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("RC4-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_rc4(), "rc4", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC2">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = rc2_encrypt_cbc(data, key);
    @endcode

    @throw RC2-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary rc2_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("RC2-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc2_cbc(), "rc2", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC2">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = rc2_decrypt_cbc(data, key);
    @endcode

    @throw RC2-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary rc2_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("RC2-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc2_cbc(), "rc2", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC2">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string str = rc2_decrypt_cbc_to_string(data, key);
    @endcode

    @throw RC2-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string rc2_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("RC2-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_rc2_cbc(), "rc2", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://en.wikipedia.org/wiki/CAST5">CAST5 algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = cast5_encrypt_cbc(data, key);
    @endcode

    @throw CAST5-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary cast5_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("CAST5-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_cast5_cbc(), "CAST5", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://en.wikipedia.org/wiki/CAST5">CAST5 algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = cast5_decrypt_cbc(data, key);
    @endcode

    @throw CAST5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary cast5_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("CAST5-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_cast5_cbc(), "CAST5", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://en.wikipedia.org/wiki/CAST5">CAST5 algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string bin = cast5_decrypt_cbc_to_string(data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw CAST5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string cast5_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   CryptoHelper ch;

   if (ch.setSingleKey("CAST5-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_cast5_cbc(), "CAST5", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC5">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @par Platform Availability:
    @ref Qore::Option::HAVE_RC5

    @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example:
    @code{.py}
binary bin = rc2_encrypt_cbc(data, key);
    @endcode

    @throw RC5-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary rc5_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
#ifndef OPENSSL_NO_RC5
   CryptoHelper ch;

   if (ch.setSingleKey("RC5-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc5_32_12_16_cbc(), "rc5", QCRYPTO_ENCRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
#else
   return missing_openssl_feature("RC5", xsink);
#endif
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC5">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @par Platform Availability:
    @ref Qore::Option::HAVE_RC5

    @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example:
    @code{.py}
binary bin = rc2_decrypt_cbc(data, key);
    @endcode

    @throw RC5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary rc5_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) [flags=RET_VALUE_ONLY] {
#ifndef OPENSSL_NO_RC5
   CryptoHelper ch;

   if (ch.setSingleKey("RC5-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc5_32_12_16_cbc(), "rc5", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getBinary();
#else
   return missing_openssl_feature("RC5", xsink);
#endif
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC5">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @par Platform Availability:
    @ref Qore::Option::HAVE_RC5

    @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example:
    @code{.py}
string str = rc2_decrypt_cbc_to_string(data, key, NOTHING, "iso-8859-1");
    @endcode

    @throw RC5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string rc5_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
#ifndef OPENSSL_NO_RC5
   CryptoHelper ch;

   if (ch.setSingleKey("RC5-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_rc5_32_12_16_cbc(), "rc5", QCRYPTO_DECRYPT, xsink))
      return QoreValue();

   return ch.getString();
#else
   return missing_openssl_feature("RC5", xsink);
#endif
}

//@}


/** @defgroup digest_functions Digest (Hash) Functions
    %Qore's cryptography support is provided by the OpenSSL library.

    A cryptographic hash function is a hash function; that is, an algorithm
    that takes an arbitrary block of data and returns a fixed-size bit string,
    the (cryptographic) hash value, such that any (accidental or intentional)
    change to the data will (with very high probability) change the hash
    value. The data to be encoded are often called the "message," and the
    hash value is sometimes called the message digest or simply digest.

    For more info: <a href="http://en.wikipedia.org/wiki/Cryptographic_hash_function">Wikipedia's Cryptographic hash function article</a>.

    See also:
        - @ref cryptographic_functions
        - @ref hmac_functions
        - @ref cryptographic_constants

 */
//@{

//! Returns the <a href="http://en.wikipedia.org/wiki/MD2_(cryptography)">MD2 message digest</a> of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_MD2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "a9046c73e00331af68917d3804f70655")

    @par Example:
    @code{.py}
string str = MD2("hello"); # returns "a9046c73e00331af68917d3804f70655"
    @endcode

    @throw MD2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD2_bin()
 */
string MD2(data[doc] data) {
#if !defined(OPENSSL_NO_MD2) && !defined(NO_MD2)
   DigestHelper dh(args);
   if (dh.doDigest(MD2_ERR, EVP_md2(), xsink))
      return QoreValue();

   return dh.getString();
#else
   return missing_openssl_feature("MD2", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD4">MD4 message digest</a> of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "866437cb7a794bce2b727acc0362ee27")

    @par Example:
    @code{.py}
string str = MD4("hello"); # returns "866437cb7a794bce2b727acc0362ee27"
    @endcode

    @throw MD4-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD4_bin()
 */
string MD4(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(MD4_ERR, EVP_md4(), xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD5">MD5 message digest</a> of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "5d41402abc4b2a76b9719d911017c592")

    @par Example:
    @code{.py}
string str = MD5("hello"); # returns "5d41402abc4b2a76b9719d911017c592"
    @endcode

    @throw MD5-DIGEST-ERROR error calculating digest (should not normally happen)

    @note
    - equivalent to <string>::toMD5()
    - the MD5 algorithm is not collision-resistant; it's recommended to use another hash algorithm (like SHA-256) if cryptographic security is important

    @see MD5_bin()
 */
string MD5(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(MD5_ERR, EVP_md5(), xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the SHA (outdated SHA-0) message digest of the supplied argument as a hex string
/** This hash algorithm was withdrawn after publishing and is considered to have serious flaws.

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "ac62a630ca850b4ea07eda664eaecf9480843152")

    @par Example:
    @code{.py}
string str = SHA("hello"); returns "ac62a630ca850b4ea07eda664eaecf9480843152"
    @endcode

    @throw SHA-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA_bin()
 */
string SHA(data[doc] data) [flags=RET_VALUE_ONLY] {
#ifdef HAVE_OPENSSL_SHA
   DigestHelper dh(args);
   if (dh.doDigest(SHA_ERR, EVP_sha(), xsink))
      return QoreValue();

   return dh.getString();
#else
   missing_openssl_feature("SHA", xsink);
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/SHA-1">SHA1</a> message digest of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")

    @par Example:
    @code{.py}
string str = SHA1("hello"); # "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"
    @endcode

    @throw SHA1-DIGEST-ERROR error calculating digest (should not normally happen)

    @note equivalent to <string>::toSHA1()

    @see SHA1_bin()
 */
string SHA1(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(SHA1_ERR, EVP_sha1(), xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the SHA-224 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA224

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "ea09ae9cc6768c50fcee903ed054556e5bfc8347907f12598aa24193")

    @par Example:
    @code{.py}
string str = SHA224("hello"); # returns "ea09ae9cc6768c50fcee903ed054556e5bfc8347907f12598aa24193"
    @endcode

    @throw SHA224-DIGEST-ERROR error calculating digest (should not normally happen)

    @note equivalent to <string>::toSHA224()

    @see SHA224_bin()
 */
string SHA224(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA224_ERR, EVP_sha224(), xsink))
      return QoreValue();

   return dh.getString();
#else
   return missing_openssl_feature("SHA224", xsink);
#endif
}

//! Returns the SHA-256 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA256

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")

    @par Example:
    @code{.py}
string str = SHA256("hello"); # returns "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
    @endcode

    @throw SHA256-DIGEST-ERROR error calculating digest (should not normally happen)

    @note equivalent to <string>::toSHA256()

    @see SHA256_bin()
 */
string SHA256(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA256_ERR, EVP_sha256(), xsink))
      return QoreValue();

   return dh.getString();
#else
   return missing_openssl_feature("SHA256", xsink);
#endif
}

//! Returns the SHA-384 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA384

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "59e1748777448c69de6b800d7a33bbfb9ff1b463e44354c3553bcdb9c666fa90125a3c79f90397bdf5f6a13de828684f")

    @par Example:
    @code{.py}
string str = SHA384("hello"); # returns "59e1748777448c69de6b800d7a33bbfb9ff1b463e44354c3553bcdb9c666fa90125a3c79f90397bdf5f6a13de828684f"
    @endcode

    @throw SHA384-DIGEST-ERROR error calculating digest (should not normally happen)

    @note equivalent to <string>::toSHA384()

    @see SHA384_bin()
 */
string SHA384(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA384_ERR, EVP_sha384(), xsink))
      return QoreValue();

   return dh.getString();
#else
   return missing_openssl_feature("SHA384", xsink);
#endif
}

//! Returns the SHA-512 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA512

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043")

    @par Example:
    @code{.py}
string str = SHA512("hello"); # returns "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043"
    @endcode

    @throw SHA512-DIGEST-ERROR error calculating digest (should not normally happen)

    @note equivalent to <string>::toSHA512()

    @see SHA512_bin()
 */
string SHA512(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA512_ERR, EVP_sha512(), xsink))
      return QoreValue();

   return dh.getString();
#else
   return missing_openssl_feature("SHA512", xsink);
#endif
}

//! Returns the DSS message digest (based on SHA-0 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")

    @par Example:
    @code{.py}
string str = DSS("hello"); # returns "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"
    @endcode

    @throw DSS-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS_bin()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
string DSS(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(DSS_ERR, EVP_dss(), xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the DSS1 message digest (based on <a href="http://en.wikipedia.org/wiki/SHA-1">SHA1</a> and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")

    @par Example:
    @code{.py}
string str = DSS1("hello"); # returns "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"
    @endcode

    @throw DSS1-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS1_bin()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
string DSS1(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(DSS1_ERR, EVP_dss1(), xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MDC2">MDC2 message digest</a> of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_MDC2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "4517036cf97b2407d6fe22aa5ab878a3")

    @par Example:
    @code{.py}
string str = MDC2("hello"); # returns "4517036cf97b2407d6fe22aa5ab878a3"
    @endcode

    @throw MDC2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MDC2_bin()
 */
string MDC2(data[doc] data) [flags=RET_VALUE_ONLY] {
#ifndef OPENSSL_NO_MDC2
   DigestHelper dh(args);
   if (dh.doDigest(MDC2_ERR, EVP_mdc2(), xsink))
      return QoreValue();

   return dh.getString();
#else
   return missing_openssl_feature("MDC2", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/RIPEMD">RIPEMD message digest</a> of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "108f07b8382412612c048d07d13f814118445acd")

    @par Example:
    @code{.py}
string str = RIPEMD160("hello"); # returns "108f07b8382412612c048d07d13f814118445acd"
    @endcode

    @throw RIPEMD160-DIGEST-ERROR error calculating digest (should not normally happen)

    @see RIPEMD160_bin()
 */
string RIPEMD160(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(RIPEMD160_ERR, EVP_ripemd160(), xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD2_(cryptography)">MD2 message digest</a> of the supplied argument as binary object
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_MD2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = MD2_bin("hello");
    @endcode

    @throw MD2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD2()
 */
binary MD2_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_MD2) && !defined(NO_MD2)
   DigestHelper dh(args);
   if (dh.doDigest(MD2_ERR, EVP_md2(), xsink))
      return QoreValue();

   return dh.getBinary();
#else
   return missing_openssl_feature("MD2", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD4">MD4 message digest</a> of the supplied argument as a binary object
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = MD4_bin("hello");
    @endcode

    @throw MD4-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD4()
 */
binary MD4_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(MD4_ERR, EVP_md4(), xsink))
      return QoreValue();

   return dh.getBinary();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD5">MD5 message digest</a> of the supplied argument as a binary object
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = MD5_bin("hello");
    @endcode

    @throw MD5-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD5()
 */
binary MD5_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(MD5_ERR, EVP_md5(), xsink))
      return QoreValue();

   return dh.getBinary();
}

//! Returns the SHA (outdated SHA-0) message digest of the supplied argument as a binary object
/** This hash algorithm was withdrawn after publishing and is considered to have serious flaws.

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = SHA_bin("hello");
    @endcode

    @throw SHA-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA()
 */
binary SHA_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
#ifdef HAVE_OPENSSL_SHA
   DigestHelper dh(args);
   if (dh.doDigest(SHA_ERR, EVP_sha(), xsink))
      return QoreValue();

   return dh.getBinary();
#else
   missing_openssl_feature("SHA", xsink);
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/SHA-1">SHA1</a> message digest of the supplied argument as a binary object
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = SHA1_bin("hello");
    @endcode

    @throw SHA1-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA1()
 */
binary SHA1_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(SHA1_ERR, EVP_sha1(), xsink))
      return QoreValue();

   return dh.getBinary();
}

//! Returns the SHA-224 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA224

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = SHA224_bin("hello");
    @endcode

    @throw SHA224-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA224()
 */
binary SHA224_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA224_ERR, EVP_sha224(), xsink))
      return QoreValue();

   return dh.getBinary();
#else
   return missing_openssl_feature("SHA224", xsink);
#endif
}

//! Returns the SHA-256 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA256

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = SHA256_bin("hello");
    @endcode

    @throw SHA256-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA256()
 */
binary SHA256_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA256_ERR, EVP_sha256(), xsink))
      return QoreValue();

   return dh.getBinary();
#else
   return missing_openssl_feature("SHA256", xsink);
#endif
}

//! Returns the SHA-384 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA384

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = SHA384_bin("hello");
    @endcode

    @throw SHA384-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA384()
 */
binary SHA384_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA384_ERR, EVP_sha384(), xsink))
      return QoreValue();

   return dh.getBinary();
#else
   return missing_openssl_feature("SHA384", xsink);
#endif
}

//! Returns the SHA-512 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA512

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = SHA512_bin("hello");
    @endcode

    @throw SHA512-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA512()
 */
binary SHA512_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA512_ERR, EVP_sha512(), xsink))
      return QoreValue();

   return dh.getBinary();
#else
   return missing_openssl_feature("SHA512", xsink);
#endif
}

//! Returns the DSS message digest (based on SHA-0 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a binary object
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = DSS_bin("hello");
    @endcode

    @throw DSS-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
binary DSS_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(DSS_ERR, EVP_dss(), xsink))
      return QoreValue();

   return dh.getBinary();
}

//! Returns the DSS1 message digest (based on SHA-0 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a binary object
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = DSS1_bin("hello");
    @endcode

    @throw DSS1-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS1()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
binary DSS1_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(DSS1_ERR, EVP_dss1(), xsink))
      return QoreValue();

   return dh.getBinary();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MDC2">MDC2 message digest</a> of the supplied argument as a binary object
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_MDC2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = MDC2_bin("hello");
    @endcode

    @throw MDC2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MDC2_bin()
 */
binary MDC2_bin(data[doc] data) [flags=RET_VALUE_ONLY] {
#ifndef OPENSSL_NO_MDC2
   DigestHelper dh(args);
   if (dh.doDigest(MDC2_ERR, EVP_mdc2(), xsink))
      return QoreValue();

   return dh.getBinary();
#else
   return missing_openssl_feature("MDC2", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/RIPEMD">RIPEMD message digest</a> of the supplied argument as a binary object
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example:
    @code{.py}
binary bin = RIPEMD160_bin("hello");
    @endcode

    @throw RIPEMD160-DIGEST-ERROR error calculating digest (should not normally happen)

    @see RIPEMD160()
 */
binary RIPEMD160_binary(data[doc] data) [flags=RET_VALUE_ONLY] {
   DigestHelper dh(args);
   if (dh.doDigest(RIPEMD160_ERR, EVP_ripemd160(), xsink))
      return QoreValue();

   return dh.getBinary();
}

//@}

/** @defgroup hmac_functions HMAC Functions
    %Qore's cryptography support is provided by the OpenSSL library.

    In cryptography, a keyed-hash message authentication code (HMAC) is
    a specific construction for calculating a message authentication code
    (MAC) involving a cryptographic hash function in combination with
    a secret cryptographic key. As with any MAC, it may be used
    to simultaneously verify both the data integrity and the authentication
    of a message. Any cryptographic hash function, such as MD5 or SHA-1,
    may be used in the calculation of an HMAC; the resulting MAC algorithm is
    termed HMAC-MD5 or HMAC-SHA1 accordingly. The cryptographic strength
    of the HMAC depends upon the cryptographic strength of the underlying
    hash function, the size of its hash output, and on the size and quality of the key.

    For more info: <a href="http://en.wikipedia.org/wiki/Hmac">Wikipedia's Hash-based message authentication code article</a>.

    See also:
        - @ref cryptographic_functions
        - @ref digest_functions
        - @ref cryptographic_constants
 */
//@{
//! Returns the <a href="http://en.wikipedia.org/wiki/MD2_(cryptography)">MD2</a> based HMAC of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_MD2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "27f5f17500b408e97643403ea8ef1413")

    @par Example:
    @code{.py}
string str = MD2_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "27f5f17500b408e97643403ea8ef1413"
    @endcode

    @throw MD2-HMAC-ERROR error calculating digest (should not normally happen)

    @see MD2_bin()
 */
string MD2_hmac(data[doc] data, string key) {
#if !defined(OPENSSL_NO_MD2) && !defined(NO_MD2)
   HMACHelper dh(args);
   if (dh.doHMAC("MD2-HMAC-ERROR", EVP_md2(), key, xsink))
      return QoreValue();

   return dh.getString();
#else
   (void)key;
   return missing_openssl_feature("MD2", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD4">MD4</a> based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "053d084f321a3886e60166ebd9609ce1")

    @par Example:
    @code{.py}
string str = MD4_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "053d084f321a3886e60166ebd9609ce1"
    @endcode

    @throw MD4-HMAC-ERROR error calculating digest (should not normally happen)
 */
string MD4_hmac(data[doc] data, string key) {
   HMACHelper dh(args);
   if (dh.doHMAC("MD4-HMAC-ERROR", EVP_md4(), key, xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD5">MD5</a> based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "87505c6164aaf6ca6315233902a01ef4")

    @par Example:
    @code{.py}
string str = MD5_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "87505c6164aaf6ca6315233902a01ef4"
    @endcode

    @note the MD5 algorithm is not collision-resistant; it's recommended to use another hash algorithm (like SHA-256) if cryptographic security is important

    @throw MD5-HMAC-ERROR error calculating digest (should not normally happen)
 */
string MD5_hmac(data[doc] data, string key) {
   HMACHelper dh(args);
   if (dh.doHMAC("MD5-HMAC-ERROR", EVP_md5(), key, xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA</a> based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "0ad47c8d36dc4606d52f7e4cbd144ef2fda492a0")

    @par Example:
    @code{.py}
string str = SHA_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "0ad47c8d36dc4606d52f7e4cbd144ef2fda492a0"
    @endcode

    @note  SHA/SHA0 was withdrawn shortly after publication due to an undisclosed "significant flaw" and replaced by the slightly revised version SHA-1.

    @throw SHA-HMAC-ERROR error calculating digest (should not normally happen)
 */
string SHA_hmac(data[doc] data, string key) {
#ifdef HAVE_OPENSSL_SHA
   HMACHelper dh(args);
   if (dh.doHMAC("SHA-HMAC-ERROR", EVP_sha(), key, xsink))
      return QoreValue();

   return dh.getString();
#else
   (void)key;
   missing_openssl_feature("SHA", xsink);
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA1</a> based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "37a3cc73159aa129b0eb22bbdf4b9309d389f629")

    @par Example:
    @code{.py}
string str = SHA1_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "37a3cc73159aa129b0eb22bbdf4b9309d389f629"
    @endcode

    @note Cryptographic weaknesses were discovered in SHA-1, and the standard was no longer approved for most cryptographic uses after 2010.

    @throw SHA1-HMAC-ERROR error calculating digest (should not normally happen)
 */
string SHA1_hmac(data[doc] data, string key) {
   HMACHelper dh(args);
   if (dh.doHMAC("SHA1-HMAC-ERROR", EVP_sha1(), key, xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA224</a> based HMAC of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA224

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "fad5667fa5aa412044555b7e077fced62372fe9c6ce20815609da12c")

    @par Example:
    @code{.py}
string str = SHA224_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "fad5667fa5aa412044555b7e077fced62372fe9c6ce20815609da12c"
    @endcode


    @throw SHA224-HMAC-ERROR error calculating digest (should not normally happen)
 */
string SHA224_hmac(data[doc] data, string key) {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   HMACHelper dh(args);
   if (dh.doHMAC("SHA224-HMAC-ERROR", EVP_sha224(), key, xsink))
      return QoreValue();

   return dh.getString();
#else
   (void)key;
   return missing_openssl_feature("SHA224", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA256</a> based HMAC of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA256

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "1c90c21e227712b62019ff831f34cba22c2e70f1a902651ef69a70705ee0f754")

    @par Example:
    @code{.py}
string str = SHA256_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "1c90c21e227712b62019ff831f34cba22c2e70f1a902651ef69a70705ee0f754"
    @endcode

    @throw SHA256-HMAC-ERROR error calculating digest (should not normally happen)
 */
string SHA256_hmac(data[doc] data, string key) {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   HMACHelper dh(args);
   if (dh.doHMAC("SHA256-HMAC-ERROR", EVP_sha256(), key, xsink))
      return QoreValue();

   return dh.getString();
#else
   (void)key;
   return missing_openssl_feature("SHA256", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA384</a> based HMAC of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA384

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "e2c253c6dcb050990b4da3cee95cd7b227f43388fa8116f476f59395af295d0d3bb7156ab2fcd0663b0500249a7a0865")

    @par Example:
    @code{.py}
string str = SHA384_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "e2c253c6dcb050990b4da3cee95cd7b227f43388fa8116f476f59395af295d0d3bb7156ab2fcd0663b0500249a7a0865"
    @endcode

    @throw SHA384-HMAC-ERROR error calculating digest (should not normally happen)
 */
string SHA384_hmac(data[doc] data, string key) {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   HMACHelper dh(args);
   if (dh.doHMAC("SHA384-HMAC-ERROR", EVP_sha384(), key, xsink))
      return QoreValue();

   return dh.getString();
#else
   (void)key;
   return missing_openssl_feature("SHA384", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/Secure_Hash_Algorithm">SHA512</a> based HMAC of the supplied argument as a hex string
/**
    @par Platform Availability:
    @ref Qore::Option::HAVE_SHA512

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "8dcefd7ea3f90ff1c822b5e9547fc36edf78c3e4ce13d47510a212a406bdda1a4094e7ea5ade90e1c736e204d331a814520eba49f3d074e2c261208de07264f6")

    @par Example:
    @code{.py}
string str = SHA512_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "8dcefd7ea3f90ff1c822b5e9547fc36edf78c3e4ce13d47510a212a406bdda1a4094e7ea5ade90e1c736e204d331a814520eba49f3d074e2c261208de07264f6"
    @endcode

    @throw SHA512-HMAC-ERROR error calculating digest (should not normally happen)
 */
string SHA512_hmac(data[doc] data, string key) {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   HMACHelper dh(args);
   if (dh.doHMAC("SHA512-HMAC-ERROR", EVP_sha512(), key, xsink))
      return QoreValue();

   return dh.getString();
#else
   (void)key;
   return missing_openssl_feature("SHA512", xsink);
#endif
}

//! Returns the DSS (SHA-0 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "37a3cc73159aa129b0eb22bbdf4b9309d389f629")

    @par Example:
    @code{.py}
string str = DSS_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "37a3cc73159aa129b0eb22bbdf4b9309d389f629"
    @endcode

    @note this algorithm is considered outdated and is included for backwards-compatibility

    @throw DSS-HMAC-ERROR error calculating digest (should not normally happen)
 */
string DSS_hmac(data[doc] data, string key) {
   HMACHelper dh(args);
   if (dh.doHMAC("DSS-HMAC-ERROR", EVP_dss(), key, xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the DSS1 (SHA-1 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "37a3cc73159aa129b0eb22bbdf4b9309d389f629")

    @par Example:
    @code{.py}
string str = DSS1_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "37a3cc73159aa129b0eb22bbdf4b9309d389f629"
    @endcode

    @note this algorithm is considered outdated and is included for backwards-compatibility

    @throw DSS1-HMAC-ERROR error calculating digest (should not normally happen)
 */
string DSS1_hmac(data[doc] data, string key) {
   HMACHelper dh(args);
   if (dh.doHMAC("DSS1-HMAC-ERROR", EVP_dss1(), key, xsink))
      return QoreValue();

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MDC2">MDC2</a> based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "e0ef6a6803e58807c5db395e180a999c")

    @par Example:
    @code{.py}
string str = MDC2_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "e0ef6a6803e58807c5db395e180a999c"
    @endcode

    @throw MDC2-HMAC-ERROR error calculating digest (should not normally happen)
 */
string MDC2_hmac(data[doc] data, string key) {
#ifndef OPENSSL_NO_MDC2
   HMACHelper dh(args);
   if (dh.doHMAC("MDC2-HMAC-ERROR", EVP_mdc2(), key, xsink))
      return QoreValue();

   return dh.getString();
#else
   (void)key;
   return missing_openssl_feature("MDC2", xsink);
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/RIPEMD">RIPEMD</a> based HMAC of the supplied argument as a hex string
/**
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments
    @param key a secret passphrase/key

    @return a hex string of the digest (ex: \c "4bca70bca1601aba57624eeb2606535cb12f2079")

    @par Example:
    @code{.py}
string str = RIPEMD160_hmac("Hello There This is a Test - 1234567890", "a key");
# returns "4bca70bca1601aba57624eeb2606535cb12f2079"
    @endcode

    @throw RIPEMD160-HMAC-ERROR error calculating digest (should not normally happen)
 */
string RIPEMD160_hmac(data[doc] data, string key) {
   HMACHelper dh(args);
   if (dh.doHMAC("RIPEMD160-HMAC-ERROR", EVP_ripemd160(), key, xsink))
      return QoreValue();

   return dh.getString();
}

//@}
