/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  QC_HTTPClient.qpp

  Qore Programming Language

  Copyright (C) 2006 - 2014 Qore Technologies

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/QoreHttpClientObject.h>
#include <qore/intern/QC_HTTPClient.h>
#include <qore/intern/QC_Queue.h>
#include <qore/intern/ssl_constants.h>
#include <qore/minitest.hpp>

#ifdef DEBUG_TESTS
#  include "tests/QC_HTTPClient_tests.cpp"
#endif

//! The HTTPClient class can be used to communicate with HTTP servers with and without TLS/SSL encryption
/** The HTTPClient class can be used to communicate with HTTP servers using the HTTP or HTTPS (HTTP using an SSL/TLS encrypted connection) protocol.

    By default \c "Connection: Keep-Alive" is always sent regardless of the HTTP protocol level set for the object, however if a server response contains \c "Connection: close", the connection will be closed as soon as the full response (including any message body if present) has been read.

    HTTP redirect responses are supported and can be limited with the \c max_redirects constructor hash key or by using the HTTPClient::setMaxRedirects() method. The default maximum number of redirects allowed is 5.

    HTTP basic authentication is supported; set the username and password in the URL (ex: \c "http://username:password@host:port/path"). To change the URL from the one set by the constructor, call HTTPClient::setURL().

    HTTP proxies and basic proxy authentication are supported by setting the proxy constructor hash key to the proxy URL (with a proxy username and password if required) or by calling the HTTPClient::setProxyURL() method.

    Objects of this class are thread-safe and support serializing multiple simultaneous requests from many threads. If a request is in progress and another thread attempts to make a request at the same time, the second thread will block until the first is complete. Therefore the total amount of time a thread could wait for a response in a multi-threaded context could be greater than the timeout value (which applies to the maximum time a single internal send() or recv() action can take).

    This class understands and automatically decodes \c "deflate", \c "gzip", and \c "bzip2" content encodings as well.

    The default I/O timeout value is 300,000 milliseconds (5 minutes). Note that the timeout value applies to individual internal send() or recv() operations; for this reason for large transfers the overall I/O time could exceed the timeout value.

    When an exception is thrown (for example, a response code of < \c 100 or >= \c 400 is received from the server), any message body returned will be in the \c "arg" key of the exception hash.

    This class understands the protocols in the following table.\n\n
    <b>%HTTPClient Class Protocols</b>
    |!Protocol/Scheme|!Default Port|!SSL?|!Description
    |\c http|\c 80|No|Unencrypted HTTP protocol
    |\c https|\c 443|Yes|HTTP protocol with SSL/TLS encryption

    Whenever using an HTTPClient method where a hash of headers can be passed to the method, some headers are generated by default by the class and can be overridden, and some are cannot be overridden and are ignored if passed by the client. See the following tables for details.

    <b>%HTTPClient Mandatory Headers</b>
    |!Header|!Description
    |\c Content-Length|This header is only sent if a message body is sent, and, if so, the length is calculated automatically.

    <b>%HTTPClient Default, but Overridable Headers</b>
    |!Header|!Default Value
    |\c Accept|\c "text/html"
    |\c Content-Type|\c "text/html"
    |\c User-Agent|\c "Qore-HTTP-Client/0.8.8"
    |\c Connection|\c "Keep-Alive"
    |\c Accept-Encoding|\c "deflate,gzip,bzip2"

    This class supports posting network events to a @ref Qore::Thread::Queue "Queue". See @ref event_handling for more information.

    The events raised by this object are listed in the following table:
    <b>HTTPClient Events</b>
    |!Name|!Description
    |@ref EVENT_HTTP_CONTENT_LENGTH|Raised when the HTTP \c "Content-Length" header is received.
    |@ref EVENT_HTTP_CHUNKED_START|Raised when HTTP chunked data is about to be received.
    |@ref EVENT_HTTP_CHUNKED_END|Raised when all HTTP chunked data has been received.
    |@ref EVENT_HTTP_REDIRECT|Raised when an HTTP redirect message is received.
    |@ref EVENT_HTTP_SEND_MESSAGE|Raised when an HTTP message is sent.
    |@ref EVENT_HTTP_MESSAGE_RECEIVED|Raised when an HTTP message is received.
    |@ref EVENT_HTTP_FOOTERS_RECEIVED|Raised when HTTP footers are received. 
    |@ref EVENT_HTTP_CHUNKED_DATA_RECEIVED|Raised when a block of HTTP chunked data is received.
    |@ref EVENT_HTTP_CHUNK_SIZE|Raised when the next chunk size for HTTP chunked data is known.

    @note 
    - This class is not available with the @ref PO_NO_NETWORK parse option.
    - URLs with UNIX sockets are generally supported in Qore with the following syntax: <tt>scheme://socket=<url_encoded_path>/path</tt>, where <tt>url_encoded_path</tt> is a path with URL-encoding as performed by @ref encode_url(); for example: \c "http://socket=%2ftmp%socket-dir%2fsocket-file-1/url/path"; this allows a filesystem path to be used in the host portion of the URL and for the URL to include a URL path as well.
 */
qclass HTTPClient [dom=NETWORK; arg=QoreHttpClientObject* client; vparent=Socket];

//! Creates the HTTPClient object based on the option parameter passed
/** To connect, call any method that requires a connection and an implicit connection is established, or call HTTPClient::connect().

    @par Example:
    @code
my HTTPClient $httpclient(("url":"http://hostname:8080/path"));
    @endcode

    @param opts sets options and changes default behaviour for the object, etc; key names are case-sensitive and therefore must all be in lower-case:
    - \c url: A string giving the URL to connect to
    - \c default_port: The default port number to connect to if none is given in the URL
    - \c protocols: A hash describing new protocols, the key is the protocol name and the value is either an integer giving the default port number or a hash with \c "port" and \c "ssl" keys giving the default port number and a boolean value to indicate that an SSL connection should be established
    - \c http_version: Either \c "1.0" or \c "1.1" for the claimed HTTP protocol version compliancy in outgoing message headers
    - \c default_path: The default path to use for new connections if a path is not otherwise specified in the connection URL
    - \c max_redirects: The maximum number of redirects before throwing an exception (the default is 5)
    - \c proxy: The proxy URL for connecting through a proxy
    - \c timeout: The timeout value in milliseconds (also can be a @ref relative_dates "relative date-time value" for clarity, ex: \c 5m)
    - \c connect_timeout: The timeout value in milliseconds for establishing a new socket connection (also can be a @ref relative_dates "relative date-time value" for clarity, ex: \c 30s)

    @throw HTTP-CLIENT-OPTION-ERROR invalid or unknown option passed in option hash
    @throw HTTP-CLIENT-URL-ERROR invalid URL string
    @throw HTTP-CLIENT-UNKNOWN-PROTOCOL unknown protocol passed in URL

    @note URLs with UNIX sockets are generally supported in Qore with the following syntax: <tt>scheme://socket=<url_encoded_path>/path</tt>, where <tt>url_encoded_path</tt> is a path with URL-encoding as performed by @ref encode_url(); for example: \c "http://socket=%2ftmp%socket-dir%2fsocket-file-1/url/path"; this allows a filesystem path to be used in the host portion of the URL and for the URL to include a URL path as well.
 */
HTTPClient::constructor(hash opts) {
   ReferenceHolder<QoreHttpClientObject> client(new QoreHttpClientObject, xsink);
   if (client->setOptions(opts, xsink))
      return;

   self->setPrivate(CID_HTTPCLIENT, client.release());
}

//! Creates the HTTPClient object
/** 
    @par Example:
    @code
my HTTPClient $httpclient();
    @endcode
 */
HTTPClient::constructor() {
   self->setPrivate(CID_HTTPCLIENT, new QoreHttpClientObject);
}

//! Copying objects of this class is not supported, an exception will be thrown
/** 
    @throw HTTPCLIENT-COPY-ERROR copying HTTPClient objects is not yet supported
 */
HTTPClient::copy() {
   xsink->raiseException("HTTPCLIENT-COPY-ERROR", "copying HTTPClient objects is not yet supported");
}

//! Destroys the HTTPClient object and closes any open connections
/** 
    @par Example:
    @code
delete $httpclient;
    @endcode
 */
HTTPClient::destructor() {
   // have to clear callbacks before destroying
   client->cleanup(xsink);
   client->deref(xsink);
}

//! Sets the HTTP protocol version string for headers in outgoing messages, allowed values are \c "1.0" and \"1.1\".
/** @param ver \c "1.0" or \"1.1\" for the HTTP protocol compliance version

    @par Example:
    @code
$httpclient.setHTTPVersion("1.1");
    @endcode

    @throw HTTP-VERSION-ERROR invalid HTTP version passed (allowed values: \c "1.0" and \"1.1\")
 */
nothing HTTPClient::setHTTPVersion(string ver) {
   client->setHTTPVersion(ver->getBuffer(), xsink);
}

//! Returns the HTTP protocol version string used in outgoing messages
/** @return the HTTP protocol version string used in outgoing messages

    @par Example:
    @code
my string $version = $httpclient.getHTTPVersion();
    @endcode
 */
string HTTPClient::getHTTPVersion() [flags=CONSTANT] {
   return new QoreStringNode(client->getHTTPVersion());
}

//! Sets the object to make a secure SSL/TLS connection on the next connect if the passed argument is @ref True, or an unencrypted cleartext connection if it is @ref False
/** This method overrides the default behaviour for the protocol set for the object

    Note that the behavior of this method when called with no argument changed in version 0.8.0; prior to version 0.8.0 calling this method with no argument would turn off secure mode; the behavior was changed to the current functionality in order to make the usage of this method consistent with other methods of the same name and to make it more logical.

    @par Example:
    @code
$httpclient.setSecure(True);
    @endcode

    @param secure if @ref True, a SSL/TLS connection will be attempted on the next connection. If @ref False, an unencrypted cleartext connection will be established
 */
nothing HTTPClient::setSecure(softbool secure = True) {
   client->setSecure(secure);
}

//! Returns @ref True if the current connection is encrypted, @ref False if not
/** @return @ref True if the current connection is encrypted, @ref False if not

    @par Example:
    @code
if ($httpclient.isSecure())
    printf("secure connection: %s %s\n", $httpclient.getSSLCipherName(), $httpclient.getSSLCipherVersion());
    @endcode
 */
bool HTTPClient::isSecure() [flags=CONSTANT] {
   return client->isSecure();
}

//! Connects to the remote socket; SSL/TLS negotiation is performed if required
/** If the protocol indicates that a secure connection should be established (or HTTPClient::setSecure() was called previsouly), SSL/TLS negotiation will be attempted. 

    If the \c TCP_NODELAY flag has been set (see HTTPClient::setNoDelay()), then after a successful connection to the remote socket, this option will be set on the socket. If an error occurs setting the \c TCP_NODELAY option, the internal flag is set to false (use HTTPClient::getNoDelay() to check the flag's state) and the error code can be retrieved with errno().

    @par Example:
    @code
$httpclient.connect();
    @endcode

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @note For possible exceptions, see the Socket::connect() method (or Socket::connectSSL() for secure connections).
 */
nothing HTTPClient::connect() {
   client->connect(xsink);
}

//! Disconnects from the remote socket if a connection is established (otherwise does nothing)
/** 
    @par Example:
    @code
$httpclient.disconnect();
    @endcode
 */
nothing HTTPClient::disconnect() {
   client->disconnect();
}

//! Sends an HTTP request with the specified method and optional message body and returns headers and any body received as a response in a hash format
/** If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @par Example:
    @code
my hash $msg = $httpclient.send($body, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @param body The message body to send
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.

    @return The headers received from the HTTP server with all key names converted to lower-case. The message body (if any) will be assigned to the value of the \c "body" key and the HTTP status will be assigned to the \c "status_code" key.

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
hash HTTPClient::send(string body, string method, *string path, *hash headers, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<QoreHashNode> rv(client->send(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, body->getBuffer(), body->strlen(), getbody, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP request with the specified method and optional message body and returns headers and any body received as a response in a hash format
/** If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @par Example:
    @code
my hash $msg = $httpclient.send($body, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @param body The message body to send; pass @ref nothing (no value) to send no body
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.

    @return The headers received from the HTTP server with all key names converted to lower-case. The message body (if any) will be assigned to the value of the \c "body" key and the HTTP status will be assigned to the \c "status_code" key.

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
hash HTTPClient::send(*binary body, string method, *string path, *hash headers, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<QoreHashNode> rv(client->send(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, body ? body->getPtr() : 0, body ? body->size() : 0, getbody, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP request with the specified method and chunked message body as given by a send callback and returns headers and any body received as a response in a hash format
/** If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @par Example:
    @code
my hash $msg = $httpclient.sendWithSendCallback($callback, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @param scb The callback giving the chunked HTTP data to send; this callback must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be sent or simply @ref nothing which will close the chunked message
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.

    @return The headers received from the HTTP server with all key names converted to lower-case. The message body (if any) will be assigned to the value of the \c "body" key and the HTTP status will be assigned to the \c "status_code" key.

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note
    - The \c "Transfer-Encoding: chunked" header is automatically set with this method if no \c "Transfer-Encoding" header is already present
    - For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)

    @since Qore 0.8.10
 */
hash HTTPClient::sendWithSendCallback(code scb, string method, *string path, *hash headers, timeout timeout_ms = 0, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<QoreHashNode> rv(client->sendWithSendCallback(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, scb, getbody, *ohrh, timeout_ms, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP request with the specified method and optional message body; headers and any body received are returned through a receive callback
/** This method is useful for receiving chunked message data in real time; chunks are sent to the receive callback as soon as they are received.
    If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @par Example:
    @code
my hash $msg = $httpclient.sendWithRecvCallback($rcv_callback, $data, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @param rcb The receive callback for the data received; first this method is called with a hash of the message headers, and then with any message body; if a chunked HTTP message is received, then the callback is called once for each chunk; when the message has been received, then the receive callback is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
    - \c "data": the string or binary data
    - \c "chunked": True if the data was received with chunked transfer encoding, False if not
    .
    Header or trailer data is placed in a hash with the following keys:
    - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
    - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
    @param body The message body to send
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)

    @since Qore 0.8.10
 */
nothing HTTPClient::sendWithRecvCallback(code rcb, string body, string method, *string path, *hash headers, timeout timeout_ms = 0, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   client->sendWithRecvCallback(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, body->getBuffer(), body->size(), getbody, *ohrh, timeout_ms, rcb, self, xsink);
}

//! Sends an HTTP request with the specified method and optional message body; headers and any body received are returned through a receive callback
/** This method is useful for receiving chunked message data in real time; chunks are sent to the receive callback as soon as they are received.
    If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @par Example:
    @code
my hash $msg = $httpclient.sendWithRecvCallback($rcv_callback, $data, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @param rcb The receive callback for the data received; first this method is called with a hash of the message headers, and then with any message body; if a chunked HTTP message is received, then the callback is called once for each chunk; when the message has been received, then the receive callback is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
    - \c "data": the string or binary data
    - \c "chunked": True if the data was received with chunked transfer encoding, False if not
    .
    Header or trailer data is placed in a hash with the following keys:
    - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
    - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
    @param body The message body to send; pass @ref nothing (no value) to send no body
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)

    @since Qore 0.8.10
 */
nothing HTTPClient::sendWithRecvCallback(code rcb, *binary body, string method, *string path, *hash headers, timeout timeout_ms = 0, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   client->sendWithRecvCallback(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, body ? body->getPtr() : 0, body ? body->size() : 0, getbody, *ohrh, timeout_ms, rcb, self, xsink);
}

//! Sends an HTTP request with the specified method and chunked message body as given by a send callback; headers and any body received are returned through a receive callback
/** This method is useful for sending chunked message data where the response is also a sent with chunked transfer encoding; chunks are sent to the receive callback as soon as they are received.
    If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @par Example:
    @code
my hash $msg = $httpclient.sendWithCallbacks($send_callback, $rcv_callback, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @param scb The callback giving the chunked HTTP data to send; this callback must return either a string or a binary value each time it is called to give the chunked data to send; when all data has been sent, then a hash of message trailers can be sent or simply @ref nothing which will close the chunked message
    @param rcb The receive callback for the data received; first this method is called with a hash of the message headers, and then with any message body; if a chunked HTTP message is received, then the callback is called once for each chunk; when the message has been received, then the receive callback is called with a hash representing any trailer data received in a chunked transfer or @ref nothing if the data was received in a normal message body or if there was no trailer data in a chunked transfer.  The argument to this callback is always a hash; data calls have the following keys:
    - \c "data": the string or binary data
    - \c "chunked": True if the data was received with chunked transfer encoding, False if not
    .
    Header or trailer data is placed in a hash with the following keys:
    - \c "hdr": this can be assigned to @ref nothing for the trailer hash if the data was not sent chunked or no trailers were included in a chunked message
    - \c "obj": this is the owning object (so socket parameters can be changed based on headers received, such as, for example, socket character encoding)
    - \c "send_aborted": this is set to @ref Qore::True "True" if a response header was set while sending an outgoing chunked message
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param timeout_ms the timeout in milliseconds for the socket I/O operations; 0 means use the default timeout value
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the normal return value of this method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note
    - The \c "Transfer-Encoding: chunked" header is automatically set with this method if no \c "Transfer-Encoding" header is already present
    - if a response is received while the chunked send operation is still in progress, an error is assumed, the send operation is aborted, and the response header is read immediately and the \c send_aborted flag is set in the argument to \a rcb
    - For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)

    @since Qore 0.8.10
 */
nothing HTTPClient::sendWithCallbacks(code scb, code rcb, string method, *string path, *hash headers, timeout timeout_ms = 0, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   client->sendWithCallbacks(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, scb, getbody, *ohrh, timeout_ms, rcb, self, xsink);
}

//! Sends an HTTP \c GET request and returns the message body received as a string or @ref nothing if no message body is received
/** In order to get the headers and the body, use the HTTPClient::send() method instead. 

    If no connection has already been established, an internal call to HTTPClient::connect() will be made before sending the request.

    If any content encoding is used for the message body in the reply, the content is decoded and returned as a string; if the content encoding uses an unknown method, then an exception is thrown.

    @par Example:
    @code
my *string $html = $httpclient.get("/path/file.html");
    @endcode

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the message body in the reply to this message or @ref nothing in case of an error or an erroneous reply by the server with no body

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_CONTENT_LENGTH, @ref EVENT_HTTP_CHUNKED_START, @ref EVENT_HTTP_CHUNKED_END, @ref EVENT_HTTP_CHUNKED_DATA_RECEIVED, @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED, @ref EVENT_HTTP_REDIRECT

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the return value of the send() method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
*string HTTPClient::get(string path, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<AbstractQoreNode> rv(client->get(path->getBuffer(), headers, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP \c HEAD request and returns as hash of the headers received
/** If no connection is established, an internal call to HTTPClient::connect() will be made before sending the message.

    @par Example:
    @code
my hash $msg = $httpclient.head("/path");
    @endcode

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the headers received from the HTTP server with all key names converted to lower-case

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_REDIRECT

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the return value of the send() method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
hash HTTPClient::head(string path, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<QoreHashNode> rv(client->head(path->getBuffer(), headers, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP \c POST request with a message body and returns the message body received as a string or @ref nothing if no message body is received
/** In order to get the headers and the body in the response, use the HTTPClient::send() method instead.

    If no connection is established, an internal call to HTTPClient::connect() will be made before sending the message.

    @par Example:
    @code
$httpclient.post("/path", $body);
    @endcode

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param body the string to use as the message body
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the message body in the reply to this message or @ref nothing in case no body was present in the response

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_CONTENT_LENGTH, @ref EVENT_HTTP_CHUNKED_START, @ref EVENT_HTTP_CHUNKED_END, @ref EVENT_HTTP_CHUNKED_DATA_RECEIVED, @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED, @ref EVENT_HTTP_REDIRECT

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the return value of the send() method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
*string HTTPClient::post(string path, string body, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<AbstractQoreNode> rv(client->post(path->getBuffer(), headers, body->getBuffer(), body->size(), *ohrh, xsink), xsink);
#ifdef DEBUG
   assert(!rv || rv->getType() == NT_STRING);
#endif
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP \c POST request with a message body and returns the message body received as a string or @ref nothing if no message body is received
/** In order to get the headers and the body in the response, use the HTTPClient::send() method instead.

    If no connection is established, an internal call to HTTPClient::connect() will be made before sending the message.

    @par Example:
    @code
$httpclient.post("/path", $body);
    @endcode

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param body the optional data to use as the message body
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the message body in the reply to this message or @ref nothing in case no body was present in the response

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_CONTENT_LENGTH, @ref EVENT_HTTP_CHUNKED_START, @ref EVENT_HTTP_CHUNKED_END, @ref EVENT_HTTP_CHUNKED_DATA_RECEIVED, @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED, @ref EVENT_HTTP_REDIRECT

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 100 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash equal to the return value of the send() method including a \c "status_code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
*string HTTPClient::post(string path, *binary body, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<AbstractQoreNode> rv(client->post(path->getBuffer(), headers, body ? body->getPtr() : 0, body ? body->size() : 0, *ohrh, xsink), xsink);
#ifdef DEBUG
   assert(!rv || rv->getType() == NT_STRING);
#endif
   return *xsink ? 0 : rv.release();
}

//! Sets the default I/O timeout value in milliseconds
/** @param timeout_ms 0 means immediate timeout (when reading will return data only if it is already available), and negative numbers mean never timeout. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.).

    @par Example:
    @code
$httpclient.setTimeout(2m);
    @endcode
 */
nothing HTTPClient::setTimeout(timeout timeout_ms = 0) {
   client->setTimeout((int)timeout_ms);
}

//! Returns the default I/O timeout as an integer in milliseconds
/** @return the default I/O timeout as an integer in milliseconds; 0 means immediate timeout (when reading only returns data if it is already available), and negative numbers mean never timeout

    @par Example:
    @code
my int $timeout = $httpclient.getTimeout();
    @endcode
 */
int HTTPClient::getTimeout() [flags=CONSTANT] {
   return client->getTimeout();
}

//! Sets the string encoding for the object; any strings deserialized with this object will be tagged with this character encoding
/** @param encoding the string encoding for the object; any strings deserialized with this object will be tagged with this character encoding

    @par Example:
    @code
$httpclient.setEncoding("UTF-8");
    @endcode
 */
nothing HTTPClient::setEncoding(string encoding) {
   client->setEncoding(QEM.findCreate(encoding));
}

//! Returns the character encoding used for the object
/** @return the character encoding used for the object

    @par Example:
    @code
my string $encoding = $httpclient.getEncoding();
    @endcode
 */
string HTTPClient::getEncoding() [flags=CONSTANT] {
   return new QoreStringNode(client->getEncoding()->getCode());
}

//! Sets a new URL value for the next connection
/** To retrieve the current URL value, use the HTTPClient::getURL() method

    @par Example:
    @code
$httpclient.setURL("https://user:password@hostname:8080/path");
    @endcode

    @param url the new URL for the object

    @throw HTTP-CLIENT-URL-ERROR invalid URL string; invalid authorization credentials in  URL (username without password or vice-versa)
    @throw HTTP-CLIENT-UNKNOWN-PROTOCOL unknown protocol (scheme) passed in URL

    @see HTTPClient::getURL()

    @note URLs with UNIX sockets are generally supported in Qore with the following syntax: <tt>scheme://socket=<url_encoded_path>/path</tt>, where <tt>url_encoded_path</tt> is a path with URL-encoding as performed by @ref encode_url(); for example: \c "http://socket=%2ftmp%socket-dir%2fsocket-file-1/url/path"; this allows a filesystem path to be used in the host portion of the URL and for the URL to include a URL path as well.
 */
HTTPClient::setURL(string url) {
   client->setURL(url->getBuffer(), xsink);
}

//! Returns the current URL
/** @return the current URL

    @par Example:
    @code
my *string $url = $httpclient.getURL();
    @endcode
 */
*string HTTPClient::getURL() [flags=CONSTANT] {
   return client->getURL();
}

//! Clears the new proxy URL value for the next connection
/** This variant of the method is equivalent to HTTPClient::clearProxyURL()

    @par Example:
    @code
$httpclient.setProxyURL();
    @endcode
 */
nothing HTTPClient::setProxyURL() {
   client->clearProxyURL();
}

//! Sets a new proxy URL value for the next connection
/** @param url the new proxy URL value for the next connection

    @par Example:
    @code
$httpclient.setProxyURL("http://user:password@proxy_host:8080/path");
    @endcode

    @throw HTTP-CLIENT-URL-ERROR invalid proxy URL string; invalid authorization credentials in proxy URL (username without password or vice-versa)
    @throw HTTP-CLIENT-PROXY-PROTOCOL-ERROR unknown protocol passed in URL

    @note URLs with UNIX sockets are generally supported in Qore with the following syntax: <tt>scheme://socket=<url_encoded_path>/path</tt>, where <tt>url_encoded_path</tt> is a path with URL-encoding as performed by @ref encode_url(); for example: \c "http://socket=%2ftmp%socket-dir%2fsocket-file-1/url/path"; this allows a filesystem path to be used in the host portion of the URL and for the URL to include a URL path as well.
 */
nothing HTTPClient::setProxyURL(string url) {
   client->setProxyURL(url->getBuffer(), xsink);
}

//! Returns the current proxy URL as a string or @ref nothing if no proxy URL is set
/** @return the current proxy URL as a string or @ref nothing if no proxy URL is set

    @par Example:
    @code
my *string $proxy_url = $httpclient.getProxyURL();
    @endcode
 */
*string HTTPClient::getProxyURL() [flags=CONSTANT] {
   return client->getProxyURL();
}

//! Clears the new proxy URL value for the next connection
/** 
    @par Example:
    @code
$httpclient.setProxyURL();
    @endcode
 */
nothing HTTPClient::clearProxyURL() {
   client->clearProxyURL();
}

//! Sets the SSL/TLS flag for the next connection to the proxy
/** 
    @par Example:
    @code
$httpclient.setProxySecure(True);
    @endcode

    @see HTTPClient::isProxySecure() to check the flag
 */
nothing HTTPClient::setProxySecure(softbool b = True) {
   client->setProxySecure(b);
}

//! Returns the SSL/TLS flag for the next proxy connection
/** @return the SSL/TLS flag for the next proxy connection

    @par Example:
    @code
my bool $b = $httpclient.isProxySecure();
    @endcode
 */
bool HTTPClient::isProxySecure() [flags=CONSTANT] {
   return client->isProxySecure();
}

//! Updates the setting for the \c max_redirects value for the object (maximum number of HTTP redirects that will be processed before an exception is raised)
/** @param mr the setting for the maximum number of HTTP redirects that will be processed before an exception is raised

    @par Example:
    @code
$httpclient.setMaxRedirects(5);
    @endcode

    @see HTTPClient::getMaxRedirects() to retrieve this value
 */
nothing HTTPClient::setMaxRedirects(softint mr = 0) {
   client->setMaxRedirects((int)mr);
}

//! Returns the current \c max_redirects value for the object (the maximum number of HTTP redirects that will be processed before an exception is raised)
/** @return the current \c max_redirects value for the object (the maximum number of HTTP redirects that will be processed before an exception is raised)

    @par Example:
    @code
my int $mr = $httpclient.getMaxRedirects();
    @endcode
 */
int HTTPClient::getMaxRedirects() [flags=CONSTANT] {
   return client->getMaxRedirects();
}

//! Clears any Queue object that may be set on the HTTPClient object so that @ref event_handling "I/O events" are no longer captured on the object
/** 
    @par Example:
    @code
$httpclient.setEventQueue();
    @endcode
 */
nothing HTTPClient::setEventQueue() {
    client->setEventQueue(0, xsink);
}

//! Sets a Queue object to receive HTTPClient and Socket events
/** @param queue a @ref Qore::Thread::Queue "Queue" object to receive HTTPClient and Socket events; note that the Queue passed cannot have any maximum size set or a QUEUE-ERROR will be thrown

    @par Example:
    @code
$httpclient.setEventQueue($queue);
    @endcode

    @throw QUEUE-ERROR the Queue passed has a maximum size set

    @see event_handling for more information
 */
nothing HTTPClient::setEventQueue(Qore::Thread::Queue[Queue] queue) {
   ReferenceHolder<Queue> q(queue, xsink);
   if (queue->getMax() != -1) {
      xsink->raiseException("QUEUE-ERROR", "the Queue object passed as a maximum size of %d entr%s, which could cause internal I/O to freeze in the HttpClient object if used; use a Queue object with no maximum size for I/O monitoring", queue->getMax(), queue->getMax() == 1 ? "y" : "ies");
      return 0;
   }
   // pass reference from QoreObject::getReferencedPrivateData() to function
   client->setEventQueue(q.release(), xsink);
}

//! Sets the connect timeout in milliseconds
/** @param timeout_ms the connect timeout in milliseconds; negative numbers mean use the default system connect timeout. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 30s = 30 seconds, etc.).

    @par Example:
    @code
$httpclient.setConnectTimeout(2m);
    @endcode
 */
nothing HTTPClient::setConnectTimeout(timeout timeout_ms = -1) {
   client->setConnectTimeout((int)timeout_ms);
}

//! Returns the connect timeout as an integer in milliseconds
/** @return Returns the connect timeout as an integer in milliseconds; negative numbers mean the system default timeout is used

    @par Example:
    @code
my int $to = $httpclient.getConnectTimeout();
    @endcode
 */
int HTTPClient::getConnectTimeout() [flags=CONSTANT] {
   return client->getConnectTimeout();
}

//! Sets the \c TCP_NODELAY setting for the object
/** When this setting is True, then data will be immediately sent out over the HTTPClient object's socket, when it is @ref False, then data transmission may be delayed to be packaged with other data for the same target.

    Delayed data transmissions may cause problems when the sender immediately closes the socket after sending data; in this case the receiver may not get the data even though the send succeeded.

    Note that if no value is given to the method, the argument will be assumed to be @ref True, and output buffering will be turned off for the HTTPClient object.

    If the socket is not connected when this call is made, then an internal flag is set and the \c TCP_NODELAY option is enabled when the next connection is established. If the socket is connected, then if an error occurs setting the \c TCP_NODELAY option on the socket, this method will return a non-zero error code; the actual error can be checked with the errno() function.

    @par Example:
    @code
$httpclient.setNoDelay(True);
    @endcode

    @param b the \c TCP_NODELAY setting for the object

    @see HTTPClient::getNoDelay()
 */
int HTTPClient::setNoDelay(softbool b = True) {
    return client->setNoDelay(b);
}

//! Returns the \c TCP_NODELAY setting for the HTTPClient object
/** 
    @par Example:
    @code
my bool $b = $httpclient.getNoDelay();
    @endcode

    @see also HTTPClient::setNoDelay()
 */
bool HTTPClient::getNoDelay() [flags=CONSTANT] {
    return client->getNoDelay();
}

//! Returns @ref True or @ref False giving the current connection state
/** @return @ref True or @ref False giving the current connection state

    @par Example:
    @code
my bool $b = $httpclient.isConnected();
    @endcode
 */
bool HTTPClient::isConnected() [flags=CONSTANT] {
    return client->isConnected();
}

//! Sets the username and password for the connection; call after HTTPClient::setURL()
/** Call this method after calling HTTPClient::setURL() to set authentication information when not present in the URL used in HTTPClient::setURL()

    @param user the username to use for authentication in the next HTTP connection
    @param pass the password to use for authentication in the next HTTP connection

    @par Example:
    @code
$httpclient.setUserPassword($user, $pass);
    @endcode
 */
nothing HTTPClient::setUserPassword(string user, string pass) {
   client->setUserPassword(user->getBuffer(), pass->getBuffer());
}

//! Clears the username and password for the connection
/** Call this method after calling HTTPClient::setURL() to clear any authentication information present in the URL used in HTTPClient::setURL()

    This variant of the method is equivalent to HTTPClient::clearUserPassword()

    @par Example:
    @code
$httpclient.setUserPassword();
    @endcode

    @see HTTPClient::clearUserPassword()
 */
nothing HTTPClient::setUserPassword() {
   client->clearUserPassword();
}

//! Clears the username and password for the connection
/** Call this method after calling HTTPClient::setURL() to clear any authentication information present in the URL used in HTTPClient::setURL()

    @par Example:
    @code
$httpclient.clearUserPassword();
    @endcode
 */
nothing HTTPClient::clearUserPassword() {
   client->clearUserPassword();
}

//! Sets the username and password for the connection to the proxy; call after HTTPClient::setProxyURL()
/** Call this method after calling HTTPClient::setProxyURL() to set proxy authentication information when not present in the URL used in HTTPClient::setProxyURL()

    @par Example:
    @code
$httpclient.setProxyUserPassword($user, $pass);
    @endcode

    @param user the username to use for proxy authentication in the next HTTP connection
    @param pass the password to use for proxy authentication in the next HTTP connection
 */
nothing HTTPClient::setProxyUserPassword(string user, string pass) {
   client->setProxyUserPassword(user->getBuffer(), pass->getBuffer());
}

//! Clears the username and password for the next proxy connection
/** Call this method after calling HTTPClient::setProxyURL() to clear any proxy authentication information present in the URL used in HTTPClient::setProxyURL()

    This variant of the method is equivalent to HTTPClient::clearProxyUserPassword()

    @par Example:
    @code
$httpclient.setProxyUserPassword();
    @endcode

    @see HTTPClient::clearProxyUserPassword()
 */
nothing HTTPClient::setProxyUserPassword() {
   client->clearProxyUserPassword();
}

//! Clears the username and password for the next proxy connection
/** Call this method after calling HTTPClient::setProxyURL() to clear any proxy authentication information present in the URL used in HTTPClient::setProxyURL()

    @par Example:
    @code
$httpclient.clearProxyUserPassword();
    @endcode
 */
nothing HTTPClient::clearProxyUserPassword() {
   client->clearProxyUserPassword();
}

//! Sets the default path used by the object if no path is set in the URL
/** @param path the default path value to set or if @ref nothing then clears the path

    @par Example:
    @code
$httpclient.setDefaultPath();
    @endcode
 */
nothing HTTPClient::setDefaultPath(*string path) {
   client->setDefaultPath(path ? path->getBuffer() : 0);
}

//! Returns the default path used by the object if no path is set in the URL
/** @return the default path used by the object if no path is set in the URL

    @par Example:
    @code
my *string $def_path = $httpclient.getDefaultPath();
    @endcode
 */
string HTTPClient::getDefaultPath() [flags=CONSTANT] {
   const char* dp = client->getDefaultPath();
   return dp ? new QoreStringNode(dp) : 0;
}

//! Returns the current connection path set in the URL
/** @return the current connection path set in the URL

    @par Example:
    @code
my *string $path = $httpclient.getConnectionPath();
    @endcode
 */
*string HTTPClient::getConnectionPath() [flags=CONSTANT] {
   const char* p = client->getConnectionPath();
   return p ? new QoreStringNode(p) : 0;
}

//! Removes any warning @ref Qore::Thread::Queue "Queue" object from the Socket
/** @par Example:
    @code
$httpclient.clearWarningQueue();
    @endcode

    @see HTTPClient::setWarningQueue()

    @since Qore 0.8.9
 */
nothing HTTPClient::clearWarningQueue() {
   client->clearWarningQueue(xsink);
}

//! Sets a @ref Qore::Thread::Queue "Queue" object to receive socket warnings
/** @par Example:
    @code
$httpclient.setWarningQueue(5000, 5000, $queue, "socket-1");
    @endcode

    @param warning_ms the threshold in milliseconds for individual socket actions (send, receive, connect), if exceeded, a socket warning is placed on the warning queue with the following keys:
    - \c "type": a string with the constant value \c "SOCKET-OPERATION-WARNING"
    - \c "operation": a string giving the operation that caused the warning (ex: \c "connect")
    - \c "us": an integer giving the number of microseconds for the operation
    - \c "timeout": an integer giving the warning threshold in microseconds 
    - \c "arg": if any \c "arg" argument is passed to the @ref Qore::HTTPClient::setWarningQueue() "HTTPClient::setWarningQueue()" method, it will be included in the warning hash here 
    @param warning_bs value in bytes per second; if any call has performance below this threshold, a socket warning is placed on the warning queue with the following keys:
    - \c "type": a string with the constant value \c "SOCKET-THROUGHPUT-WARNING"
    - \c "dir": either \c "send" or \c "recv" depending on the direction of the data flow
    - \c "bytes": the amount of bytes sent
    - \c "us": an integer giving the number of microseconds for the operation
    - \c "bytes_sec": a float giving the transfer speed in bytes per second
    - \c "threshold": an integer giving the warning threshold in bytes per second
    - \c "arg": if any \c "arg" argument is passed to the @ref Qore::HTTPClient::setWarningQueue() "HTTPClient::setWarningQueue()" method, it will be included in the warning hash here 
    @param queue the @ref Qore::Thread::Queue "Queue" object to receive warning events
    @param arg an optional argument to be placed in the \c "arg" key in each warning hash (could be used to identify the socket for example)
    @param min_ms the minimum transfer time with a resolution of milliseconds for a transfer to be eligible for triggering a warning; transfers that take less than this period of time are not eligible for raising a warning

    @throw QUEUE-ERROR the Queue passed has a maximum size set
    @throw SOCKET-SETWARNINGQUEUE-ERROR at least one of \a warning_ms and \a warning_bs must be > 0

    @see HTTPClient::clearWarningQueue()

    @since Qore 0.8.9
 */
nothing HTTPClient::setWarningQueue(int warning_ms, int warning_bs, Queue[Queue] queue, any arg, timeout min_ms = 1s) {
   ReferenceHolder<Queue> q(queue, xsink);
   if (queue->getMax() != -1) {
      xsink->raiseException("QUEUE-ERROR", "the Queue object passed as a maximum size of %d entr%s, which could cause internal I/O to freeze in the Socket object if used; use a Queue object with no maximum size for I/O monitoring", queue->getMax(), queue->getMax() == 1 ? "y" : "ies");
      return 0;
   }
   // pass reference from QoreObject::getReferencedPrivateData() to function
   client->setWarningQueue(xsink, warning_ms, warning_bs, q.release(), arg ? arg->refSelf() : 0, min_ms);
}

//! Returns performance statistics for the socket
/** @par Example:
    @code
my hash $h = $httpclient.getUsageInfo();
    @endcode

    @return a hash with the following keys:
    - \c "bytes_sent": an integer giving the total amount of bytes sent
    - \c "bytes_recv": an integer giving the total amount of bytes received
    - \c "us_sent": an integer giving the total number of microseconds spent sending data
    - \c "us_recv": an integer giving the total number of microseconds spent receiving data
    - \c "arg": (only if warning values have been set with @ref Qore::HTTPClient::setWarningQueue() "HTTPClient::setWarningQueue()") the optional argument for warning hashes
    - \c "timeout": (only if warning values have been set with @ref Qore::HTTPClient::setWarningQueue() "HTTPClient::setWarningQueue()") the warning timeout in microseconds
    - \c "min_throughput": (only if warning values have been set with @ref Qore::HTTPClient::setWarningQueue() "HTTPClient::setWarningQueue()") the minimum warning throughput in bytes/sec

    @since Qore 0.8.9

    @see HTTPClient::clearStats()
 */
hash HTTPClient::getUsageInfo() [flags=CONSTANT] {
   return client->getUsageInfo();
}

//! Clears performance statistics
/** @par Example:
    @code
$httpclient.clearStats();
    @endcode

    @since Qore 0.8.9

    @see HTTPClient::getUsageInfo()
*/
HTTPClient::clearStats() {
   client->clearStats();
}

//! temporarily disables implicit reconnections; must be called when the server is already connected                                              
/** @par Example:
    @code
$httpclient.connect();
$httpclient.setPersistent();
    @endcode

    The persistent flag is automatically reset to @ref Qore::False "False" whenever the connection is closed; it must be called manually for every connection to turn off implicit reconnections.

    To turn off the persistent flag manually, call @ref HTTPClient::disconnect()

    @since Qore 0.8.10
 */
HTTPClient::setPersistent() {
   client->setPersistent(xsink);
}

