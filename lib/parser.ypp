%{ /* -*- mode: c++; indent-tabs-mode: nil -*-

  parser.ypp

  Qore Programming Language

  Copyright (C) 2003 - 2017 Qore Technologies, s.r.o.

  Permission is hereby granted, free of charge, to any person obtaining a
  copy of this software and associated documentation files (the "Software"),
  to deal in the Software without restriction, including without limitation
  the rights to use, copy, modify, merge, publish, distribute, sublicense,
  and/or sell copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  DEALINGS IN THE SOFTWARE.

  Note that the Qore library is released under a choice of three open-source
  licenses: MIT (as above), LGPL 2+, or GPL 2+; see README-LICENSE for more
  information.
*/

#include "qore/Qore.h"
#include "qore/intern/BreakStatement.h"
#include "qore/intern/ContinueStatement.h"
#include "qore/intern/ReturnStatement.h"
#include "qore/intern/RethrowStatement.h"
#include "qore/intern/ThreadExitStatement.h"
#include "qore/intern/ExpressionStatement.h"
#include "qore/intern/DoWhileStatement.h"
#include "qore/intern/SummarizeStatement.h"
#include "qore/intern/ContextStatement.h"
#include "qore/intern/IfStatement.h"
#include "qore/intern/WhileStatement.h"
#include "qore/intern/ForStatement.h"
#include "qore/intern/ForEachStatement.h"
#include "qore/intern/TryStatement.h"
#include "qore/intern/ThrowStatement.h"
#include "qore/intern/StatementBlock.h"
#include "qore/intern/ParserSupport.h"
#include "qore/intern/SwitchStatement.h"
#include "qore/intern/CaseNodeWithOperator.h"
#include "qore/intern/CaseNodeRegex.h"
#include "qore/intern/OnBlockExitStatement.h"
#include "qore/intern/ConstantList.h"
#include "qore/intern/GlobalVariableList.h"
#include "qore/intern/QoreNamespaceIntern.h"
#include "qore/intern/QoreParseHashNode.h"
#include "qore/intern/ModuleInfo.h"

#include "parser.hpp"

#include "qore/intern/QoreClassIntern.h"
#include "qore/intern/qore_program_private.h"
#include "qore/intern/typed_hash_decl_private.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <memory>
#include <utility>
#include <vector>

#define YYINITDEPTH 300
//#define YYDEBUG 1

#define YYLLOC_DEFAULT(Current, Rhs, N)                      \
   do                                                        \
      if (N) {                                               \
         (Current).first_line = YYRHSLOC(Rhs, 1).first_line; \
         (Current).first_col  = YYRHSLOC(Rhs, 1).first_col;  \
         (Current).last_line  = YYRHSLOC(Rhs, N).last_line;  \
         (Current).last_col   = YYRHSLOC(Rhs, N).last_col;   \
      }                                                      \
      else {                                                 \
         (Current).first_line = (Current).last_line =        \
            YYRHSLOC(Rhs, 0).last_line;                      \
         (Current).first_col = (Current).last_col =          \
            YYRHSLOC(Rhs, 0).last_col;                       \
      }                                                      \
   while (0)

class HashElement {
public:
   AbstractQoreNode* key;
   AbstractQoreNode* value;
   QoreProgramLocation loc;

   DLLLOCAL HashElement(AbstractQoreNode* k, AbstractQoreNode* v, int sl, int el) : key(k), value(v), loc(sl, el) {
      //traceout("HashElement::HashElement()");
   }

   DLLLOCAL ~HashElement() {
      discard(key, nullptr);
      discard(value, nullptr);
   }

   DLLLOCAL void addDelete(QoreParseHashNode* h) {
      h->add(key, value, loc);
      key = value = nullptr;
      delete this;
   }
};

static AbstractQoreNode* makeErrorTree(AbstractQoreNode* left, AbstractQoreNode* right) {
   discard(left, nullptr);
   discard(right, nullptr);
   return &False;
}

// for constant definitions
class ConstNode {
public:
   QoreProgramLocation loc;
   NamedScope name;
   AbstractQoreNode* value;
   bool pub;

  DLLLOCAL ConstNode(const QoreProgramLocation& loc, char* n, AbstractQoreNode* v, bool p = false) : loc(loc), name(n), value(v), pub(p) {
      // see if constant definitions are allowed
      if (parse_check_parse_option(PO_NO_CONSTANT_DEFS))
         parse_error(loc, "illegal constant definition \"%s\" (conflicts with parse option PO_NO_CONSTANT_DEFS)", n);
   }
   DLLLOCAL AbstractQoreNode* takeValue() {
      AbstractQoreNode* rv = value;
      value = nullptr;
      return rv;
   }
   DLLLOCAL const std::string& getName() const {
      return name.getIdentifierStr();
   }
   DLLLOCAL bool isPublic() const {
      return pub;
   }
};

class ObjClassDef {
public:
   QoreProgramLocation loc;
   NamedScope* name;
   QoreClass* oc;

   DLLLOCAL ObjClassDef(const QoreProgramLocation& loc, NamedScope *n, QoreClass* o) : loc(loc), name(n), oc(o) {
   }

   DLLLOCAL ObjClassDef(const QoreProgramLocation& loc, char* n, QoreClass* o) : loc(loc), name(new NamedScope(n)), oc(o) {
   }

   DLLLOCAL ~ObjClassDef() {
      delete name;
   }
};

class HashDeclDef {
public:
   QoreProgramLocation loc;
   NamedScope* name;
   TypedHashDecl* hashdecl;

   DLLLOCAL HashDeclDef(const QoreProgramLocation& loc, NamedScope *n, typed_hash_decl_private* hp) :
        loc(loc), name(n), hashdecl(hp->newTypedHashDecl(name->getIdentifier())) {
   }

   DLLLOCAL HashDeclDef(const QoreProgramLocation& loc, char* n, typed_hash_decl_private* hp) :
        loc(loc), name(new NamedScope(n)), hashdecl(hp->newTypedHashDecl(name->getIdentifier())) {
   }

   DLLLOCAL ~HashDeclDef() {
      delete name;
   }
};

class ParseUserFunctionBase {
public:
   QoreProgramLocation loc;
   UserFunctionVariant* variant;

   DLLLOCAL ParseUserFunctionBase(const QoreProgramLocation& loc, UserFunctionVariant* v) : loc(loc), variant(v) {
   }

   DLLLOCAL ~ParseUserFunctionBase() {
      if (variant)
         variant->deref();
   }

   DLLLOCAL void setPublic() {
      variant->setModulePublic();
   }
};

class ParseUserFunction : public ParseUserFunctionBase {
public:
   char* name;

   DLLLOCAL ParseUserFunction(const QoreProgramLocation& loc, char* n_name, UserFunctionVariant* n_variant) : ParseUserFunctionBase(loc, n_variant), name(n_name) {
   }

   DLLLOCAL ~ParseUserFunction() {
      if (name)
         free(name);
   }

   DLLLOCAL void add(qore_ns_private& ns) {
      qore_root_ns_private::addPendingVariant(ns, name, variant);
      variant = 0;
      // make sure definition was legal
      if (parse_check_parse_option(PO_NO_SUBROUTINE_DEFS)) {
         const char* nsn = ns.name.c_str();
         parse_error(loc, "function '%s%s%s()' cannot be defined (conflicts with parse option PO_NO_SUBROUTINE_DEFS)", nsn[0] ? nsn : "", nsn[0] ? "::" : "", name);
      }

      delete this;
   }
};

class ParseScopedUserFunction : public ParseUserFunctionBase {
public:
   NamedScope name;

   DLLLOCAL ParseScopedUserFunction(const QoreProgramLocation& loc, char* n_name, UserFunctionVariant* n_variant) : ParseUserFunctionBase(loc, n_variant), name(n_name) {
   }

   DLLLOCAL void add(qore_ns_private& ns) {
      qore_root_ns_private::addPendingVariant(ns, name, variant);
      variant = 0;
      // make sure definition was legal
      if (parse_check_parse_option(PO_NO_SUBROUTINE_DEFS))
         parse_error(loc, "function '%s()' cannot be defined (conflicts with parse option PO_NO_SUBROUTINE_DEFS)", name.ostr);

      delete this;
   }
};

struct GVarDecl {
   QoreProgramLocation loc;
   bool pub;

   DLLLOCAL GVarDecl(const QoreProgramLocation& loc, bool p) : loc(loc), pub(p) {
   }

   DLLLOCAL virtual ~GVarDecl() {
   }

   DLLLOCAL virtual void add(qore_ns_private& ns) = 0;

   DLLLOCAL virtual AbstractQoreNode* makeVar() = 0;
};

struct GVarSingleDecl : public GVarDecl {
   char* name;
   const QoreTypeInfo* typeInfo;
   QoreParseTypeInfo* parseTypeInfo;

   DLLLOCAL GVarSingleDecl(const QoreProgramLocation& loc, char* n, const QoreTypeInfo* ti, QoreParseTypeInfo* pti, bool p, bool bare) : GVarDecl(loc, p), name(n), typeInfo(ti), parseTypeInfo(pti) {
      //printd(5, "GVarSingleDecl::GVarSingleDecl() '%s' %d-%d\n", n, loc.start_line, loc.end_line);
      if (bare) {
         if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
            parse_error(loc, "global variable '%s' declared without '$' prefix, but parse option 'allow-bare-refs' is not set", n);
      }
      else {
         if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
            parse_error(loc, "reference to variable '$%s' with the '$' sign is not allowed when parse option 'allow-bare-refs' is set", n);
      }
   }

   DLLLOCAL virtual ~GVarSingleDecl() {
      if (name)
         free(name);

      delete parseTypeInfo;
   }

   DLLLOCAL char* takeName() {
      char* rv = name;
      name = 0;
      return rv;
   }

   DLLLOCAL QoreParseTypeInfo* takeParseTypeInfo() {
      QoreParseTypeInfo* rv = parseTypeInfo;
      parseTypeInfo = nullptr;
      return rv;
   }

   DLLLOCAL virtual void add(qore_ns_private& ns) {
      ns.parseAddGlobalVarDecl(loc, takeName(), typeInfo, takeParseTypeInfo(), pub);
      delete this;
   }

   DLLLOCAL virtual AbstractQoreNode* makeVar() {
      GlobalVarRefNode* gv = typeInfo
         ? new GlobalVarRefNode(loc, takeName(), typeInfo)
         : new GlobalVarRefNode(loc, takeName(), takeParseTypeInfo());
      if (pub)
         gv->setPublic();

      delete this;
      return gv;
   }
};

struct GVarListDecl : public GVarDecl {
   QoreListNode* l;

   DLLLOCAL GVarListDecl(const QoreProgramLocation& loc, QoreListNode* list, bool p) : GVarDecl(loc, p), l(list) {
      bool bareok = parse_check_parse_option(PO_ALLOW_BARE_REFS);

      ListIterator li(l);
      while (li.next()) {
         AbstractQoreNode* n = li.getValue();
         qore_type_t t = get_node_type(n);
         if (t == NT_BAREWORD) {
            BarewordNode* b = reinterpret_cast<BarewordNode*>(n);
            if (!bareok)
               parse_error(loc, "global variable '%s' in global variable declaration list declared without '$' prefix, but parse option 'allow-bare-refs' is not set", b->str);
         }
         else if (t == NT_VARREF) {
            VarRefNode* vrn = reinterpret_cast<VarRefNode*>(n);
            if (vrn->explicitScope()) {
               if (vrn->getType() == VT_LOCAL)
                  parse_error(loc, "illegal use of 'my %s' in global variable declaration list", vrn->getName());
               else if (vrn->getType() == VT_GLOBAL)
                  parse_error(loc, "illegal use of 'our %s' in global variable declaration list", vrn->getName());
            }
         }
         else
            parse_error(loc, "element %d in list following 'our' is not a variable reference (%s)", li.index(), get_type_name(n));
      }
   }

   DLLLOCAL virtual ~GVarListDecl() {
      if (l)
         l->deref(0);
   }

   DLLLOCAL QoreListNode* takeList() {
      QoreListNode* rv = l;
      l = 0;
      return rv;
   }

   DLLLOCAL virtual void add(qore_ns_private& ns) {
      ListIterator li(l);
      while (li.next()) {
         AbstractQoreNode* n = li.getValue();
         qore_type_t t = get_node_type(n);
         if (t == NT_BAREWORD) {
            BarewordNode* b = reinterpret_cast<BarewordNode*>(n);
            ns.parseAddGlobalVarDecl(loc, b->takeString(), 0, 0, pub);
         }
         else if (t == NT_VARREF) {
            VarRefNode* vrn = reinterpret_cast<VarRefNode*>(n);
            if (!vrn->explicitScope()) {
               VarRefDeclNode* vrdn = dynamic_cast<VarRefDeclNode*>(vrn);
               if (vrdn)
                  ns.parseAddGlobalVarDecl(loc, vrn->takeName(), vrdn->getTypeInfo(), vrdn->takeParseTypeInfo(), pub);
               else
                  ns.parseAddGlobalVarDecl(loc, vrn->takeName(), 0, 0, pub);
            }
         }
      }

      delete this;
   }

   DLLLOCAL virtual AbstractQoreNode* makeVar() {
      l->setVariableList();
      ListIterator li(l);
      while (li.next()) {
         AbstractQoreNode* n = li.getValue();
         qore_type_t t = get_node_type(n);
         VarRefNode* vrn = nullptr;
         if (t == NT_BAREWORD) {
            BarewordNode* b = reinterpret_cast<BarewordNode*>(n);
            GlobalVarRefNode* v = new GlobalVarRefNode(loc, b->takeString());
            b->deref();
            AbstractQoreNode** p = li.getValuePtr();
            *p = vrn = v;
         }
         else if (t == NT_VARREF) {
            vrn = reinterpret_cast<VarRefNode*>(n);
            if (!vrn->explicitScope()) {
               vrn->makeGlobal();
               vrn->setExplicitScope();
            }
         }

         if (vrn && pub)
            vrn->setPublic();
      }

      QoreListNode* rv = takeList();
      delete this;
      return rv;
   }
};

static int check_method(const QoreProgramLocation& loc, const char* name, BCAList* bcal, RetTypeInfo* returnTypeInfo) {
   bool con = !strcmp(name, "constructor");
   bool dst = !con && !strcmp(name, "destructor");

   // see if a return type is given for special methods
   if (returnTypeInfo && (con || dst)) {
      parse_error(loc, "%s methods may not declare a return type", name);
      return -1;
   }

   if (bcal && !con) {
      parse_error(loc, "base class constructor lists are only legal when defining constructor() methods");
      return -1;
   }

   return 0;
}

#define OFM_PUBLIC     (1 << 0)
#define OFM_PRIVATE    (1 << 1)
#define OFM_INTERNAL   (1 << 2)
#define OFM_SYNCED     (1 << 3)
#define OFM_STATIC     (1 << 4)
#define OFM_DEPRECATED (1 << 5)
#define OFM_FINAL      (1 << 6)
#define OFM_ABSTRACT   (1 << 7)

static inline MethodVariantBase* new_method_variant(const QoreProgramLocation& loc, const char* name, int mod, int n_sig_first_line, int n_sig_last_line, AbstractQoreNode* params, BCAList* bcal, RetTypeInfo* returnTypeInfo, StatementBlock *b) {
   //printd(5, "new_method_variant() '%s' b: %p\n", name, b);
   int64 flags = QC_NO_FLAGS;

   if (get_pop_argv_ref())
      flags |= QC_USES_EXTRA_ARGS;

   ClassAccess access = Public;
   if (mod & OFM_PRIVATE) {
      if (mod & OFM_INTERNAL)
         parse_error(loc, "%s() methods cannot be both private:hierarchy and private:internal", name);
      if (mod & OFM_PUBLIC)
         parse_error(loc, "%s() methods cannot be both public and private", name);
      access = Private;
   }
   else if (mod & OFM_INTERNAL) {
      if (mod & OFM_PUBLIC)
         parse_error(loc, "%s() methods cannot be both public and private", name);
      access = Internal;
   }

   if (mod & OFM_DEPRECATED)
      flags |= QC_DEPRECATED;

   if (!strcmp(name, "constructor")) {
      if (mod & OFM_SYNCED)
         parse_error(loc, "%s() methods cannot be synchronized", name);
      if (mod & OFM_FINAL)
         parse_error(loc, "%s() methods cannot be declared final; declare the class final instead", name);
      if (mod & OFM_ABSTRACT)
         parse_error(loc, "%s() methods cannot be declared abstract", name);
      if (returnTypeInfo) {
         parse_error(loc, "return type information cannot be defined for %s() methods", name);
         delete returnTypeInfo;
      }
      return new UserConstructorVariant(access, b, n_sig_first_line, n_sig_last_line, params, bcal, flags);
   }
   if (bcal) {
      parse_error(loc, "only constructors may have base class constructor arguments");
      delete bcal;
      bcal = 0;
   }
   if (!strcmp(name, "destructor")) {
      if (params) {
         parse_error(loc, "parameters cannot be defined for destructors");
         params->deref(nullptr);
      }
      if (mod & OFM_SYNCED)
         parse_error(loc, "%s() methods cannot be synchronized", name);
      if (mod & OFM_FINAL)
         parse_error(loc, "%s() methods cannot be declared final; declare the class final instead", name);
      if (mod & OFM_ABSTRACT)
         parse_error(loc, "%s() methods cannot be declared abstract", name);
      if (returnTypeInfo) {
         parse_error(loc, "return type information cannot be defined for %s() methods", name);
         delete returnTypeInfo;
      }
      if (access > Public)
	 parse_error(loc, "destructors cannot be private");
      return new UserDestructorVariant(b, n_sig_first_line, n_sig_last_line);
   }
   if (!strcmp(name, "copy")) {
      if (mod & OFM_FINAL)
         parse_error(loc, "%s() methods cannot be declared final; declare the class final instead", name);
      return new UserCopyVariant(access, b, n_sig_first_line, n_sig_last_line, params, returnTypeInfo, mod & OFM_SYNCED);
   }

   if (!strcmp(name, "methodGate") || !strcmp(name, "memberGate") || !strcmp(name, "memberNotification")) {
      if (mod & OFM_FINAL)
         parse_error(loc, "%s() methods cannot be declared final; they are not inherited anyway", name);
      if (mod & OFM_ABSTRACT)
         parse_error(loc, "%s() methods cannot be declared abstract; they are not inherited anyway", name);
   }

   if (mod & OFM_FINAL && mod & OFM_ABSTRACT)
      parse_error(loc, "method '%s()' is declared both final and abstract", name);

   return new UserMethodVariant(access, mod & OFM_FINAL, b, n_sig_first_line, n_sig_last_line, params, returnTypeInfo, mod & OFM_SYNCED, flags, mod & OFM_ABSTRACT);
}

struct MethodDef {
   QoreProgramLocation loc;
   MethodVariantBase* m;
   NamedScope name;
   bool static_flag;

   DLLLOCAL MethodDef(const QoreProgramLocation& loc, int mod, char* n, int n_sig_first_line, int n_sig_last_line, AbstractQoreNode* params, BCAList* bcal, RetTypeInfo* returnTypeInfo, StatementBlock *b) : loc(loc), m(0), name(n), static_flag(mod & OFM_STATIC) {
      if (check_method(loc, name.getIdentifier(), bcal, returnTypeInfo)) {
         if (params)
            params->deref(0);
         delete bcal;
         delete b;
         delete returnTypeInfo;
         return;
      }

      m = new_method_variant(loc, name.getIdentifier(), mod, n_sig_first_line, n_sig_last_line, params, bcal, returnTypeInfo, b);
   }

   DLLLOCAL ~MethodDef() {
      delete m;
   }

   DLLLOCAL void parseAddToClassAndDel() {
      if (m) {
         // if there are any errors, the function below will delete memory
         // the following method takes ownership of "m" unconditionally
         qore_root_ns_private::parseAddMethodToClass(loc, name, m, static_flag);
         m = 0;
      }
      delete this;
   }

   DLLLOCAL void add(qore_ns_private& ns) {
      // the following method takes ownership of "m" unconditionally
      ns.parseAddMethodToClass(loc, name, m, static_flag);
      m = 0;
   }
};

static AbstractQoreNode* parse_hash_map(const QoreProgramLocation& loc, QoreParseHashNode* exp, QoreListNode* l) {
   assert(l && (l->size() == 1 || l->size() == 2));
   ReferenceHolder<> exph(exp, 0);
   ReferenceHolder<> lh(l, 0);

   // check hash expression
   size_t len = exp->size();

   if (len == 0) {
       qore_program_private::makeParseWarning(getProgram(), loc, QP_WARN_INVALID_OPERATION, "INVALID-OPERATION",
            "empty hash as an argument to the hash map operator, this expression will always evaluate to an empty hash");
       return new QoreHashNode;
   }

   if (len != 1) {
      parse_error(loc, "invalid initial argument to hash map operator, expected a single key value pair; got %d hash elements instead", len);
      return &True;
   }

   if (l->size() == 1) {
      AbstractQoreNode* iter = l->shift();
      return new QoreHashMapOperatorNode(loc, exp->takeFirstKeyNode(), exp->takeFirstValueNode(), iter);
   }

   AbstractQoreNode* iter = l->shift();
   AbstractQoreNode* select = l->shift();
   return new QoreHashMapSelectOperatorNode(loc, exp->takeFirstKeyNode(), exp->takeFirstValueNode(), iter, select);
}

static AbstractQoreNode* parse_map(const QoreProgramLocation& loc, AbstractQoreNode* exp, QoreListNode* l) {
   assert(l && (l->size() == 1 || l->size() == 2));
   ReferenceHolder<> lh(l, 0);

   if (l->size() == 1) {
      AbstractQoreNode* arg = l->shift();
      return new QoreMapOperatorNode(loc, exp, arg);
   }

   AbstractQoreNode* iterator_exp = l->shift();
   AbstractQoreNode* select_exp = l->shift();
   return new QoreMapSelectOperatorNode(loc, exp, iterator_exp, select_exp);
}

#define NSN_NONE     0
#define NSN_OCD      1
#define NSN_HASHDECL 2
#define NSN_CONST    3
#define NSN_NS       4
#define NSN_FUNC     5
#define NSN_SFUNC    6
#define NSN_VAR      7
#define NSN_METH     8

struct NSNode {
   int type;
   union {
      ObjClassDef* ocd;
      HashDeclDef* hashdecl;
      ConstNode* cn;
      QoreNamespace* ns;
      ParseUserFunction* func;
      ParseScopedUserFunction* sfunc;
      GVarDecl* gv;
      MethodDef* meth;
   } n;

   DLLLOCAL NSNode(ObjClassDef* o) { type = NSN_OCD; n.ocd = o; }
   DLLLOCAL NSNode(HashDeclDef* h) { type = NSN_HASHDECL; n.hashdecl = h; }
   DLLLOCAL NSNode(ConstNode* c) { type = NSN_CONST; n.cn = c; }
   DLLLOCAL NSNode(QoreNamespace* s) { type = NSN_NS; n.ns = s; }
   DLLLOCAL NSNode(ParseUserFunction* f) : type(NSN_FUNC) {
      n.func = f;
   }
   DLLLOCAL NSNode(ParseScopedUserFunction* f) : type(NSN_SFUNC) {
      n.sfunc = f;
   }

   DLLLOCAL NSNode(GVarDecl* gv) : type(NSN_VAR) {
      n.gv = gv;
   }

   DLLLOCAL NSNode(MethodDef* m) : type(NSN_METH) {
      n.meth = m;
   }

   DLLLOCAL void deref() {
      switch (type) {
         case NSN_OCD:
            delete n.ocd;
            break;
         case NSN_HASHDECL:
            delete n.hashdecl;
            break;
         case NSN_CONST:
            delete n.cn;
            break;
         case NSN_NS:
            delete n.ns;
            break;
         case NSN_FUNC:
            delete n.func;
            break;
         case NSN_SFUNC:
            delete n.sfunc;
            break;
         case NSN_VAR:
            delete n.gv;
            break;
         case NSN_METH:
            delete n.meth;
            break;
         default:
            assert(false);
            // no break
      }
      delete this;
   }

   DLLLOCAL void add(qore_ns_private& ns) {
      switch (type) {
         case NSN_OCD:
            //printd(5, "ocd: %s %d-%d c: %d-%d\n", n.ocd->oc->getName(), n.ocd->loc.start_line, n.ocd->loc.end_line, qore_class_private::get(*n.ocd->oc)->loc.start_line, qore_class_private::get(*n.ocd->oc)->loc.end_line);
            ns.parseAddPendingClass(n.ocd->loc, *(n.ocd->name), n.ocd->oc);
            delete n.ocd;
            break;
         case NSN_HASHDECL:
            ns.parseAddPendingHashDecl(n.hashdecl->loc, *(n.hashdecl->name), n.hashdecl->hashdecl);
            break;
         case NSN_CONST:
            ns.parseAddConstant(n.cn->loc, n.cn->name, n.cn->value, n.cn->pub);
            delete n.cn;
            break;
         case NSN_NS:
            ns.parseAddNamespace(n.ns);
            break;
         case NSN_FUNC:
            n.func->add(ns);
            break;
         case NSN_SFUNC:
            n.sfunc->add(ns);
            break;
         case NSN_VAR:
            n.gv->add(ns);
            break;
         case NSN_METH:
            n.meth->add(ns);
            delete n.meth;
            break;
         default:
            assert(false);
            // no break
      }
      delete this;
   }
};

typedef std::vector<NSNode*>nsnode_list_t;

struct NSNodeList : public nsnode_list_t {
   DLLLOCAL void deref() {
      for (nsnode_list_t::iterator i = begin(), e = end(); i != e; ++i)
         (*i)->deref();

      delete this;
   }

   DLLLOCAL void add(qore_ns_private& ns) {
      for (nsnode_list_t::iterator i = begin(), e = end(); i != e; ++i)
         (*i)->add(ns);
   }
};

static QoreListNode* make_list(AbstractQoreNode* a1, AbstractQoreNode* a2) {
   QoreListNode* l = new QoreListNode;
   l->push(a1);
   l->push(a2);
   return l;
}

static QoreListNode* splice_expressions(AbstractQoreNode* a1, AbstractQoreNode* a2) {
   //tracein("splice_expressions()");
   if (a1 && a1->getType() == NT_LIST) {
      QoreListNode* l = reinterpret_cast<QoreListNode*>(a1);
      if (!l->isFinalized()) {
         //printd(5, "LIST x\n");
         l->push(a2);
         return l;
      }
   }
   return make_list(a1, a2);
}

typedef std::pair<char*, QoreMemberInfo*> member_pair_t;
typedef std::pair<char*, QoreVarInfo*> var_pair_t;
typedef std::pair<char*, HashDeclMemberInfo*> hashmem_pair_t;

#define MI_Member 0
#define MI_Constant 1
#define MI_Var 2
#define MI_HashMem 3

struct MemberInfo {
protected:
   DLLLOCAL MemberInfo(const QoreProgramLocation& loc) : loc(loc) {
   }

public:
   QoreProgramLocation loc;
   char* name;
   unsigned char type;
   union {
      QoreMemberInfo* memberInfo;
      QoreVarInfo* varInfo;
      HashDeclMemberInfo* hashMemberInfo;
      AbstractQoreNode* exp;
   } u;

   DLLLOCAL MemberInfo(char* n, QoreMemberInfo* mi) : loc(mi->loc), name(n), type(MI_Member) {
      u.memberInfo = mi;
      if (!(mi && mi->parseHasTypeInfo()) && parse_check_parse_option(PO_REQUIRE_TYPES))
         parse_error(mi->loc, "member '%s' declared without type information, but parse options require type information for all declarations", name);
   }

   DLLLOCAL MemberInfo(const QoreProgramLocation& loc, char* n, AbstractQoreNode* exp) : loc(loc), name(n), type(MI_Constant) {
      u.exp = exp;
   }

   DLLLOCAL MemberInfo(char* n, HashDeclMemberInfo* mi) : loc(mi->loc), name(n), type(MI_HashMem) {
      u.hashMemberInfo = mi;
   }

   DLLLOCAL ~MemberInfo() {
      if (name)
         free(name);
      switch (type) {
         case MI_Member:
            delete u.memberInfo;
            break;
         case MI_Var:
            delete u.varInfo;
            break;
         case MI_HashMem:
            delete u.hashMemberInfo;
            break;
         case MI_Constant:
            if (u.exp)
               u.exp->deref(0);
            break;
      }
   }

   DLLLOCAL member_pair_t getPair() {
      assert(type == MI_Member);
      member_pair_t m = std::make_pair(name, u.memberInfo);
      name = nullptr;
      u.memberInfo = nullptr;
      return m;
   }

   DLLLOCAL var_pair_t getVarPair() {
      assert(type == MI_Var);
      var_pair_t m = std::make_pair(name, u.varInfo);
      name = nullptr;
      u.varInfo = nullptr;
      return m;
   }

   DLLLOCAL hashmem_pair_t getHashMemPair() {
      assert(type == MI_HashMem);
      hashmem_pair_t m = std::make_pair(name, u.hashMemberInfo);
      name = nullptr;
      u.hashMemberInfo = nullptr;
      return m;
   }

   DLLLOCAL AbstractQoreNode* takeExp() {
      assert(type == MI_Constant);
      AbstractQoreNode* rv = u.exp;
      u.exp = nullptr;
      return rv;
   }
};

struct ClassVarInfo : public MemberInfo {
   DLLLOCAL ClassVarInfo(char* n, QoreVarInfo* vi) : MemberInfo(vi->loc) {
      name = n;
      type = MI_Var;
      u.varInfo = vi;
      if (!(vi && vi->parseHasTypeInfo()) && parse_check_parse_option(PO_REQUIRE_TYPES))
         parse_error(vi->loc, "class static variable '%s' declared without type information, but parse options require type information for all declarations", name);
   }

   DLLLOCAL char* takeName() {
      char* n = name;
      name = nullptr;
      return n;
   }
};

class MemberList {
protected:
   // for new class members
   QoreMemberMap mmap;
   // for new class constants
   ConstantList cmap;
   // for new class static variables
   QoreVarMap vmap;

   DLLLOCAL MemberList() : cmap((qore_class_private*)0) {
   }

public:
   DLLLOCAL MemberList(MemberInfo* member) : cmap((qore_class_private*)0) {
      if (!member)
         return;

      if (member->type == MI_Member)
         mmap.addNoCheck(member->getPair());
      else if (member->type == MI_Constant)
         cmap.parseAdd(member->loc, member->name, member->takeExp());
      else
         vmap.addNoCheck(member->getVarPair());

      delete member;
   }

   DLLLOCAL ~MemberList() {
   }

   // takes over ownership of name and typeInfo
   DLLLOCAL int add(MemberInfo* member) {
      if (!member)
         return -1;

      if (member->type == MI_Member) {
         if (mmap.inList(member->name)) {
            parse_error(member->loc, "duplicate member declaration '%s'", member->name);
            delete member;
            return -1;
         }

         // add new member to list
         mmap.addNoCheck(member->getPair());
         delete member;
      }
      else if (member->type == MI_Constant) {
         if (cmap.inList(member->name)) {
            parse_error(member->loc, "duplicate constant declaration '%s'", member->name);
            delete member;
            return -1;
         }
         if (vmap.find(member->name)) {
            parse_error(member->loc, "constant declaration collides with static class variable declaration '%s'", member->name);
            delete member;
            return -1;
         }

         // add new constant to list
         cmap.parseAdd(member->loc, member->name, member->takeExp());
         delete member;
      }
      else {
         assert(member->type == MI_Var);
         if (vmap.find(member->name)) {
            parse_error(member->loc, "duplicate static class variable declaration '%s'", member->name);
            delete member;
            return -1;
         }
         if (cmap.inList(member->name)) {
            parse_error(member->loc, "static class variable declaration collides with constant declaration '%s'", member->name);
            delete member;
            return -1;
         }

         // add new member to list
         vmap.addNoCheck(member->getVarPair());
         delete member;
      }

      return 0;
   }

   DLLLOCAL void merge(QoreClass* qc, ClassAccess access) {
      mmap.moveAllTo(qc, access);
      vmap.moveAllTo(qc, access);

      // merge constants
      qore_class_private::get(*qc)->parseAssimilateConstants(cmap, access);
   }
};

class EmptyMemberList : public MemberList {
public:
   DLLLOCAL EmptyMemberList() {
   }
};

struct ParserTypeStruct {
protected:
   DLLLOCAL ParserTypeStruct() {
   }

public:
   const QoreTypeInfo* typeInfo = nullptr;
   QoreParseTypeInfo* parseTypeInfo = nullptr;

   DLLLOCAL ParserTypeStruct(QoreParseTypeInfo* n_parseTypeInfo) : parseTypeInfo(n_parseTypeInfo) {
   }

   DLLLOCAL ParserTypeStruct(char* id, bool or_nothing) : typeInfo(or_nothing ? getBuiltinUserOrNothingTypeInfo(id) : getBuiltinUserTypeInfo(id)) {
      //printd(0, "ParserTypeStruct::ParserTypeStruct('%s', %d) t: %p %s\n", id, or_nothing, typeInfo, QoreTypeInfo::getName(typeInfo));
      if (typeInfo) {
         free(id);
         return;
      }

      parseTypeInfo = new QoreParseTypeInfo(id, or_nothing);
   }

   DLLLOCAL ~ParserTypeStruct() {
      delete parseTypeInfo;
   }

   DLLLOCAL const QoreTypeInfo* getTypeInfo() const {
      return typeInfo;
   }

   // static version of method, checking for null pointer
   DLLLOCAL static const QoreTypeInfo* getTypeInfo(ParserTypeStruct* pts) {
      return pts ? pts->getTypeInfo() : nullptr;
   }

   DLLLOCAL QoreParseTypeInfo* getParseTypeInfo() {
      QoreParseTypeInfo* rv = parseTypeInfo;
      parseTypeInfo = nullptr;
      return rv;
   }

   // static version of method, checking for null pointer
   DLLLOCAL static QoreParseTypeInfo* getParseTypeInfo(ParserTypeStruct* pts) {
      return pts ? pts->getParseTypeInfo() : nullptr;
   }

   DLLLOCAL const char* getClassName() {
      assert(parseTypeInfo);
      return parseTypeInfo->cscope->ostr;
   }

   DLLLOCAL static ParserTypeStruct* getType(char* id, bool or_nothing) {
      return new ParserTypeStruct(getParseType(id, or_nothing));
   }

   DLLLOCAL static QoreParseTypeInfo* getParseType(char* id, bool or_nothing) {
      char* p0 = strchr(id, '<');
      if (p0) {
         char* p1 = strrchr(id, '>');
         if (p1 > (p0 + 1)) {
            *p0 = '\0';
            *p1 = '\0';
            ++p0;
            bool st_or_nothing = *p0 == '*';
            QoreParseTypeInfo* st = getParseType(strdup(p0 + (st_or_nothing ? 1 : 0)), st_or_nothing);
            return new QoreParseTypeInfo(id, or_nothing, st);
         }
      }
      return new QoreParseTypeInfo(id, or_nothing);
   }
};

static AbstractQoreNode* process_dot(int sline, int eline, AbstractQoreNode* l, AbstractQoreNode* r) {
   qore_type_t rtype = r->getType();
   switch (rtype) {
      case NT_BAREWORD: {
         BarewordNode* b = reinterpret_cast<BarewordNode*>(r);
         if (!b->isFinalized()) {
            AbstractQoreNode* rv = new QoreHashObjectDereferenceOperatorNode(QoreProgramLocation(sline, eline), l, b->makeQoreStringNode());
            b->deref();
            return rv;
         }
         break;
      }

      case NT_FUNCTION_CALL: {
         FunctionCallNode* f = reinterpret_cast<FunctionCallNode*>(r);
         assert(!f->getFunction());
         if (!f->isFinalized()) {
            MethodCallNode* m = new MethodCallNode(QoreProgramLocation(sline, eline), f->takeName(), f->takeArgs());
            f->deref();

            return new QoreDotEvalOperatorNode(QoreProgramLocation(sline, eline), l, m);
         }
         break;
      }
   }

   return new QoreHashObjectDereferenceOperatorNode(QoreProgramLocation(sline, eline), l, r);
}

static int check_strong_encapsulation(const QoreProgramLocation& loc, const char* type, const char* name) {
   if (parse_check_parse_option(PO_STRONG_ENCAPSULATION)) {
      parse_error(loc, "illegal out of line %s definition \"%s\" (conflicts with parse option PO_STRONG_ENCAPSULATION)", type, name);
      return -1;
   }
   return 0;
}

static int check_case(const QoreProgramLocation& loc, const char* op, AbstractQoreNode* exp) {
   // ignore if NULL (= NOTHING)
   if (node_has_effect(exp)) {
      if (op)
         parse_error(loc, "case expression with '%s' needs run-time evaluation", op);
      else
         parse_error(loc, "case expression needs run-time evaluation", op);
      return -1;
   }
   return 0;
}

static void check_funcmod(const QoreProgramLocation& loc, int mod) {
   if (mod & (OFM_PRIVATE|OFM_INTERNAL))
      parse_error(loc, "illegal 'private' modifier in function declaration");
   if (mod & OFM_STATIC)
      parse_error(loc, "illegal 'static' modifier in function declaration");
   if (mod & OFM_FINAL)
      parse_error(loc, "illegal 'final' modifier in function declaration");
   if (mod & OFM_ABSTRACT)
      parse_error(loc, "illegal 'abstract' modifier in function declaration");
}

static void check_classmod(const QoreProgramLocation& loc, int mod, QoreClass& qc) {
   if (mod & (OFM_PRIVATE|OFM_INTERNAL))
      parse_error(loc, "illegal 'private' modifier in class declaration");
   if (mod & OFM_SYNCED)
      parse_error(loc, "illegal 'synchronized' modifier in class declaration");
   if (mod & OFM_STATIC)
      parse_error(loc, "illegal 'static' modifier in class declaration");
   if (mod & OFM_PUBLIC)
      qore_class_private::setPublic(qc);
   if (mod & OFM_DEPRECATED)
      parse_error(loc, "illegal 'deprecated' modifier in class declaration");
   if (mod & OFM_FINAL)
      qore_class_private::setFinal(qc);
   if (mod & OFM_ABSTRACT)
      parse_error(loc, "illegal 'abstract' modifier in class declaration");
}

static void check_hashdeclmod(const QoreProgramLocation& loc, int mod, typed_hash_decl_private& hashdecl) {
   if (mod & (OFM_PRIVATE|OFM_INTERNAL))
      parse_error(loc, "illegal 'private' modifier in hashdecl");
   if (mod & OFM_SYNCED)
      parse_error(loc, "illegal 'synchronized' modifier in hashdecl");
   if (mod & OFM_STATIC)
      parse_error(loc, "illegal 'static' modifier in hashdecl");
   if (mod & OFM_PUBLIC)
      hashdecl.setPublic();
   if (mod & OFM_DEPRECATED)
      parse_error(loc, "illegal 'deprecated' modifier in hashdecl");
   if (mod & OFM_FINAL)
      parse_error(loc, "illegal 'final' modifier in hashdecl");
   if (mod & OFM_ABSTRACT)
      parse_error(loc, "illegal 'abstract' modifier in hashdecl");
}

static void check_nsmod(const QoreProgramLocation& loc, int mod, qore_ns_private& ns) {
   if (mod & (OFM_PRIVATE|OFM_INTERNAL))
      parse_error(loc, "illegal 'private' modifier in namespace declaration");
   if (mod & OFM_SYNCED)
      parse_error(loc, "illegal 'synchronized' modifier in namespace declaration");
   if (mod & OFM_STATIC)
      parse_error(loc, "illegal 'static' modifier in namespace declaration");
   if (mod & OFM_PUBLIC)
      ns.setPublic();
   if (mod & OFM_DEPRECATED)
      parse_error(loc, "illegal 'deprecated' modifier in namespace declaration");
   if (mod & OFM_FINAL)
      parse_error(loc, "illegal 'final' modifier in namespace declaration");
   if (mod & OFM_ABSTRACT)
      parse_error(loc, "illegal 'abstract' modifier in namespace declaration");
}

bool node_has_effect(const AbstractQoreNode* n) {
   if (!n || n->is_value())
      return false;

   if (n->getType() == NT_OPERATOR)
      return reinterpret_cast<const QoreOperatorNode*>(n)->hasEffect();

   const ParseNode* pn = dynamic_cast<const ParseNode*>(n);
   return pn ? pn->has_effect() : true;
}

struct MethodNode {
public:
   // name of method
   char* name;
   // method variant to add to class
   MethodVariantBase *m;
   // static flag
   bool static_flag;

   DLLLOCAL MethodNode(char* mname, MethodVariantBase *v, bool n_static) : name(mname), m(v), static_flag(n_static) {
   }

   DLLLOCAL ~MethodNode() {
      free(name);
      delete m;
   }

   DLLLOCAL void addAndDelete(QoreClass* qc) {
      qore_class_private::addUserMethod(*qc, name, m, static_flag);
      m = 0;
      delete this;
   }

   DLLLOCAL const QoreProgramLocation& getLoc() const {
      return m->getUserVariantBase()->getUserSignature()->getParseLocation();
   }
};

static AbstractQoreNode* is_rewritable_op(AbstractQoreNode* n) {
   qore_type_t nt = get_node_type(n);
   if (nt == NT_OPERATOR) {
      QoreBinaryLValueOperatorNode* op = dynamic_cast<QoreBinaryLValueOperatorNode*>(n);
      if (op)
         return op->getRight();
   }

   return 0;
}

static AbstractQoreNode* checkRewriteList(QoreListNode* l) {
   if (!parse_check_parse_option(PO_BROKEN_LIST_PARSING))
      return l;

   // rewrite expression if it's a list without parentheses and
   // the first expression has one of the following operators:
   // =, +=, -=
   if (l->isFinalized())
      return l;

   AbstractQoreNode* e0 = l->retrieve_entry(0);

   AbstractQoreNode* r = is_rewritable_op(e0);
   if (r) {
      AbstractQoreNode* last = e0;
      AbstractQoreNode* top = e0;
      while (true) {
         AbstractQoreNode* nr = is_rewritable_op(r);
         if (!nr)
            break;
         last = r;
         r = nr;
      }
      assert(dynamic_cast<QoreBinaryLValueOperatorNode*>(last));
      // take first element from list (the tree) and make it the new expression
      QoreBinaryLValueOperatorNode* op = reinterpret_cast<QoreBinaryLValueOperatorNode*>(last);
      l->swap(0, op->swapRight(l));
      return top;
   }

   return l;
}

void ignore_return_value(AbstractQoreNode* n) {
   qore_type_t t = get_node_type(n);
   if (t == NT_OPERATOR)
      reinterpret_cast<QoreOperatorNode*>(n)->ignoreReturnValue();
}

static qore_var_t get_var_type() {
   return parse_check_parse_option(PO_ASSUME_LOCAL) ? VT_LOCAL : VT_UNRESOLVED;
}

static QoreOperatorNode* processAssignment(int sline, int eline, AbstractQoreNode* $1, AbstractQoreNode* $3) {
   return ($1 && $1->getType() == NT_LIST)
      ? static_cast<QoreOperatorNode*>(new QoreListAssignmentOperatorNode(QoreProgramLocation(sline, eline), $1, $3))
      : static_cast<QoreOperatorNode*>(new QoreAssignmentOperatorNode(QoreProgramLocation(sline, eline), $1, $3));
}

static AbstractQoreNode* processCall(int sline, int eline, AbstractQoreNode* $1, AbstractQoreNode* $3) {
    AbstractQoreNode* $$;
   //printd(5, "1=%s (%p), 3=%s (%p)\n", $1->getTypeName(), $1, $3 ? $3->getTypeName() : "n/a", $3);
   qore_type_t t = get_node_type($1);
   if (t == NT_BAREWORD) {
      BarewordNode* b = reinterpret_cast<BarewordNode*>($1);
      // take string from node and delete node
      char* str = b->takeString();
      b->deref();
      printd(5, "parsing call %s() args=%p %s\n", str, $3, $3 ? $3->getTypeName() : "n/a");
      $$ = new FunctionCallNode(QoreProgramLocation(sline, eline), str, make_args($3));
   }
   else if (t == NT_CONSTANT) {
      ScopedRefNode* c = reinterpret_cast<ScopedRefNode*>($1);
      // take NamedScope from node and delete node
      NamedScope *ns = c->takeName();
      c->deref();
      assert(ns->size() > 1);
      printd(5, "parsing scoped call (static method, new object call, or program function call) %s()\n", ns->ostr);
      $$ = new StaticMethodCallNode(QoreProgramLocation(sline, eline), ns, make_args($3));
   }
   else if (t == NT_SELF_VARREF) {
      SelfVarrefNode* v = reinterpret_cast<SelfVarrefNode*>($1);
      // take string from node and delete node
      char* str = v->takeString();
      v->deref();
      //printd(5, "parsing in-object method call %s()\n", str);
      $$ = new SelfFunctionCallNode(QoreProgramLocation(sline, eline), str, make_args($3));
   }
   else {
      QoreHashObjectDereferenceOperatorNode* hodon;

      if (t == NT_OPERATOR) {
         hodon = dynamic_cast<QoreHashObjectDereferenceOperatorNode*>($1);
         if (hodon) {
            AbstractQoreNode* r = hodon->getRight();
            if (!r || r->getType() != NT_STRING)
               hodon = 0;
         }
      }
      else
         hodon = 0;

      if (hodon) {
         // create an object method call node
         // take the string
         QoreStringNode* str = reinterpret_cast<QoreStringNode*>(hodon->swapRight(0));
         assert(str->getEncoding() == QCS_DEFAULT);
         char* cstr = str->giveBuffer();
         assert(cstr);
         str->deref();

         MethodCallNode* mc = new MethodCallNode(QoreProgramLocation(sline, eline), cstr, make_args($3));

         // destroy the original operator and create a new operator object
         assert(hodon->is_unique());
         AbstractQoreNode* l = hodon->swapLeft(0);
         hodon->deref(0);

         $$ = new QoreDotEvalOperatorNode(QoreProgramLocation(sline, eline), l, mc);
      }
      else {
         $$ = 0;
         if ($1 && $1->getType() == NT_VARREF) {
            VarRefNode* r = reinterpret_cast<VarRefNode*>($1);
            qore_var_t vartype = r->getType();

            if (vartype != VT_UNRESOLVED) {
               $$ = r->makeNewCall($3);
               //printd(5, "makeNewCall(%p) returned %p (%s)\n", $3, $$, get_type_name($$));
               if (!$$)
                  parseException(QoreProgramLocation(sline, eline), "INVALID-CODE-REFERENCE-CALL", "%s variable '%s' declared as a function reference call", r->getType() == VT_GLOBAL ? "global" : "local", r->getName());
            }
         }
         if (!$$) {
            $$ = new CallReferenceCallNode(QoreProgramLocation(sline, eline), $1, make_args($3));
            printd(5, "made new CallReferenceCallNode: %p exp=%p %s\n", $$, $1, get_type_name($1));
         }
      }
   }
   return $$;
}

static void check_operator(const QoreOperatorNode *n, const char *parent, const char *child) {
    if (parse_check_parse_option(PO_BROKEN_LOGIC_PRECEDENCE)) {
        if (!n->getInParentheses()) {
            qore_program_private::makeParseWarning(getProgram(), QP_WARN_BROKEN_LOGIC_PRECEDENCE, "BROKEN-LOGIC-PRECEDENCE", "%s gets under %s in the parse tree as an impact of broken-logic-precedence flag being set - please consider using parenthesis to enforce the desired operator precedence", child, parent);
        }
    }
}

static void check_operator_log_or(const AbstractQoreNode *n, const char *parent) {
    if (dynamic_cast< const QoreLogicalOrOperatorNode *>(n)) {
        check_operator(static_cast<const QoreOperatorNode*>(n), parent, "logical OR");
    }
}

static void check_operator_bin_or(const AbstractQoreNode *n, const char *parent) {
    if (dynamic_cast< const QoreBinaryOrOperatorNode *>(n)) {
        check_operator(static_cast<const QoreOperatorNode*>(n), parent, "binary OR");
    }
}

static void check_operator_bin_xor(const AbstractQoreNode *n, const char *parent) {
    if (dynamic_cast< const QoreBinaryXorOperatorNode *>(n)) {
        check_operator(static_cast<const QoreOperatorNode*>(n), parent, "binary XOR");
    }
}

%}

%pure-parser
%lex-param {yyscan_t yyscanner}
%parse-param {yyscan_t yyscanner}
%locations
%error-verbose

%union {
   bool b;
   int i4;
   int64 integer;
   double decimal;
   QoreStringNode* String;
   char* string;
   BinaryNode* binary;
   AbstractQoreNode* node;
   QoreParseHashNode* hash;
   QoreListNode* list;
   AbstractStatement* statement;
   struct MemberInfo* memberinfo;
   struct ClassVarInfo* classvarinfo;
   StatementBlock *sblock;
   ContextModList* cmods;
   ContextMod *cmod;
   class HashElement* hashelement;
   QoreFunction* userfunc;
   struct MethodNode* methodnode;
   class MemberList* memberlist;
   QoreClass* qoreclass;
   typed_hash_decl_private* hashdeclpriv;
   class ConstNode* constnode;
   QoreNamespace *ns;
   struct NSNodeList* nsnlist;
   struct NSNode* nsn;
   class ObjClassDef* classdef;
   class HashDeclDef* hashdecldef;
   DateTimeNode* datetime;
   QoreRegexSubst* RegexSubst;
   QoreTransliteration* Trans;
   SwitchStatement* switchstmt;
   CaseNode* casenode;
   BCList* sclist;
   class BCNode* sclnode;
   BCAList* bcalist;
   BCANode* bcanode;
   NamedScope *nscope;
   QoreRegex* Regex;
   QoreImplicitArgumentNode* implicit_arg;
   RetTypeInfo* returnTypeInfo;
   struct ParserTypeStruct* parsertype;
   class ParseUserFunction* parsefunc;
   class ParseScopedUserFunction* sparsefunc;
   struct GVarDecl* gv;
   QoreNumberNode* num;
   TryModuleError* trymod;
   struct MethodDef* methoddef;
}

%{

#define LEX_PARAMETERS YYSTYPE *lvalp, YYLTYPE *loc, yyscan_t scanner

DLLLOCAL int yylex(LEX_PARAMETERS);

DLLLOCAL void yyerror(YYLTYPE* loc, yyscan_t scanner, const char* str) {
   //printd(5, "yyerror() location: %d:%d - %d:%d \"%s\"\n", loc->first_line, loc->first_col, loc->last_line, loc->last_col, str);
   parse_error(QoreProgramLocation(loc->first_line, loc->last_line), "%s", str);
}

%}

// define string aliases for token names for more user-friendly error reporting
%token TOK_RETURN "return"
%token TOK_RETURNS "returns"
%token TOK_MY "my"
%token TOK_DO "do"
%token TOK_TRY "try"
%token TOK_THROW "throw"
%token TOK_CATCH "catch"
%token TOK_WHERE "where"
%token TOK_WHILE "while"
%token TOK_IF "if"
%token TOK_FOR "for"
%token TOK_SUB "sub"
%token TOK_THREAD_EXIT "thread_exit"
%token TOK_BREAK "break"
%token TOK_CONTINUE "continue"
%token TOK_CONTEXT_ROW "%%"
%token TOK_FIND "find"
%token TOK_FOREACH "foreach"
%token TOK_IN "in"
%token TOK_DELETE "delete"
%token TOK_REMOVE "remove"
%token TOK_PRIVATE "private"
%token TOK_PRIVATEINTERNAL "private:internal"
%token TOK_PRIVATEHIERARCHY "private:hierarchy"
%token TOK_PUBLIC "public"
%token TOK_SYNCHRONIZED "synchronized"
%token TOK_DEPRECATED "deprecated"
%token TOK_CONTEXT "context"
%token TOK_SORT_BY "sortBy"
%token TOK_SORT_DESCENDING_BY "sortDescendingBy"
%token TOK_SUB_CONTEXT "subcontext"
%token TOK_CONST "const"
%token TOK_SUMMARIZE "summarize"
%token TOK_BY "by"
%token TOK_OUR "our"
%token TOK_RETHROW "rethrow"
%token TOK_SWITCH "switch"
%token TOK_CASE "case"
%token TOK_DEFAULT "default"
%token TOK_INHERITS "inherits"
%token TOK_ELSE "else"
%token TOK_STATIC "static"
%token TOK_NAMESPACE "namespace"
%token TOK_MODULE "module"
%token TOK_FINAL "final"
%token TOK_ABSTRACT "abstract"
%token TOK_HASHDECL "hashdecl"

// currently unused tokens
%token TOK_UNREFERENCE "unreference"

// operator tokens
%token P_INCREMENT "++ operator"
%token P_DECREMENT "-- operator"
%token PLUS_EQUALS "+= operator"
%token MINUS_EQUALS "-= operator"
%token AND_EQUALS "&= operator"
%token OR_EQUALS "|= operator"
%token MODULA_EQUALS "%= operator"
%token MULTIPLY_EQUALS "*= operator"
%token DIVIDE_EQUALS "/= operator"
%token XOR_EQUALS "^= operator"
%token SHIFT_LEFT_EQUALS "<<= operator"
%token SHIFT_RIGHT_EQUALS ">>= operator"
%token TOK_UNSHIFT "unshift"
%token TOK_PUSH "push"
%token TOK_POP "pop"
%token TOK_SHIFT "shift"
%token TOK_CHOMP "chomp"
%token TOK_TRIM "trim"
%token LOGICAL_AND "&& operator"
%token LOGICAL_OR "|| operator"
%token BROKEN_LOGICAL_OR "|| operator (compat)"
%token BROKEN_BINARY_OR "| operator (compat)"
%token BROKEN_BINARY_XOR "^ operator (compat)"
%token LOGICAL_EQ "== operator"
%token LOGICAL_NE "!= operator"
%token LOGICAL_LE "<= operator"
%token LOGICAL_GE ">= operator"
%token LOGICAL_CMP "<=> operator"
%token ABSOLUTE_EQ "=== operator"
%token ABSOLUTE_NE "!== operator"
%token REGEX_MATCH "=~ operator"
%token REGEX_NMATCH "!~ operator"
%token TOK_EXISTS "exists"
%token TOK_INSTANCEOF "instanceof"
%token SHIFT_RIGHT ">> operator"
%token SHIFT_LEFT "<< operator"
%token TOK_ELEMENTS "elements"
%token TOK_KEYS "keys"
%token TOK_NEW "new"
%token TOK_BACKGROUND "background"
%token TOK_ON_EXIT "on_exit"
%token TOK_ON_SUCCESS "on_success"
%token TOK_ON_ERROR "on_error"
%token TOK_MAP "map"
%token TOK_FOLDR "foldr"
%token TOK_FOLDL "foldl"
%token TOK_SELECT "select"
%token TOK_SPLICE "splice"
%token TOK_EXTRACT "extract"
%token IMPLICIT_ELEMENT "$# operator"
%token NULL_COALESCING "?? operator"
%token VALUE_COALESCING "?* operator"

 // tokens returning data
%token <integer> INTEGER "integer value"
%token <decimal> QFLOAT "floating-point value"
%token <num> NUMBER "arbitrary-precision number"
%token <string> IDENTIFIER "identifier"
%token <string> ANGLE_IDENTIFIER "type identifier with angle brackets"
%token <string> VAR_REF "variable reference"
%token <string> BACKQUOTE "backquote expression"
%token <string> SELF_REF "in-object member reference"
%token <string> KW_IDENTIFIER_OPENPAREN "identifier or keyword used as function or method identifier"
%token <string> SCOPED_REF "namespace or class-scoped reference"
%token <string> SCOPED_VREF "namespace-scoped global variable reference"
%token <string> CONTEXT_REF "context reference"
%token <string> COMPLEX_CONTEXT_REF "named context reference"
%token <string> QORE_CAST "cast operator"
%token <string> CLASS_STRING "simple class declaration"
%token <datetime> DATETIME "date/time value"
%token <String> QUOTED_WORD "quoted string"
%token <binary> BINARY "binary constant value"
%token <RegexSubst> REGEX_SUBST "regular expression substitution expression"
%token <Trans> REGEX_TRANS "transliteration expression"
%token <nscope> CLASS_SCOPED_REF "scoped class declaration"
%token <nscope> BASE_CLASS_CALL "call to base class method"
%token <Regex> REGEX "regular expression"
%token <Regex> REGEX_EXTRACT "regular expression extraction expression"
%token <implicit_arg> IMPLICIT_ARG_REF "implicit argument reference"
%token <String> DOT_KW_IDENTIFIER "keyword used as hash key or object member reference"
%token <trymod> TRY_MODULE_ERROR "%try-module error token"
%token <string> TYPESPEC "<type specification>"

%nonassoc IFX SCOPED_REF SCOPED_VREF
%nonassoc TOK_ELSE

// FIXME: check precedence
%nonassoc TOK_UNSHIFT TOK_PUSH TOK_SPLICE TOK_EXTRACT TOK_MAP TOK_FOLDR TOK_FOLDL TOK_SELECT
%left ','
%right PLUS_EQUALS MINUS_EQUALS AND_EQUALS OR_EQUALS MODULA_EQUALS MULTIPLY_EQUALS DIVIDE_EQUALS XOR_EQUALS SHIFT_LEFT_EQUALS SHIFT_RIGHT_EQUALS '='
%right '?' ':'
%right NULL_COALESCING VALUE_COALESCING
%left LOGICAL_OR
%left LOGICAL_AND BROKEN_LOGICAL_OR
%left '|'
%left '^'
%left '&' BROKEN_BINARY_OR BROKEN_BINARY_XOR
%left '<' '>' LOGICAL_EQ LOGICAL_NE LOGICAL_LE LOGICAL_GE LOGICAL_CMP ABSOLUTE_EQ ABSOLUTE_NE REGEX_MATCH REGEX_NMATCH
%right TOK_EXISTS TOK_INSTANCEOF
%left SHIFT_RIGHT SHIFT_LEFT    // binary shift right and left
%left '+' '-'                   // arithmetic plus and minus
%left '%'                       // modulo
%left '*' '/'                   // arithmetic multiply and divide
%right TOK_ELEMENTS TOK_KEYS
%nonassoc TOK_SHIFT TOK_POP TOK_CHOMP TOK_TRIM
%left NEG                     // unary minus, defined for precedence
%left UPLUS           // unary plus, defined for precedence
%right '~' '\\'               // binary not, reference operator
%left '!'                     // logical not
%right TOK_BACKGROUND TOK_DELETE TOK_REMOVE QORE_CAST
%nonassoc TOK_NEW
%nonassoc P_INCREMENT P_DECREMENT
%left '{' '[' '.' '(' DOT_KW_IDENTIFIER  // list and object references, etc, defined for precedence

%type <sblock>         block
%type <sblock>         statement_or_block
%type <sblock>         statements
%type <statement>      statement
%type <statement>      return_statement
%type <statement>      try_statement
%type <node>           exp
%type <node>           exp_n
%type <node>           exp_c
%type <node>           myexp
%type <node>           scalar
%type <hash>           hash
%type <hash>           alt_hash
%type <list>           list
%type <list>           list_n
%type <String>         string
%type <hashelement>    hash_element
%type <cmods>          context_mods
%type <cmod>           context_mod
%type <methodnode>     inline_methoddef
%type <memberlist>     internal_member_list
%type <memberlist>     private_member_list
%type <memberlist>     public_member_list
%type <memberlist>     member_list
%type <memberinfo>     member
%type <memberlist>     member_list2
%type <memberinfo>     member2
%type <memberinfo>     hashdecl_member
%type <classvarinfo>   classvardecl
%type <qoreclass>      class_attributes
%type <hashdeclpriv>   hashdecl_attrs
%type <classdef>       class_def
%type <hashdecldef>    hashdecl_def
%type <ns>             top_namespace_decl
%type <nsnlist>        namespace_decls
%type <nsn>            namespace_decl
%type <constnode>      scoped_const_decl
%type <constnode>      unscoped_const_decl
%type <i4>             method_modifiers
%type <i4>             method_modifier
%type <i4>             nsc_modifiers
%type <returnTypeInfo> return_value
%type <string>         optname
%type <statement>      switch_statement
%type <switchstmt>     case_block
%type <casenode>       case_code
%type <sclist>         superclass_list
%type <sclist>         inheritance_list
%type <sclnode>        superclass
%type <bcalist>        base_constructor_list
%type <bcalist>        base_constructors
%type <bcanode>        base_constructor
%type <string>         ident_openparen
%type <parsertype>     qtypedef
%type <parsertype>     uncqtypedef
%type <parsefunc>      sub_def
%type <sparsefunc>     scoped_sub_def
%type <b>              ppub
%type <gv>             gvardecl
%type <methoddef>      outofline_methoddef

 // destructor actions for elements that need deleting when parse errors occur
%destructor { delete $$; } TRY_MODULE_ERROR REGEX_BEGIN REGEX REGEX_SUBST REGEX_EXTRACT REGEX_TRANS BASE_CLASS_CALL CLASS_SCOPED_REF block statement_or_block statements statement return_statement try_statement hash_element context_mods context_mod inline_methoddef class_def hashdecl_def top_namespace_decl scoped_const_decl unscoped_const_decl switch_statement case_block case_code superclass base_constructor internal_member_list private_member_list public_member_list member_list member_list2 base_constructor_list base_constructors return_value member member2 hashdecl_member superclass_list inheritance_list qtypedef uncqtypedef classvardecl sub_def scoped_sub_def gvardecl outofline_methoddef hash alt_hash regex regex_extract regex_subst regex_trans
%destructor { qore_class_private::get(*$$)->deref(); } class_attributes
%destructor { free($$); } IDENTIFIER ANGLE_IDENTIFIER VAR_REF SELF_REF CONTEXT_REF COMPLEX_CONTEXT_REF BACKQUOTE SCOPED_REF SCOPED_VREF KW_IDENTIFIER_OPENPAREN QORE_CAST CLASS_STRING optname ident_openparen
%destructor { if ($$) $$->deref(); } namespace_decl namespace_decls quoted_word string QUOTED_WORD DATETIME BINARY IMPLICIT_ARG_REF DOT_KW_IDENTIFIER hashdecl_attrs
%destructor { if ($$) $$->deref(nullptr); } exp exp_n exp_c myexp scalar list

%%
top_level_commands:
        top_level_command
        | top_level_commands top_level_command
        ;

top_level_command:
        sub_def {
           $1->add(*(qore_ns_private::get(*(getRootNS()))));
        }
        | scoped_sub_def {
           // see if strong encapsulation is enabled
           check_strong_encapsulation($1->loc, "function", $1->name.ostr);
           $1->add(*(qore_ns_private::get(*(getRootNS()))));
        }
        | class_def {
           qore_root_ns_private::parseAddClass($1->loc, *($1->name), $1->oc);

           // see if class definitions are allowed
           if (parse_check_parse_option(PO_NO_CLASS_DEFS))
              parse_error($1->loc, "illegal class definition \"%s\" (conflicts with parse option NO_CLASS_DEFS)", $1->oc->getName());
           delete $1;
        }
        | hashdecl_def {
           //qore_root_ns_private::parseAddTypedHash($1->loc, *($1->name), $1->hashdecl);
           delete $1;
        }
        | scoped_const_decl {
           // see if strong encapsulation is enabled
           check_strong_encapsulation($1->loc, "constant", $1->name.ostr);
           qore_root_ns_private::parseAddConstant($1->loc, *getRootNS(), $1->name, $1->value, $1->pub);
           delete $1;
        }
        | unscoped_const_decl {
           qore_root_ns_private::parseAddConstant($1->loc, *getRootNS(), $1->name, $1->value, $1->pub);
           delete $1;
        }
        | outofline_methoddef {
           // see if strong encapsulation is enabled
           check_strong_encapsulation($1->loc, "method", $1->name.ostr);
           $1->parseAddToClassAndDel();
        }
        | statement {
           if ($1) {
              if ($1->isParseDeclaration())
                 delete $1;
              else
                 qore_program_private::addStatement(*(getProgram()), $1);
           }
        }
        | '{' '}'
        | '{' statements '}' {
           // set line range
           $2->loc.start_line = @1.first_line;
           $2->loc.end_line = @2.last_line;
           qore_program_private::addStatement(*(getProgram()), $2);
        }
        | top_namespace_decl {
           QoreProgramLocation loc(@1.first_line, @1.last_line);
           qore_root_ns_private::parseAddNamespace($1);
           // see if ns declaration is legal
           if (parse_check_parse_option(PO_NO_NAMESPACE_DEFS))
              parse_error(loc, "illegal namespace definition \"%s\" (conflicts with parse option PO_NO_NAMESPACE_DEFINITION)", $1->getName());
        }
        | TOK_MODULE '{' module_decls '}' {
           QoreModuleDefContext* qmd = get_module_def_context();
           if (!qmd)
              qore_program_private::makeParseWarning(getProgram(), QoreProgramLocation(@1.first_line, @4.last_line), QP_WARN_MODULE_ONLY, "MODULE-ONLY", "module definitions are ignored when not defining a module");
           else {
              QoreUserModuleDefContextHelper* uqmd = static_cast<QoreUserModuleDefContextHelper*>(qmd);
              uqmd->close();
           }
           // registered internally
        }
        | TRY_MODULE_ERROR {
           bool has_dollar = $1->var[0] == '$';
           if (!has_dollar) {
              if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
                 parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "%%try-module variable '%s' declared without '$' prefix, but parse option 'allow-bare-refs' is not set", $1->var);
           }
           else {
              $1->fixName();
              if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
                 parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "%%try-module variable '%s' declared with '$' prefix, but parse option 'allow-bare-refs' is set", $1->var);
           }

           if (parse_check_parse_option(PO_NO_TOP_LEVEL_STATEMENTS)) {
              parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "'%%try-module' with exception variable cannot be used with parse option NO_TOP_LEVEL_STATEMENTS; use %%try-module without an exception variable instead");
           }
           else {
              VarRefTryModuleErrorNode* left = new VarRefTryModuleErrorNode(QoreProgramLocation(@1.first_line, @1.last_line), $1->takeName());
              QoreAssignmentOperatorNode* exp = new QoreAssignmentOperatorNode(QoreProgramLocation(@1.first_line, @1.last_line), left, $1->takeExceptionHash());
              qore_program_private::addStatement(*(getProgram()), new ExpressionStatement(@1.first_line, @1.last_line, exp));
           }
           delete $1;
        }
        ;

module_decls:
        module_decl {
        }
        | module_decls module_decl {
        }
        ;

module_decl:
        IDENTIFIER '=' exp ';' {
           QoreModuleDefContext* qmd = get_module_def_context();
           QoreProgramLocation loc(@1.first_line, @3.last_line);
           if (!qmd)
              qore_program_private::makeParseWarning(getProgram(), loc, QP_WARN_MODULE_ONLY, "MODULE-ONLY", "cannot add module tag '%s' = <%s> when not defining a module", $1, get_type_name($3));
           else
              qmd->set(loc, $1, $3);

           free($1);
           $3->deref(0);
        }
        ;

ppub:   /* empty */
        { $$ = false; }
        | TOK_PUBLIC {
           $$ = true;
        }
        ;

gvardecl:
        ppub TOK_OUR uncqtypedef SCOPED_REF {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @4.last_line);
           // see if strong encapsulation is enabled
           check_strong_encapsulation(loc, "global variable", $4);
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($3);
           $$ = new GVarSingleDecl(loc, $4, t, t ? 0 : ParserTypeStruct::getParseTypeInfo($3), $1, true);
           delete $3;
        }
        | ppub TOK_OUR SCOPED_REF {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @3.last_line);
           // see if strong encapsulation is enabled
           check_strong_encapsulation(loc, "global variable", $3);
           $$ = new GVarSingleDecl(loc, $3, 0, 0, $1, true);
        }
        | ppub TOK_OUR uncqtypedef IDENTIFIER {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @4.last_line);
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($3);
           $$ = new GVarSingleDecl(loc, $4, t, t ? 0 : ParserTypeStruct::getParseTypeInfo($3), $1, true);
           delete $3;
        }
        | ppub TOK_OUR IDENTIFIER {
           $$ = new GVarSingleDecl(QoreProgramLocation($1 ? @1.first_line : @2.first_line, @3.last_line), $3, 0, 0, $1, true);
        }
        | ppub TOK_OUR qtypedef SCOPED_VREF {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @4.last_line);
           // see if strong encapsulation is enabled
           check_strong_encapsulation(loc, "global variable", $4);
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($3);
           $$ = new GVarSingleDecl(loc, $4, t, t ? 0 : ParserTypeStruct::getParseTypeInfo($3), $1, false);
           delete $3;
        }
        | ppub TOK_OUR qtypedef VAR_REF {
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($3);
           $$ = new GVarSingleDecl(QoreProgramLocation($1 ? @1.first_line : @2.first_line, @4.last_line), $4, t, t ? 0 : ParserTypeStruct::getParseTypeInfo($3), $1, false);
           delete $3;
        }
        | ppub TOK_OUR '(' list ')' {
           $$ = new GVarListDecl(QoreProgramLocation($1 ? @1.first_line : @2.first_line, @5.last_line), $4, $1);
        }
        ;

top_namespace_decl:
        nsc_modifiers TOK_NAMESPACE '{' namespace_decls '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @5.last_line);
           qore_ns_private* p = new qore_ns_private(loc);
           check_nsmod(loc, $1, *p);
           $4->add(*p);
           delete $4;
           $$ = p->ns;
        }
        | nsc_modifiers TOK_NAMESPACE ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @2.last_line);
           qore_ns_private* p = new qore_ns_private(loc);
           check_nsmod(loc, $1, *p);
           $$ = p->ns;
        }
        | nsc_modifiers TOK_NAMESPACE '{' '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @4.last_line);
           qore_ns_private* p = new qore_ns_private(loc);
           check_nsmod(loc, $1, *p);
           $$ = p->ns;
        }
        ;

namespace_decls:
        namespace_decl {
           $$ = new NSNodeList;
           if ($1)
              $$->push_back($1);
        }
        | namespace_decls namespace_decl {
           $$ = $1;
           if ($2)
              $$->push_back($2);
        }
        ;

namespace_decl:
        scoped_const_decl {
           // see if strong encapsulation is enabled
           check_strong_encapsulation($1->loc, "constant", $1->name.ostr);
           $$ = new NSNode($1);
        }
        | unscoped_const_decl {
           $$ = new NSNode($1);
        }
        | class_def {
           $$ = new NSNode($1);
           // see if class definitions are allowed
           if (parse_check_parse_option(PO_NO_CLASS_DEFS))
              parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "illegal class definition \"%s\" (conflicts with parse option PO_NO_CLASS_DEFS)", $1->oc->getName());
        }
        | hashdecl_def {
           $$ = new NSNode($1);
        }
        | sub_def {
           $$ = new NSNode($1);
        }
        | scoped_sub_def {
           // see if strong encapsulation is enabled
           check_strong_encapsulation($1->loc, "function", $1->name.ostr);
           $$ = new NSNode($1);
        }
        | gvardecl ';' {
           $$ = new NSNode($1);
        }
        | top_namespace_decl {
           $$ = new NSNode($1);
           // see if ns declaration is legal
           if (parse_check_parse_option(PO_NO_NAMESPACE_DEFS))
              parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "illegal namespace definition \"%s\" (conflicts with parse option PO_NO_NAMESPACE_DEFINITION)", $1->getName());
        }
        | outofline_methoddef {
           $$ = new NSNode($1);
        }
        ;

unscoped_const_decl:
        TOK_CONST IDENTIFIER '=' exp ';' {
           $$ = new ConstNode(QoreProgramLocation(@1.first_line, @4.last_line), $2, $4);
        }
        | TOK_PUBLIC TOK_CONST IDENTIFIER '=' exp ';' {
           $$ = new ConstNode(QoreProgramLocation(@1.first_line, @5.last_line), $3, $5, true);
        }
        ;

scoped_const_decl:
        TOK_CONST SCOPED_REF '=' exp ';' {
           $$ = new ConstNode(QoreProgramLocation(@1.first_line, @4.last_line), $2, $4);
        }
        | TOK_PUBLIC TOK_CONST SCOPED_REF '=' exp ';' {
           $$ = new ConstNode(QoreProgramLocation(@1.first_line, @5.last_line), $3, $5, true);
        }
        ;

block:
        '{' statements '}'
        { $$ = $2; }
        |
        '{' /* NOTHING */ '}'
        { $$ = new StatementBlock(@1.first_line, @1.last_line); }
        ;

statement_or_block:
        statement
        { $$ = new StatementBlock(@1.first_line, @1.last_line, $1); }
        |
        block
        { $$ = $1; }
        ;

statements:
        statement
        { $$ = new StatementBlock(@1.first_line, @1.last_line, $1); }
        | block
        { $$ = new StatementBlock(@1.first_line, @1.last_line, $1); }
        | statements block
        { $1->addStatement($2); $$ = $1; }
        | statements statement
        { $1->addStatement($2); $$ = $1; }
        ;

optname:
        /* empty */
        { $$ = 0; }
        | IDENTIFIER { $$ = $1; }
        ;

statement:
    ';' { $$ = new StatementBlock(@1.first_line, @1.last_line); }
    | exp_n ';' {
           // if the expression has no effect and it's not a variable declaration
           qore_type_t t = $1 ? $1->getType() : 0;
           bool ok = false;
           if (t == NT_LIST) {
              QoreListNode* l = reinterpret_cast<QoreListNode*>($1);
              // rewrite expression if it's a list without parentheses under certain conditions
              $1 = checkRewriteList(l);

              if (l->isVariableList())
                 ok = true;
           }

           if (!ok && !node_has_effect($1) && (t != NT_VARREF || !reinterpret_cast<VarRefNode*>($1)->parseIsDecl()))
              parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "statement has no effect (%s)", $1 ? $1->getTypeName() : "NOTHING");
           ignore_return_value($1);
           $$ = new ExpressionStatement(@1.first_line, @1.last_line, $1);
        }
        // this should be covered as an expression, but for some reason it isn't...
        | SCOPED_REF '(' myexp ')' ';' {
           NamedScope *ns = new NamedScope($1);
           assert(ns->size() > 1);
           printd(5, "statement: parsing static method call: %s() size=%d\n", ns->ostr, ns->size());
           $$ = new ExpressionStatement(@1.first_line, @1.last_line, new StaticMethodCallNode(QoreProgramLocation(@1.first_line, @4.last_line), ns, make_args($3)));
        }
        | try_statement
        { $$ = $1; }
        | TOK_RETHROW ';' {
           $$ = new RethrowStatement(@1.first_line, @1.last_line);
        }
        | TOK_THROW exp ';' {
           $$ = new ThrowStatement(@1.first_line, @2.last_line, $2);
        }
        | TOK_ON_EXIT statement_or_block {
           $$ = new OnBlockExitStatement(@1.first_line, @2.last_line, $2, OBE_Unconditional);
        }
        | TOK_ON_SUCCESS statement_or_block {
           $$ = new OnBlockExitStatement(@1.first_line, @2.last_line, $2, OBE_Success);
        }
        | TOK_ON_ERROR statement_or_block {
           $$ = new OnBlockExitStatement(@1.first_line, @2.last_line, $2, OBE_Error);
        }
        | TOK_SUB_CONTEXT context_mods statement_or_block {
           $$ = new ContextStatement(@1.first_line, @3.last_line, 0, 0, $2, $3);
        }
        | TOK_SUMMARIZE optname '(' exp ')' TOK_BY '(' exp ')' context_mods statement_or_block {
           $$ = new SummarizeStatement(@1.first_line, @11.last_line, $2, $4, $10, $11, $8);
        }
        | TOK_CONTEXT optname '(' exp ')' context_mods statement_or_block {
           $$ = new ContextStatement(@1.first_line, @7.last_line, $2, $4, $6, $7);
        }
        | TOK_IF '(' exp ')' statement_or_block %prec IFX {
           $$ = new IfStatement(@1.first_line, @5.last_line, $3, $5);
        }
        | TOK_IF '(' exp ')' statement_or_block TOK_ELSE statement_or_block {
           $$ = new IfStatement(@1.first_line, @7.last_line, $3, $5, $7);
        }
        | TOK_WHILE '(' exp ')' statement_or_block {
           $$ = new WhileStatement(@1.first_line, @5.last_line, $3, $5);
        }
        | TOK_DO statement_or_block TOK_WHILE '(' exp ')' ';' {
           $$ = new DoWhileStatement(@1.first_line, @5.last_line, $5, $2);
        }
        | TOK_FOR '(' myexp ';' myexp ';' myexp ')' statement_or_block {
           $$ = new ForStatement(@1.first_line, @9.last_line, $3, $5, $7, $9);
        }
        | TOK_FOREACH exp TOK_IN '(' exp ')' statement_or_block {
           $$ = new ForEachStatement(@1.first_line, @7.last_line, $2, $5, $7);
        }
        | return_statement ';' { $$ = $1; }
        | TOK_THREAD_EXIT ';' {
           // see if thread exit is allowed
           if (parse_check_parse_option(PO_NO_THREAD_CONTROL))
              parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "illegal use of \"thread_exit\" (conflicts with parse option PO_NO_THREAD_CONTROL)");

           $$ = new ThreadExitStatement(@1.first_line, @1.last_line);
        }
        | TOK_BREAK ';' {
          $$ = new BreakStatement(@1.first_line, @1.last_line);
        }
        | TOK_CONTINUE ';' {
          $$ = new ContinueStatement(@1.first_line, @1.last_line);
        }
        | switch_statement { $$ = $1; }
        | error ';'        { $$ = 0; }
        ;

context_mods:
        // empty
        { $$ = 0; }
        | context_mods context_mod {
           if (!$1)
              $$ = new ContextModList($2);
           else {
              $1->addContextMod($2);
              $$ = $1;
           }
        }
        ;

context_mod:
        TOK_WHERE '(' exp ')'
        { $$ = new ContextMod(CM_WHERE_NODE, $3); }
        | TOK_SORT_BY '(' exp ')'
        { $$ = new ContextMod(CM_SORT_ASCENDING, $3); }
        | TOK_SORT_DESCENDING_BY '(' exp ')'
        { $$ = new ContextMod(CM_SORT_DESCENDING, $3); }
        ;

return_statement:
        TOK_RETURN     { $$ = new ReturnStatement(@1.first_line, @1.last_line); }
        |
        TOK_RETURN exp { $$ = new ReturnStatement(@1.first_line, @2.last_line, $2); }
        ;

switch_statement:
        TOK_SWITCH '(' exp ')' '{' case_block '}'
        {
           $6->setSwitch($3);
           $$ = $6;
           $$->loc.start_line = @1.first_line;
           $$->loc.end_line = @7.last_line;
        }
        ;

case_block:
        case_code
        {
           $$ = new SwitchStatement($1);
        }
        | case_block case_code
        {
           $1->addCase($2);
           $$ = $1;
        }
        ;

case_code:
        TOK_CASE LOGICAL_GE exp ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           check_case(loc, ">=", $3);
           $$ = new CaseNodeWithOperator(loc, $3, $5, QoreLogicalGreaterThanOrEqualsOperatorNode::doGreaterThanOrEquals);
        }
        | TOK_CASE LOGICAL_GE exp ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           check_case(loc, ">=", $3);
           $$ = new CaseNodeWithOperator(loc, $3, 0, QoreLogicalGreaterThanOrEqualsOperatorNode::doGreaterThanOrEquals);
        }

        | TOK_CASE LOGICAL_LE exp ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           check_case(loc, "<=", $3);
           $$ = new CaseNodeWithOperator(loc, $3, $5, QoreLogicalLessThanOrEqualsOperatorNode::doLessThanOrEquals);
        }
        | TOK_CASE LOGICAL_LE exp ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           check_case(loc, "<=", $3);
           $$ = new CaseNodeWithOperator(loc, $3, 0, QoreLogicalLessThanOrEqualsOperatorNode::doLessThanOrEquals);
        }

        | TOK_CASE LOGICAL_EQ exp ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           check_case(loc, "==", $3);
           $$ = new CaseNodeWithOperator(loc, $3, $5, QoreLogicalEqualsOperatorNode::softEqual);
        }
        | TOK_CASE LOGICAL_EQ exp ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           check_case(loc, "==", $3);
           $$ = new CaseNodeWithOperator(loc, $3, 0, QoreLogicalEqualsOperatorNode::softEqual);
        }

        | TOK_CASE '<' exp ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           check_case(loc, "<", $3);
           $$ = new CaseNodeWithOperator(loc, $3, $5, QoreLogicalLessThanOperatorNode::doLessThan);
        }
        | TOK_CASE '<' exp ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           check_case(loc, "<", $3);
           $$ = new CaseNodeWithOperator(loc, $3, 0, QoreLogicalLessThanOperatorNode::doLessThan);
        }

        | TOK_CASE '>' exp ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           check_case(loc, ">", $3);
           $$ = new CaseNodeWithOperator(loc, $3, $5, QoreLogicalGreaterThanOperatorNode::doGreaterThan);
        }
        | TOK_CASE '>' exp ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           check_case(loc, ">", $3);
           $$ = new CaseNodeWithOperator(loc, $3, 0, QoreLogicalGreaterThanOperatorNode::doGreaterThan);
        }

        | TOK_CASE REGEX_MATCH REGEX ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           $$ = new CaseNodeRegex(loc, $3, $5);
        }
        | TOK_CASE REGEX_MATCH REGEX ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           $$ = new CaseNodeRegex(loc, $3, 0);
        }

        | TOK_CASE REGEX_NMATCH REGEX ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           $$ = new CaseNodeNegRegex(loc, $3, $5);
        }
        | TOK_CASE REGEX_NMATCH REGEX ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           $$ = new CaseNodeNegRegex(loc, $3, 0);
        }

        | TOK_CASE REGEX ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           $$ = new CaseNodeRegex(loc, $2, $4);
        }
        | TOK_CASE REGEX ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @3.last_line);
           $$ = new CaseNodeRegex(loc, $2, 0);
        }

        | TOK_CASE exp ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           check_case(loc, 0, $2);
           $$ = new CaseNode(loc, $2, $4);
        }
        | TOK_CASE exp ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @3.last_line);
           check_case(loc, 0, $2);
           $$ = new CaseNode(loc, $2, 0);
        }

        | TOK_DEFAULT ':' statements
        {
           QoreProgramLocation loc(@1.first_line, @3.last_line);
           $$ = new CaseNode(loc, 0, $3);
        }
        | TOK_DEFAULT ':' // nothing
        {
           QoreProgramLocation loc(@1.first_line, @2.last_line);
           $$ = new CaseNode(loc, 0, 0);
        }
        ;

try_statement:
        TOK_TRY statement_or_block TOK_CATCH '(' myexp ')' statement_or_block {
           char* param = 0;
           const QoreTypeInfo *typeInfo = 0;
           if ($5) {
              if ($5->getType() == NT_VARREF) {
                 VarRefNode *varRefNode = static_cast<VarRefNode*>($5);
                 param = varRefNode->takeName();
                 if (varRefNode->isDecl()) {
                    VarRefDeclNode *varRefDeclNode = static_cast<VarRefDeclNode*>(varRefNode);
                    if (varRefDeclNode->getParseTypeInfo() || QoreTypeInfo::parseAccepts(varRefDeclNode->getTypeInfo(), hashTypeInfo) == QTI_NOT_EQUAL) {
                       parse_error(QoreProgramLocation(@1.first_line, @7.last_line), "the type of catch parameter '%s' must be 'hash'", param);
                    }
                    else
                      typeInfo = varRefDeclNode->getTypeInfo();
                 }
              } else if ($5->getType() == NT_BAREWORD) {
                 param = reinterpret_cast<BarewordNode*>($5)->takeString();
                 if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
                    parse_error(QoreProgramLocation(@1.first_line, @7.last_line), "local variable '%s' in catch parameter list declared without '$' prefix, but parse option 'allow-bare-refs' is not set", param);
              } else
                 parse_error(QoreProgramLocation(@1.first_line, @7.last_line), "only one parameter accepted in catch block for exception hash");
           $5->deref(0);
           }
           $$ = new TryStatement(@1.first_line, @7.last_line, $2, $7, param, typeInfo);
        }
        ;

myexp:  /* empty */  { $$ = 0; }
        | exp        { $$ = $1; }
        | error      { $$ = 0; }
        ;

hashdecl_def:
        nsc_modifiers TOK_HASHDECL IDENTIFIER '{' hashdecl_attrs '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @6.last_line);
           check_hashdeclmod(loc, $1, *($5));
           $$ = new HashDeclDef(loc, $3, $5);
        }
        | nsc_modifiers TOK_HASHDECL SCOPED_REF '{' hashdecl_attrs '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @6.last_line);
           check_hashdeclmod(loc, $1, *($5));
           $$ = new HashDeclDef(loc, $3, $5);
        }
        ;

class_def:
        nsc_modifiers CLASS_STRING inheritance_list '{' class_attributes '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @6.last_line);
           check_classmod(loc, $1, *($5));
           qore_class_private::parseSetBaseClassList(*($5), $3);
           $$ = new ObjClassDef(loc, $2, $5);
        }
        | nsc_modifiers CLASS_SCOPED_REF inheritance_list '{' class_attributes '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @6.last_line);
           // see if strong encapsulation is enabled
           check_strong_encapsulation(loc, "class", $2->ostr);
           check_classmod(loc, $1, *($5));
           $$ = new ObjClassDef(loc, $2, $5);
           qore_class_private::parseSetBaseClassList(*($5), $3);
        }
        | nsc_modifiers CLASS_STRING inheritance_list ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @3.last_line);
           // class name is set automatically from name saved in scanner
           QoreClass* qc = new QoreClass;
           qore_class_private::get(*qc)->loc = loc;
           check_classmod(loc, $1, *qc);
           qore_class_private::parseSetBaseClassList(*qc, $3);
           $$ = new ObjClassDef(loc, $2, qc);
        }
        | nsc_modifiers CLASS_SCOPED_REF inheritance_list ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @3.last_line);
           // see if strong encapsulation is enabled
           check_strong_encapsulation(loc, "class", $2->ostr);
           // class name is set automatically from name saved in scanner
           QoreClass* qc = new QoreClass;
           qore_class_private::get(*qc)->loc = loc;
           check_classmod(loc, $1, *qc);
           $$ = new ObjClassDef(loc, $2, qc);
           qore_class_private::parseSetBaseClassList(*qc, $3);
        }
        | nsc_modifiers CLASS_STRING inheritance_list '{' '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @5.last_line);
           // class name is set automatically from name saved in scanner
           QoreClass* qc = new QoreClass;
           qore_class_private::get(*qc)->loc = loc;
           check_classmod(loc, $1, *qc);
           qore_class_private::parseSetBaseClassList(*qc, $3);
           $$ = new ObjClassDef(loc, $2, qc);
        }
        | nsc_modifiers CLASS_SCOPED_REF inheritance_list '{' '}' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @5.last_line);
           // see if strong encapsulation is enabled
           check_strong_encapsulation(loc, "class", $2->ostr);
           // class name is set automatically from name saved in scanner
           QoreClass* qc = new QoreClass;
           qore_class_private::get(*qc)->loc = loc;
           check_classmod(loc, $1, *qc);
           $$ = new ObjClassDef(loc, $2, qc);
           qore_class_private::parseSetBaseClassList(*qc, $3);
        }
        ;

inheritance_list:
        TOK_INHERITS superclass_list {
           $$ = $2;
        }
        | { // NOTHING
           $$ = 0;
        }
        ;

superclass_list:
        superclass {
           $$ = new BCList($1);
        }
        | superclass_list ',' superclass {
           $1->push_back($3);
           $$ = $1;
        }
        ;

superclass:
        IDENTIFIER {
           $$ = new BCNode($1, Public);
        }
        | SCOPED_REF {
           $$ = new BCNode(new NamedScope($1), Public);
        }
        | TOK_PUBLIC IDENTIFIER {
           $$ = new BCNode($2, Public);
        }
        | TOK_PUBLIC SCOPED_REF {
           $$ = new BCNode(new NamedScope($2), Public);
        }
        | TOK_PRIVATE IDENTIFIER {
           $$ = new BCNode($2, Private);
        }
        | TOK_PRIVATE SCOPED_REF {
           $$ = new BCNode(new NamedScope($2), Private);
        }
        | TOK_PRIVATEHIERARCHY IDENTIFIER {
           $$ = new BCNode($2, Private);
        }
        | TOK_PRIVATEHIERARCHY SCOPED_REF {
           $$ = new BCNode(new NamedScope($2), Private);
        }
        | TOK_PRIVATEINTERNAL IDENTIFIER {
           $$ = new BCNode($2, Internal);
        }
        | TOK_PRIVATEINTERNAL SCOPED_REF {
           $$ = new BCNode(new NamedScope($2), Internal);
        }
        ;

hashdecl_attrs:
        hashdecl_member {
           QoreProgramLocation loc(@1.first_line, @1.last_line);
           $$ = new typed_hash_decl_private(loc);
           if ($1)
              $$->parseAdd($1->getHashMemPair());
        }
        | hashdecl_attrs hashdecl_member {
           if ($2) {
              if ($1->hasMember($2->name)) {
                 parse_error($2->loc, "duplicate hashdecl member declaration '%s'", $2->name);
              }
              else {
                 // add new member to list
                 $1->parseAdd($2->getHashMemPair());
              }
              delete $2;
           }

           $$ = $1;
        }
        ;

hashdecl_member:
        uncqtypedef IDENTIFIER ';' {
           QoreProgramLocation loc(@1.first_line, @2.last_line);
           $$ = new MemberInfo($2, new HashDeclMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1)));
           delete $1;
        }
        | uncqtypedef IDENTIFIER '=' exp ';' {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           $$ = new MemberInfo($2, new HashDeclMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1), $4));
           delete $1;
        }
        | uncqtypedef IDENTIFIER '(' myexp ')' ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @5.last_line);
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($1);
           ScopedObjectCallNode* new_call = nullptr;

           if (!$1)
              parse_error(loc, "cannot call constructor without declaring the class");
           else if (t)
              parse_error(loc, "cannot call constructor for non-class base type '%s'", QoreTypeInfo::getName(t));
           else
              new_call = new ScopedObjectCallNode(loc, new NamedScope(strdup($1->getClassName())), make_args($4));

           $$ = new MemberInfo($2, new HashDeclMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1), new_call));

           delete $1;
        }
        ;

class_attributes:
        inline_methoddef {
           $$ = new QoreClass;
           qore_class_private::get(*$$)->loc = $1->getLoc();
           $1->addAndDelete($$);
        }
        | internal_member_list {
           $$ = new QoreClass;
           qore_class_private::get(*$$)->loc = QoreProgramLocation(@1.first_line, @1.last_line);
           $1->merge($$, Internal);
           delete $1;
        }
        | private_member_list {
           $$ = new QoreClass;
           qore_class_private::get(*$$)->loc = QoreProgramLocation(@1.first_line, @1.last_line);
           $1->merge($$, Private);
           delete $1;
        }
        | public_member_list {
           $$ = new QoreClass;
           qore_class_private::get(*$$)->loc = QoreProgramLocation(@1.first_line, @1.last_line);
           $1->merge($$, Public);
           delete $1;
        }
        | unscoped_const_decl {
           $$ = new QoreClass;
           QoreProgramLocation loc(@1.first_line, @1.last_line);
           qore_class_private::get(*$$)->loc = loc;
           qore_class_private::parseAddConstant(*($$), loc, $1->getName(), $1->takeValue(), Public);
           delete $1;
        }
        | class_attributes inline_methoddef {
           qore_class_private::get(*$1)->loc.end_line = @2.last_line;
           $2->addAndDelete($1);
           $$ = $1;
        }
        | class_attributes internal_member_list {
           qore_class_private::get(*$1)->loc.end_line = @2.last_line;
           $2->merge($1, Internal);
           $$ = $1;
           delete $2;
        }
        | class_attributes private_member_list {
           qore_class_private::get(*$1)->loc.end_line = @2.last_line;
           $2->merge($1, Private);
           $$ = $1;
           delete $2;
        }
        | class_attributes public_member_list {
           qore_class_private::get(*$1)->loc.end_line = @2.last_line;
           $2->merge($1, Public);
           $$ = $1;
           delete $2;
        }
        | class_attributes unscoped_const_decl {
           qore_class_private::get(*$1)->loc.end_line = @2.last_line;
           qore_class_private::parseAddConstant(*($$), QoreProgramLocation(@2.first_line, @2.last_line), $2->getName(), $2->takeValue(), Public);
           $$ = $1;
           delete $2;
        }
        ;

uncqtypedef:
        IDENTIFIER {
           $$ = new ParserTypeStruct($1, false);
        }
        | SCOPED_REF {
           $$ = new ParserTypeStruct(new QoreParseTypeInfo($1, false));
        }
        | ANGLE_IDENTIFIER {
           $$ = ParserTypeStruct::getType($1, false);
        }
        | '*' IDENTIFIER {
           $$ = new ParserTypeStruct($2, true);
        }
        | '*' SCOPED_REF {
           $$ = new ParserTypeStruct(new QoreParseTypeInfo($2, true));
        }
        | '*' ANGLE_IDENTIFIER {
           $$ = ParserTypeStruct::getType($2, true);
        }
        ;

qtypedef:
        /* empty */
        { $$ = 0; }
        | uncqtypedef {
           $$ = $1;
        }
        ;

internal_member_list
    : TOK_PRIVATEINTERNAL member_list ';'                 { $$ = $2; }
    | TOK_PRIVATEINTERNAL '{' member_list2 '}'            { $$ = $3; }
    | TOK_PRIVATEINTERNAL '{' '}'                         { $$ = new EmptyMemberList; }
    ;

private_member_list
    : TOK_PRIVATE member_list ';'                 { $$ = $2; }
    | TOK_PRIVATE '{' member_list2 '}'            { $$ = $3; }
    | TOK_PRIVATE '{' '}'                         { $$ = new EmptyMemberList; }
    | TOK_PRIVATEHIERARCHY member_list ';'        { $$ = $2; }
    | TOK_PRIVATEHIERARCHY '{' member_list2 '}'   { $$ = $3; }
    | TOK_PRIVATEHIERARCHY '{' '}'                { $$ = new EmptyMemberList; }
    ;

public_member_list
    : TOK_PUBLIC member_list ';'            { $$ = $2; }
    | TOK_PUBLIC '{' member_list2 '}'       { $$ = $3; }
    | TOK_PUBLIC '{' '}'                    { $$ = new EmptyMemberList; }
    ;

classvardecl:
        TOK_STATIC uncqtypedef IDENTIFIER ';' {
           QoreProgramLocation loc(@1.first_line, @3.last_line);
           $$ = new ClassVarInfo($3, new QoreVarInfo(loc, ParserTypeStruct::getTypeInfo($2), ParserTypeStruct::getParseTypeInfo($2)));
           delete $2;
        }
        | TOK_STATIC IDENTIFIER ';' {
           QoreProgramLocation loc(@1.first_line, @2.last_line);
           $$ = new ClassVarInfo($2, new QoreVarInfo(loc));
        }
        | TOK_STATIC uncqtypedef IDENTIFIER '=' exp ';' {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           $$ = new ClassVarInfo($3, new QoreVarInfo(loc, ParserTypeStruct::getTypeInfo($2), ParserTypeStruct::getParseTypeInfo($2), $5));
           //printd(5, "new QoreVarInfo = %p (empty: %d)\n", $$->u.varInfo, $$->u.varInfo->empty());
           delete $2;
        }
        | TOK_STATIC IDENTIFIER '=' exp ';' {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           $$ = new ClassVarInfo($2, new QoreVarInfo(loc, nullptr, nullptr, $4));
        }
        | TOK_STATIC uncqtypedef IDENTIFIER '(' myexp ')' ';' {
           QoreProgramLocation loc(@1.first_line, @6.last_line);
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($2);
           ScopedObjectCallNode* new_call = 0;

           if (t)
              parse_error(loc, "cannot call constructor for non-class base type '%s'", QoreTypeInfo::getName(t));
           else
              new_call = new ScopedObjectCallNode(loc, new NamedScope(strdup($2->getClassName())), make_args($5));

           $$ = new ClassVarInfo($3, new QoreVarInfo(loc, ParserTypeStruct::getTypeInfo($2), ParserTypeStruct::getParseTypeInfo($2), new_call));

           delete $2;
        }
        ;

member2:
        qtypedef SELF_REF ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @2.last_line);
           $$ = new MemberInfo($2, new QoreMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1)));
           delete $1;
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "reference to '$.%s' with the '$.' prefix is not allowed when parse option 'allow-bare-refs' is set", $2);
        }
        | qtypedef SELF_REF '=' exp ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @4.last_line);
           $$ = new MemberInfo($2, new QoreMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1), $4));
           delete $1;
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "reference to '$.%s' with the '$.' prefix is not allowed when parse option 'allow-bare-refs' is set", $2);
        }
        | qtypedef SELF_REF '(' myexp ')' ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @5.last_line);
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($1);
           ScopedObjectCallNode* new_call = 0;

           if (!$1)
              parse_error(loc, "cannot call constructor without declaring the class");
           else if (t)
              parse_error(loc, "cannot call constructor for non-class base type '%s'", QoreTypeInfo::getName(t));
           else
              new_call = new ScopedObjectCallNode(loc, new NamedScope(strdup($1->getClassName())), make_args($4));

           $$ = new MemberInfo($2, new QoreMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1), new_call));

           delete $1;
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "reference to '$.%s' with the '$.' prefix is not allowed when parse option 'allow-bare-refs' is set", $2);
        }
        | uncqtypedef IDENTIFIER ';' {
           QoreProgramLocation loc(@1.first_line, @2.last_line);
           $$ = new MemberInfo($2, new QoreMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1)));
           delete $1;
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "member '%s' declared without '$.' prefix, but parse option 'allow-bare-refs' is not set", $2);
        }
        | uncqtypedef IDENTIFIER '=' exp ';' {
           QoreProgramLocation loc(@1.first_line, @4.last_line);
           $$ = new MemberInfo($2, new QoreMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1), $4));
           delete $1;
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "member '%s' declared without '$.' prefix, but parse option 'allow-bare-refs' is not set", $2);
        }
        | uncqtypedef IDENTIFIER '(' myexp ')' ';' {
           QoreProgramLocation loc(@1.first_line, @5.last_line);
           const QoreTypeInfo* t = ParserTypeStruct::getTypeInfo($1);
           ScopedObjectCallNode* new_call = 0;

           if (!$1)
              parse_error(loc, "cannot call constructor without declaring the class");
           else if (t)
              parse_error(loc, "cannot call constructor for non-class base type '%s'", QoreTypeInfo::getName(t));
           else
              new_call = new ScopedObjectCallNode(loc, new NamedScope(strdup($1->getClassName())), make_args($4));

           $$ = new MemberInfo($2, new QoreMemberInfo(loc, ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1), new_call));

           delete $1;
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "member '%s' declared without '$.' prefix, but parse option 'allow-bare-refs' is not set", $2);
        }
        | IDENTIFIER ';' {
           QoreProgramLocation loc(@1.first_line, @1.last_line);
           $$ = new MemberInfo($1, new QoreMemberInfo(loc));
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "member '%s' declared without '$.' prefix, but parse option 'allow-bare-refs' is not set", $1);
        }
        | IDENTIFIER '=' exp ';' {
           QoreProgramLocation loc(@1.first_line, @3.last_line);
           $$ = new MemberInfo($1, new QoreMemberInfo(loc, nullptr, nullptr, $3));
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "member '%s' declared without '$.' prefix, but parse option 'allow-bare-refs' is not set", $1);
        }
        | classvardecl {
           $$ = $1;
        }
        | unscoped_const_decl {
           QoreProgramLocation loc(@1.first_line, @1.last_line);
           if ($1->pub)
              parse_error(loc, "cannot change class constant scope for constant '%s' within a public or private declaration block", $1->name.ostr);
           $$ = new MemberInfo(loc, $1->name.takeName(), $1->value);
           delete $1;
        }
        ;

member:
        SELF_REF {
           QoreProgramLocation loc(@1.first_line, @1.last_line);
           $$ = new MemberInfo($1, new QoreMemberInfo(loc));
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "reference to '$.%s' with the '$.' prefix is not allowed when parse option 'allow-bare-refs' is set", $1);
        }
        | SELF_REF SCOPED_REF {
           QoreProgramLocation loc(@1.first_line, @2.last_line);
           $$ = new MemberInfo($1, new QoreMemberInfo(loc, nullptr, new QoreParseTypeInfo($2)));
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "reference to '$.%s' with the '$.' prefix is not allowed when parse option 'allow-bare-refs' is set", $1);
        }
        ;

member_list:
        member {
           $$ = new MemberList($1);
        }
        | member_list ',' member {
           $1->add($3);
           $$ = $1;
        }
        ;

member_list2:
        member2 {
           $$ = new MemberList($1);
        }
        | member_list2 member2 {
           $1->add($2);
           $$ = $1;
        }
        ;

ident_openparen:
        IDENTIFIER '(' {
           $$ = $1;
        }
        | TOK_KEYS '(' {
           $$ = strdup("keys");
        }
        | KW_IDENTIFIER_OPENPAREN {
           $$ = $1;
        }
        ;

inline_methoddef:
        nsc_modifiers ident_openparen myexp ')' base_constructor_list return_value block {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @7.last_line);
           if ($1 & OFM_ABSTRACT) {
              if ($7)
                 parse_error(loc, "'abstract' can only be used with no implementation (remove the body and terminate the declaration with ';' or remove the 'abstract')");
              else
                 parse_error(loc, "'abstract' can only be used with no implementation (terminate the declaration with ';' instead of '{}')");
           }
           check_method(loc, $2, $5, $6);
           $$ = new MethodNode($2, new_method_variant(loc, $2, $1, @3.first_line, @3.last_line, $3, $5, $6, $7), $1 & OFM_STATIC);
        }
        | nsc_modifiers uncqtypedef ident_openparen myexp ')' base_constructor_list block {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @7.last_line);
           if ($1 & OFM_ABSTRACT) {
              if ($7)
                 parse_error(loc, "'abstract' can only be used with no implementation (remove the body and terminate the declaration with ';' or remove the 'abstract')");
              else
                 parse_error(loc, "'abstract' can only be used with no implementation (terminate the declaration with ';' instead of '{}')");
           }
           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
           delete $2;

           check_method(loc, $3, $6, rt);

           $$ = new MethodNode($3, new_method_variant(loc, $3, $1, @4.first_line, @4.last_line, $4, $6, rt, $7), $1 & OFM_STATIC);
        }
        | nsc_modifiers ident_openparen myexp ')' base_constructor_list return_value ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @6.last_line);
           if (!($1 & OFM_ABSTRACT))
              parse_error(loc, "non-abstract method declared without any body; either declare the method 'abstract' or declare an empty method body with '{}'");
           check_method(loc, $2, $5, $6);
           $$ = new MethodNode($2, new_method_variant(loc, $2, $1, @3.first_line, @3.last_line, $3, $5, $6, 0), $1 & OFM_STATIC);
        }
        | nsc_modifiers uncqtypedef ident_openparen myexp ')' base_constructor_list ';' {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @6.last_line);
           if (!($1 & OFM_ABSTRACT))
              parse_error(loc, "non-abstract method declared without any body; either declare the method 'abstract' or declare an empty method body with '{}'");
           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
           delete $2;

           check_method(loc, $3, $6, rt);

           $$ = new MethodNode($3, new_method_variant(loc, $3, $1, @4.first_line, @4.last_line, $4, $6, rt, 0), $1 & OFM_STATIC);
        }
        ;

outofline_methoddef:
        method_modifiers SCOPED_REF '(' myexp ')' base_constructor_list return_value block {
           QoreProgramLocation loc(@1.first_line, @8.last_line);
           if ($1 & OFM_ABSTRACT) {
              if ($8)
                 parse_error(loc, "'abstract' can only be used with no implementation (remove the body and terminate the declaration with ';' or remove the 'abstract')");
              else
                 parse_error(loc, "'abstract' can only be used with no implementation (terminate the declaration with ';' instead of '{}')");
           }

           $$ = new MethodDef(loc, $1, $2, @4.first_line, @4.last_line, $4, $6, $7, $8);
        }
        | method_modifiers uncqtypedef SCOPED_REF '(' myexp ')' base_constructor_list block {
           QoreProgramLocation loc(@1.first_line, @8.last_line);
           if ($1 & OFM_ABSTRACT) {
              if ($8)
                 parse_error(loc, "'abstract' can only be used with no implementation (remove the body and terminate the declaration with ';' or remove the 'abstract')");
              else
                 parse_error(loc, "'abstract' can only be used with no implementation (terminate the declaration with ';' instead of '{}')");
           }
           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
           delete $2;

           $$ = new MethodDef(loc, $1, $3, @5.first_line, @5.last_line, $5, $7, rt, $8);
        }
        | method_modifiers SCOPED_REF '(' myexp ')' base_constructor_list return_value ';' {
           QoreProgramLocation loc(@1.first_line, @7.last_line);
           if (!($1 & OFM_ABSTRACT))
              parse_error(loc, "non-abstract method declared without any body; either declare the method 'abstract' or declare an empty method body with '{}'");
           $$ = new MethodDef(loc, $1, $2, @4.first_line, @4.last_line, $4, $6, $7, 0);
        }
        | method_modifiers uncqtypedef SCOPED_REF '(' myexp ')' base_constructor_list ';' {
           QoreProgramLocation loc(@1.first_line, @7.last_line);
           if (!($1 & OFM_ABSTRACT))
              parse_error(loc, "non-abstract method declared without any body; either declare the method 'abstract' or declare an empty method body with '{}'");
           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
           delete $2;

           $$ = new MethodDef(loc, $1, $3, @5.first_line, @5.last_line, $5, $7, rt, 0);
        }
        | SCOPED_REF '(' myexp ')' base_constructor_list return_value block {
           QoreProgramLocation loc(@1.first_line, @7.last_line);
           $$ = new MethodDef(loc, 0, $1, @3.first_line, @3.last_line, $3, $5, $6, $7);
        }
        | uncqtypedef SCOPED_REF '(' myexp ')' base_constructor_list block {
           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($1), ParserTypeStruct::getTypeInfo($1));
           delete $1;

           QoreProgramLocation loc(@1.first_line, @7.last_line);
           $$ = new MethodDef(loc, 0, $2, @4.first_line, @4.last_line, $4, $6, rt, $7);
        }
        ;

base_constructor_list:
        ':' base_constructors {
           $$ = $2;
        }
        | { // nothing
           $$ = 0;
        }
        ;

base_constructors:
        base_constructor {
           $$ = new BCAList($1);
        }
        | base_constructors ',' base_constructor {
           $1->push_back($3);
           $$ = $1;
        }
        ;

base_constructor:
        IDENTIFIER '(' myexp ')' {
           $$ = new BCANode($1, make_args($3), @3.first_line, @3.last_line);
        }
        | SCOPED_REF '(' myexp ')' {
           $$ = new BCANode(new NamedScope($1), make_args($3), @3.first_line, @3.last_line);
        }
        ;

nsc_modifiers:
        // nothing
        { $$ = 0; }
        | method_modifiers {
           $$ = $1;
        }

method_modifiers:
        method_modifier { $$ = $1; }
        | method_modifiers method_modifier {
           if (($1 | $2) == $1)
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "modifier given twice");
           $$ = $1 | $2;
        }
        ;

method_modifier:
        TOK_PRIVATE { $$ = OFM_PRIVATE; }
        | TOK_PRIVATEHIERARCHY { $$ = OFM_PRIVATE; }
        | TOK_PRIVATEINTERNAL { $$ = OFM_INTERNAL; }
        | TOK_STATIC { $$ = OFM_STATIC; }
        | TOK_SYNCHRONIZED { $$ = OFM_SYNCED; }
        | TOK_DEPRECATED { $$ = OFM_DEPRECATED; }
        | TOK_PUBLIC { $$ = OFM_PUBLIC; }
        | TOK_FINAL { $$ = OFM_FINAL; }
        | TOK_ABSTRACT { $$ = OFM_ABSTRACT; }
        ;

return_value:
        TOK_RETURNS qtypedef {
           if (!$2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "missing type declaration after 'returns'");
              $$ = 0;
           }
           else {
              $$ = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
              delete $2;
           }
        }
        | /* nothing */
        {
           $$ = 0;
        }
        ;

sub_def:
        TOK_SUB ident_openparen myexp ')' return_value block {
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           $$ = new ParseUserFunction(QoreProgramLocation(@1.first_line, @6.last_line), $2, new UserFunctionVariant($6, @3.first_line, @3.last_line, $3, $5, false, flags));
        }
        | uncqtypedef TOK_SUB ident_openparen myexp ')' block {
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;

           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($1), ParserTypeStruct::getTypeInfo($1));
           delete $1;

           $$ = new ParseUserFunction(QoreProgramLocation(@1.first_line, @6.last_line), $3, new UserFunctionVariant($6, @4.first_line, @4.last_line, $4, rt, false, flags));
        }
        | method_modifiers TOK_SUB ident_openparen myexp ')' return_value block {
           QoreProgramLocation loc(@1.first_line, @7.last_line);
           check_funcmod(loc, $1);
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           if ($1 & OFM_DEPRECATED)
              flags |= QC_DEPRECATED;

           $$ = new ParseUserFunction(loc, $3, new UserFunctionVariant($7, @4.first_line, @4.last_line, $4, $6, $1 & OFM_SYNCED, flags));
           if ($1 & OFM_PUBLIC)
              $$->setPublic();
        }
        | method_modifiers uncqtypedef TOK_SUB ident_openparen myexp ')' block {
           QoreProgramLocation loc(@1.first_line, @7.last_line);
           check_funcmod(loc, $1);
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           if ($1 & OFM_DEPRECATED)
              flags |= QC_DEPRECATED;

           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
           delete $2;

           $$ = new ParseUserFunction(loc, $4, new UserFunctionVariant($7, @5.first_line, @5.last_line, $5, rt, $1 & OFM_SYNCED, flags));
           if ($1 & OFM_PUBLIC)
              $$->setPublic();
        }
        ;

scoped_sub_def:
        TOK_SUB SCOPED_REF '(' myexp ')' return_value block {
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           $$ = new ParseScopedUserFunction(QoreProgramLocation(@1.first_line, @7.last_line), $2, new UserFunctionVariant($7, @4.first_line, @4.last_line, $4, $6, false, flags));
        }
        | uncqtypedef TOK_SUB SCOPED_REF '(' myexp ')' block {
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;

           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($1), ParserTypeStruct::getTypeInfo($1));
           delete $1;

           $$ = new ParseScopedUserFunction(QoreProgramLocation(@1.first_line, @7.last_line), $3, new UserFunctionVariant($7, @5.first_line, @5.last_line, $5, rt, false, flags));
        }
        | method_modifiers TOK_SUB SCOPED_REF '(' myexp ')' return_value block {
           QoreProgramLocation loc(@1.first_line, @8.last_line);
           check_funcmod(loc, $1);
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           if ($1 & OFM_DEPRECATED)
              flags |= QC_DEPRECATED;

           $$ = new ParseScopedUserFunction(loc, $3, new UserFunctionVariant($8, @5.first_line, @5.last_line, $5, $7, $1 & OFM_SYNCED, flags));
           if ($1 & OFM_PUBLIC)
              $$->setPublic();
        }
        | method_modifiers uncqtypedef TOK_SUB SCOPED_REF '(' myexp ')' block {
           QoreProgramLocation loc(@1.first_line, @8.last_line);
           check_funcmod(loc, $1);
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           if ($1 & OFM_DEPRECATED)
              flags |= QC_DEPRECATED;

           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
           delete $2;

           $$ = new ParseScopedUserFunction(loc, $4, new UserFunctionVariant($8, @6.first_line, @6.last_line, $6, rt, $1 & OFM_SYNCED, flags));
           if ($1 & OFM_PUBLIC)
              $$->setPublic();
        }
        ;

list:
        exp ',' exp
        { $$ = splice_expressions($1, $3); }
        | exp ',' {
           QoreListNode* l;
           if ($1 && $1->getType() == NT_LIST) {
              l = reinterpret_cast<QoreListNode*>($1);
              if (l->isFinalized()) {
                 QoreListNode* nl = new QoreListNode;
                 nl->push(l);
                 l = nl;
              }
           }
           else {
              l = new QoreListNode;
              l->push($1);
              // parse_error(QoreProgramLocation(@1.first_line, @3.last_line), "problem in parsing ',' in list: left side of comma is not a list (type: '%s')", $1 ? $1->getTypeName() : "NOTHING");
              // so we don't insert null values in the parse tree
           }
           $$ = l;
        }
        ;

list_n:
    exp_n ',' exp
        { $$ = splice_expressions($1, $3); }
        | exp_n ',' {
       QoreListNode* l;
       if ($1 && $1->getType() == NT_LIST)
          l = reinterpret_cast<QoreListNode*>($1);
       else {
          l = new QoreListNode;
          l->push($1);
          // parse_error(QoreProgramLocation(@1.first_line, @3.last_line), "problem in parsing ',' in list: left side of comma is not a list (type: '%s')", $1 ? $1->getTypeName() : "NOTHING");
          // so we don't insert null values in the parse tree
       }
       $$ = l;
        }
        ;

hash:
        hash_element {
           $$ = new QoreParseHashNode(QoreProgramLocation(@1.first_line, @1.last_line));
           $1->addDelete($$);
        }
        | hash ',' hash_element {
           $3->addDelete($1);
           $1->updateLastLine(@3.last_line);
           $$ = $1;
        }
        | hash ','
        { /* empty ',' on end of hash */ $$ = $1; }
        ;

hash_element:
        exp ':' exp
        { $$ = new HashElement($1, $3, @1.first_line, @3.last_line); }
        ;

alt_hash:
        '{' hash '}' {
           // mark for the curly-bracket version of a literal parse hash expression for the hash version of the map operator
           $2->setCurly();
           $$ = $2;
        }
        ;

exp_c:
        scalar
        { $$ = $1; }
        | BINARY
        { $$ = $1; }
        | '(' hash ')'
        { $$ = $2; }
        | SCOPED_REF
        { $$ = new ScopedRefNode(QoreProgramLocation(@1.first_line, @1.last_line), $1); }
        | qtypedef VAR_REF {
           if (!$1 && !strcmp($2, "argv"))
              inc_argv_ref();

           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @2.last_line);
           if ($1)
              $$ = new VarRefDeclNode(loc, $2, get_var_type(), ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1));
           else
              $$ = new VarRefNode(loc, $2, get_var_type());

           delete $1;
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "reference to variable '%s' with the '$' sign is not allowed when parse option 'allow-bare-refs' is set", $2);
        }
        | qtypedef SCOPED_VREF {
           QoreProgramLocation loc($1 ? @1.first_line : @2.first_line, @2.last_line);
           if ($1)
              $$ = new VarRefDeclNode(loc, $2, get_var_type(), ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1));
           else
              $$ = new VarRefNode(loc, $2, get_var_type());

           delete $1;
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "reference to variable '%s' with the '$' sign is not allowed when parse option 'allow-bare-refs' is set", $2);
        }
        | uncqtypedef IDENTIFIER {
           QoreProgramLocation loc(@1.first_line, @2.last_line);
           $$ = new VarRefDeclNode(loc, $2, get_var_type(), ParserTypeStruct::getTypeInfo($1), ParserTypeStruct::getParseTypeInfo($1));
           delete $1;
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(loc, "local variable '%s' declared without '$' prefix, but parse option 'allow-bare-refs' is not set", $2);
        }
        | TOK_MY uncqtypedef IDENTIFIER {
           VarRefDeclNode* v = new VarRefDeclNode(QoreProgramLocation(@1.first_line, @3.last_line), $3, VT_LOCAL, ParserTypeStruct::getTypeInfo($2), ParserTypeStruct::getParseTypeInfo($2));
           v->setExplicitScope();
           $$ = v;
           delete $2;
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(QoreProgramLocation(@1.first_line, @3.last_line), "local variable '%s' declared without '$' prefix, but parse option 'allow-bare-refs' is not set", $3);
        }
        | TOK_MY IDENTIFIER {
           // see if types are required
           if (parse_check_parse_option(PO_REQUIRE_TYPES))
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "local variable '%s' declared without type information, but parse options require all declarations to have type information", $2);
           VarRefNode* v = new VarRefNode(QoreProgramLocation(@1.first_line, @2.last_line), $2, VT_LOCAL);
           v->setExplicitScope();
           $$ = v;
           if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "local variable '%s' declared without '$' prefix, but parse option 'allow-bare-refs' is not set", $2);
        }
        | TOK_MY qtypedef VAR_REF {
           VarRefNode* v;
           if ($2) {
              v = new VarRefDeclNode(QoreProgramLocation(@1.first_line, @3.last_line), $3, VT_LOCAL, ParserTypeStruct::getTypeInfo($2), ParserTypeStruct::getParseTypeInfo($2));
              delete $2;
           }
           else {
              // see if types are required
              if (parse_check_parse_option(PO_REQUIRE_TYPES))
                 parse_error(QoreProgramLocation(@1.first_line, @3.last_line), "local variable '%s' declared without type information, but parse options require all declarations to have type information", $3);
              v = new VarRefNode(QoreProgramLocation(@1.first_line, @3.last_line), $3, VT_LOCAL);
           }
           v->setExplicitScope();
           $$ = v;
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(QoreProgramLocation(@1.first_line, @3.last_line), "reference to variable '$%s' with the '$' sign is not allowed when parse option 'allow-bare-refs' is set", $3);
        }
        | TOK_MY '(' list ')' {
           $3->setVariableList();
           ListIterator li($3);
           while (li.next()) {
              AbstractQoreNode* n = li.getValue();
              qore_type_t t = get_node_type(n);
              if (t == NT_BAREWORD) {
                 BarewordNode* b = reinterpret_cast<BarewordNode*>(n);
                 if (parse_check_parse_option(PO_REQUIRE_TYPES))
                    parse_error(QoreProgramLocation(@1.first_line, @4.last_line), "local variable '%s' declared without type information, but parse options require all declarations to have type information", b->str);
                 if (!parse_check_parse_option(PO_ALLOW_BARE_REFS))
                    parse_error(QoreProgramLocation(@1.first_line, @4.last_line), "local variable '%s' in local variable declaration list declared without '$' prefix, but parse option 'allow-bare-refs' is not set", b->str);
                 VarRefNode* v = new VarRefNode(QoreProgramLocation(@1.first_line, @4.last_line), b->takeString(), VT_LOCAL);
                 v->setExplicitScope();
                 b->deref();
                 AbstractQoreNode** p = li.getValuePtr();
                 *p = v;
              }
              else if (t == NT_VARREF) {
                 VarRefNode* v = reinterpret_cast<VarRefNode*>(n);
                 // see if types are required
                 if (parse_check_parse_option(PO_REQUIRE_TYPES) && !v->isDecl())
                    parse_error(QoreProgramLocation(@1.first_line, @4.last_line), "local variable '%s' declared without type information, but parse options require all declarations to have type information", v->getName());
                 if (v->explicitScope()) {
                    if (v->getType() == VT_LOCAL)
                       parse_error(QoreProgramLocation(@1.first_line, @4.last_line), "illegal use of 'my %s' in local variable declaration list", v->getName());
                    else if (v->getType() == VT_GLOBAL)
                       parse_error(QoreProgramLocation(@1.first_line, @4.last_line), "illegal use of 'our %s' in local variable declaration list", v->getName());
                 }
                 else
                    v->makeLocal();
                 v->setExplicitScope();
              }
              else
                 parse_error(QoreProgramLocation(@1.first_line, @4.last_line), "element %d in list following 'my' is not a variable reference (%s)", li.index(), get_type_name(n));
           }
           $$ = $3;
        }
        | gvardecl {
           $$ = $1->makeVar();
        }
        | IDENTIFIER
        {
           if (parse_check_parse_option(PO_ASSUME_LOCAL & PO_ALLOW_BARE_REFS) && !strcmp($1, "argv"))
              inc_argv_ref();

           $$ = new BarewordNode(QoreProgramLocation(@1.first_line, @1.last_line), $1);
        }
        | CONTEXT_REF
        { $$ = new ContextrefNode(QoreProgramLocation(@1.first_line, @1.last_line), $1); }
        | TOK_CONTEXT_ROW
        { $$ = new ContextRowNode(QoreProgramLocation(@1.first_line, @1.last_line)); }
        | COMPLEX_CONTEXT_REF
        { $$ = new ComplexContextrefNode(QoreProgramLocation(@1.first_line, @1.last_line), $1); }
        | TOK_FIND exp TOK_IN exp TOK_WHERE '(' exp ')'
        { $$ = new FindNode(QoreProgramLocation(@1.first_line, @8.last_line), $2, $4, $7); }
        | TOK_EXISTS exp
        { $$ = new QoreExistsOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2); }
        | TOK_ELEMENTS exp
        { $$ = new QoreElementsOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2); }
        | TOK_KEYS exp {
           $$ = new QoreKeysOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | TOK_UNSHIFT exp {  // unshift list, element
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           if (!l || l->size() != 2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "invalid arguments to unshift, expected: lvalue, expression (%s)", $2->getTypeName());
              $$ = makeErrorTree($2, 0);
           }
           else {
              AbstractQoreNode* lv = l->shift();
              $$ = new QoreUnshiftOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), lv, l->shift());
              $2->deref(0);
           }
        }
        | TOK_SHIFT exp {
           $$ = new QoreShiftOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | TOK_PUSH exp {  // push lvalue-list, element
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           if (!l || l->size() != 2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "invalid arguments to push, expected: lvalue, expression (%s)", $2->getTypeName());
              $$ = makeErrorTree($2, 0);
           }
           else {
              AbstractQoreNode* lv = l->shift();
              $$ = new QorePushOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), lv, l->shift());
              $2->deref(0);
           }
        }
        | TOK_POP exp {
           $$ = new QorePopOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | TOK_CHOMP exp {
           $$ = new QoreChompOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | TOK_TRIM exp {
           $$ = new QoreTrimOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | TOK_SPLICE exp {  // splice lvalue-list, offset, [length, list]
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           if (!l) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "invalid arguments to splice, expected: lvalue, offset exp[, length exp[, list exp]] (got %s)", get_type_name($2));
              $$ = makeErrorTree($2, 0);
           }
           else if (l->size() < 2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "too few arguments to splice, expected at least 2 arguments as follows: lvalue, offset exp[, length exp[, list exp]] (got %d arguments)", l->size());
              $$ = makeErrorTree($2, 0);
           }
           else if (l->size() > 4) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "too many arguments to splice, expected maximum 4 arguments as follows: lvalue, offset exp[, length exp[, list exp]] (got %d arguments)", l->size());
              $$ = makeErrorTree($2, 0);
           }
           else {
              AbstractQoreNode* lv = l->shift();
              $$ = new QoreSpliceOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), lv, l->shift(), l->shift(), l->shift());
              discard(l, 0);
           }
        }
        | TOK_EXTRACT exp {  // extract lvalue-list, offset, [length, list]
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           if (!l) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "invalid arguments to extract, expected: lvalue, offset exp[, length exp[, list exp]] (got %s)", get_type_name($2));
              $$ = makeErrorTree($2, 0);
           }
           else if (l->size() < 2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "too few arguments to extract, expected at least 2 arguments as follows: lvalue, offset exp[, length exp[, list exp]] (got %d arguments)", l->size());
              $$ = makeErrorTree($2, 0);
           }
           else if (l->size() > 4) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "too many arguments to extract, expected maximum 4 arguments as follows: lvalue, offset exp[, length exp[, list exp]] (got %d arguments)", l->size());
              $$ = makeErrorTree($2, 0);
           }
           else {
              AbstractQoreNode* lv = l->shift();
              $$ = new QoreExtractOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), lv, l->shift(), l->shift(), l->shift());
              discard(l, 0);
           }
        }
        | TOK_MAP exp {
           QoreProgramLocation loc(@1.first_line, @2.last_line);
           pop_ignore_numeric_argv_ref();
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           int len = l ? (int)l->size() : 0;
           if (!l || len < 2 || len > 3) {
              parse_error(loc, "invalid arguments to map operator, expected: 2 or 3 element list (code expression, list argument, [select expression]), got: '%s'", get_type_name($2));
              $$ = makeErrorTree($2, 0);
           }
           else {
              // get first expression from list
              AbstractQoreNode* exp = l->shift();
              qore_type_t t = get_node_type(exp);
              $$ = 0;
              if (t == NT_PARSE_HASH) {
                 QoreParseHashNode* phn = reinterpret_cast<QoreParseHashNode*>(exp);
                 if (phn->isCurly())
                    $$ = parse_hash_map(loc, phn, l);
              }

              if (!$$)
                 $$ = parse_map(loc, exp, l);
           }
        }
        | TOK_FOLDR exp {
           pop_ignore_numeric_argv_ref();
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           if (!l || l->size() != 2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "invalid arguments to foldr operator, expected: 2-element list expected: 2-element list (fold expression and list expression), got: '%s'", get_type_name($2));
              $$ = makeErrorTree($2, 0);
           }
           else {
              AbstractQoreNode* code_exp = l->shift();
              AbstractQoreNode* arg = l->shift();
              $$ = new QoreFoldrOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), code_exp, arg);
              $2->deref(0);
           }
        }
        | TOK_FOLDL exp {
           pop_ignore_numeric_argv_ref();
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           if (!l || l->size() != 2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "invalid arguments to foldl operator, expected: 2-element list (fold expression and list expression), got: '%s'", get_type_name($2));
              $$ = makeErrorTree($2, 0);
           }
           else {
              AbstractQoreNode* code_exp = l->shift();
              AbstractQoreNode* arg = l->shift();
              $$ = new QoreFoldlOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), code_exp, arg);
              $2->deref(0);
           }
        }
        | TOK_SELECT exp {
           pop_ignore_numeric_argv_ref();
           QoreListNode* l = $2 && $2->getType() == NT_LIST ? reinterpret_cast<QoreListNode*>($2) : 0;
           if (!l || l->size() != 2) {
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "invalid arguments to select operator, expected: 2-element list (list expression and select expression) got: '%s'", get_type_name($2));
              $$ = makeErrorTree($2, 0);
           }
           else {
              AbstractQoreNode* arg = l->shift();
              AbstractQoreNode* select_exp = l->shift();
              $$ = new QoreSelectOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), arg, select_exp);
              $2->deref(0);
           }
        }
        | P_INCREMENT exp {  // pre-increment
           $$ = new QorePreIncrementOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | P_DECREMENT exp {  // pre-decrement
           $$ = new QorePreDecrementOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | BASE_CLASS_CALL '(' myexp ')' {
           printd(5, "parsing in-object base class method call %s()\n", $1->ostr);
           if (!strcmp($1->getIdentifier(), "copy"))
              parse_error(QoreProgramLocation(@1.first_line, @4.last_line), "illegal call to base class copy method '%s'", $1->ostr);

           $$ = new SelfFunctionCallNode(QoreProgramLocation(@1.first_line, @4.last_line), $1, make_args($3));
        }
        | KW_IDENTIFIER_OPENPAREN myexp ')' {
           printd(5, "parsing call %s()\n", $1);
           $$ = new FunctionCallNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, make_args($2));
        }
        | SELF_REF
        {
           $$ = new SelfVarrefNode(QoreProgramLocation(@1.first_line, @1.last_line), $1);
           if (parse_check_parse_option(PO_ALLOW_BARE_REFS))
              parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "reference to '$.%s' with the '$.' prefix is not allowed when parse option 'allow-bare-refs' is set", $1);
        }
        | '-' exp %prec NEG	     {
           // FIXME: need to expand constant expression checking to determine
           //        if the expression can throw an exception at run-time
           // first check for constant expressions
           $$ = new QoreUnaryMinusOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | '+' exp %prec UPLUS
        {
           $$ = new QoreUnaryPlusOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | '~' exp {
           $$ = new QoreBinaryNotOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | '!' exp {
           $$ = new QoreLogicalNotOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | '\\' exp {
           qore_type_t t = $2 ? $2->getType() : 0;
           //printd(5, "backslash exp line %d, type %s\n", @2.first_line, $2->getTypeName());

           if (t == NT_FUNCTION_CALL || t == NT_PROGRAM_FUNC_CALL) {
              $$ = reinterpret_cast<FunctionCallNode*>($2)->makeReferenceNodeAndDeref();
           }
           else if (t == NT_SELF_CALL) {
              $$ = reinterpret_cast<SelfFunctionCallNode*>($2)->makeReferenceNodeAndDeref();
           }
           else if (t == NT_STATIC_METHOD_CALL) {
              $$ = reinterpret_cast<StaticMethodCallNode*>($2)->makeReferenceNodeAndDeref();
           }
           else {
              bool make_ref = true;

              if (t == NT_OPERATOR) {
                 QoreDotEvalOperatorNode* deon = dynamic_cast<QoreDotEvalOperatorNode*>($2);
                 if (deon) {
                    $$ = deon->makeCallReference();
                    make_ref = false;
                 }
              }

              if (make_ref) {
                 //printd(5, "type=%s\n", $2->getTypeName());
                 $$ = new ParseReferenceNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
              }
	   }
        }
        | TOK_NEW IDENTIFIER '(' myexp ')' {
           $$ = new ScopedObjectCallNode(QoreProgramLocation(@1.first_line, @5.last_line), new NamedScope($2), make_args($4));
           if (parse_check_parse_option(PO_NO_NEW))
              parse_error(QoreProgramLocation(@1.first_line, @5.last_line), "illegal use of the 'new' operator (conflicts with parse option PO_NO_NEW)");
        }
        | TOK_NEW SCOPED_REF '(' myexp ')' {
           $$ = new ScopedObjectCallNode(QoreProgramLocation(@1.first_line, @5.last_line), new NamedScope($2), make_args($4));
           if (parse_check_parse_option(PO_NO_NEW))
              parse_error(QoreProgramLocation(@1.first_line, @5.last_line), "illegal use of the 'new' operator (conflicts with parse option PO_NO_NEW)");
        }
        | TOK_BACKGROUND exp {
           $$ = new QoreBackgroundOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
           // check to see if the expression is legal
           if (parse_check_parse_option(PO_NO_THREAD_CONTROL))
              parse_error(QoreProgramLocation(@1.first_line, @2.last_line), "illegal use of 'background' operator (conflicts with parse option PO_NO_THREAD_CONTROL)");
           else if (!node_has_effect($2))
              parse_error(QoreProgramLocation(@2.first_line, @2.last_line), "argument to background operator (%s) has no effect", get_type_name($2));
        }
        | BACKQUOTE {
           $$ = new BackquoteNode(QoreProgramLocation(@1.first_line, @1.last_line), $1);
           if (parse_check_parse_option(PO_NO_EXTERNAL_PROCESS))
              parse_error(QoreProgramLocation(@1.first_line, @1.last_line), "illegal use of backquote operator (conflicts with parse option PO_NO_EXTERNAL_PROCESS)");
        }
        | '(' exp ')' {
           $$ = $2;
           if ($2) {
              switch ($2->getType()) {
                 case NT_LIST:
                    reinterpret_cast<QoreListNode*>($2)->setFinalized();
                    break;
                 case NT_FUNCTION_CALL:
                    reinterpret_cast<FunctionCallNode*>($2)->setFinalized();
                    break;
                 case NT_BAREWORD:
                    reinterpret_cast<BarewordNode*>($2)->setFinalized();
                    break;
                 case NT_OPERATOR:
                    dynamic_cast<QoreOperatorNode*>($2)->setInParentheses();
                    break;
              }
           }
        }
        | '(' ')' { QoreListNode* l = new QoreListNode; l->setFinalized(); $$ = l; }
        | TOK_SUB '(' myexp ')' return_value block {
           int ar = get_pop_argv_ref();
           $$ = new QoreClosureParseNode(QoreProgramLocation(@1.first_line, @6.last_line), new UserClosureFunction($6, @3.first_line, @3.last_line, $3, $5, false, ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS));
        }
        | uncqtypedef TOK_SUB '(' myexp ')' block {
           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($1), ParserTypeStruct::getTypeInfo($1));
           delete $1;

           int ar = get_pop_argv_ref();
           $$ = new QoreClosureParseNode(QoreProgramLocation(@1.first_line, @6.last_line), new UserClosureFunction($6, @4.first_line, @4.last_line, $4, rt, false, ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS));
        }
        | method_modifiers TOK_SUB '(' myexp ')' return_value block {
           QoreProgramLocation loc(@1.first_line, @7.last_line);
           check_funcmod(loc, $1);
           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           if ($1 & OFM_DEPRECATED)
              flags |= QC_DEPRECATED;
           $$ = new QoreClosureParseNode(loc, new UserClosureFunction($7, @4.first_line, @4.last_line, $4, $6, $1 | OFM_SYNCED, flags));
        }
        | method_modifiers uncqtypedef TOK_SUB '(' myexp ')' block {
           QoreProgramLocation loc(@1.first_line, @7.last_line);
           check_funcmod(loc, $1);

           RetTypeInfo* rt = new RetTypeInfo(ParserTypeStruct::getParseTypeInfo($2), ParserTypeStruct::getTypeInfo($2));
           delete $2;

           int ar = get_pop_argv_ref();
           int64 flags = ar > 0 ? QC_USES_EXTRA_ARGS : QC_NO_FLAGS;
           if ($1 & OFM_DEPRECATED)
              flags |= QC_DEPRECATED;
           $$ = new QoreClosureParseNode(loc, new UserClosureFunction($7, @5.first_line, @5.last_line, $5, rt, $1 | OFM_SYNCED, flags));
        }
        | IMPLICIT_ARG_REF {
           $$ = $1;
           inc_numeric_argv_ref();
        }
        | IMPLICIT_ELEMENT {
           $$ = new QoreImplicitElementNode(QoreProgramLocation(@1.first_line, @1.last_line));
        }
        | TOK_DELETE exp {
           $$ = new QoreDeleteOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | TOK_REMOVE exp {
           $$ = new QoreRemoveOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $2);
        }
        | QORE_CAST '(' exp ')' {
           $$ = new QoreCastOperatorNode(QoreProgramLocation(@1.first_line, @4.last_line), $1, $3);
        }
        ;

exp:
    exp_c
    | list                              { $$ = $1; }
    | alt_hash                          { $$ = $1; }
    | '{' '}'                           { $$ = new QoreParseHashNode(QoreProgramLocation(@1.first_line, @2.last_line), true); }
    | exp PLUS_EQUALS exp               { $$ = new QorePlusEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp MINUS_EQUALS exp              { $$ = new QoreMinusEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp AND_EQUALS exp                { $$ = new QoreAndEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp OR_EQUALS exp                 { $$ = new QoreOrEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp MODULA_EQUALS exp             { $$ = new QoreModuloEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp MULTIPLY_EQUALS exp           { $$ = new QoreMultiplyEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp DIVIDE_EQUALS exp             { $$ = new QoreDivideEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp XOR_EQUALS exp                { $$ = new QoreXorEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp SHIFT_LEFT_EQUALS exp         { $$ = new QoreShiftLeftEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp SHIFT_RIGHT_EQUALS exp        { $$ = new QoreShiftRightEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '=' exp                       { $$ = processAssignment(@1.first_line, @3.last_line, $1, $3); }
    | exp TOK_INSTANCEOF IDENTIFIER     { QoreProgramLocation loc(@1.first_line, @3.last_line); $$ = new QoreInstanceOfOperatorNode(loc, $1, new ClassRefNode(loc, $3)); }
    | exp TOK_INSTANCEOF SCOPED_REF     { QoreProgramLocation loc(@1.first_line, @3.last_line); $$ = new QoreInstanceOfOperatorNode(loc, $1, new ClassRefNode(loc, $3)); }
    | exp NULL_COALESCING exp           { $$ = new QoreNullCoalescingOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp VALUE_COALESCING exp          { $$ = new QoreValueCoalescingOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '?' exp ':' exp               { $$ = new QoreQuestionMarkOperatorNode(QoreProgramLocation(@1.first_line, @5.last_line), $1, $3, $5); }
    | exp P_INCREMENT                   { $$ = new QorePostIncrementOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $1); } // post-increment
    | exp P_DECREMENT                   { $$ = new QorePostDecrementOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $1); } // post-decrement
    | exp '(' myexp ')'                 { $$ = processCall(@1.first_line, @4.last_line, $1, $3); }
    | exp LOGICAL_AND exp               { check_operator_log_or($1, "logical AND"); $$ = new QoreLogicalAndOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp LOGICAL_OR exp                { $$ = new QoreLogicalOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp BROKEN_LOGICAL_OR exp         { $$ = new QoreLogicalOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp BROKEN_BINARY_OR exp          { $$ = new QoreBinaryOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp BROKEN_BINARY_XOR exp         { check_operator_bin_or($1, "binary XOR"); $$ = new QoreBinaryXorOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '|' exp                       { $$ = new QoreBinaryOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '&' exp                       { check_operator_bin_or($1, "binary AND"); check_operator_bin_xor($1, "binary AND"); $$ = new QoreBinaryAndOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '^' exp                       { $$ = new QoreBinaryXorOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp REGEX_MATCH REGEX             { $$ = new QoreRegexMatchOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp REGEX_NMATCH REGEX            { $$ = new QoreRegexNMatchOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp REGEX_MATCH REGEX_SUBST       { $$ = new QoreRegexSubstOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp REGEX_MATCH REGEX_TRANS       { $$ = new QoreTransliterationOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp REGEX_MATCH REGEX_EXTRACT     { $$ = new QoreRegexExtractOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '>' exp                       { $$ = new QoreLogicalGreaterThanOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '<' exp                       { $$ = new QoreLogicalLessThanOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp LOGICAL_CMP exp               { $$ = new QoreLogicalComparisonOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp LOGICAL_EQ exp                { $$ = new QoreLogicalEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp ABSOLUTE_EQ exp               { $$ = new QoreLogicalAbsoluteEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp ABSOLUTE_NE exp               { $$ = new QoreLogicalAbsoluteNotEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp LOGICAL_NE exp                { $$ = new QoreLogicalNotEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp LOGICAL_LE exp                { $$ = new QoreLogicalLessThanOrEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp LOGICAL_GE exp                { $$ = new QoreLogicalGreaterThanOrEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp SHIFT_LEFT exp                { $$ = new QoreShiftLeftOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp SHIFT_RIGHT exp               { $$ = new QoreShiftRightOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '+' exp                       { $$ = new QorePlusOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '-' exp                       { $$ = new QoreMinusOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '%' exp                       { $$ = new QoreModuloOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '/' exp                       { $$ = new QoreDivisionOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '*' exp                       { $$ = new QoreMultiplicationOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '[' exp ']'                   { $$ = new QoreSquareBracketsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '{' exp '}'                   { $$ = new QoreHashObjectDereferenceOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp '.' exp                       { $$ = process_dot(@1.first_line, @3.last_line, $1, $3); }
    | exp DOT_KW_IDENTIFIER             { $$ = new QoreHashObjectDereferenceOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $1, $2); }
    ;

exp_n:
    exp_c
    | list_n                              { $$ = $1; }
    | exp_n PLUS_EQUALS exp               { $$ = new QorePlusEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n MINUS_EQUALS exp              { $$ = new QoreMinusEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n AND_EQUALS exp                { $$ = new QoreAndEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n OR_EQUALS exp                 { $$ = new QoreOrEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n MODULA_EQUALS exp             { $$ = new QoreModuloEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n MULTIPLY_EQUALS exp           { $$ = new QoreMultiplyEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n DIVIDE_EQUALS exp             { $$ = new QoreDivideEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n XOR_EQUALS exp                { $$ = new QoreXorEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n SHIFT_LEFT_EQUALS exp         { $$ = new QoreShiftLeftEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n SHIFT_RIGHT_EQUALS exp        { $$ = new QoreShiftRightEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '=' exp                       { $$ = processAssignment(@1.first_line, @3.last_line, $1, $3); }
    | exp_n TOK_INSTANCEOF IDENTIFIER     { QoreProgramLocation loc(@1.first_line, @3.last_line); $$ = new QoreInstanceOfOperatorNode(loc, $1, new ClassRefNode(loc, $3)); }
    | exp_n TOK_INSTANCEOF SCOPED_REF     { QoreProgramLocation loc(@1.first_line, @3.last_line); $$ = new QoreInstanceOfOperatorNode(loc, $1, new ClassRefNode(loc, $3)); }
    | exp_n NULL_COALESCING exp           { $$ = new QoreNullCoalescingOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n VALUE_COALESCING exp          { $$ = new QoreValueCoalescingOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '?' exp ':' exp               { $$ = new QoreQuestionMarkOperatorNode(QoreProgramLocation(@1.first_line, @5.last_line), $1, $3, $5); }
    | exp_n P_INCREMENT                   { $$ = new QorePostIncrementOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $1); } // post-increment
    | exp_n P_DECREMENT                   { $$ = new QorePostDecrementOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $1); } // post-decrement
    | exp_n '(' myexp ')'                 { $$ = processCall(@1.first_line, @4.last_line, $1, $3); }
    | exp_n LOGICAL_AND exp               { check_operator_log_or($1, "logical AND"); $$ = new QoreLogicalAndOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n LOGICAL_OR exp                { $$ = new QoreLogicalOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n BROKEN_LOGICAL_OR exp         { $$ = new QoreLogicalOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n BROKEN_BINARY_OR exp          { $$ = new QoreBinaryOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n BROKEN_BINARY_XOR exp         { check_operator_bin_or($1, "binary XOR"); $$ = new QoreBinaryXorOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '|' exp                       { $$ = new QoreBinaryOrOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '&' exp                       { check_operator_bin_or($1, "binary AND"); check_operator_bin_xor($1, "binary AND"); $$ = new QoreBinaryAndOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '^' exp                       { $$ = new QoreBinaryXorOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n REGEX_MATCH REGEX             { $$ = new QoreRegexMatchOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n REGEX_NMATCH REGEX            { $$ = new QoreRegexNMatchOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n REGEX_MATCH REGEX_SUBST       { $$ = new QoreRegexSubstOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n REGEX_MATCH REGEX_TRANS       { $$ = new QoreTransliterationOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n REGEX_MATCH REGEX_EXTRACT     { $$ = new QoreRegexExtractOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '>' exp                       { $$ = new QoreLogicalGreaterThanOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '<' exp                       { $$ = new QoreLogicalLessThanOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n LOGICAL_CMP exp               { $$ = new QoreLogicalComparisonOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n LOGICAL_EQ exp                { $$ = new QoreLogicalEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n ABSOLUTE_EQ exp               { $$ = new QoreLogicalAbsoluteEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n ABSOLUTE_NE exp               { $$ = new QoreLogicalAbsoluteNotEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n LOGICAL_NE exp                { $$ = new QoreLogicalNotEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n LOGICAL_LE exp                { $$ = new QoreLogicalLessThanOrEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n LOGICAL_GE exp                { $$ = new QoreLogicalGreaterThanOrEqualsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n SHIFT_LEFT exp                { $$ = new QoreShiftLeftOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n SHIFT_RIGHT exp               { $$ = new QoreShiftRightOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '+' exp                       { $$ = new QorePlusOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '-' exp                       { $$ = new QoreMinusOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '%' exp                       { $$ = new QoreModuloOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '/' exp                       { $$ = new QoreDivisionOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '*' exp                       { $$ = new QoreMultiplicationOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '[' exp ']'                   { $$ = new QoreSquareBracketsOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '{' exp '}'                   { $$ = new QoreHashObjectDereferenceOperatorNode(QoreProgramLocation(@1.first_line, @3.last_line), $1, $3); }
    | exp_n '.' exp                       { $$ = process_dot(@1.first_line, @3.last_line, $1, $3); }
    | exp_n DOT_KW_IDENTIFIER             { $$ = new QoreHashObjectDereferenceOperatorNode(QoreProgramLocation(@1.first_line, @2.last_line), $1, $2); }
    ;

string:
        QUOTED_WORD {
           $$ = $1;
        }
        | QUOTED_WORD string {
           $$ = $1;
           $$->concat($2);
           $2->deref();
        }
        ;

scalar:
        QFLOAT        { $$ = new QoreFloatNode($1); }
        | INTEGER     { $$ = new QoreBigIntNode($1); }
        | string      { $$ = $1; }
        | DATETIME    { $$ = $1; }
        | NUMBER      { $$ = $1; }
        ;

%%
