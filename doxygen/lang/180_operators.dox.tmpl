/** @page operators Operators

    @tableofcontents

    The following table lists all %Qore operators in order of precedence, starting with the highest precedence. The lower the precedence number, the higher the precedence, therefore the operators with precedence level 1 (\c "{}", \c "[]", \c ".") have the highest precedence of all %Qore operators. The precedence levels in %Qore are roughly equal to the precedence levels of C language operators. To explicitly specify the precedence for expression evaluation, use parentheses <tt>()</tt>.  Note that all examples are given in @ref new-style "%new-style".

    <b>Operators</b>
    |!Operator|!Prec.|!Description|!Example
    |@ref backquote_operator "``"|\c 1|@ref backquote_operator "backquote/backtick operator"|@code{.py} `ls -l`@endcode
    |@ref hash_element_operator "{}"|\c 1|@ref hash_element_operator "hash element or object member expression dereference operator"|@code{.py} hash{"na" + "me"}@endcode
    |@ref dot_operator "."|\c 1|@ref dot_operator "hash element or object member literal dereference operator"|@code{.py} hash.name@endcode @code{.py} obj.method()@endcode
    |@ref list_element_operator "[]"|\c 1|@ref list_element_operator "list element, string, and binary dereference operator"|@code{.py} list[1]@endcode
    |@ref pre_increment_operator "++"|\c 2|@ref pre_increment_operator "pre-increment operator"|@code{.py} ++a@endcode
    |@ref post_increment_operator "++"|\c 2|@ref post_increment_operator "post-increment operator"|@code{.py} a++@endcode
    |@ref pre_decrement_operator "--"|\c 2|@ref pre_decrement_operator "pre-decrement operator"|@code{.py} --a@endcode
    |@ref post_decrement_operator "--"|\c 2|@ref post_decrement_operator "post-decrement operator"|@code{.py} a--@endcode
    |@ref new "new"|\c 3|@ref new "class instantiation/new object operator"|@code{.py} new Socket()@endcode
    |@ref background "background"|\c 3|@ref background "background/thread creation operator"|@code{.py} background mainThread()@endcode
    |@ref delete "delete"|\c 3|@ref delete "delete operator"|@code{.py} delete var@endcode
    |@ref remove "remove"|\c 3|@ref remove "remove operator"|@code{.py} remove var@endcode
    |@ref cast "cast<>()"|\c 3|@ref cast "cast<>() operator"|@code{.py} cast<SubClass>(var)@endcode
    |@ref logical_negation_operator "!"|\c 4|@ref logical_negation_operator "logical negation operator"|@code{.py} if (!(a > 10)) {}@endcode
    |@ref binary_not_operator "~"|\c 5|@ref binary_not_operator "binary not/bit inversion operator"|@code{.py} var = ~var@endcode
    |@ref unary_plus_operator "+ (unary plus)"|\c 6|@ref unary_plus_operator "unary plus operator"|@code v{.py}ar = +var@endcode
    |@ref unary_minus_operator "- (unary minus)"|\c 6|@ref unary_minus_operator "unary minus operator"|@code{.py} var = -var@endcode
    |@ref shift "shift"|\c 7|@ref shift "shift list element operator"|@code{.py} shift list@endcode
    |@ref pop "pop"|\c 7|@ref pop "pop list element operator"|@code{.py} pop list@endcode
    |@ref chomp "chomp"|\c 7|@ref chomp "chomp end-of-line character operator"|@code{.py} chomp string@endcode
    |@ref trim "trim"|\c 7|@ref trim "trim characters operator"|@code{.py} trim string@endcode
    |@ref elements "elements"|\c 8|@ref elements "number of elements operator (list, hash, string, binary)"|@code{.py} elements list@endcode
    |@ref keys "keys"|\c 8|@ref keys "hash key list operator"|@code{.py} keys hash@endcode
    |@ref multiplication_operator "*"|\c 9|@ref multiplication_operator "multiplication operator"|@code{.py} var = a * 10@endcode
    |@ref division_operator "/"|\c 9|@ref division_operator "division operator"|@code{.py} var = a / 10@endcode
    |@ref modulo_operator "%"|\c 10|@ref modulo_operator "modulo operator"|@code{.py} var = a % 10@endcode
    |@ref plus_operator "+"|\c 11|@ref plus_operator "plus operator: string, binary, list, and hash concatenation, integer and float addition"|@code{.py} a + 10@endcode @code{.py} "hello" + "there"@endcode @code{.py} list + "new value"@endcode @code{.py} hash + ( "newkey" : 100 )@endcode
    |@ref minus_operator "-"|\c 11|@ref minus_operator "minus operator (arithmetic subtraction, hash key removal)"|@code{.py} a - 10@endcode
    |@ref shift_right_operator ">>"|\c 12|@ref shift_right_operator "bitwise shift right operator"|@code{.py} 0xff00 >> 8@endcode
    |@ref shift_left_operator "<<"|\c 12|@ref shift_left_operator "bitwise shift left operator"|@code{.py} 0xff00 << 8@endcode
    |@ref exists "exists"|\c 13|@ref exists "exists value operator"|@code{.py} exists var@endcode
    |@ref instanceof "instanceof"|\c 13|@ref instanceof "instanceof class operator"|@code{.py} instanceof Qore::Mutex@endcode
    |@ref logical_less_than_operator "<"|\c 14|@ref logical_less_than_operator "Logical less than operator"|@code{.py} a < 10@endcode
    |@ref logical_greater_than_operator ">"|\c 14|@ref logical_greater_than_operator "Logical greater than operator"|@code{.py} a > 10@endcode
    |@ref logical_equality_operator "=="|\c 14|@ref logical_equality_operator "Logical equality operator"|@code{.py} a == 10@endcode
    |@ref logical_inequality_operator "!="|\c 14|@ref logical_inequality_operator "logical inequality operator"|@code{.py} a != 10@endcode
    |@ref logical_less_than_or_equals_operator "<="|\c 14|@ref logical_less_than_or_equals_operator "Logical less then or equals operator"|@code{.py} a <= 10@endcode
    |@ref logical_greater_than_or_equals_operator ">="|\c 14|@ref logical_greater_than_or_equals_operator "logical greater than or equals operator"|@code{.py} a >= 10@endcode
    |@ref logical_comparison_operator "<=>"|\c 14|@ref logical_comparison_operator "logical comparison operator"|@code{.py} a <=> b@endcode
    |@ref logical_absolute_equality_operator "==="|\c 14|@ref logical_absolute_equality_operator "absolute logical equality operator"|@code{.py} a === 10@endcode
    |@ref logical_absolute_inequality_operator "!=="|\c 14|@ref logical_absolute_inequality_operator "absolute logical inequality operator"|@code{.py} a !== 10@endcode
    |@ref regex_match_operator "=~ //"|\c 14|@ref regex_match_operator "regular expression match operator"|@code{.py} a =~ /text/@endcode
    |@ref regex_no_match_operator "!~ //"|\c 14|@ref regex_no_match_operator "regular expression no match operator"|@code{.py} a !~ /text/@endcode
    |@ref regex_subst_operator "=~ s///"|\c 14|@ref regex_subst_operator "regular expression substitution operator"|@code{.py} a =~ s/text/text/@endcode
    |@ref regex_extract_operator "=~ x//"|\c 14|@ref regex_extract_operator "regular expression pattern extraction operator"|@code{.py} a =~ x/(\w+):(\w+)/@endcode
    |@ref transliteration_operator "=~ tr"|\c 14|@ref transliteration_operator "transliteration operator"|@code{.py} a =~ tr/a-z/A-Z/@endcode
    |@ref bitwise_and_operator "&"|\c 15|@ref bitwise_and_operator "bitwise/binary AND operator"|@code{.py} a & 0xff@endcode
    |@ref bitwise_xor_operator "^"|\c 16|@ref bitwise_xor_operator "bitwise/binary XOR operator"|@code{.py} a ^ 0xff@endcode
    |@ref bitwise_or_operator "|"|\c 17|@ref bitwise_or_operator "bitwise/binary OR operator"|@code{.py} a | 0xff@endcode
    |@ref logical_and_operator "&&"|\c 18|@ref logical_and_operator "logical AND operator"|@code{.py} (a = 1) && (b < 10)@endcode
    |@ref logical_or_operator "||"|\c 19|@ref logical_or_operator "logical OR operator"|@code{.py} (a = 1) || (b < 10)@endcode
    |@ref conditional_operator "? :"|\c 20|@ref conditional_operator "conditional operator"|@code{.py} a == 2 ? "yes" : "no"@endcode
    |@ref null_coalescing_operator "??"|\c 20|@ref null_coalescing_operator "null coalescing operator"|@code{.py} any var = a ?? b@endcode
    |@ref value_coalescing_operator "?*"|\c 20|@ref value_coalescing_operator "value coalescing operator"|@code{.py} any var = a ?* b@endcode
    |@ref comma_operator ","|\c 21|@ref comma_operator "comma operator"|@code{.py} 1, 2, 3, 4, 5@endcode
    |@ref unshift "unshift"|\c 22|@ref unshift "unshift list element operator"|@code{.py} unshift list, val@endcode
    |@ref push "push"|\c 22|@ref push "push list element operator"|@code{.py} push list, val@endcode
    |@ref splice "splice"|\c 22|@ref splice "splice list or string operator"|@code{.py} splice list, 2, 2, (1, 2, 3)@endcode
    |@ref extract "extract"|\c 22|@ref extract "extract list or string operator"|@code{.py} my sublist = extract list, 2, 2, (1, 2, 3)@endcode
    |@ref map "map"|\c 22|@ref map "map operator"|@code{.py} map closure($1), list@endcode
    |@ref hmap "hash map"|\c 22|@ref hmap "hash map operator"|@code{.py} map {expr($1) : expr($1)}, list@endcode
    |@ref foldl "foldl"|\c 22|@ref foldl "fold left to right operator"|@code{.py} foldl closure($1 - $2), list@endcode
    |@ref foldr "foldr"|\c 22|@ref foldr "fold right to left operator"|@code{.py} foldr closure($1 - $2), list@endcode
    |@ref select "select"|\c 22|@ref select "select elements from list operator"|@code{.py} select list, $1 > 1@endcode
    |@ref assignment_operator "="|\c 23|@ref assignment_operator "assignment operator"|@code{.py} var = 1@endcode
    |@ref plus_equals_operator "+="|\c 23|@ref plus_equals_operator "plus-equals (add-to) operator"|@code{.py} var += 5@endcode
    |@ref minus_equals_operator "-="|\c 23|@ref minus_equals_operator "minus-equals (subtract-from) operator"|@code{.py} var -= 5@endcode
    |@ref and_equals_operator "&="|\c 23|@ref and_equals_operator "and-equals operator"|@code{.py} var &= 0x2000@endcode
    |@ref or_equals_operator "|="|\c 23|@ref or_equals_operator "or-equals operator"|@code{.py} var |= 0x2000@endcode
    |@ref modulo_equals_operator "%="|\c 23|@ref modulo_equals_operator "modulo-equals operator"|@code{.py} var %= 100@endcode
    |@ref multiply_equals_operator "*="|\c 23|@ref multiply_equals_operator "multiply-equals operator"|@code{.py} var *= 10@endcode
    |@ref divide_equals_operator "/="|\c 23|@ref divide_equals_operator "divide-equals operator"|@code{.py} var /= 10@endcode
    |@ref xor_equals_operator "^="|\c 23|@ref xor_equals_operator "xor-equals operator"|@code{.py} var ^= 0x2000@endcode
    |@ref shift_left_equals_operator "<<="|\c 23|@ref shift_left_equals_operator "shift-left-equals operator"|@code{.py} var <<= 0x2000@endcode
    |@ref shift_right_equals_operator ">>="|\c 23|@ref shift_right_equals_operator "shift-right-equals operator"|@code{.py} var >>= 0x2000@endcode

    @note All %Qore operators perform thread-atomic actions with respect to the immediate arguments of the operator. If the operators are used in a complex expression, the entire expression is not thread-atomic unless explicit user-level locking is used. For example: <tt>a += 5</tt> is a thread-atomic action, but <tt>a += b--</tt> is not atomic, but rather made up of two atomic actions.\n\n
    When an operator taking more than one argument is used with arguments of different data types, %Qore automatically converts one or both data types to a data type supported by the operator in order to evaluate the result, according to the precedence lists given for each operator. That is; when an operator operates on mixed types, the types listed first in the following sections have precedence over types listed farther down in the lists. The result type will always be equal to the final operation type after any conversions due to type precedence per operator. If no type of either argument matches a supported data type for the operator, both types will be converted to the highest precedence data type for the operator and then the operator will evaluate the result. For explicit type conversion, please see the boolean(), string(), date(), int(), float(), etc functions.

    <hr>
    @section backquote_operator Backquote Operator (``)

    @par Synopsis
    Executes the shell command in a separate process and returns the stdout as a string. To perform the same action using a %Qore expression, see the backquote() function.

    @par Syntax
    <tt>`</tt><em>shell_command</em><tt>`</tt>

    @par Return Type
    @ref string_type "string"

    @par Example
    @code{.py} string dir = `ls -l`@endcode

    <b>Arguments Processed by ``</b>
    |!Argument|!Returns|!Processing
    |unquoted @ref string "string" \a shell_command|@ref string_type "string"|The shell command will be executed and the \c stdout is returned as a string

    @throw BACKQUOTE-ERROR An error occurred in fork() or creating the output pipe

    <hr>
    @section hash_element_operator Hash Element or Object Member Expression Dereference Operator ({})

    @par Synopsis
    Retrieves the value of hash key or object member by evaulating an expression.

    @par Syntax
    \a container_expression <tt>{</tt> \a expression <tt>}</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} printf("%s\n", hash{getName()});@endcode

    <b>Arguments Processed by {}</b>
    |!Argument|!Processing
    |\a container_expression|This expression must evaluate to a @ref hash "hash" or an @ref object "object"; if not, the operator returns no value (@ref nothing)
    |\a expression|- @ref list "list": if the expression evaluates to a list, then a slice of the hash or object is returned as a hash containing keys given in the list that are present in the hash or object. If the key as given in the list (converted to a string if necessary) is not present in the hash or object, then it is also not present in the hash returned; if none of the given keys exist in the hash, an empty hash is returned.\n- anything other than @ref list "list": the expression is converted to a string (if necessary); the value of the hash key corresponding to this string will be returned; if the key or member does not exist, then no value is returned

    @throw PRIVATE-MEMBER Attempt to access a private member outside the class

    <hr>
    @section dot_operator Hash Element or Object Member Literal Dereference Operator (.)

    @par Synopsis
    Retrieves the value of a hash key or object member using a literal identifier or an expression.

    @par Syntax
    \a hash_or_object_expression <tt>.</tt> <i>identifier</i> \n
    \a object_expression <tt>.</tt> \a method_name<tt>(</tt><em>[args ...]</em><tt>)</tt>\n
    \a hash_or_object_expression <tt>.</tt> <i>expression</i> \n

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} printf("%s\n", hash.name);@endcode
    @code{.py} obj.method("argument");@endcode

    <b>Arguments Processed by . (hash key or object member literal dereference)</b>
    |!Argument|!Processing
    |\a hash_or_object_expression|This expression must evaluate to a hash or an object; if not, then the operator returns no value
    |\a identifier|An unquoted string taken as the literal name of the hash key or object member. If no such key exists, then no value is returned. In order to use hash keys that are not valid %Qore identifiers, please use the {} operator. If the member is a private member and access is made outside the class, a run-time exception will be thrown.  Also note that constants or static class member names will not be resolved, in this case the string given is used as the literal name of the hash key or object member

    <b>Arguments Processed by . (object method call)</b>
    |!Argument|!Processing
    |\a object_expression|The \a object_expression must evaluate to an object or a run-time exception is thrown
    |<em>method_name</em><tt>([</tt><em>args</em><tt>])</tt>|If the method does not exist in the class a run-time exception is thrown. Otherwise the method is called with any optional arguments given and the return value of the method is returned.

    <b>Arguments Processed by . (hash key or object member expression dereference)</b>
    |!Argument|!Processing
    |\a hash_or_object_expression|This expression must evaluate to a hash or an object; if not, then the operator returns no value
    |\a expression|- @ref list "list": if the expression evaluates to a list, then a slice of the hash or object is returned as a hash containing keys given in the list that are present in the hash or object. If the key as given in the list (converted to a string if necessary) is not present in the hash or object, then it is also not present in the hash returned; if none of the given keys exist in the hash, an empty hash is returned.\n- anything other than @ref list "list": the expression is converted to a string (if necessary); the value of the hash key corresponding to this string will be returned; if the key or member does not exist, then no value is returned

    @throw PRIVATE-MEMBER Attempt to access a private member outside the class
    @throw METHOD-DOES-NOT-EXIST Attempt to access a method not defined for this class
    @throw METHOD-IS-PRIVATE Attempt to access a private method from outside the class
    @throw BASE-CLASS-IS-PRIVATE Attempt to access a method of a privately-inherited base class from outside the class
    @throw OBJECT-METHOD-EVAL-ON-NON-OBJECT Attempt to execute a method on a non-object

    <hr>
    @section list_element_operator List, String, and Binary Dereference Operator ([])

    @par Synopsis
    Retrieves the value of a list element, the given character of a string, or the integer value of a byte for a binary object. If the index value is not valid for the argument, @ref nothing is returned. Note that this operator only works as a list dereferencing operator in lvalue expressions; you cannot assign a character or a byte value to strings or binaries using this operator.

    @par Syntax
    <em>list_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>
    <em>string_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>
    <em>binary_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} printf("%s\n", list[2]);@endcode
    @code{.py} printf("%s\n", str[2]);@endcode
    @code{.py} printf("0x%x\n", binary[2]);@endcode

    <b>Arguments Processed by []</b>
    |!Argument|!Processing
    |\a list_expression|If the expression evaluates to a list, then the \a offset_expression will be used to return the given element from the list
    |\a string_expression|If the expression evaluates to a string, then the \a offset_expression will be used to return the given character from the list; note that multi-byte characters with UTF-8 are properly respected with this operator
    |\a binary_expression|If the expression evaluates to a binary, then the \a offset_expression will be used to return the integer value of the byte given from the binary object
    |\a offset_expression|The expression is evaluated and converted to an integer if necessary. Then the value of the given element given is returned according to the type of the first expression (as listed above; elements start at position 0)

    This operator does not throw any exceptions; if the first expression does not evaluate to either a list, string, or binary, then no value (@ref nothing) is returned.

    <hr>
    @section pre_increment_operator Pre-Increment Operator (++)

    @par Synopsis
    Increments an lvalue and returns the incremented value; only works on integer and floating-point values.

    @par Syntax
    <tt>++</tt><em>lvalue</em>

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code{.py} ++i;@endcode

    <b>Arguments Processed by ++ (pre-increement)</b>
    |!Argument|!Processing
    |@ref float|increments \a lvalue and returns the result
    |@ref integer (or any other type)|First converts the value of \a lvalue to an integer if necessary, then increments \a lvalue and returns the result

    This operator does not throw any exceptions.

    <hr>
    @section post_increment_operator Integer Post-Increment Operator (++)

    @par Synopsis
    Increments an integer or floating-point lvalue and returns the value before the increment; if the \a lvalue is neither a floating-point value or an integer, it will be converted to an integer

    @par Syntax
    <em>lvalue</em><tt>++</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} i++;@endcode

    <b>Arguments Processed by ++ (post-increment)</b>
    |!Argument|!Processing
    |@ref float|saves the value of the \a lvalue as the result, then increments \a lvalue, then returns the saved original value of \a lvalue
    |@ref integer (or any other type)|saves the value of the \a lvalue as the result, then converts the value of \a lvalue to an integer if necessary and increments it, then returns the saved original value of \a lvalue

    This operator does not throw any exceptions.

    <hr>
    @section pre_decrement_operator Integer Pre-Decrement Operator (--)

    @par Synopsis
    Decrements an lvalue and returns the incremented value; only works on integer and floating-point values.

    @par Syntax
    <tt>--</tt><em>lvalue</em>

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code{.py} --i;@endcode

    <b>Arguments Processed by -- (pre-decrement)</b>
    |!Argument|!Processing
    |@ref float|increments \a lvalue and returns the result
    |@ref integer (or any other type)|First converts the value of \a lvalue to an integer if necessary, then increments \a lvalue and returns the result

    This operator does not throw any exceptions.

    <hr>
    @section post_decrement_operator Integer Post-Decrement Operator (--)

    @par Synopsis
    Decrements an integer or floating-point lvalue and returns the value before the decrement; if the \a lvalue is neither a floating-point value or an integer, it will be converted to an integer

    @par Syntax
    <em>lvalue</em><tt>--</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    i--;

    <b>Arguments Processed by -- (post-decrement)</b>
    |!Argument|!Processing
    |@ref float|saves the value of the \a lvalue as the result, then decrements \a lvalue, then returns the saved original value of \a lvalue
    |@ref integer (or any other type)|saves the value of the \a lvalue as the result, then converts the value of \a lvalue to an integer if necessary and decrements it, then returns the saved original value of \a lvalue

    This operator does not throw any exceptions.

    <hr>
    @section new New Object Operator (new)

    @par Synopsis
    Creates an instance of a class by running the class' constructor on the new class (if any exists) and returns the new object.\n\n
    Note that if possible it is normally better to declare an object with its type and use the abbreviated form to construct the object as follows:\n
    @code{.py} Mutex m();@endcode
    This provides type information to the parser which allows more errors to be caught at parse time (instead of at run time), and furthermore allows %Qore to improve performance by performing more work once at parse time rather than for every time the object is accessed at run time (for example, method and variant resolution), and normally requires less typing.

    @par Syntax
    <tt><b>new</b></tt> <em>class_identifier</em><tt>(</tt><em>constructor_args ...</em><tt>)</tt>

    @par Return Type
    an object of the specific class given

    @par Example
    @code{.py} Mutex obj = new Qore::Mutex();@endcode

    <b>Arguments Processed by new</b>
    |!Argument|!Processing
    |\a class_identifier|The class_identifier must be an existing class name; if so, the operator instantiates an object of this class, executes the constructor for the class (if any exists, along with any base class constructors, if applicable) on the new object, and returns the object (for constructor execution order in an inherited class, see @ref inheritance). If an exception is thrown in the constructor, the object is deleted immediately.

    @note See class documentation for possible exceptions

    <hr>
    @section background Background Operator (background)

    @par Synopsis
    Start a background thread and return the TID (thread ID).

    @note
    - expressions that have no effect cannot be used with the background operator (a parse exception will be thrown)
    - it is illegal to make changes to a local variable anywhere in a background expression (a parse exception will be thrown)
    - local variables and find expressions are evaluated before the new thread is started and the result of the evaluation is used in the expression in the new thread
    - it is not possible to pass local variables by reference anywhere in a background expression (a parse exception will be thrown)

    @par Syntax
    <tt><b>background</b></tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} int tid = background startThread();@endcode

    <b>Arguments Processed by background</b>
    |!Argument|!Processing
    |\a expression|The \a expression given as an argument will be executed in a new thread. The TID of the new thread will be returned as the return value of the operator

    @throw THREAD-CREATION-FAILURE If the thread table is full or if the operating system returns an error while starting the thread, this exception is thrown

    <hr>
    @section delete Delete Operator (delete)

    @par Synopsis
    The delete operator deletes the contents of an lvalue. If the delete operator is called on an object, the object will be destroyed unconditionally. The delete operator does not return any value.\n\n
    When called on a hash key, the key is removed from the hash entirely; when called on a list element, the element is assigned @ref nothing (i.e. the list size does not change).\n\n
    The delete operator will delete multiple keys from a hash (i.e. delete a slice from a hash) when called on a hash dereferenced by a list of strings, giving the keys to delete (see example below).\n\n
    In the case the delete operator operates on an object, any exception can be thrown that is thrown by the class' destructor.\n\n
    For a similar operator that returns the value that is removed from the data structure, and does not delete objects, see the @ref remove "remove operator".

    @par Syntax
    <tt><b>delete</b></tt> \a lvalue_expression

    @par Return Type
    Does not return any value

    @par Example
    @code{.py}
# delete a single key from a hash
delete value;
# delete multiple values from a hash
delete h.("a", "b", "c");
    @endcode

    This operator does not throw any exceptions, however exceptions could be thrown in an object's destructor method when deleted by this operator.

    <hr>
    @section remove Remove Operator (remove)

    @par Synopsis
    The remove operator removes a value from a data structure, or, in the case the operand of the remove operator is a simple value, the value itself is removed from the variable and returned. The remove operator returns the value removed from the \a lvalue.\n\n
    When called on a hash key, the key is removed from the hash entirely, and the value returned is the value of the key removed from the hash; when called on a list element, the element is assigned @ref nothing (i.e. the list size does not change).\n\n
    The remove operator will remove and return a slice from a hash when called on a hash dereferenced by a list of strings, giving the keys to remove (see example below).\n\n
    The remove operator does not call destructors when operating on objects, but if removing an object from an lvalue or from a data structure within the \a lvalue causes the object to go out of scope, it will be destroyed, and then its destructor could throw an exception.\n\n
    For a similar operator that deletes the value that is removed from the data structure, see the @ref delete "delete operator".

    @par Syntax
    <tt><b>remove</b></tt> \a lvalue_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py}
# remove a single value from a hash
any var = remove hash.value;
# remove a slice from a hash
hash nh = remove h.("a", "b", "c");
    @endcode

    This operator does not throw any exceptions, however exception could be thrown in an object's destructor if it goes out of scope due to the action of this operator.

    <hr>
    @section cast Cast Operator (cast<>())

    @par Synopsis
    The cast<>() operator provides a way to tell the parser that the type of object is not actually the declared type but rather a subclass as given between the angle brackets.

    @par Syntax
    <tt><b>cast</b></tt>\<<em>class_identifier</em><tt>\>(</tt><em>object_expression</em><tt>)</tt>

    @par Return Type
    the specific class given

    @par Example
    @code{.py} cast<SubClass>(obj).method();@endcode

    <b>Arguments Processed by cast<>()</b>
    |!Argument|!Processing
    |\a class_identifier|This must be a literal unquoted string giving a class name or a namespace-qualified path to a class (ex: \c Namespace::MyClass)
    |\a object_expression|This must be an expression that evaluates to an object that can be cast to the given class; this is mostly useful at parse time to avoid @ref non-existent-method-call "non-existent-method-call warnings"

    @throw RUNTIME-CAST-ERROR The expression given does not evaluate to an object that can be cast to the given class

    <hr>
    @section logical_negation_operator Logical Not Operator (!)

    @par Synopsis
    Reverses the logical sense of an expression (@ref Qore::True "True" becomes @ref Qore::False "False" and @ref Qore::False "False" becomes @ref Qore::True "True").

    @par Syntax
    <tt>!</tt><em>expression</em>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (!exists error_code)
    do_something();
    @endcode

    <b>Arguments Processed by !</b>
    |!Argument|!Processing
    |\a expression|The expression is evaluated and converted to a @ref boolean "bool", if necessary. Then the value is logically reversed (@ref Qore::True "True" becomes @ref Qore::False "False", @ref Qore::False "False" becomes @ref Qore::True "True")

    This operator does not throw any exceptions.

    <hr>
    @section binary_not_operator Binary Not Operator (~)

    @par Synopsis
    The value of each bit in an integer is reversed (0 becomes 1, 1 becomes 0).

    @par Syntax
    <tt>~</tt><em>expression</em>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a = ~b;@endcode

    <b>Arguments Processed by ~</b>
    |!Argument|!Processing
    |\a expression|The argument is converted to an integer (if necessary), and bitwise negation is performed on the argument (ex: <tt>666 & ~27</tt> results in \c 640)

    This operator does not throw any exceptions

    <hr>
    @section unary_minus_operator Unary Minus Operator (-)

    @par Synopsis
    Changes the sign of numeric values.

    @par Syntax
    -expression

    @par Return Type
    @ref int_type "int", @ref number_type "number", @ref float_type "float" or @ref date_type "date"

    @par Example
    @code{.py} a = -b;@endcode

    <b>Arguments Processed by - (unary minus)</b>
    |!Argument|!Processing
    |@ref float|Gives the negative of its argument as a @ref float, ex: <tt>-(-1.1) = 1.1, -(1.1) = -1.1</tt>
    |@ref integer|Gives the negative of its argument as an @ref integer, ex: <tt>-(-1) = 1, -(1) = -1</tt>
    |@ref number|Gives the negative of its argument as a @ref number, ex: <tt>-(-1.1n) = 1.1n, -(1.1n) = -1.1n</tt>
    |@ref date|Gives the negative of its argument as a @ref date, ex: <tt>-(-1s) = 1s, -(1s) = -1s</tt>
    |@ref other|Returns 0

    This operator does not throw any exceptions

    <hr>
    @section unary_plus_operator Unary Plus Operator (+)

    @par Synopsis
    Does nothing with numeric values, converts others to 0.

    @par Syntax
    +expression

    @par Return Type
    @ref int_type "int", @ref number_type "number", @ref float_type "float" or @ref date_type "date"

    @par Example
    @code{.py} a = +b;@endcode

    <b>Arguments Processed by + (unary minus)</b>
    |!Argument|!Processing
    |@ref float|Gives the value of its argument as a @ref float, ex: <tt>+1.1 = 1.1</tt>
    |@ref integer|Gives the value of its argument as an @ref integer, ex: <tt>+1 = 1</tt>
    |@ref number|Gives the value of its argument as a @ref number, ex: <tt>+1.1n = 1.1n</tt>
    |@ref date|Gives the value of its argument as a @ref date, ex: <tt>+1s = 1s</tt>
    |@ref other|Returns 0

    This operator does not throw any exceptions

    <hr>
    @section shift Shift Operator (shift)

    @par Synopsis
    Removes the first element from a list and returns that element.  Throws a parse-time exception
    if the \a lvalue is known not to be a list at parse time, otherwise throws a runtime exception if
    the \a lvalue is not a list if @ref strict-args "%strict-args" is in effect.

    @par Syntax
    <tt><b>shift</b></tt> \a lvalue

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} *string a = shift ARGV;@endcode

    <b>Arguments Processed by shift</b>
    |!Argument|!Processing
    |\a lvalue|Returns the first element of the list, and the list is modified by having the first element removed from the list. If the \a lvalue is an empty list, the operator returns no value (@ref nothing).

    This operator throws an exception if the \a lvalue is not a list.

    <hr>
    @section pop Pop Operator (pop)

    @par Synopsis
    Removes the last element from a list and returns that element.  Throws a parse-time exception
    if the \a lvalue is known not to be a list at parse time, otherwise throws a runtime exception if
    the \a lvalue is not a list if @ref strict-args "%strict-args" is in effect.

    @par Syntax
    <tt><b>pop</b></tt> \a lvalue

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} a = pop list;@endcode

    <b>Arguments Processed by pop</b>
    |!Argument|!Processing
    |\a lvalue|Returns the last element of the list, and the list is modified, having the last element removed from the list. If the \a lvalue is an empty list, the operator returns no value (@ref nothing).

    This operator throws an exception if the \a lvalue is not a list.

    <hr>
    @section chomp Chomp Operator (chomp)

    @par Synopsis
    Removes the end-of-line marker(s) (\c '\\n' or \c '\\r\\n') from a string, or each string element in a list, or each hash key value in a hash (if the value is a string) and returns the number of characters removed.\n\n
    To perform this operation on a non-lvalue expression, see the chomp() function.

    @par Syntax
    <tt><b>chomp</b></tt><i>lvalue</i>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} chomp str;@endcode

    <b>Arguments Processed by chomp</b>
    |!Argument|!Processing
    |\a lvalue (@ref string)|Removes any EOL characters from a string and returns the number of characters removed.
    |\a lvalue (@ref list)|Removes any EOL characters from each string element of the list passed and returns the number of characters removed.
    |\a lvalue (@ref hash)|Removes any EOL characters from each hash key's value (where the value is a string) and returns the number of characters removed.

    This operator does not throw any exceptions.

    <hr>
    @section trim Trim Operator (trim)

    @par Synopsis
    Removes whitespace characters from the beginning and end of a string, or each string element in a list, or each hash key value in a hash (if the value is a string) and returns the value processed (string, list, or hash).\n\n
    To perform this operation on a non-lvalue expression, see the trim() function.\n\n
    The following whitespace characters are removed from the beginning and end of strings: <tt>' '</tt> (blank spaces), \c '\\n', \c '\\r', \c '\\t', \c '\\v' (vertical tab, ASCII 11), and \c '\\0' (null character).

    @par Syntax
    <tt><b>trim</b></tt> \a lvalue

    @par Return Type
    @ref string_type "string", @ref list_type "list", or @ref hash_type "hash"

    @par Example
    @code{.py} trim str;@endcode

    <b>Arguments Processed by trim</b>
    |!Argument|!Processing
    |\a lvalue (@ref string)|Removes whitespace characters from the beginning and end of a string and returns the value processed.
    |\a lvalue (@ref list)|Removes whitespace characters from the beginning and end of each string element of the list passed and returns the list.
    |\a lvalue (@ref hash)|Removes whitespace characters from the beginning and end of each string value of the hash passed and returns the hash.

    This operator does not throw any exceptions.

    <hr>
    @section map Map Operator (map)

    @par Synopsis
    Executes (or maps) an expression on a list and returns the result. An optional select expression can be given to filter elements out from the result list.\n\n
    If the first argument is a single element hash expression using curly brackets, then the @ref hmap "hash variant of the map operator" is used instead.\n\n
    If the second argument (\a list_expression) is an object inheriting the @ref Qore::AbstractIterator "AbstractIterator" class, the <b><tt>map</tt></b> operator iterates the object by calling @ref Qore::AbstractIterator::next() "AbstractIterator::next()", and the implicit argument <tt>$1</tt> in the \a map_expression and any optional \a select_expression is the value returned by @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()".\n\n
    If the second argument is not a list or an object inheriting @ref Qore::AbstractIterator "AbstractIterator", then \a map_expression is executed on the single value and the result is returned (assuming that any \a select_expression accepts the value).\n\n

    @par Return Type
    @ref any_type "any"

    @par Syntax
    <tt><b>map</b></tt> \a map_expression, <em>list_expression [, select_expression]</em>

    @par Examples
    @code{.py}
# returns (2, 4, 6)
list l = map $1 * 2, (1, 2, 3);
    @endcode
    @code{.py}
# prints out the keys of a hash; one to a line
map printf("%s\n", $1), hash.keyIterator();
    @endcode

    <b>Arguments Processed by map</b>
    |!Argument|!Processing
    |\a map_expression|The expression to map on the list; the implicit argument <tt>$1</tt> represents the current element being processed
    |\a list_expression|The data to process; if this is not a list then the \a map_expression is run on the single argument passed, unless the \a map_expression is an object inheriting the @ref Qore::AbstractIterator "AbstractIterator" class; in this case the <b><tt>map</tt></b> operator iterates the object by calling @ref Qore::AbstractIterator::next() "AbstractIterator::next()"
    |<em>[select_expression]</em>|An optional expression than can be used to filter out elements of the list before the map expression is applied; if this expression evaluates to @ref Qore::False "False" on an element, then the element will be skipped and the \a map_expression will not be applied on that element.

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    @see @ref hmap for a variant of this operator that creates and returns a hash rather than a list

    @since %Qore 0.8.6.2 the map operator when used with an @ref Qore::AbstractIterator "AbstractIterator" object instantiates the value returned by @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" instead of the iterator itself

    <hr>
    @section hmap Hash Map Operator (map)

    @par Synopsis
    This variant of the map operator builds a hash from a list or iterator argument and can be differentiated from the standard list @ref map "map" operator by the use of curly brackets in the initial expression; in this case the hash version of the map operator is used.  This operator executes (or maps) an expression on a list and returns the result in form of a hash. An optional select expression can be given to filter elements out from the result hash.\n\n
    If the first argument is anything other than a single element hash expression using curly brackets, then the @ref map "list variant of the map operator" is used instead.\n\n
    If the third argument (\a list_expression) is an object inheriting the @ref Qore::AbstractIterator "AbstractIterator" class, the <b><tt>map</tt></b> operator iterates the object by calling @ref Qore::AbstractIterator::next() "AbstractIterator::next()", and the implicit argument <tt>$1</tt> in the \a map_expression and any optional \a select_expression is the value returned by @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()".\n\n
    If the third argument is not a list or an object inheriting @ref Qore::AbstractIterator "AbstractIterator", then \a map_expression is executed on the single value and the result is returned (assuming that any \a select_expression accepts the value).\n\n

    @par Return Type
    @ref hash in case of valid third expression, otherwise @ref nothing

    @par Syntax
    <tt><b>map</b></tt> {\a key_expression,  : \a value_expression},  <em>list_expression [, select_expression]</em>

    @par Examples
    @code{.py}
hash h = map {$1 : $1 * 2}, (1, 2, 3);
# returns: {"1": 2, "2": 4, "3": 6}
    @endcode
    @code{.py}
hash h = map {$1 : $1 * 2}, (1, 2, 3), $1 > 1;
# returns: {"2": 4, "3": 6}
    @endcode

    <b>Arguments Processed by the hash version of map</b>
    |!Argument|!Processing
    |\a key_expression|The expression to map on the list or iterator value which will result in the key for the current hash element; the implicit argument <tt>$1</tt> represents the current element being processed. The result of the expression is converted to a string to be used as the hash key for the current element
    |\a value_expression|The expression to map on the list which will result in the value for the current hash element; the implicit argument <tt>$1</tt> represents the current element being processed
    |\a list_expression|The data to process; if this is not a list then the \a map_expression is run on the single argument passed, unless the \a map_expression is an object inheriting the @ref Qore::AbstractIterator "AbstractIterator" class; in this case the <b><tt>map</tt></b> operator iterates the object by calling @ref Qore::AbstractIterator::next() "AbstractIterator::next()"
    |<em>[select_expression]</em>|An optional expression than can be used to filter out elements of the list before the map expression is applied; if this expression evaluates to @ref Qore::False "False" on an element, then the element will be skipped and the \a map_expression will not be applied on that element.

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    @see @ref map for a variant of this operator that creates and returns a list

    @since %Qore 0.8.12 this variant of the map operator exists which builds a hash from a list or iterator source

    <hr>
    @section foldl Fold Left Operator (foldl)

    @par Synopsis
    Folds an operation on a list from left to right and returns the result. The result of each individual operation is used as the first argument in the foldl expression for the next element in the list. The first operation of the fold is made by executing the fold expression on the first and second elements of the list, from this point onwards, the result of each successive operation is used as the first argument for the next operation, the second argument being the next element in the list.\n\n
    If the second argument (\a list_expression) is an object inheriting the @ref Qore::AbstractIterator "AbstractIterator" class, the <b><tt>foldl</tt></b> operator iterates the object by calling @ref Qore::AbstractIterator::next() "AbstractIterator::next()", and the implicit arguments <tt>$1</tt> and <tt>$2</tt> in \a expression are the container values returned by @ref Qore::AbstractBidirectionalIterator::getValue() "AbstractBidirectionalIterator::getValue()".
    If the \a list_expression does not evaluate to a list or an object inheriting @ref Qore::AbstractIterator "AbstractIterator", then the evaluated argument is returned immediately with no processing by the fold expression.

    @par Syntax
    <tt><b>foldl</b></tt> \a expression, \a list_expression

    @par Return Type
    @ref any_type "any"

    @par Examples
    The following returns <tt><b>foldl</b></tt> expression returns \c 5
    @code{.py}
int result = foldl $1 - $2, (10, 4, 1);
    @endcode
    \n The following <tt><b>foldl</b></tt> expression joins a list with \c ", " or returns a single argument (if the second operand is not a list)
    @code{.py}
string str = foldl $1 + ", " + $2, list;
    @endcode

    <b>Arguments Processed by foldl</b>
    |!Argument|!Processing
    |\a expression|The expression to fold on the list; the implicit argument <tt>$1</tt> represents the result of the last operation (or the first element in the list when beginning the fold), and <tt>$2</tt> represents the next element of the list.
    |\a list_expression|The list, @ref Qore::AbstractIterator "AbstractIterator" object or other value according to the rules above to process

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    <hr>
    @section foldr Fold Right Operator (foldr)

    @par Synopsis
    Folds an operation on a list from right to left and returns the result. The result of each individual operation is used as the first argument in the foldr expression for the next element in the list in reverse order. The first operation of the right fold is made by executing the fold expression on the last and penultimate elements of the list, from this point onwards, the result of each successive operation is used as the first argument for the next operation, the second argument being the next element in the list in reverse order.\n\n
    If the second argument (\a list_expression) is an object inheriting the @ref Qore::AbstractBidirectionalIterator "AbstractBidirectionalIterator" class, the <b><tt>foldr</tt></b> operator iterates the object by calling @ref Qore::AbstractBidirectionalIterator::prev() "AbstractBidirectionalIterator::prev()", and the implicit arguments <tt>$1</tt> and <tt>$2</tt> in \a expression are the container values returned by @ref Qore::AbstractBidirectionalIterator::getValue() "AbstractBidirectionalIterator::getValue()".
    If the \a list_expression does not evaluate to a list or an object inheriting @ref Qore::AbstractBidirectionalIterator "AbstractBidirectionalIterator", then the evaluated argument is returned immediately with no processing by the fold expression.

    @par Syntax
    <tt><b>foldr</b></tt> \a expression, \a list_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py}
# returns -13
foldr $1 - $2, (10, 4, 1);
    @endcode

    <b>Arguments Processed by foldr</b>
    |!Argument|!Processing
    |\a expression|The expression to fold on the list; the implicit argument <tt>$1</tt> represents the result of the last operation (or the last element in the list when beginning the fold), and <tt>$2</tt> represents the next element of the list in reverse order.
    |\a list_expression|The list, @ref Qore::AbstractIterator "AbstractIterator" object or other value according to the rules above to process

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    <hr>
    @section select Select From List Operator (select)

    @par Synopsis
    Selects elements from a list that meet the given criteria and returns the new list.\n\n
    If the first argument (\a list_expression) is an object inheriting the @ref Qore::AbstractIterator "AbstractIterator" class, the <b><tt>select</tt></b> operator iterates the object by calling @ref Qore::AbstractIterator::next() "AbstractIterator::next()", and the implicit argument <tt>$1</tt> in \a expression is the value returned by @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()"; in this case the operator always returns a list (which may be empty if \a expression returns @ref Qore::False "False" for all elements in the iterator object or if the iterator object is empty), and the value of the object in the list returned is the value returned by @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()".\n\n
    If the list expression does not evaluate to a list or an object inheriting @ref Qore::AbstractIterator "AbstractIterator", then the select expression is evaluated using the value of the list expression as an argument, if it evalutes to true, then the value is returned, otherwise, no value is returned.

    @par Syntax
    <tt><b>select</b></tt> \a list_expression, \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py}
# returns (2, 4, 6)
select (1, 2, 3, 4, 5, 6), !($1 % 2);
    @endcode

    <b>Arguments Processed by select</b>
    |!Argument|!Processing
    |\a list_expression|The list to process or an object inheriting @ref Qore::AbstractIterator "AbstractIterator"
    |\a expression|The expression will be evaluated on each element of the list, the implicit argument <tt>$1</tt> represents current element of the list (or the iterator object itself when \a list_expression is an object inheriting @ref Qore::AbstractIterator "AbstractIterator"); only if the expression evaluates to @ref Qore::True "True" will the element appear in the result list

    This operator does not throw any exceptions (however note that exceptions could be thrown by the expression executed by this operator).

    @since %Qore 0.8.6.2 the map operator when used with an @ref Qore::AbstractIterator "AbstractIterator" object instantiates the value returned by @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" instead of the iterator itself

    <hr>
    @section elements Elements Operator (elements)

    @par Synopsis
    Returns the number of elements in a list, the number of keys in a hash, the number of characters (not bytes) in a string, or the number of bytes in a binary object.

    @par Syntax
    <tt><b>elements</b></tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} int size = elements list;@endcode

    <b>Arguments Processed by elements</b>
    |!Argument|!Processing
    |\a expression @ref list_type "list"|Returns the number of elements in the list
    |\a expression @ref hash_type "hash"|Returns the number of keys in the hash
    |\a expression @ref string_type "string"|Returns the number of characters in the string (which may be different than the number of bytes for multi-byte character encodings such as \c UTF-8
    |\a expression @ref binary_type "binary"|Returns the number of bytes in the binary object

    This operator does not throw any exceptions.

    @see @ref <value>::size()

    <hr>
    @section keys Keys Operator (keys)

    @par Synopsis
    Returns a list representing the keys in a hash.

    @par Syntax
    <tt><b>keys</b></tt> \a hash_expression

    @par Return Type
    @ref list_type "list" or @ref nothing

    @par Example
    @code{.py}
foreach string key in (keys hash)
    printf("%s = %s\n", key, hash{key});
    @endcode

    <b>Arguments Processed by keys</b>
    |!Argument|!Processing
    |\a hash_expression|Returns a list of strings giving the keys in \a hash_expression, which must evaluate to a hash. If not, then no value is returned.

    This operator does not throw any exceptions.

    @see
    - @ref <hash>::keys()
    - @ref <object>::keys()

    <hr>
    @section multiplication_operator Multiply Operator (*)

    @par Synopsis
    Multiplies two arguments.

    @par Syntax
    \a expression1 <tt>*</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", or @ref number_type "number"

    @par Example
    @code{.py} value = x * y;@endcode

    <b>Arguments Processed by * (in order of precedence)</b>
    |!Argument|!Processing
    |@ref number_type "number"|Gives the result of multiplying its arguments; @ref integer "ints" and @ref float "floats" are converted to @ref number "numbers" if at least one of the arguments is a @ref number "number"
    |@ref float_type "float"|Gives the result of multiplying its arguments; @ref integer "ints" are converted to @ref float "floats" if at least one of the arguments is a @ref float "float"
    |@ref int_type "int"|Gives the result of multiplying its arguments
    |any other type|Converts argument to a @ref number "number" and performs the multiplication

    This operator does not throw any exceptions.

    <hr>
    @section division_operator Divide Operator (/)

    @par Synopsis
    Divides a number by another.

    @par Syntax
    \a expression1 <tt>/</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", or @ref number_type "number"

    @par Example
    @code{.py} value = x / y;@endcode

    <b>Arguments Processed by / (in order of precedence)</b>
    |!Argument|!Processing
    |@ref number_type "number"|Gives the result of dividing its arguments; @ref integer "ints" and @ref float "floats" are converted to @ref number "numbers" if at least one of the arguments is a @ref number "number"
    |@ref float_type "float"|Gives the result of dividing its arguments; @ref integer "ints" are converted to @ref float "floats" if at least one of the arguments is a @ref float "float"
    |@ref int_type "int"|Gives the result of dividing its arguments
    |any other type|Converts argument to a @ref float_type "float" and performs the division

    @throw DIVISION-BY-ZERO division by zero error

    <hr>
    @section modulo_operator Modulo Operator (%)

    @par Synopsis
    Gives the integer remainder after division of one number by another.

    @par Syntax
    \a expression1 <tt>%</tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} mod = x % y;@endcode

    <b>Arguments Processed by %</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives \a expression1 modulo \a expression2 (ex: <tt>12 % 10</tt> result in \c 2). Arguments are converted to integers if necessary.

    This operator does not throw any exceptions.

    <hr>
    @section plus_operator Plus (Addition and Concatentation) Operator (+)

    @par Synopsis
    Numeric addition, list, string, binary, and hash concatenation operator.

    @par Syntax
    \a expression1 <tt>+</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref number_type "number", @ref date_type "date", @ref list_type "list", @ref string_type "string", @ref binary_type "binary", or @ref hash_type "hash"

    @par Example
    @code{.py} a = 1 + 2;@endcode
    @code{.py} string = "hello" + "-there";@endcode
    @code{.py} list = (1, 2) + ("three", "four", "five");@endcode
    @code{.py} hash = ( "key1" : 1, "key2" : 2) + ( "key3" : "three", "key4": "four");@endcode
    @code{.py} bin = bin1 + bin2;@endcode

    <b>Arguments Processed by + (in order of precedence)</b>
    |!Argument|!Processing
    |@ref list_type list|Gives the result of concatenating its arguments, i.e. <tt>(1, 2) + (3, 4) = (1, 2, 3, 4)</tt>
    |@ref string_type "string"|Gives the result of concatenating its arguments
    |@ref date_type "date"|Gives the result of adding date/time values (see @ref date_time_arithmetic)
    |@ref number_type "number"|Gives the result of adding its arguments
    |@ref float_type "float"|Gives the result of adding its arguments
    |@ref int_type "int"|Gives the result of adding its arguments
    |@ref hash_type "hash"|Gives the result of concatenating/merging its arguments. Any common keys will be overwritten by the values in the second hash (\a expression2)

    This operator does not throw any exceptions.

    <hr>
    @section minus_operator Minus Operator (-)

    @par Synopsis
    With @ref float "float", @ref integer "integer", or @ref number "number" arguments, subtracts one number from another.\n\n
    With @ref date "date" arguments, subtracts one date from another; if both date arguments are @ref absolute_dates "absolute dates", the result is a @ref relative_dates "relative date" (duration) giving the time between them; if the first date argument is an @ref absolute_dates "absolute date" and the second is a @ref relative_dates "relative date" (duration), then the result is an @ref absolute_dates "absolute date". If both date arguments are @ref relative_dates "relative dates", then the result is a @ref relative_dates "relative date". If the first argument is a @ref relative_dates "relative date" and the second date is an @ref absolute_dates "absolute date", the @ref absolute_dates "absolute date"'s epoch offset (offset in seconds and microseconds from \c 1970-01-01Z) is used to perform the calculation, and a @ref relative_dates "relative date/time value" is produced.\n\n
    However, if the left-hand side is a @ref hash "hash", and the right-hand side is a string, then the hash key represented by the string will be removed from the hash. If the left-hand side is a hash and the right-hand side is a list, then each element in the list will be converted to a string and any hash key with that name will be deleted from the hash.

    @par Syntax
    \a expression1 <tt>-</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref number_type "number", @ref date_type "date", or @ref hash_type "hash"

    @par Example
    @code{.py} num = x - y;@endcode
    @code{.py} date = 2010-05-13 - P3MT14H10M;@endcode
    @code{.py} hash = hash - "key";@endcode
    @code{.py} hash = hash - ("key1", "key2", "key3");@endcode

    <b>Arguments Processed by - (in order of precedence)</b>
    |!Argument|!Processing
    |@ref date_type "date"|date subtraction: \a expression1 - \a expression2
    |@ref number_type "number"|arithmetic subtraction: \a expression1 - \a expression2
    |@ref float_type "float"|arithmetic subtraction: \a expression1 - \a expression2
    |@ref int_type "int"|arithmetic subtraction: \a expression1 - \a expression2
    |@ref hash_type "hash" - @ref string_type "string"|hash key deletion: \a expression1 - \a expression2
    |@ref hash_type "hash" - @ref list_type "list"|hash key deletion: \a expression1 - \a expression2; all elements of the list are converted to strings (if necessary) and any keys with those names are deleted from the hash.

    This operator does not throw any exceptions.

    <hr>
    @section shift_right_operator Shift Right Operator (>>)

    @par Synopsis
    Shifts bits in an integer towards zero (divides an integer by a power of 2)

    @par Syntax
    \a expression1 <tt>\>\></tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a = x >> y;@endcode

    <b>Arguments Processed by >></b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of shifting \a expression1 right by \a expression2 bits. Arguments are converted to integers if necesssary.

    This operator does not throw any exceptions.

    <hr>
    @section shift_left_operator Shift Left Operator (<<)

    @par Synopsis
    Shifts bits in an integer towards infinity (multiplies an integer by a power of 2)

    @par Syntax
    \a expression1 <tt>\<\<</tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a = x << y;@endcode

    <b>Arguments Processed by <<</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of shifting \a expression1 left by \a expression2 bits. Arguments are converted to integers if necessary.

    This operator does not throw any exceptions.

    <hr>
    @section instanceof Class Instance Operator (instanceof)

    @par Synopsis
    Tests if an expression is an instance of a given class or not.

    @par Syntax
    \a expression <tt><b>instanceof</b></tt> \a class_identifier

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (obj instanceof Qore::Mutex)
    print("object is Mutex\n");
    @endcode

    <b>Arguments Processed by instanceof</b>
    |!Argument|!Processing
    |\a expression|If expression is an instance of the named class, then the operator returns @ref Qore::True "True", otherwise returns @ref Qore::False "False". The operator will return @ref Qore::True "True" if the class is a base class, also even if it is privately inherited.

    This operator does not throw any exceptions.

    <hr>
    @section exists Exists Operator (exists)

    @par Synopsis
    Tests if an expression represents a value or not.

    @par Syntax
    <tt><b>exists</b></tt> \a expression

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (exists a)
    printf("a = n\n", a);
    @endcode

    <b>Arguments Processed by exists</b>
    |!Argument|!Processing
    |\a expression|If \a expression evaluates to a value, then the operator returns @ref Qore::True "True", otherwise returns @ref Qore::False "False".

    This operator does not throw any exceptions.

    <hr>
    @section logical_less_than_operator Less Than Operator (<)

    @par Synopsis
    Tests if a value is less than another; types are converted if necessary (ex: <tt>("1" < 2)</tt> is @ref Qore::True "True").

    @par Syntax
    \a expression1 < \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x < y)
    printf("%n is less than %n\n", x, y);
    @endcode

    <b>Arguments Processed by < (in order of precedence)</b>
    |!Argument|!Processing
    |@ref number_type "number"|If \a expression1 is numerically less than \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref float_type "float"|If \a expression1 is numerically less than \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref int_type "int"|If \a expression1 is numerically less than \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref string_type "string"|If \a expression1 comes before \a expression2 in string sort order, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref date_type "date"|If \a expression1 is before (or a shorter amount of time than of the arguments are @ref relative_dates) \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"

    This operator does not throw any exceptions.

    <hr>
    @section logical_greater_than_operator Greater Than Operator (>)

    @par Synopsis
    Tests if a value is greater than another; types are converted if necessary (ex: <tt>("2" > 1)</tt> is @ref Qore::True "True").

    @par Syntax
    \a expression1 > \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x > y)
    printf("%n is less than %n\n", x, y);
    @endcode

    <b>Arguments Processed by > (in order of precedence)</b>
    |!Argument|!Processing
    |@ref number_type "number"|If \a expression1 is numerically greater than \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref float_type "float"|If \a expression1 is numerically greater than \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref int_type "int"|If \a expression1 is numerically greater than \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref string_type "string"|If \a expression1 comes after \a expression2 in string sort order, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref date_type "date"|If \a expression1 is after \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"

    This operator does not throw any exceptions.

    <hr>
    @section logical_equality_operator Equals Operator (==)

    @par Synopsis
    Tests if a value is equal to another; types are converted if necessary (ex: <tt>("1" == 1)</tt> is @ref Qore::True "True"). For absolute equals, where types must also be equal to return true, see the @ref logical_absolute_equality_operator.

    @par Syntax
    \a expression1 == \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x == y)
    printf("%n is equal to %n\n", x, y);
    @endcode

    <b>Arguments Processed by == (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 is equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref number_type "number"|If \a expression1 is equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref float_type "float"|If \a expression1 is equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref int_type "int"|If \a expression1 is equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref date_type "date"|If \a expression1 is equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref list_type "list"|If each element in the each list where order is relevant satisfies this operator, the operator returns @ref Qore::True "True", otherwise it returns @ref Qore::False "False"
    |@ref hash_type "hash"|If each hash has the same keys and the value of each equal key in each hash satisfies this operator, the operator returns @ref Qore::True "True", otherwise it returns @ref Qore::False "False"
    |@ref binary_type "binary"|If \a expression1's memory contents and size are equal to \a expression2's, then returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref object_type "object"|If \a expression1 is a reference to the same object as \a expression2, then returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref null|If both expressions are @ref null, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref nothing|If neither expression has a value, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"

    This operator does not throw any exceptions.

    <hr>
    @section logical_inequality_operator Not Equals Operator (!=)

    @par Synopsis
    Tests if a value is not equal to another; types are converted if necessary (ex: <tt>("1" != 1)</tt> is @ref Qore::False "False").

    @par Syntax
    \a expression1 != \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x != y)
    printf("%n is not equal to %n\n", x, y);
    @endcode

    <b>Arguments Processed by != (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 is not equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref number_type "number"|If \a expression1 is not equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref float_type "float"|If \a expression1 is not equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref int_type "int"|If \a expression1 is not equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref date_type "date"|If \a expression1 is not equal to \a expression2, returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref list_type "list"|If each element in the each list where order is relevant satisfies this operator, the operator returns @ref Qore::True "True", otherwise it returns @ref Qore::False "False"
    |@ref hash_type "hash"|If the hashes have different keys or the value of each equal key in each hash satisfies this operator, the operator returns @ref Qore::True "True", otherwise it returns @ref Qore::False "False"
    |@ref binary_type "binary"|If \a expression1's memory contents or size are not equal to \a expression2's, then returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref object_type "object"|If \a expression1 is not a reference to the same object as \a expression2, then returns @ref Qore::True "True", otherwise @ref Qore::False "False"
    |@ref null|If either expressions is not @ref null, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref nothing|If one of the expressions has a value, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"

    This operator does not throw any exceptions.

    <hr>
    @section logical_less_than_or_equals_operator Less Than Or Equals Operator (<=)

    @par Synopsis
    Tests if a value is less than or equals to another value; types are converted if necessary (ex: <tt>("1" <= 2)</tt> is @ref Qore::True "True").

    @par Syntax
    \a expression1 <= \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x <= y)
    printf("%n is less than or equal to %n\n", x, y);
    @endcode

    <b>Arguments Processed by <= (in order of precedence)</b>
    |!Argument|!Processing
    |@ref number_type "number"|If \a expression1 is numerically less than or equal to \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref float_type "float"|If \a expression1 is numerically less than or equal to \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref int_type "int"|If \a expression1 is numerically less than or equal to \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref string_type "string"|If \a expression1 comes before in string sort order or is the same as \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref date_type "date"|If \a expression1 is before or is the same exact date and time as \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"

    This operator does not throw any exceptions.

    <hr>
    @section logical_greater_than_or_equals_operator Greater Than Or Equals Operator (>=)

    @par Synopsis
    Tests if a value is greater than or equals to another value; types are converted if necessary (ex: <tt>("2" >= 1)</tt> is @ref Qore::True "True").

    @par Syntax
    \a expression1 >= \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x >= y)
    printf("%n is greater than or equal to %n\n", x, y);
    @endcode

    <b>Arguments Processed by >= (in order of precedence)</b>
    |!Argument|!Processing
    |@ref number_type "number"|If \a expression1 is numerically greater than or equal to \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref float_type "float"|If \a expression1 is numerically greater than or equal to \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref int_type "int"|If \a expression1 is numerically greater than or equal to \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref string_type "string"|If \a expression1 comes after in string sort order or is the same as \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"
    |@ref date_type "date"|If \a expression1 is after or is the same exact date and time as \a expression2, returns @ref Qore::True "True", otherwise returns @ref Qore::False "False"

    This operator does not throw any exceptions.

    <hr>
    @section logical_comparison_operator Comparison (<=>) Operator

    @par Synopsis
    Tests if the left-hand value is less than, equal, or greater than the right-hand value; types are converted if necessary (ex: ("1" <=> 2) returns -1).

    @par Syntax
    \a expression1 <=> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py}
switch (x <=> y) {
    case -1:
        print("x is less than y\n");
        break;

    case 0:
        print("x is equal to y\n");
        break;

    case 1:
        print("x is greater than y\n");
        break;
}
    @endcode

    <b>Arguments Processed by <=> (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 comes after in string sort order as \a expression2, returns \c 1, otherwise if they are equal, returns \c 0, otherwise if \a expression1 comes before \a expression2, returns \c -1
    |@ref number_type "number"|If \a expression1 is numerically greater than \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1
    |@ref float_type "float"|If \a expression1 is numerically greater than \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1
    |@ref int_type "int"|If \a expression1 is numerically greater than \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1
    |@ref date_type "date"|If \a expression1 is after \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1

    This operator throws NAN-COMPARE-ERROR if any of the operands is NaN.

    <hr>
    @section logical_absolute_equality_operator Absolute Equals Operator (===)

    @par Synopsis
    Checks two values for equality without doing any data type conversions; if the types do not match, then the result is @ref Qore::False "False".

    @par Syntax
    \a expression1 === \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x === y)
    printf("%n is equal to %n and has the same data type as well\n", x, y);
    @endcode

    <b>Arguments Processed by ===</b>
    |!Argument|!Processing
    |All|This operator returns @ref Qore::True "True" only if the types and values of both sides of the operator are exactly equal, otherwise returns @ref Qore::False "False". No type conversions are done.

    This operator does not throw any exceptions.

    <hr>
    @section logical_absolute_inequality_operator Absolute Not Equals Operator (!==)

    @par Synopsis
    Checks two values for inequality without doing any data type conversions. If the data types do not match, then returns @ref Qore::True "True".

    @par Syntax
    \a expression1 !== \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x !== y)
    printf("%n is not equal to %n and may not have the data type as well\n", x, y);
    @endcode

    <b>Arguments Processed by !==</b>
    |!Argument|!Processing
    |All|This operator returns @ref Qore::True "True" if either the types or the values of the arguments are different, otherwise it retuns @ref Qore::False "False". No type conversions are done.

    This operator does not throw any exceptions.

    <hr>
    @section regex_match_operator Regular Expression Match Operator (=~)

    @par Synopsis
    Checks for a regular expression match; returns @ref Qore::True "True" if the expression matches the string, @ref Qore::False "False" if not. See @ref qore_regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref qore_regex for more information about regular expression support in %Qore.

    @par Syntax
    \a expression <tt>=~ [m]/</tt><em>regex</em><tt>/[isxm]</tt>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (str =~ /hello/)
    printf("%s contains 'hello'\n", str);
    @endcode

    <b>Arguments Processed by =~</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator returns @ref Qore::True "True" if the regular expression in \a regex matches the string in \a expression.

    This operator does not throw any exceptions.

    <hr>
    @section regex_no_match_operator Regular Expression No Match Operator (!~)

    @par Synopsis
    Checks for a regular expression non match; returns @ref Qore::True "True" if the expression does not match the string, @ref Qore::False "False" if it does. See @ref qore_regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref qore_regex for more information about regular expression support in %Qore.

    @par Syntax
    \a expression <tt>!~ [m]/</tt><em>regex</em><tt>/[isxm]</tt>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (str !~ /hello/)
    printf("%s does not contain 'hello'\n", str);
    @endcode

    <b>Arguments Processed by !~</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator returns @ref Qore::True "True" if the regular expression in \a regex does not match the string in \a expression.

    This operator does not throw any exceptions.

    <hr>
    @section regex_subst_operator Regular Expression Substitution Operator

    @par Synopsis
    Looks for a regular expression match in a string, and, if found, substitutes the matched string with a new string. Subpattern backreferences are supported in the target string, <tt>$1</tt>=first subpattern, <tt>$2</tt>=second subpattern, etc... See @ref qore_regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref qore_regex for more information about regular expression support in %Qore.

    @par Syntax
    \a lvalue <tt>=~ s/</tt><em>regex_pattern</em><tt>/</tt><em>target_string</em><tt>/[isxmg]</tt>

    @par Return Type
    @ref string_type "string" or @ref nothing (if the \a lvalue does not hold a string)

    @par Example
    @code{.py}
str =~ s/hello/goodbye/i;
str =~ s/(\w+) +(\w+)/$2, $1/;
    @endcode

    <b>Arguments Processed by =~ s///</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator substitutes text in the \a lvalue string if the regular expression matches. Subpattern backreferences are supported in \a target_string, <tt>$1</tt>=first subpattern, <tt>$2</tt>=second subpattern, etc..

    This operator does not throw any exceptions.

    <hr>
    @section regex_extract_operator Regular Expression Pattern Extraction Operator

    @par Synopsis
    Matches regular expression patterns (enclosed in parentheses) in a string and returns a list giving the text matched for each pattern. If the regular expression does not match, then no value (@ref nothing) is returned. See @ref qore_regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref qore_regex for more information about regular expression support in %Qore.

    @par Syntax
    \a string <tt>=~ x/</tt><em>regex_with_patterns</em><tt>/[isxm]</tt>

    @par Return Type
    @ref list_type "list" or @ref nothing (if the \a lvalue does not hold a string or if the pattern is not matched)

    @par Example
    @code{.py}
list =~ x/(\w+):(\w+)/;
list =~ x/(.*)\.(.*)/;
    @endcode

    <b>Arguments Processed by =~ x//</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator extracts strings from \a string based on patterns enclosed in parentheses in the regular expression.

    This operator does not throw any exceptions.

    <hr>
    @section transliteration_operator Transliteration Operator

    @par Synopsis
    Makes character substitutions in an lvalue; character ranges can also be used.

    @par Syntax
    \a lvalue <tt>=~ tr/</tt><em>source_chars</em><tt>/</tt><em>target_chars</em><tt>/</tt>

    @par Return Type
    @ref string_type "string" or @ref nothing (if the \a lvalue does not hold a string)

    @par Example
    @code{.py} str =~ tr/a-z/A-Z/;@endcode

    <b>Arguments Processed by =~ tr//</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator substitutes characters in the \a lvalue string. Note that if there are more characters in \a source_chars than in \a target_chars, then the last character in \a target_chars will be used for any source matches where the source character position is greater than the length of \a target_chars.

    This operator does not throw any exceptions.

    <hr>
    @section bitwise_and_operator Bitwise/Binary And Operator (&)

    @par Synopsis
    Performs a bitwise (binary) AND operation on two integers.

    @par Syntax
    \a expression1 & \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a = x & y;@endcode

    <b>Arguments Processed by &</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) AND operation between \a expression1 and \a expression2 (ex: <tt>0xffb2 & 0xa1 = 0xa1</tt>); operands are converted to integers if necessary.

    This operator does not throw any exceptions.

    <hr>
    @section bitwise_or_operator Bitwise/Binary Or Operator (|)

    @par Synopsis
    Performs a bitwise (binary) OR operation on two integers.

    @par Syntax
    \a expression1 | \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a = x | y;@endcode

    <b>Arguments Processed by |</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) OR operation between \a expression1 and \a expression2 (ex: <tt>0xb001 \| 0xfea = 0xbfeb</tt>); operands are converted to integers if necessary

    This operator does not throw any exceptions.

    <hr>
    @section bitwise_xor_operator Bitwise/Binary Xor Operator (^)

    @par Synopsis
    Performs a bitwise (binary) XOR operation on two integers.

    @par Syntax
    \a expression1 ^ \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a = x ^ y;@endcode

    <b>Arguments Processed by ^</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) EXCLUSIVE OR operation between \a expression1 and \a expression2 (ex: <tt>0xaef1 & 0xfb32 = 0x55c3</tt>); operands are converted to integers if necessary

    This operator does not throw any exceptions.

    <hr>
    @section logical_and_operator Logical And Operator (&&)

    @par Synopsis
    Checks to see if two expressions are @ref Qore::True "True" with logical short-circuiting.

    @par Syntax
    \a expression1 && \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x && y)
    printf("%n and %n are both True\n", x, y);
    @endcode

    <b>Arguments Processed by &&</b>
    |!Argument|!Processing
    |@ref bool_type "bool"|Returns @ref Qore::True "True" if both expressions are @ref Qore::True "True", @ref Qore::False "False" if otherwise. Logical short-circuiting is implemented; if \a expression1 is @ref Qore::False "False", then \a expression2 is not evaluated, and the operator returns @ref Qore::False "False".

    This operator does not throw any exceptions.

    <hr>
    @section logical_or_operator Logical Or Operator (||)

    @par Synopsis
    Returns @ref Qore::True "True" if either of the arguments are @ref Qore::True "True" with logical short-circuiting.

    @par Syntax
    \a expression1 || \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code{.py}
if (x || y)
    printf("either %n or %n or both are True\n", x, y);
    @endcode

    <b>Arguments Processed by ||</b>
    |!Argument|!Processing
    |@ref bool_type "bool"|Returns @ref Qore::True "True" if either or both expressions evaluate to @ref Qore::True "True", @ref Qore::False "False" if otherwise. Logical short-circuiting is implemented; if \a expression1 is @ref Qore::True "True", then \a expression2 is not evaluated, and the operator returns @ref Qore::True "True".

    This operator does not throw any exceptions.

    <hr>
    @section conditional_operator Conditional Operator (? :)

    @par Synopsis
    Evaluates and returns the value of one of two expressions depending on the value of a conditional expression.

    @par Syntax
    \a expression ? \a if_true_expression : \a if_false_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} a = (z > 100 ? "Big" : "Small");@endcode

    <b>Arguments Processed by ? :</b>
    |!Argument|!Processing
    |All|If \a expression is evaluated to be @ref Qore::True "True", then the \a if_true_expression is evaluated and returned. Otherwise the \a if_false_expression is evaluated and returned.

    This operator does not throw any exceptions.

    <hr>
    @section null_coalescing_operator Null Coalescing Operator (??)

    @par Synopsis
    Evaluates the first operand and checks for a value (i. e. not @ref nothing or @ref null).  If it evaluates to a value, then the value of the first operand is returned, otherwise the second operand is evaluated and returned.  When chained, the first argument with a value is returned.

    @par Syntax
    \a expression1 ?? \a expression2

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} x = a ?? b ?? c;@endcode

    <b>Arguments Processed by ??</b>
    |!Argument|!Processing
    |All|If \a expression1 is evaluated to be @ref nothing or @ref null then the \a expession2 is evaluated and returned. Otherwise the value of \a expression1 is returned.

    This operator does not throw any exceptions.

    See also @ref value_coalescing_operator that works same except for operands are evaluated based on being @ref Qore::False "False" instead of being @ref nothing or @ref null.


    <hr>
    @section value_coalescing_operator Value Coalescing Operator (?*)

    @par Synopsis
    Evaluates the first operand and checks for a value (@ref Qore::True "True" or @ref Qore::False "False"). If it evaluates to @ref Qore::True "True", then the value of the first operand is returned, otherwise the second operand is evaluated and returned.  When chained, the first argument with a value is returned.

    @par Syntax
    \a expression1 ?* \a expression2

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} x = a ?* b ?* c;@endcode

    <b>Arguments Processed by ?*</b>
    |!Argument|!Processing
    |All|If \a expression1 is evaluated to be @ref Qore::False "False" then the \a expession2 is evaluated and returned. Otherwise the value of \a expression1 is returned.

    This operator does not throw any exceptions.

    See also @ref null_coalescing_operator that works same except for operands are evaluated based on being @ref nothing or @ref null instead of being @ref Qore::False "False".


    <hr>
    @section comma_operator Comma Operator (,)

    @par Synopsis
    Makes a list from more than one element.

    @par Syntax
    \a expression1, \a expression2

    @par Return Type
    @ref list_type "list"

    @par Example
    @code{.py} a = 1, 2, "three";@endcode

    <b>Arguments Processed by ,</b>
    |!Argument|!Processing
    |All|The comma operator builds lists of arguments

    This operator does not throw any exceptions.

    <hr>
    @section unshift Unshift Operator (unshift)

    @par Synopsis
    Inserts an element into the first position of a list, moves all other elements up one position and returns the list processed. Throws an exception if the \a lvalue is not a list.

    @par Syntax
    <tt><b>unshift</b></tt> \a lvalue, \a expression

    @par Return Type
    @ref list_type "list"

    @par Example
    @code{.py} unshift list, "one";@endcode

    <b>Arguments Processed by unshift</b>
    |!Argument|!Processing
    |All|Inserts the value of \a expression as the first element in the list given by \a lvalue. All other elements in the list are moved forward. If \a expression evaluates to a list, this list will be appended as the last element of \a lvalue. To concatenate lists, use the @ref plus_operator "plus operator".

    <hr>
    @section push Push Operator (push)

    @par Synopsis
    Adds one element to the end of a list and returns the list processed. Throws a parse-time exception
    if the \a lvalue is known not to be a list at parse time, otherwise throws a runtime exception if
    the \a lvalue is not a list if @ref strict-args "%strict-args" is in effect.

    @par Syntax
    <tt><b>push</b></tt> \a lvalue, \a expression

    @par Return Type
    @ref list_type "list"

    @par Example
    @code{.py} push list, "last";@endcode

    <b>Arguments Processed by push</b>
    |!Argument|!Processing
    |All|Appends the value of the \a expression as the last element in the list given by \a lvalue. If \a expression evaluates to a list, this list will be appended as the last element of \a lvalue. To concatenate lists, use the @ref plus_operator "plus operator".

    <hr>
    @section splice Splice Operator (splice)

    @par Synopsis
    Removes and optionally inserts elements in lists, strings, and binary objects and returns the \a lvalue after processing. For a similar operator that returns the values removed, see the @ref extract "extract operator".\n\n
    Works on strings, lists, and binary data in a similar way; removes elements from a list, characters from a string, or bytes from binary data and optionally inserts new ones. If no \a length_expression is given, splice removes all elements/characters/bytes from the list, string, or binary data lvalue starting at \a offset_expression (offsets begin at 0). Otherwise, a number of elements/characters/bytes equal to \a length_expression is removed (or up to the end of the list/string/data if applicable). If \a substitution_expression is present, then the removed elements/characters/bytes are substituted with the elements/string/bytes given by this expression.\n\n
    Note that string splice takes character offsets, which may not be the same as byte offsets for multi-byte character encodings, such as \c UTF-8

    @par Syntax
    <tt><b>splice</b></tt> \a lvalue, \a offset_expression<em>, [length_expression, [substitution_expression]]</em>

    @par Return Type
    @ref list_type "list", @ref string_type "string", or @ref binary_type "binary" (returns \a lvalue after processing)

    @par Example
    @code{.py} splice list, 2, 2;@endcode
    @code{.py} splice string, 2, 2, "-text-";@endcode
    @code{.py} splice bin, 2, 2, <deadbeef>;@endcode

    <b>Arguments Processed by splice</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list", @ref string_type "string", or @ref binary_type "binary")|If the \a lvalue is a list, list elements are processed, if it is a string, characters in the string are processed, and for binary data, bytes are processed. For any other data type, no action is taken.
    |\a offset_expression|The start element/character/byte position for removing elements/characters/bytes from the list, string, or binary data; if this value is negative, it gives the element offset from the end of the data
    |\a length_expression|The number of elements/characters/bytes to remove. If this expression is not present, then all elements/characters/bytes from the offset to the end of the list/string/binary data are removed. If this expression is present and evaluates to 0, no characters/elements/byte are removed; if this value is negative, then it gives an offset from the end of the data (ie -2 means remove all elements/characters/bytes up to but not including the last two)
    |\a substitution_expression|For list splice, an optional element or list to substitute for the removed elements (to insert a list in a single element's position, make sure that the list to be inserted is the first and only element of another list used as the argument in this position; in other words, pass a list within a single-element list). For string splice, an optional string to substitute for the removed characters.  For binary splice, string or binary data to substitute for any removed bytes.

    <hr>
    @section extract Extract Operator (extract)

    @par Synopsis
    Removes and optionally inserts elements in lists and strings. For a similar operator that removes values from an lvalue and returns the \a lvalue (instead of the value removed), see the @ref splice "splice operator".\n\n
    Works on either strings, lists, and binary data in a similar way; removes elements from a list, characters from a string, and bytes from binary data and optionally inserts new ones. If no length_expression is given, extract removes all elements/characters/bytes from the \a lvalue starting at \a offset_expression (offsets begin at 0). Otherwise, a number of elements/characters/bytes equal to \a length_expression is removed (or up to the end of the data if applicable). If \a substitution_expression is present, then the removed elements/characters/bytes are substituted with the data given by this expression.\n\n
    When operating on lists, a list is returned of any elements extracted (if no elements are extracted, then an empty list is returned); when operating on strings, a string is extracted of all characters extracted from the string (if no characters are extracted, then an empty string is returned).  When operating on binary data, a binary object is returned.\n\n
    Note that string extract takes character offsets, which may not be the same as byte offsets for multi-byte character encodings, such as \c UTF-8

    @par Syntax
    <tt><b>extract</b></tt> \a lvalue, \a offset_expression<em>, [length_expression, [substitution_expression]]</em>

    @par Return Type
    @ref list_type "list", @ref string_type "string", or @ref binary_type "binary" (the value(s) removed from \a lvalue)

    @par Example
    @code{.py} list sublist = extract list, 2, 2;@endcode
    @code{.py} string substring = extract string, 2, 2, "-text-";@endcode
    @code{.py} binary b = extract bin, 2, 2, <deadbeef>;@endcode

    <b>Arguments Processed by extract</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list", @ref string_type "string", or @ref binary_type "binary")|If the \a lvalue is a list, list elements are processed, if it is a string, characters in the string are processed, and for binary data, bytes are processed. For any other data type, no action is taken.
    |\a offset_expression|The start element/character/byte position for removing elements/characters/bytes from the list, string, or binary data; if this value is negative, it gives the element offset from the end of the data
    |\a length_expression|The number of elements/characters/bytes to remove. If this expression is not present, then all elements/characters/bytes from the offset to the end of the list/string/binary data are removed. If this expression is present and evaluates to 0, no characters/elements/byte are removed; if this value is negative, then it gives an offset from the end of the data (ie -2 means remove all elements/characters/bytes up to but not including the last two)
    |\a substitution_expression|For list extract, an optional element or list to substitute for the removed elements (to insert a list in a single element's position, make sure that the list to be inserted is the first and only element of another list used as the argument in this position; in other words, pass a list within a single-element list). For string splice, an optional string to substitute for the removed characters.  For binary splice, string or binary data to substitute for any removed bytes.

    <hr>
    @section assignment_operator Assignment Operator (=)

    @par Synopsis
    Assigns a value to an lvalue and returns the value assigned.

    @par Syntax
    \a lvalue <tt>=</tt> \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code{.py} a = 1;@endcode

    <b>Arguments Processed by =</b>
    |!Argument|!Processing
    |All|Assigns the value of \a expression to \a lvalue

    <hr>
    @section plus_equals_operator Plus Equals Operator (+=)

    @par Synopsis
    Increments and concatentates an lvalue with the value of an expression depending on the data type of the \a lvalue, unless the \a lvalue is @ref nothing, in which case this operator acts like the assignment operator (simply assigns the value of the right hand side to the \a lvalue).

    @par Syntax
    \a lvalue <tt>+=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref number_type "number", @ref date_type "date", @ref list_type "list", @ref string_type "string", @ref binary_type "binary", @ref hash_type "hash", or @ref object_type "object"

    @par Example
    @code{.py} a += 10;@endcode
    @code{.py} date += P1M2DT45M;@endcode
    @code{.py} list += new_element;@endcode
    @code{.py} string += ".foo";@endcode
    @code{.py} binary += <0c67a374>@endcode
    @code{.py} hash += ("new-key" : 1, "other" : "two");@endcode
    @code{.py} object += hash;@endcode

    <b>Arguments Processed by +=</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list")|the expression will be evaluated and concatenated to the \a lvalue. If \a expression is a list, the lists will be concatenated, to ensure adding a single element to a list, use the @ref push "push operator"
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object")|the \a expression will be evaluated, and, if it is a hash or object, then it's members will be added to the \a lvalue, any duplicate elements in the \a lvalue will be overridden by elements in the \a expression.
    |\a lvalue (@ref string_type "string")|the \a expression will be evaluated and converted to a string if necessary and concatenated to the \a lvalue.
    |\a lvalue (@ref number_type "number")|the \a expression will be evaluated and converted to a number if necessary and added to the \a lvalue.
    |\a lvalue (@ref float_type "float")|the \a expression will be evaluated and converted to a float if necessary and added to the \a lvalue.
    |\a lvalue (@ref binary_type "binary")|the \a expression will be evaluated and converted to a binary if necessary and added to the \a lvalue.
    |\a lvalue (@ref date_type "date")|the \a expression will be evaluated and converted to a date if necessary and added to the \a lvalue.
    |\a lvalue (@ref nothing)|the \a lvalue will be assigned to the value of \a expression.
    |\a lvalue (all other types)|the \a lvalue's type will be converted to an integer, and the \a expression will be evaluated and converted to an integer if necessary, and then the result will be added to the \a lvalue.

    <hr>
    @section minus_equals_operator Minus Equals Operator (-=)

    @par Synopsis
    For a float or integer argument, decrements the value of an \a lvalue by the value of an \a expression. However if the \a lvalue is a hash or object and the \a expression is a string, removes the key represented by the string from the hash or object.

    @par Syntax
    \a lvalue <tt>-=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref number_type "number", @ref date_type "date", @ref hash_type "hash", or @ref object_type "object"

    @par Example
    @code{.py} a -= 10;@endcode
    @code{.py} date -= PT45H213S;@endcode
    @code{.py} hash -= "key";@endcode
    @code{.py} hash -= ("key1", "key2");@endcode
    @code{.py} object -= "key";@endcode
    @code{.py} object -= list_of_keys;@endcode

    <b>Arguments Processed by -=</b>
    |!Argument|!Processing
    |\a lvalue (@ref number_type "number")|the \a expression will be evaluated and converted to a number if necessary and subtracted from the \a lvalue
    |\a lvalue (@ref float_type "float")|the \a expression will be evaluated and converted to a float if necessary and subtracted from the \a lvalue
    |\a lvalue (@ref date_type "date")|the \a expression will be evaluated and converted to a date if necessary and subtracted from the \a lvalue
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object"), \a expression (@ref string_type "string")|the hash key represented by \a expression will be removed from the \a lvalue
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object"), \a expression (@ref list_type "list")|each element in the list will be converted to a string (if necessary) and the key represented by each string will be removed from the hash or object
    |\a lvalue (@ref nothing), \a expression (any type)|the \a expression will be assigned to \a lvalue
    |\a lvalue (all other types)|the \a lvalue's type will be converted to an integer (if necessary), and the \a expression will be evaluated and converted to an integer (if necessary), and then the result will be subtracted from the \a lvalue

    <hr>
    @section and_equals_operator And Equals Operator (&=)

    @par Synopsis
    Performs a bitwise (binary) AND operation on an \a lvalue using the value of an \a expression and returns the new value.

    @par Syntax
    \a lvalue <tt>&=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a &= 0xfe;@endcode

    <b>Arguments Processed by &=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary and'ed to the \a lvalue

    <hr>
    @section or_equals_operator Or Equals Operator (|=)

    @par Synopsis
    Performs a bitwise (binary) OR operation on an \a lvalue using the value of an \a expression and returns the new value.

    @par Syntax
    \a lvalue <tt>|=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a |= 0xba;@endcode

    <b>Arguments Processed by |=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary or'ed to the \a lvalue

    <hr>
    @section modulo_equals_operator Modulo Equals Operator (%=)

    @par Synopsis
    Performs a modulo calculation on an lvalue using the value of an expression and returns the new value.

    @par Syntax
    \a lvalue <tt>%=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a %= 100;@endcode

    <b>Arguments Processed by %=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be used to divide the \a lvalue's value and the remainder will be saved to the \a lvalue

    <hr>
    @section multiply_equals_operator Multiply Equals Operator (*=)

    @par Synopsis
    Performs a multiplication operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>*=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", or @ref number_type "number"

    @par Example
    @code{.py} a *= 10;@endcode

    <b>Arguments Processed by *=</b>
    |!Argument|!Processing
    |All|The type precedence from highest to lowest is @ref number "number", @ref float "float" float, and @ref integer "int", other types are converted to @ref integer "int". The \a expression will be evaluated and multiplied by the \a lvalue, and the result will be saved to the \a lvalue.

    <hr>
    @section divide_equals_operator Divide Equals Operator (/=)

    @par Synopsis
    Performs a division operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>/=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", or @ref number_type "number"

    @par Example
    @code{.py} a /= 10;@endcode

    <b>Arguments Processed by /=</b>
    |!Argument|!Processing
    |All|The type precedence from highest to lowest is @ref number "number", @ref float "float" float, and @ref integer "int", other types are converted to @ref integer "int"; The \a expression will be evaluated and multiplied by the \a lvalue, and the result will be saved to the \a lvalue. The \a expression will be evaluated and used to divide the \a lvalue, and the result will be saved to the \a lvalue.

    @throw DIVISION-BY-ZERO If the divisor expression evaluates to zero, this exception is thrown

    <hr>
    @section xor_equals_operator Xor Equals Operator (^=)

    @par Synopsis
    Performs an exclusive-or operation on an lvalue using the value of an expression.

    @par Syntax
    \a lvalue <tt>^=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a ^= 0xf9034ba7;@endcode

    <b>Arguments Processed by ^=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and exclusive-or'ed with the \a lvalue, and the result will be saved to the \a lvalue

    <hr>
    @section shift_left_equals_operator Shift Left Equals Operator (\<\<=)

    @par Synopsis
    Performs a shift-left operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>\<\<=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code{.py} a <<= 3;@endcode

    <b>Arguments Processed by \<\<=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and this value will determine how many bits the \a lvalue will be shifted left. The result will be saved to the \a lvalue.

    <hr>
    @section shift_right_equals_operator Shift Right Equals Operator (\>\>=)

    @par Synopsis
    Performs a shift-right operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>\>\>=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example$
    @code{.py} a >>= 3;@endcode

    <b>Arguments Processed by >>=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and this value will determine how many bits the \a lvalue will be shifted right. The result will be saved to the \a lvalue.
*/
